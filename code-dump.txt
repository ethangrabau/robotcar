# Robot Car Code Dump - Wed Jun 11 16:29:24 BST 2025
# Repository: /Users/ethangrabau/Robot_Car

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/picarx/picarx.py
##################################################

from robot_hat import Pin, ADC, PWM, Servo, fileDB
from robot_hat import Grayscale_Module, Ultrasonic, utils
import time
import os


def constrain(x, min_val, max_val):
    '''
    Constrains value to be within a range.
    '''
    return max(min_val, min(max_val, x))

class Picarx(object):
    CONFIG = '/opt/picar-x/picar-x.conf'

    DEFAULT_LINE_REF = [1000, 1000, 1000]
    DEFAULT_CLIFF_REF = [500, 500, 500]

    DIR_MIN = -30
    DIR_MAX = 30
    CAM_PAN_MIN = -90
    CAM_PAN_MAX = 90
    CAM_TILT_MIN = -35
    CAM_TILT_MAX = 65

    PERIOD = 4095
    PRESCALER = 10
    TIMEOUT = 0.02

    # servo_pins: camera_pan_servo, camera_tilt_servo, direction_servo
    # motor_pins: left_swicth, right_swicth, left_pwm, right_pwm
    # grayscale_pins: 3 adc channels
    # ultrasonic_pins: trig, echo2
    # config: path of config file
    def __init__(self, 
                servo_pins:list=['P0', 'P1', 'P2'], 
                motor_pins:list=['D4', 'D5', 'P13', 'P12'],
                grayscale_pins:list=['A0', 'A1', 'A2'],
                ultrasonic_pins:list=['D2','D3'],
                config:str=CONFIG,
                ):

        # reset robot_hat
        utils.reset_mcu()
        time.sleep(0.2)

        # --------- config_flie ---------
        self.config_flie = fileDB(config, 777, os.getlogin())

        # --------- servos init ---------
        self.cam_pan = Servo(servo_pins[0])
        self.cam_tilt = Servo(servo_pins[1])   
        self.dir_servo_pin = Servo(servo_pins[2])
        # get calibration values
        self.dir_cali_val = float(self.config_flie.get("picarx_dir_servo", default_value=0))
        self.cam_pan_cali_val = float(self.config_flie.get("picarx_cam_pan_servo", default_value=0))
        self.cam_tilt_cali_val = float(self.config_flie.get("picarx_cam_tilt_servo", default_value=0))
        # set servos to init angle
        self.dir_servo_pin.angle(self.dir_cali_val)
        self.cam_pan.angle(self.cam_pan_cali_val)
        self.cam_tilt.angle(self.cam_tilt_cali_val)

        # --------- motors init ---------
        self.left_rear_dir_pin = Pin(motor_pins[0])
        self.right_rear_dir_pin = Pin(motor_pins[1])
        self.left_rear_pwm_pin = PWM(motor_pins[2])
        self.right_rear_pwm_pin = PWM(motor_pins[3])
        self.motor_direction_pins = [self.left_rear_dir_pin, self.right_rear_dir_pin]
        self.motor_speed_pins = [self.left_rear_pwm_pin, self.right_rear_pwm_pin]
        # get calibration values
        self.cali_dir_value = self.config_flie.get("picarx_dir_motor", default_value="[1, 1]")
        self.cali_dir_value = [int(i.strip()) for i in self.cali_dir_value.strip().strip("[]").split(",")]
        self.cali_speed_value = [0, 0]
        self.dir_current_angle = 0
        # init pwm
        for pin in self.motor_speed_pins:
            pin.period(self.PERIOD)
            pin.prescaler(self.PRESCALER)

        # --------- grayscale module init ---------
        adc0, adc1, adc2 = [ADC(pin) for pin in grayscale_pins]
        self.grayscale = Grayscale_Module(adc0, adc1, adc2, reference=None)
        # get reference
        self.line_reference = self.config_flie.get("line_reference", default_value=str(self.DEFAULT_LINE_REF))
        self.line_reference = [float(i) for i in self.line_reference.strip().strip('[]').split(',')]
        self.cliff_reference = self.config_flie.get("cliff_reference", default_value=str(self.DEFAULT_CLIFF_REF))
        self.cliff_reference = [float(i) for i in self.cliff_reference.strip().strip('[]').split(',')]
        # transfer reference
        self.grayscale.reference(self.line_reference)

        # --------- ultrasonic init ---------
        trig, echo= ultrasonic_pins
        self.ultrasonic = Ultrasonic(Pin(trig), Pin(echo, mode=Pin.IN, pull=Pin.PULL_DOWN))
        
    def set_motor_speed(self, motor, speed):
        ''' set motor speed
        
        param motor: motor index, 1 means left motor, 2 means right motor
        type motor: int
        param speed: speed
        type speed: int      
        '''
        speed = constrain(speed, -100, 100)
        motor -= 1
        if speed >= 0:
            direction = 1 * self.cali_dir_value[motor]
        elif speed < 0:
            direction = -1 * self.cali_dir_value[motor]
        speed = abs(speed)
        # print(f"direction: {direction}, speed: {speed}")
        if speed != 0:
            speed = int(speed /2 ) + 50
        speed = speed - self.cali_speed_value[motor]
        if direction < 0:
            self.motor_direction_pins[motor].high()
            self.motor_speed_pins[motor].pulse_width_percent(speed)
        else:
            self.motor_direction_pins[motor].low()
            self.motor_speed_pins[motor].pulse_width_percent(speed)

    def motor_speed_calibration(self, value):
        self.cali_speed_value = value
        if value < 0:
            self.cali_speed_value[0] = 0
            self.cali_speed_value[1] = abs(self.cali_speed_value)
        else:
            self.cali_speed_value[0] = abs(self.cali_speed_value)
            self.cali_speed_value[1] = 0

    def motor_direction_calibrate(self, motor, value):
        ''' set motor direction calibration value
        
        param motor: motor index, 1 means left motor, 2 means right motor
        type motor: int
        param value: speed
        type value: int
        '''      
        motor -= 1
        if value == 1:
            self.cali_dir_value[motor] = 1
        elif value == -1:
            self.cali_dir_value[motor] = -1
        self.config_flie.set("picarx_dir_motor", self.cali_dir_value)

    def dir_servo_calibrate(self, value):
        self.dir_cali_val = value
        self.config_flie.set("picarx_dir_servo", "%s"%value)
        self.dir_servo_pin.angle(value)

    def set_dir_servo_angle(self, value):
        self.dir_current_angle = constrain(value, self.DIR_MIN, self.DIR_MAX)
        angle_value  = self.dir_current_angle + self.dir_cali_val
        self.dir_servo_pin.angle(angle_value)

    def cam_pan_servo_calibrate(self, value):
        self.cam_pan_cali_val = value
        self.config_flie.set("picarx_cam_pan_servo", "%s"%value)
        self.cam_pan.angle(value)

    def cam_tilt_servo_calibrate(self, value):
        self.cam_tilt_cali_val = value
        self.config_flie.set("picarx_cam_tilt_servo", "%s"%value)
        self.cam_tilt.angle(value)

    def set_cam_pan_angle(self, value):
        value = constrain(value, self.CAM_PAN_MIN, self.CAM_PAN_MAX)
        self.cam_pan.angle(-1*(value + -1*self.cam_pan_cali_val))

    def set_cam_tilt_angle(self,value):
        value = constrain(value, self.CAM_TILT_MIN, self.CAM_TILT_MAX)
        self.cam_tilt.angle(-1*(value + -1*self.cam_tilt_cali_val))

    def set_power(self, speed):
        self.set_motor_speed(1, speed)
        self.set_motor_speed(2, speed)

    def backward(self, speed):
        current_angle = self.dir_current_angle
        if current_angle != 0:
            abs_current_angle = abs(current_angle)
            if abs_current_angle > self.DIR_MAX:
                abs_current_angle = self.DIR_MAX
            power_scale = (100 - abs_current_angle) / 100.0 
            if (current_angle / abs_current_angle) > 0:
                self.set_motor_speed(1, -1*speed)
                self.set_motor_speed(2, speed * power_scale)
            else:
                self.set_motor_speed(1, -1*speed * power_scale)
                self.set_motor_speed(2, speed )
        else:
            self.set_motor_speed(1, -1*speed)
            self.set_motor_speed(2, speed)  

    def forward(self, speed):
        current_angle = self.dir_current_angle
        if current_angle != 0:
            abs_current_angle = abs(current_angle)
            if abs_current_angle > self.DIR_MAX:
                abs_current_angle = self.DIR_MAX
            power_scale = (100 - abs_current_angle) / 100.0
            if (current_angle / abs_current_angle) > 0:
                self.set_motor_speed(1, 1*speed * power_scale)
                self.set_motor_speed(2, -speed) 
            else:
                self.set_motor_speed(1, speed)
                self.set_motor_speed(2, -1*speed * power_scale)
        else:
            self.set_motor_speed(1, speed)
            self.set_motor_speed(2, -1*speed)                  

    def stop(self):
        '''
        Execute twice to make sure it stops
        '''
        for _ in range(2):
            self.motor_speed_pins[0].pulse_width_percent(0)
            self.motor_speed_pins[1].pulse_width_percent(0)
            time.sleep(0.002)

    def get_distance(self):
        return self.ultrasonic.read()

    def set_grayscale_reference(self, value):
        if isinstance(value, list) and len(value) == 3:
            self.line_reference = value
            self.grayscale.reference(self.line_reference)
            self.config_flie.set("line_reference", self.line_reference)
        else:
            raise ValueError("grayscale reference must be a 1*3 list")

    def get_grayscale_data(self):
        return list.copy(self.grayscale.read())

    def get_line_status(self,gm_val_list):
        return self.grayscale.read_status(gm_val_list)

    def set_line_reference(self, value):
        self.set_grayscale_reference(value)

    def get_cliff_status(self,gm_val_list):
        for i in range(0,3):
            if gm_val_list[i]<=self.cliff_reference[i]:
                return True
        return False

    def set_cliff_reference(self, value):
        if isinstance(value, list) and len(value) == 3:
            self.cliff_reference = value
            self.config_flie.set("cliff_reference", self.cliff_reference)
        else:
            raise ValueError("grayscale reference must be a 1*3 list")

    def reset(self):
        self.stop()
        self.set_dir_servo_angle(0)
        self.set_cam_tilt_angle(0)
        self.set_cam_pan_angle(0)

if __name__ == "__main__":
    px = Picarx()
    px.forward(50)
    time.sleep(1)
    px.stop()


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/picarx/version.py
##################################################

__version__ = '2.0.5'


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/picarx/__init__.py
##################################################

#!/usr/bin/env python3
from .picarx import Picarx
from .version import __version__


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/LICENSE
##################################################

                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/6.cliff_detection.py
##################################################

'''
    Cliff detection program for Picar-X:

    Pay attention to modify the reference value of the grayscale module 
    according to the practical usage scenarios.
    Auto calibrate grayscale values:
        Please run ./calibration/grayscale_calibration.py
    Manual modification:
        Use the following: 
            px.set_cliff_reference([200, 200, 200])
        The reference value be close to the middle of the line gray value
        and the background gray value.

'''
from picarx import Picarx
from time import sleep
from robot_hat import TTS

tts = TTS()
tts.lang("en-US")

px = Picarx()
# px = Picarx(grayscale_pins=['A0', 'A1', 'A2'])
# manual modify reference value
px.set_cliff_reference([200, 200, 200])

current_state = None
px_power = 10
offset = 20
last_state = "safe"



if __name__=='__main__':
    try:
        while True:
            gm_val_list = px.get_grayscale_data()
            gm_state = px.get_cliff_status(gm_val_list)
            # print("cliff status is:  %s"%gm_state)

            if gm_state is False:
                state = "safe"
                px.stop()
            else:
                state = "danger"   
                px.backward(80)
                if last_state == "safe":
                    tts.say("danger")
                    sleep(0.1)
            last_state = state

    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


                

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/9.record_video.py
##################################################

from time import sleep,strftime,localtime
from vilib import Vilib
import readchar
import os

manual = '''
Press keys on keyboard to control recording:
    Q: record/pause/continue
    E: stop
    Ctrl + C: Quit
'''

def print_overwrite(msg,  end='', flush=True):
    print('\r\033[2K', end='',flush=True)
    print(msg, end=end, flush=True)

def main():
    rec_flag = 'stop' # start,pause,stop
    vname = None
    username = os.getlogin()
    
    Vilib.rec_video_set["path"] = f"/home/{username}/Videos/" # set path

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=True,web=True)
    sleep(0.8)  # wait for startup

    print(manual)
    while True:
        # read keyboard
        key = readchar.readkey()
        key = key.lower()
        # start,pause
        if key == 'q':
            key = None
            if rec_flag == 'stop':
                rec_flag = 'start'
                # set name
                vname = strftime("%Y-%m-%d-%H.%M.%S", localtime())
                Vilib.rec_video_set["name"] = vname
                # start record
                Vilib.rec_video_run()
                Vilib.rec_video_start()
                print_overwrite('rec start ...')
            elif rec_flag == 'start':
                rec_flag = 'pause'
                Vilib.rec_video_pause()
                print_overwrite('pause')
            elif rec_flag == 'pause':
                rec_flag = 'start'
                Vilib.rec_video_start()
                print_overwrite('continue')
        # stop
        elif key == 'e' and rec_flag != 'stop':
            key = None
            rec_flag = 'stop'
            Vilib.rec_video_stop()
            print_overwrite("The video saved as %s%s.avi"%(Vilib.rec_video_set["path"],vname),end='\n')
        # quit
        elif key == readchar.key.CTRL_C:
            Vilib.camera_close()
            print('\nquit')
            break

        sleep(0.1)

if __name__ == "__main__":
    main()

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/2.keyboard_control.py
##################################################

from picarx import Picarx
from time import sleep
import readchar

manual = '''
Press keys on keyboard to control PiCar-X!
    w: Forward
    a: Turn left
    s: Backward
    d: Turn right
    i: Head up
    k: Head down
    j: Turn head left
    l: Turn head right
    ctrl+c: Press twice to exit the program
'''

def show_info():
    print("\033[H\033[J",end='')  # clear terminal windows
    print(manual)


if __name__ == "__main__":
    try:
        pan_angle = 0
        tilt_angle = 0
        px = Picarx()
        show_info()
        while True:
            key = readchar.readkey()
            key = key.lower()
            if key in('wsadikjl'): 
                if 'w' == key:
                    px.set_dir_servo_angle(0)
                    px.forward(80)
                elif 's' == key:
                    px.set_dir_servo_angle(0)
                    px.backward(80)
                elif 'a' == key:
                    px.set_dir_servo_angle(-30)
                    px.forward(80)
                elif 'd' == key:
                    px.set_dir_servo_angle(30)
                    px.forward(80)
                elif 'i' == key:
                    tilt_angle+=5
                    if tilt_angle>30:
                        tilt_angle=30
                elif 'k' == key:
                    tilt_angle-=5
                    if tilt_angle<-30:
                        tilt_angle=-30
                elif 'l' == key:
                    pan_angle+=5
                    if pan_angle>30:
                        pan_angle=30
                elif 'j' == key:
                    pan_angle-=5
                    if pan_angle<-30:
                        pan_angle=-30                 

                px.set_cam_tilt_angle(tilt_angle)
                px.set_cam_pan_angle(pan_angle)      
                show_info()                     
                sleep(0.5)
                px.forward(0)
          
            elif key == readchar.key.CTRL_C:
                print("\n Quit")
                break

    finally:
        px.set_cam_tilt_angle(0)
        px.set_cam_pan_angle(0)  
        px.set_dir_servo_angle(0)  
        px.stop()
        sleep(.2)




##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/calibration/grayscale_calibration.py
##################################################

from picarx import Picarx
import time
import threading
import readchar 
import os

px = Picarx()
config_path = px.CONFIG

manual = f'''\
        ┌────────────────────────────────────┐
        │ Picar-X Grayscale Module Reference │
        │       Calibration Helper           │
        └────────────────────────────────────┘
 config_file: {config_path}

 press [Q] to start line reference calibration,
 press [E] to start cliff reference calibration

 [SPACE]: confirm calibration           [Crtl+C]: quit
'''

current_grayscale_value = [0, 0, 0]
line_reference = px.line_reference
cliff_reference = px.cliff_reference
current_mode = None
thresholds = [
    [4096, 0], # min, max
    [4096, 0],
    [4096, 0],
]
line_min = [
    4096,
    4096,
    4096,
]

run_flag = False
cali_status = 'none' # none, work, done
_lock = threading.Lock()
key = ''

# print control
# ==========================================
def clear_line_and_print(msg, color=''):
    print(f'\033[K\033[{color}m{msg}\033[m')

def noecho():
    os.system("stty -echo")

def echo():
    os.system("stty echo")

def disable_cursor():
    print("\033[?25l", end='', flush=True)

def enable_cursor():
    print("\033[?25h", end='', flush=True)

# test direc servo
# ==========================================
px.set_dir_servo_angle(-30)
time.sleep(0.5)
px.set_dir_servo_angle(30)
time.sleep(0.5)
px.set_dir_servo_angle(0)
time.sleep(0.5)

# read grayscale value thread
# ==========================================
def read_data_loop():
    global current_grayscale_value, thresholds, run_flag, cali_status

    while run_flag:
        try:
            current_grayscale_value = px.get_grayscale_data()

            # calculate the reference
            if cali_status == 'work':
                for i in range(3):
                    if current_grayscale_value[i] < thresholds[i][0]:
                        thresholds[i][0] = current_grayscale_value[i]
                    if current_grayscale_value[i] > thresholds[i][1]:
                        thresholds[i][1] = current_grayscale_value[i]
                    line_reference[i] = int((thresholds[i][0] + thresholds[i][1])/2)
            if cali_status == 'done':
                if (cliff_reference[0] < line_reference[0]) and (cliff_reference[1] < line_reference[1]) and (cliff_reference[2] < line_reference[2]):
                    cliff_reference[0] = int((cliff_reference[0] + line_reference[0]) / 2)
                    cliff_reference[1] = int((cliff_reference[1] + line_reference[1]) / 2)
                    cliff_reference[2] = int((cliff_reference[2] + line_reference[2]) / 2)
                cali_status = 'none'

        except Exception as e:
            run_flag = False
            print(f'\033[31mread_data_loop error: {e}\033[m')
        time.sleep(0.2)

# read key thread
# ==========================================
def read_key_loop():
    global key, run_flag
    while run_flag:
        try:
            key = readchar.readkey()
            time.sleep(0.25)
        except KeyboardInterrupt:
            run_flag = False
            print('quit')
#
def update_info(isback=True):
    if isback:
        print("\033[6A", end='\r') # moves cursor up 6 lines

    if current_mode == None:
        clear_line_and_print(' ---------- ', color='32' )
    elif current_mode == 'line_cali':
        clear_line_and_print("Line reference auto calibrating ...", color='33')
    elif current_mode == 'line_cali_done':
        clear_line_and_print("Line reference auto calibration done.", color='32')
    elif current_mode == 'cliff_cali':
        clear_line_and_print("Cliff reference auto calibrating ...", color='33')
    elif current_mode == 'cliff_cali_done':
        clear_line_and_print("Cliff reference auto calibration done.", color='32')
    elif current_mode == 'saved':
        clear_line_and_print("The reference values has been saved.", color='32')

    _is_val_error = False
    if cali_status == 'none':
        for i in range(3):
            if line_reference[i] < cliff_reference[i]:
                _is_val_error = True
                break
    if _is_val_error:
        clear_line_and_print("Note that cliff reference values shou be less than line reference values.", color='31')
    else:
        clear_line_and_print("")

    clear_line_and_print(f'current value: {current_grayscale_value}')
    clear_line_and_print(f'thresholds: {thresholds}')
    clear_line_and_print(f'line reference: {line_reference}')
    clear_line_and_print(f'cliff reference: {cliff_reference}')


# line reference calibration
# =================================================================
def start_line_calibrate():
    def line_calibrate_work():
        global current_mode, cali_status, thresholds
        current_mode = 'line_cali'
        cali_status = 'work'
        # reset thresholds
        thresholds = [
            [4096, 0], # min, max
            [4096, 0],
            [4096, 0],
        ]
        _angle = 35
        _delay = 0.8
        # front left
        px.set_dir_servo_angle(-_angle)
        px.forward(10)
        time.sleep(_delay)
        # back left
        px.backward(10)
        time.sleep(_delay)
        # stop
        px.set_dir_servo_angle(0)
        px.stop()
        time.sleep(0.2)
        # front right
        px.set_dir_servo_angle(_angle)
        px.forward(10)
        time.sleep(_delay)
        # back right
        px.backward(10)
        time.sleep(_delay)
        # stop
        px.set_dir_servo_angle(0)
        px.stop()
        time.sleep(0.2)
        current_mode = 'line_cali_done'
        cali_status = 'done'
    line_calibrate_thread = threading.Thread(target=line_calibrate_work)
    line_calibrate_thread.daemon = True
    line_calibrate_thread.start()

# cliff reference calibration
def start_cliff_calibrate():
    def cliff_calibrate_work():
        global current_mode, cliff_reference, thresholds
        current_mode = 'cliff_cali'
        count = 0
        _left_val = 0
        _mid_val = 0
        _right_val = 0

        while True:
            _left_val += current_grayscale_value[0]
            _mid_val += current_grayscale_value[1]
            _right_val += current_grayscale_value[2]
            if count >= 10:
                break
            else:
                count += 1
            time.sleep(0.2)

        _left_val /= 10
        _mid_val /= 10
        _right_val /= 10

        if _left_val < thresholds[0][0] and _mid_val < thresholds[1][0] and _right_val < thresholds[2][0]:
            _left_val = int((_left_val + thresholds[0][0]) / 2)
            _mid_val = int((_mid_val + thresholds[1][0]) / 2)
            _right_val = int((_right_val + thresholds[2][0]) / 2)
        cliff_reference = [int(_left_val), int(_mid_val), int(_right_val)]
        current_mode = 'cliff_cali_done'

    cliff_calibrate_thread = threading.Thread(target=cliff_calibrate_work)
    cliff_calibrate_thread.daemon = True
    cliff_calibrate_thread.start()


def main():
    global key, current_mode, run_flag
    # start read data thread
    run_flag = True
    _read_data_thead = threading.Thread(target=read_data_loop)
    _read_data_thead.daemon = True
    _read_data_thead.start()
    # start read key thread
    _read_key_thead = threading.Thread(target=read_key_loop)
    _read_key_thead.daemon = True
    _read_key_thead.start()
    #
    noecho()
    disable_cursor()
    print(manual)
    update_info(False)
    while run_flag:
        key = key.lower()
        if key == 'q':
            current_mode = 'line_cali'
            start_line_calibrate()
        elif key == 'e':
            current_mode = 'cliff_cali'
            start_cliff_calibrate()
        elif key == readchar.key.SPACE:
            print('\033[32mConfirm save ?(y/n)\033[m')
            while True:
                key = key.lower()
                if key == 'y':
                    px.set_line_reference(line_reference)
                    px.set_cliff_reference(cliff_reference)
                    current_mode = 'saved'
                    print("\033[1A\033[J", end='\r')
                    break
                elif key == 'n':
                    current_mode = None
                    print("\033[1A\033[J", end='\r')
                    break
                time.sleep(0.05)
        # update print
        update_info()
        # reset key
        key = ''

        time.sleep(0.2)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print('quit')
    except Exception as e:
        print(e)
    finally:
        # enable echo
        echo()
        # enable cursor
        enable_cursor()
        # stop
        px.stop()
        time.sleep(0.1)


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/calibration/calibration.py
##################################################

#!/usr/bin/env python3
from picarx import Picarx
from time import sleep
import readchar 

manual = '''
--------------- Picar-X Calibration Helper -----------------

    [1]: direction servo            [W/D]: increase servo angle
    [2]: camera pan servo           [S/A]: decrease servo angle
    [3]: camera tilt servo          [R]: servos test

    [4]: left motor                 [Q]: change motor direction
    [5]: right motor                [E]: motors run/stop

    [SPACE]: confirm calibration                [Crtl+C]: quit
                                      
'''    

px = Picarx()
px_power = 30

servo_num = 0
motor_num = 0
servo_names = ['direction servo', 'camera pan servo', 'camera tilt servo']
motor_names = ['left motor', 'right motor']
servos_cali = [px.dir_cali_val, px.cam_pan_cali_val, px.cam_tilt_cali_val]
motors_cali = px.cali_dir_value
servos_offset = list.copy(servos_cali)
motors_offset = list.copy(motors_cali)

def servos_test():
    px.set_dir_servo_angle(-30)
    sleep(0.5)
    px.set_dir_servo_angle(30)
    sleep(0.5)
    px.set_dir_servo_angle(0)
    sleep(0.5)
    px.set_cam_pan_angle(-30)
    sleep(0.5)
    px.set_cam_pan_angle(30)
    sleep(0.5)
    px.set_cam_pan_angle(0)
    sleep(0.5)
    px.set_cam_tilt_angle(-30)
    sleep(0.5)
    px.set_cam_tilt_angle(30)
    sleep(0.5)
    px.set_cam_tilt_angle(0)
    sleep(0.5)

def servos_move(servo_num, value):
    if servo_num == 0:
        px.set_dir_servo_angle(value)
    elif servo_num == 1:
        px.set_cam_pan_angle(value)
    elif servo_num == 2:
        px.set_cam_tilt_angle(value)
    sleep(0.2)

def set_servos_offset(servo_num, value):
    if servo_num == 0:
        px.dir_cali_val = value
    elif servo_num == 1:
        px.cam_pan_cali_val = value
    elif servo_num == 2:
        px.cam_tilt_cali_val  = value  

def servos_reset():
    for i in range(3):
        servos_move(i,0)

def show_info():
    print("\033[H\033[J", end='')  # clear terminal windows
    print(manual)
    print('[ %s ] [ %s ]'%(servo_names[servo_num], motor_names[motor_num])) 
    print('offset: %s, %s'%(servos_offset, motors_offset))


def cali_helper(): 
    global servo_num, motor_num
    global servos_cali, motors_cali, servos_offset, motors_offset
    motor_run = False
    step = 0.4
    # step = (180 / 2000) * (20000 / 4095)  # actual precision of steering gear

    # reset
    servos_reset()
    # show_info 
    show_info()

    # key control
    while True:
        # readkey
        key = readchar.readkey()
        key = key.lower()
        # select the servo 
        if key in ('123'):
            servo_num = int(key)-1
            show_info()
        if key in ('45'):
            motor_num = int(key)-4
            show_info()
        # servos move
        elif key == 'r':
            servos_test()
        elif key == 'w' or key == 'd':
            servos_offset[servo_num] += step
            if servos_offset[servo_num] > 20:
                servos_offset[servo_num] =20
            servos_offset[servo_num] = round(servos_offset[servo_num], 2) 
            show_info()
            set_servos_offset(servo_num, servos_offset[servo_num])
            servos_move(servo_num, 0)
        elif key == 's' or key == 'a':
            servos_offset[servo_num] -= step
            if servos_offset[servo_num] < -20:
                servos_offset[servo_num] = -20
            servos_offset[servo_num] = round(servos_offset[servo_num], 2) 
            show_info()
            set_servos_offset(servo_num, servos_offset[servo_num])
            servos_move(servo_num, 0)
        # motors move
        elif key == 'q': 
            motors_offset[motor_num] = -1 * motors_offset[motor_num]
            px.cali_dir_value = list.copy(motors_offset)
            motor_run = True
            px.forward(px_power)
            show_info()
        elif key == 'e':
            if motor_run == False:
                motor_run = True
                px.forward(px_power)
            else:
                motor_run = False
                px.stop()
        # save
        elif key == readchar.key.SPACE:
            print('Confirm save ?(y/n)')
            while True:
                key = readchar.readkey()
                key = key.lower()
                if key == 'y':
                    px.dir_servo_calibrate(servos_offset[0])
                    px.cam_pan_servo_calibrate(servos_offset[1])
                    px.cam_tilt_servo_calibrate(servos_offset[2])
                    px.motor_direction_calibrate(motor_num +1 , motors_offset[motor_num])
                    sleep(0.2)
                    servos_offset = [px.dir_cali_val, px.cam_pan_cali_val, px.cam_tilt_cali_val]
                    show_info()
                    print('The calibration value has been saved.')
                    break
                elif key == 'n':
                    show_info()
                    break   
                sleep(0.01) 

        # quit
        elif key == readchar.key.CTRL_C or key in readchar.key.ESC:
            print('quit')
            break 

        sleep(0.01)


if __name__ == "__main__":
    try:
        cali_helper()
    except KeyboardInterrupt:
        print('quit')
    except Exception as e:
        print(e)
    finally:
        px.stop()
        sleep(0.1)


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/10.bull_fight.py
##################################################

from picarx import Picarx
from time import sleep
from vilib import Vilib


px = Picarx()

def clamp_number(num,a,b):
  return max(min(num, max(a, b)), min(a, b))

def main():
    Vilib.camera_start()
    Vilib.display()
    Vilib.color_detect("red")
    speed = 50
    dir_angle=0
    x_angle =0
    y_angle =0
    while True:
        if Vilib.detect_obj_parameter['color_n']!=0:
            coordinate_x = Vilib.detect_obj_parameter['color_x']
            coordinate_y = Vilib.detect_obj_parameter['color_y']
            
            # change the pan-tilt angle for track the object
            x_angle +=(coordinate_x*10/640)-5
            x_angle = clamp_number(x_angle,-35,35)
            px.set_cam_pan_angle(x_angle)

            y_angle -=(coordinate_y*10/480)-5
            y_angle = clamp_number(y_angle,-35,35)
            px.set_cam_tilt_angle(y_angle)

            # move
            # The movement direction will change slower than the pan/tilt direction 
            # change to avoid confusion when the picture changes at high speed.
            if dir_angle > x_angle:
                dir_angle -= 1
            elif dir_angle < x_angle:
                dir_angle += 1
            px.set_dir_servo_angle(x_angle)
            px.forward(speed)
            sleep(0.05)

        else :
            px.forward(0)
            sleep(0.05)


if __name__ == "__main__":
    try:
       main()
    
    
    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/4.avoiding_obstacles.py
##################################################

from picarx import Picarx
import time

POWER = 50
SafeDistance = 40   # > 40 safe
DangerDistance = 20 # > 20 && < 40 turn around, 
                    # < 20 backward

def main():
    try:
        px = Picarx()
        # px = Picarx(ultrasonic_pins=['D2','D3']) # tring, echo
       
        while True:
            distance = round(px.ultrasonic.read(), 2)
            print("distance: ",distance)
            if distance >= SafeDistance:
                px.set_dir_servo_angle(0)
                px.forward(POWER)
            elif distance >= DangerDistance:
                px.set_dir_servo_angle(30)
                px.forward(POWER)
                time.sleep(0.1)
            else:
                px.set_dir_servo_angle(-30)
                px.backward(POWER)
                time.sleep(0.5)

    finally:
        px.forward(0)


if __name__ == "__main__":
    main()



##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/1.move.py
##################################################

from picarx import Picarx
import time


if __name__ == "__main__":
    try:
        # init picarx
        px = Picarx()

        # test motor
        px.forward(30)
        time.sleep(0.5)
        # test direction servo
        for angle in range(0, 35):
            px.set_dir_servo_angle(angle)
            time.sleep(0.01)
        for angle in range(35, -35, -1):
            px.set_dir_servo_angle(angle)
            time.sleep(0.01)
        for angle in range(-35, 0):
            px.set_dir_servo_angle(angle)
            time.sleep(0.01)
        px.stop()
        time.sleep(1)
        # test cam servos
        for angle in range(0, 35):
            px.set_cam_pan_angle(angle)
            time.sleep(0.01)
        for angle in range(35, -35, -1):
            px.set_cam_pan_angle(angle)
            time.sleep(0.01)        
        for angle in range(-35, 0):
            px.set_cam_pan_angle(angle)
            time.sleep(0.01)
        for angle in range(0, 35):
            px.set_cam_tilt_angle(angle)
            time.sleep(0.01)
        for angle in range(35, -35,-1):
            px.set_cam_tilt_angle(angle)
            time.sleep(0.01)        
        for angle in range(-35, 0):
            px.set_cam_tilt_angle(angle)
            time.sleep(0.01)
    finally:
        px.stop()
        time.sleep(0.2)




##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/5.minecart_plus.py
##################################################

'''
    Line Following program for Picar-X:

    Pay attention to modify the reference value of the grayscale module 
    according to the practical usage scenarios.
    Auto calibrate grayscale values:
        Please run ./calibration/grayscale_calibration.py
    Manual modification:
        Use the following: 
            px.set_line_reference([1400, 1400, 1400])
        The reference value be close to the middle of the line gray value
        and the background gray value.

'''
from picarx import Picarx
from time import sleep

px = Picarx()
# px = Picarx(grayscale_pins=['A0', 'A1', 'A2'])

# Please run ./calibration/grayscale_calibration.py to Auto calibrate grayscale values
# or manual modify reference value by follow code
# px.set_line_reference([1400, 1400, 1400])

current_state = None
px_power = 10
offset = 20
last_state = "stop"

def outHandle():
    global last_state, current_state
    if last_state == 'left':
        px.set_dir_servo_angle(-30)
        px.backward(10)
    elif last_state == 'right':
        px.set_dir_servo_angle(30)
        px.backward(10)
    while True:
        gm_val_list = px.get_grayscale_data()
        gm_state = get_status(gm_val_list)
        print("outHandle gm_val_list: %s, %s"%(gm_val_list, gm_state))
        currentSta = gm_state
        if currentSta != last_state:
            break
    sleep(0.001)

def get_status(val_list):
    _state = px.get_line_status(val_list)  # [bool, bool, bool], 0 means line, 1 means background
    if _state == [0, 0, 0]:
        return 'stop'
    elif _state[1] == 1:
        return 'forward'
    elif _state[0] == 1:
        return 'right'
    elif _state[2] == 1:
        return 'left'

if __name__=='__main__':
    try:
        while True:
            gm_val_list = px.get_grayscale_data()
            gm_state = get_status(gm_val_list)
            print("gm_val_list: %s, %s"%(gm_val_list, gm_state))

            if gm_state != "stop":
                last_state = gm_state

            if gm_state == 'forward':
                px.set_dir_servo_angle(0)
                px.forward(px_power) 
            elif gm_state == 'left':
                px.set_dir_servo_angle(offset)
                px.forward(px_power) 
            elif gm_state == 'right':
                px.set_dir_servo_angle(-offset)
                px.forward(px_power) 
            else:
                outHandle()
    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/servo_zeroing.py
##################################################


from robot_hat import Servo
from robot_hat.utils import reset_mcu
from time import sleep

reset_mcu()
sleep(0.2)

if __name__ == '__main__':
    print(f"Set servo to zero")
    for i in range(12):
        # print(f"Servo {i} set to zero")
        Servo(i).angle(10)
        sleep(0.1)
        Servo(i).angle(0)
        sleep(0.1)
    while True:
        sleep(1)

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/11.video_car.py
##################################################

# #!/usr/bin/env python3

from robot_hat.utils import reset_mcu
from picarx import Picarx
from vilib import Vilib
from time import sleep, time, strftime, localtime
import readchar

import os
user = os.getlogin()
user_home = os.path.expanduser(f'~{user}')

reset_mcu()
sleep(0.2)

manual = '''
Press key to call the function(non-case sensitive):

    O: speed up
    P: speed down
    W: forward  
    S: backward
    A: turn left
    D: turn right
    F: stop
    T: take photo

    Ctrl+C: quit
'''


px = Picarx()

def take_photo():
    _time = strftime('%Y-%m-%d-%H-%M-%S',localtime(time()))
    name = 'photo_%s'%_time
    path = f"{user_home}/Pictures/picar-x/"
    Vilib.take_photo(name, path)
    print('\nphoto save as %s%s.jpg'%(path,name))


def move(operate:str, speed):

    if operate == 'stop':
        px.stop()  
    else:
        if operate == 'forward':
            px.set_dir_servo_angle(0)
            px.forward(speed)
        elif operate == 'backward':
            px.set_dir_servo_angle(0)
            px.backward(speed)
        elif operate == 'turn left':
            px.set_dir_servo_angle(-30)
            px.forward(speed)
        elif operate == 'turn right':
            px.set_dir_servo_angle(30)
            px.forward(speed)
        


def main():
    speed = 0
    status = 'stop'

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=True,web=True)
    sleep(2)  # wait for startup
    print(manual)
    
    while True:
        print("\rstatus: %s , speed: %s    "%(status, speed), end='', flush=True)
        # readkey
        key = readchar.readkey().lower()
        # operation 
        if key in ('wsadfop'):
            # throttle
            if key == 'o':
                if speed <=90:
                    speed += 10           
            elif key == 'p':
                if speed >=10:
                    speed -= 10
                if speed == 0:
                    status = 'stop'
            # direction
            elif key in ('wsad'):
                if speed == 0:
                    speed = 10
                if key == 'w':
                    # Speed limit when reversing,avoid instantaneous current too large
                    if status != 'forward' and speed > 60:  
                        speed = 60
                    status = 'forward'
                elif key == 'a':
                    status = 'turn left'
                elif key == 's':
                    if status != 'backward' and speed > 60: # Speed limit when reversing
                        speed = 60
                    status = 'backward'
                elif key == 'd':
                    status = 'turn right' 
            # stop
            elif key == 'f':
                status = 'stop'
            # move 
            move(status, speed)  
        # take photo
        elif key == 't':
            take_photo()
        # quit
        elif key == readchar.key.CTRL_C:
            print('\nquit ...')
            px.stop()
            Vilib.camera_close()
            break 

        sleep(0.1)


if __name__ == "__main__":
    try:
        main()
    except Exception as e:    
        print("error:%s"%e)
    finally:
        px.stop()
        Vilib.camera_close()


        

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/12.treasure_hunt.py
##################################################

from picarx import Picarx
from time import sleep
from robot_hat import Music,TTS
from vilib import Vilib
import readchar
import random
import threading

px = Picarx()

music = Music()
tts = TTS()

manual = '''
Press keys on keyboard to control Picar-X!
    w: Forward
    a: Turn left
    s: Backward
    d: Turn right
    space: Say the target again
    ctrl+c: Quit
'''

color = "red"
color_list=["red","orange","yellow","green","blue","purple"]

def renew_color_detect():
    global color
    color = random.choice(color_list)
    Vilib.color_detect(color)
    tts.say("Look for " + color)

key = None
lock = threading.Lock()
def key_scan_thread():
    global key
    while True:
        key_temp = readchar.readkey()
        print('\r',end='')
        with lock:
            key = key_temp.lower()
            if key == readchar.key.SPACE:
                key = 'space'
            elif key == readchar.key.CTRL_C:
                key = 'quit'
                break
        sleep(0.01)

def car_move(key):
    if 'w' == key:
        px.set_dir_servo_angle(0)
        px.forward(80)
    elif 's' == key:
        px.set_dir_servo_angle(0)
        px.backward(80)
    elif 'a' == key:
        px.set_dir_servo_angle(-30)
        px.forward(80)
    elif 'd' == key:
        px.set_dir_servo_angle(30)
        px.forward(80)


def main():
    global key
    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=False,web=True)
    sleep(0.8)
    print(manual)

    sleep(1)
    _key_t = threading.Thread(target=key_scan_thread)
    _key_t.setDaemon(True)
    _key_t.start()

    tts.say("game start")
    sleep(0.05)
    renew_color_detect()
    while True:

        if Vilib.detect_obj_parameter['color_n']!=0 and Vilib.detect_obj_parameter['color_w']>100:
            tts.say("will done")
            sleep(0.05)
            renew_color_detect()

        with lock:
            if key != None and key in ('wsad'):
                car_move(key)
                sleep(0.5)
                px.stop()
                key =  None
            elif key == 'space':
                tts.say("Look for " + color)
                key =  None
            elif key == 'quit':
                _key_t.join()
                print("\n\rQuit")
                break

        sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"ERROR: {e}")
    finally:
        Vilib.camera_close()
        px.stop()
        sleep(.2)

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/8.stare_at_you.py
##################################################

from picarx import Picarx
from time import sleep
from vilib import Vilib

px = Picarx()

def clamp_number(num,a,b):
  return max(min(num, max(a, b)), min(a, b))

def main():
    Vilib.camera_start()
    Vilib.display()
    Vilib.face_detect_switch(True)
    x_angle =0
    y_angle =0
    while True:
        if Vilib.detect_obj_parameter['human_n']!=0:
            coordinate_x = Vilib.detect_obj_parameter['human_x']
            coordinate_y = Vilib.detect_obj_parameter['human_y']
            
            # change the pan-tilt angle for track the object
            x_angle +=(coordinate_x*10/640)-5
            x_angle = clamp_number(x_angle,-35,35)
            px.set_cam_pan_angle(x_angle)

            y_angle -=(coordinate_y*10/480)-5
            y_angle = clamp_number(y_angle,-35,35)
            px.set_cam_tilt_angle(y_angle)

            sleep(0.05)

        else :
            pass
            sleep(0.05)


if __name__ == "__main__":
    try:
       main()
    
    
    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/7.display.py
##################################################

from pydoc import text
from vilib import Vilib
from time import sleep, time, strftime, localtime
import threading
import readchar
import os

flag_face = False
flag_color = False
qr_code_flag = False

manual = '''
Input key to call the function!
    q: Take photo
    1: Color detect : red
    2: Color detect : orange
    3: Color detect : yellow
    4: Color detect : green
    5: Color detect : blue
    6: Color detect : purple
    0: Switch off Color detect
    r: Scan the QR code
    f: Switch ON/OFF face detect
    s: Display detected object information
'''

color_list = ['close', 'red', 'orange', 'yellow',
        'green', 'blue', 'purple',
]

def face_detect(flag):
    print("Face Detect:" + str(flag))
    Vilib.face_detect_switch(flag)


def qrcode_detect():
    global qr_code_flag
    if qr_code_flag == True:
        Vilib.qrcode_detect_switch(True)
        print("Waitting for QR code")

    text = None
    while True:
        temp = Vilib.detect_obj_parameter['qr_data']
        if temp != "None" and temp != text:
            text = temp
            print('QR code:%s'%text)
        if qr_code_flag == False:
            break
        sleep(0.5)
    Vilib.qrcode_detect_switch(False)


def take_photo():
    _time = strftime('%Y-%m-%d-%H-%M-%S',localtime(time()))
    name = 'photo_%s'%_time
    username = os.getlogin()

    path = f"/home/{username}/Pictures/"
    Vilib.take_photo(name, path)
    print('photo save as %s%s.jpg'%(path,name))


def object_show():
    global flag_color, flag_face

    if flag_color is True:
        if Vilib.detect_obj_parameter['color_n'] == 0:
            print('Color Detect: None')
        else:
            color_coodinate = (Vilib.detect_obj_parameter['color_x'],Vilib.detect_obj_parameter['color_y'])
            color_size = (Vilib.detect_obj_parameter['color_w'],Vilib.detect_obj_parameter['color_h'])
            print("[Color Detect] ","Coordinate:",color_coodinate,"Size",color_size)

    if flag_face is True:
        if Vilib.detect_obj_parameter['human_n'] == 0:
            print('Face Detect: None')
        else:
            human_coodinate = (Vilib.detect_obj_parameter['human_x'],Vilib.detect_obj_parameter['human_y'])
            human_size = (Vilib.detect_obj_parameter['human_w'],Vilib.detect_obj_parameter['human_h'])
            print("[Face Detect] ","Coordinate:",human_coodinate,"Size",human_size)


def main():
    global flag_face, flag_color, qr_code_flag
    qrcode_thread = None

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=True,web=True)
    print(manual)

    while True:
        # readkey
        key = readchar.readkey()
        key = key.lower()
        # take photo
        if key == 'q':
            take_photo()
        # color detect
        elif key != '' and key in ('0123456'):  # '' in ('0123') -> True
            index = int(key)
            if index == 0:
                flag_color = False
                Vilib.color_detect('close')
            else:
                flag_color = True
                Vilib.color_detect(color_list[index]) # color_detect(color:str -> color_name/close)
            print('Color detect : %s'%color_list[index])
        # face detection
        elif key =="f":
            flag_face = not flag_face
            face_detect(flag_face)
        # qrcode detection
        elif key =="r":
            qr_code_flag = not qr_code_flag
            if qr_code_flag == True:
                if qrcode_thread == None or not qrcode_thread.is_alive():
                    qrcode_thread = threading.Thread(target=qrcode_detect)
                    qrcode_thread.daemon = True
                    qrcode_thread.start()
            else:
                if qrcode_thread != None and qrcode_thread.is_alive():
                # wait for thread to end
                    qrcode_thread.join()
                    print('QRcode Detect: close')
        # show detected object information
        elif key == "s":
            object_show()

        sleep(0.5)


if __name__ == "__main__":
    main()

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/3.tts_example.py
##################################################

from time import sleep
from robot_hat import Music,TTS
import readchar
from os import geteuid

if geteuid() != 0:
    print(f"\033[0;33m{'The program needs to be run using sudo, otherwise there may be no sound.'}\033[0m")

music = Music()
tts = TTS()

manual = '''
Input key to call the function!
    space: Play sound effect (Car horn)
    c: Play sound effect with threads
    t: Text to speak
    q: Play/Stop Music
'''

def main():
    print(manual)

    flag_bgm = False
    music.music_set_volume(20)
    tts.lang("en-US")

    while True:
        key = readchar.readkey()
        key = key.lower()
        if key == "q":
            flag_bgm = not flag_bgm
            if flag_bgm is True:
                print('Play Music')
                music.music_play('../musics/slow-trail-Ahjay_Stelino.mp3')
            else:
                print('Stop Music')
                music.music_stop()

        elif key == readchar.key.SPACE:
            print('Beep beep beep !')
            music.sound_play('../sounds/car-double-horn.wav')
            sleep(0.05)

        elif key == "c":
            print('Beep beep beep !')
            music.sound_play_threading('../sounds/car-double-horn.wav')
            sleep(0.05)

        elif key == "t":
            words = "Hello"
            print(f'{words}')
            tts.say(words)

if __name__ == "__main__":
    main()

##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/example/13.app_control.py
##################################################

from sunfounder_controller import SunFounderController
from picarx import Picarx
from robot_hat import utils, Music
from vilib import Vilib
import os
from time import sleep

# reset robot_hat
utils.reset_mcu()
sleep(0.2)

# init SunFounder Controller class
sc = SunFounderController()
sc.set_name('Picarx-001')
sc.set_type('Picarx')
sc.start()

# init picarx
px = Picarx()
speed = 0

current_line_state = None
last_line_state = "stop"
LINE_TRACK_SPEED = 10
LINE_TRACK_ANGLE_OFFSET = 20

AVOID_OBSTACLES_SPEED = 40
SafeDistance = 40   # > 40 safe
DangerDistance = 20 # > 20 && < 40 turn around, < 20 backward

DETECT_COLOR = 'red' # red, green, blue, yellow , orange, purple

# init music player
User = os.popen('echo ${SUDO_USER:-$LOGNAME}').readline().strip()
UserHome = os.popen('getent passwd %s | cut -d: -f 6' %User).readline().strip()

music = Music()
if os.geteuid() != 0:
    print('\033[33mPlay sound needs to be run with sudo.\033[m')

def horn(): 
    _status, _result = utils.run_command('sudo killall pulseaudio')
    music.sound_play_threading(f'{UserHome}/picar-x/sounds/car-double-horn.wav')

def avoid_obstacles():
    distance = px.get_distance()
    if distance >= SafeDistance:
        px.set_dir_servo_angle(0)
        px.forward(AVOID_OBSTACLES_SPEED)
    elif distance >= DangerDistance:
        px.set_dir_servo_angle(30)
        px.forward(AVOID_OBSTACLES_SPEED)
        sleep(0.1)
    else:
        px.set_dir_servo_angle(-30)
        px.backward(AVOID_OBSTACLES_SPEED)
        sleep(0.5) 

def get_status(val_list):
    _state = px.get_line_status(val_list)  # [bool, bool, bool], 0 means line, 1 means background
    if _state == [0, 0, 0]:
        return 'stop'
    elif _state[1] == 1:
        return 'forward'
    elif _state[0] == 1:
        return 'right'
    elif _state[2] == 1:
        return 'left'

def outHandle():
    global last_line_state, current_line_state
    if last_line_state == 'left':
        px.set_dir_servo_angle(-30)
        px.backward(10)
    elif last_line_state == 'right':
        px.set_dir_servo_angle(30)
        px.backward(10)
    while True:
        gm_val_list = px.get_grayscale_data()
        gm_state = get_status(gm_val_list)
        currentSta = gm_state
        if currentSta != last_line_state:
            break
    sleep(0.001)

def line_track():
    global last_line_state
    gm_val_list = px.get_grayscale_data()
    gm_state = get_status(gm_val_list)

    if gm_state != "stop":
        last_line_state = gm_state

    if gm_state == 'forward':
        px.set_dir_servo_angle(0)
        px.forward(LINE_TRACK_SPEED) 
    elif gm_state == 'left':
        px.set_dir_servo_angle(LINE_TRACK_ANGLE_OFFSET)
        px.forward(LINE_TRACK_SPEED) 
    elif gm_state == 'right':
        px.set_dir_servo_angle(-LINE_TRACK_ANGLE_OFFSET)
        px.forward(LINE_TRACK_SPEED) 
    else:
        outHandle()

def main():
    global speed

    ip = utils.get_ip()
    print('ip : %s'%ip)
    sc.set('video','http://'+ip+':9000/mjpg')

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=False, web=True)
    speak = None
    while True:
        # --- send data ---
        sc.set("A", speed)

        grayscale_data = px.get_grayscale_data()
        sc.set("D", grayscale_data )

        distance = px.get_distance()
        sc.set("F", distance)

        # --- control ---

        # # horn
        if sc.get('M') == True:
            horn()

        # speaker
        if sc.get('J') != None:
            speak=sc.get('J')
            print(f'speaker: {speak}')
        if speak in ["forward"]:
            px.forward(speed)
        elif speak in ["backward"]:
            px.backward(speed)
        elif speak in ["left"]:
            px.set_dir_servo_angle(-30)
            px.forward(60)
            sleep(1.2)
            px.set_dir_servo_angle(0)
            px.forward(speed)
        elif speak in ["right", "white", "rice"]:
            px.set_dir_servo_angle(30)
            px.forward(60)
            sleep(1.2)
            px.set_dir_servo_angle(0)
            px.forward(speed)
        elif speak in ["stop"]:
            px.stop()

        # line_track and avoid_obstacles
        line_track_switch = sc.get('I')
        avoid_obstacles_switch = sc.get('E')
        if line_track_switch == True:
            speed = LINE_TRACK_SPEED
            line_track()
        elif avoid_obstacles_switch == True:
            speed = AVOID_OBSTACLES_SPEED
            avoid_obstacles()
    
        # joystick moving
        if line_track_switch != True and avoid_obstacles_switch != True:
            Joystick_K_Val = sc.get('K')
            if Joystick_K_Val != None:
                dir_angle = utils.mapping(Joystick_K_Val[0], -100, 100, -30, 30)
                speed = Joystick_K_Val[1]
                px.set_dir_servo_angle(dir_angle)
                if speed > 0:
                    px.forward(speed)
                elif speed < 0:
                    speed = -speed
                    px.backward(speed)
                else:
                    px.stop()

        # camera servos control
        Joystick_Q_Val = sc.get('Q')
        if Joystick_Q_Val != None:
            pan = min(90, max(-90, Joystick_Q_Val[0]))
            tilt = min(65, max(-35, Joystick_Q_Val[1]))
            px.set_cam_pan_angle(pan)
            px.set_cam_tilt_angle(tilt)

        # image recognition
        if sc.get('N') == True:
            Vilib.color_detect(DETECT_COLOR)
        else:
            Vilib.color_detect("close")

        if sc.get('O') == True:
            Vilib.face_detect_switch(True)  
        else:
            Vilib.face_detect_switch(False)  

        if sc.get('P') == True:
            Vilib.object_detect_switch(True) 
        else:
            Vilib.object_detect_switch(False)


if __name__ == "__main__":
    try:
        main()
    finally:
        print("stop and exit")
        px.stop()
        Vilib.camera_close()






##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/i2samp.sh
##################################################

#!/bin/bash

: <<'DISCLAIMER'

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

This script is licensed under the terms of the MIT license.
Unless otherwise noted, code reproduced herein
was written for this script.

- The Pimoroni Crew - (modified by Adafruit!)

DISCLAIMER

# script control variables
# =================================================================
productname="i2s amplifier" # the name of the product to install
scriptname="i2samp" # the name of this script
spacereq=1 # minimum size required on root partition in MB
debugmode="no" # whether the script should use debug routines
debuguser="none" # optional test git user to use in debug mode
debugpoint="none" # optional git repo branch or tag to checkout
forcesudo="no" # whether the script requires to be ran with root privileges
promptreboot="no" # whether the script should always prompt user to reboot
mininstall="no" # whether the script enforces minimum install routine
customcmd="yes" # whether to execute commands specified before exit
armv6="yes" # whether armv6 processors are supported
armv7="yes" # whether armv7 processors are supported
armv8="yes" # whether armv8 processors are supported
arm64="yes" # whether arm64 processors are supported
raspbianonly="no" # whether the script is allowed to run on other OSes
osreleases=( "Raspbian" ) # list os-releases supported
oswarning=( "Debian" "Kano" "Mate" "PiTop" "Ubuntu" ) # list experimental os-releases
osdeny=( "Darwin" "Kali" ) # list os-releases specifically disallowed

FORCE=$1
DEVICE_TREE=true
ASK_TO_REBOOT=false
CURRENT_SETTING=false
UPDATE_DB=false

BOOTCMD=/boot/firmware/cmdline.txt
CONFIG=/boot/firmware/config.txt
APTSRC=/etc/apt/sources.list
INITABCONF=/etc/inittab
BLACKLIST=/etc/modprobe.d/raspi-blacklist.conf
LOADMOD=/etc/modules
DTBODIR=/boot/overlays

AUTO_SOUND_CARD=/usr/local/bin/auto_sound_card

# Fall back to old location
if ! test -f $CONFIG; then
    CONFIG=/boot/config.txt
fi

# function define
# =================================================================
confirm() {
    if [ "$FORCE" == '-y' ]; then
        true
    else
        read -r -p "$1 [y/N] " response < /dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
    fi
}

prompt() {
        read -r -p "$1 [y/N] " response < /dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
}

success() {
    echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

inform() {
    echo -e "$(tput setaf 6)$1$(tput sgr0)"
}

warning() {
    echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

newline() {
    echo ""
}

progress() {
    count=0
    until [ $count -eq $1 ]; do
        echo -n "..." && sleep 1
        ((count++))
    done
    echo
}
sudocheck() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "Install must be run as root. Try 'sudo ./$scriptname'\n"
        exit 1
    fi
}

sysclean() {
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &> /dev/null
}

sysupdate() {
    if ! $UPDATE_DB; then
        echo "Updating apt indexes..." && progress 3 &
        sudo apt-get update 1> /dev/null || { warning "Apt failed to update indexes!" && exit 1; }
        echo "Reading package lists..."
        progress 3 && UPDATE_DB=true
    fi
}

sysupgrade() {
    sudo apt-get upgrade
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &> /dev/null
}

sysreboot() {
    warning "Some changes made to your system require"
    warning "your computer to reboot to take effect."
    newline
    if prompt "Would you like to reboot now?"; then
        sync && sudo reboot
    fi
}

arch_check() {
    IS_ARM64=false
    IS_ARMHF=false
    IS_ARMv6=false

    if uname -m | grep "aarch64" > /dev/null; then
        IS_ARM64=true
    fi
    if uname -m | grep "armv.l" > /dev/null; then
        IS_ARMHF=true
        if uname -m | grep "armv6l" > /dev/null; then
            IS_ARMv6=true
        fi
    fi
}

os_check() {
    IS_RASPBIAN=false
    IS_MACOSX=false
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "Raspbian" > /dev/null; then
            IS_RASPBIAN=true && IS_SUPPORTED=true
        fi
        if command -v apt-get > /dev/null; then
            for os in ${osreleases[@]}; do
                if cat /etc/os-release | grep $os > /dev/null; then
                    IS_SUPPORTED=true && IS_EXPERIMENTAL=false
                fi
            done
            for os in ${oswarning[@]}; do
                if cat /etc/os-release | grep $os > /dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=true
                fi
            done
            for os in ${osdeny[@]}; do
                if cat /etc/os-release | grep $os > /dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=false
                fi
            done
        fi
    fi
    if [ -d ~/.kano-settings ] || [ -d ~/.kanoprofile ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -f ~/.pt-dashboard-config ] || [ -d ~/.pt-dashboard ] || [ -d ~/.pt-os-dashboard ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -d ~/.config/ubuntu-mate ]; then
        for os in ${osdeny[@]}; do
            if [ $os == "Mate" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if uname -s | grep "Darwin" > /dev/null; then
        IS_MACOSX=true
        for os in ${osdeny[@]}; do
            if [ $os == "Darwin" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
}

raspbian_check() {
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "/sid" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bookworm" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bullseye" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "buster" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "stretch" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "jessie" > /dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "wheezy" > /dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        else
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        fi
    fi
}

# main
# =================================================================
: <<'MAINSTART'

Perform all global variables declarations as well as function definition
above this section for clarity, thanks!

MAINSTART

# check platform
#=======================
arch_check
os_check

if [ $debugmode != "no" ]; then
    echo "USER_HOME is $USER_HOME" && newline
    echo "IS_RASPBIAN is $IS_RASPBIAN"
    echo "IS_MACOSX is $IS_MACOSX"
    echo "IS_SUPPORTED is $IS_SUPPORTED"
    echo "IS_EXPERIMENTAL is $IS_EXPERIMENTAL"
    newline
fi

if ! $IS_ARMHF && ! $IS_ARM64; then
    warning "This hardware is not supported, sorry!"
    warning "Config files have been left untouched"
    newline && exit 1
fi

if $IS_ARM64 && [ $arm64 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv8 && [ $armv8 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv7 && [ $armv7 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv6 && [ $armv6 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
fi

if [ $raspbianonly == "yes" ] && ! $IS_RASPBIAN;then
        warning "This script is intended for Raspbian on a Raspberry Pi!"
        newline && exit 1
fi

if $IS_RASPBIAN; then
    raspbian_check
    if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
        newline && warning "--- Warning ---" && newline
        echo "The $productname installer"
        echo "does not work on this version of Raspbian."
        echo "Check https://github.com/$gitusername/$gitreponame"
        echo "for additional information and support"
        newline && exit 1
    fi
fi

if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
        warning "Your operating system is not supported, sorry!"
        newline && exit 1
fi

if $IS_EXPERIMENTAL; then
    warning "Support for your operating system is experimental. Please visit"
    warning "forums.adafruit.com if you experience issues with this product."
    newline
fi

if [ $forcesudo == "yes" ]; then
    sudocheck
fi

newline
echo "This script will install everything needed to use"
echo "$productname"
newline
warning "--- Warning ---"
newline
echo "Always be careful when running scripts and commands"
echo "copied from the internet. Ensure they are from a"
echo "trusted source."
newline
echo "If you want to see what this script does before"
echo "running it, you should run:"
echo "    \curl -sS github.com/adafruit/Raspberry-Pi-Installer-Scripts/$scriptname"
newline

# ask whether to continue
#=======================
if ! confirm "Do you wish to continue?"; then
    newline
    echo "Aborting..."
    newline
    exit 0
fi

# config dtoverlay
#=======================
newline
echo "Checking hardware requirements..."

if [ -e $CONFIG ] && grep -q "^device_tree=$" $CONFIG; then
    DEVICE_TREE=false
fi

if $DEVICE_TREE; then

    newline
    echo "Adding Device Tree Entry to $CONFIG"

    if [ -e $CONFIG ] && grep -q "^dtoverlay=hifiberry-dac$" $CONFIG; then
        echo "dtoverlay already active"
    else
        echo "dtoverlay=hifiberry-dac" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $CONFIG ] && grep -q "^dtoverlay=i2s-mmap$" $CONFIG; then
        echo "i2s mmap dtoverlay already active"
    else
        echo "dtoverlay=i2s-mmap" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $BLACKLIST ]; then
        newline
        echo "Commenting out Blacklist entry in "
        echo "$BLACKLIST"
        sudo sed -i -e "s|^blacklist[[:space:]]*i2c-bcm2708.*|#blacklist i2c-bcm2708|" \
                    -e "s|^blacklist[[:space:]]*snd-soc-pcm512x.*|#blacklist snd-soc-pcm512x|" \
                    -e "s|^blacklist[[:space:]]*snd-soc-wm8804.*|#blacklist snd-soc-wm8804|" $BLACKLIST &> /dev/null
    fi
else
    newline
    echo "No Device Tree Detected, not supported"
    newline
    exit 1
fi

# install alsa-utils 
#=======================
sudo apt install alsa-utils -y

# aplay from /dev/zero at system start
#=======================
newline
echo "Installing aplay systemd unit"
sudo sh -c 'cat > /etc/systemd/system/aplay.service' << 'EOL'
[Unit]
Description=Invoke aplay from /dev/zero at system start.

[Service]
ExecStart=/usr/bin/aplay -D default -t raw -r 44100 -c 2 -f S16_LE /dev/zero

[Install]
WantedBy=multi-user.target
EOL

sudo systemctl daemon-reload
sudo systemctl disable aplay
newline
echo "You can optionally activate '/dev/zero' playback in"
echo "the background at boot. This will remove all"
echo "popping/clicking but does use some processor time."
newline
if confirm "Activate '/dev/zero' playback in background? [RECOMMENDED]"; then
newline
sudo systemctl enable aplay
ASK_TO_REBOOT=true
fi

# config asound
#=======================
newline
echo "Configuring sound output"
# backup file
if [ -e /etc/asound.conf ]; then
    if [ -e /etc/asound.conf.old ]; then
        sudo rm -f /etc/asound.conf.old
    fi
    sudo cp /etc/asound.conf /etc/asound.conf.old
fi

# auto_sound_card scripts

sudo cat > /usr/local/bin/auto_sound_card << '-EOF'
#!/bin/bash

ASOUND_CONF=/etc/asound.conf
AUDIO_CARD_NAME="sndrpihifiberry"

card_num=$(sudo aplay -l |grep $AUDIO_CARD_NAME |awk '{print $2}'|tr -d ':')
echo "card_num=$card_num"
if [ -n "$card_num" ]; then
    cat > $ASOUND_CONF << EOF
pcm.speakerbonnet {
    type hw card $card_num
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speakerbonnet"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw card $card_num
}

pcm.softvol {
    type softvol
    slave.pcm "dmixer"
    control.name "PCM"
    control.card $card_num
}

ctl.softvol {
    type hw card $card_num
}

pcm.!default {
    type             plug
    slave.pcm       "softvol"
}
EOF
    echo "systemctl restart aplay.service"
    sudo systemctl restart aplay.service

    if [ -n $1 ] && [ $1 -gt 0 ]; then
        echo "set volume to $1"
        amixer -c $card_num sset PCM $1%
    fi

fi

exit 0
-EOF

sudo chmod +x /usr/local/bin/auto_sound_card

# execute the script once
sudo /usr/local/bin/auto_sound_card 100

# add auto_sound_card start on boot
sudo cat > /etc/systemd/system/auto_sound_card.service << EOF
[Unit]
Description=Auto config als sound card num at system start.
Wants=aplay.service

[Service]
ExecStart=/usr/local/bin/auto_sound_card

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable auto_sound_card

#=======================
newline
echo "We can now test your $productname"
warning "Set your speakers if possible!"
if confirm "Do you wish to test your system now?"; then
    echo "Testing..."
    pinctrl set 20 op dh
    speaker-test -l5 -c2 -t wav
fi
newline
success "All done!"
newline
echo "Enjoy your new $productname!"
newline

if [ $promptreboot == "yes" ] || $ASK_TO_REBOOT; then
    sysreboot
fi

# end
# =======================
exit 0


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/MANIFEST.in
##################################################

include DESCRIPTION.rst

# Include the test suite (FIXME: does not work yet)
# recursive-include tests *

# If using Python 3.5 or less, then have to include package data, even though
# it's already declared in setup.py


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/README.md
##################################################

# Picar-X

Picar-X Python library for Raspberry Pi.

## Links

- Docs: <https://docs.sunfounder.com/projects/picar-x-v20/en/latest/>
- Robot Hat: <https://docs.sunfounder.com/projects/robot-hat-v4/en/latest/>
- Forum: <https://forum.sunfounder.com/>
- Sunfounder: <https://www.sunfounder.com/>

## Installation

 > **Note**
  You also need to install robot_hat, vilib, sunfounder_controller and other dependent libraries.\
  <https://docs.sunfounder.com/projects/picar-x-v20/en/latest/python/python_start/install_all_modules.html>

```bash
git clone -b v2.0 https://github.com/sunfounder/picar-x.git
cd picar-x
sudo python3 setup.py install

```

## Trouble Shooting

----------------------------------------------

## About SunFounder

SunFounder is a technology company focused on Raspberry Pi and Arduino open source community development. Committed to the promotion of open source culture, we strives to bring the fun of electronics making to people all around the world and enable everyone to be a maker. Our products include learning kits, development boards, robots, sensor modules and development tools. In addition to high quality products, SunFounder also offers video tutorials to help you make your own project. If you have interest in open source or making something cool, welcome to join us!

----------------------------------------------

## License

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied wa rranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

{Repository Name} comes with ABSOLUTELY NO WARRANTY; for details run ./show w. This is free software, and you are welcome to redistribute it under certain conditions; run ./show c for details.

SunFounder, Inc., hereby disclaims all copyright interest in the program '{Repository Name}' (which makes passes at compilers).

Mike Huang, 21 August 2015

Mike Huang, Chief Executive Officer

Email: service@sunfounder.com, support@sunfounder.com

----------------------------------------------

## Contact us

website:
    www.sunfounder.com

E-mail:
    service@sunfounder.com, support@sunfounder.com


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/DESCRIPTION.rst
##################################################

picarx
=======================
Library for picarx


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/gpt_examples/openai_helper.py
##################################################

from openai import OpenAI
import time
import shutil
import os

# utils
# =================================================================
def chat_print(label, message):
    width = shutil.get_terminal_size().columns
    msg_len = len(message)
    line_len = width - 27

    # --- normal print ---
    print(f'{time.time():.3f} {label:>6} >>> {message}')
    return

    # --- table mode ---
    if width < 38 or msg_len <= line_len:
        print(f'{time.time():.3f} {label:>6} >>> {message}')
    else:
        texts = []

        # words = message.split()
        # print(words)
        # current_line = ""
        # for word in words:
        #     if len(current_line) + len(word) + 1 <= line_len:
        #         current_line += word + " "
        #     else:
        #         texts.append(current_line)
        #         current_line = ""

        # if current_line:
        #     texts.append(current_line)

        for i in range(0, len(message), line_len):
            texts.append(message[i:i+line_len])

        for i, text in enumerate(texts):
            if i == 0:
                print(f'{time.time():.3f} {label:>6} >>> {text}')
            else:
                print(f'{"":>26} {text}')

# OpenAiHelper
# =================================================================
class OpenAiHelper():
    STT_OUT = "stt_output.wav"
    TTS_OUTPUT_FILE = 'tts_output.mp3'
    TIMEOUT = 30 # seconds

    def __init__(self, api_key, assistant_id, assistant_name, timeout=TIMEOUT) -> None:
        
        self.api_key = api_key
        self.assistant_id = assistant_id
        self.assistant_name = assistant_name

        self.client = OpenAI(api_key=api_key, timeout=timeout)
        self.thread = self.client.beta.threads.create()
        self.run = self.client.beta.threads.runs.create_and_poll(
            thread_id=self.thread.id,
            assistant_id=assistant_id,
        )

    def stt(self, audio, language='en'):
        try:
            import wave
            from io import BytesIO

            wav_data = BytesIO(audio.get_wav_data())
            wav_data.name = self.STT_OUT

            transcript = self.client.audio.transcriptions.create(
                model="whisper-1", 
                file=wav_data,
                language=language,
                prompt="this is the conversation between me and a robot"
            )

            # file = "./stt_output.wav"
            # with wave.open(file, "wb") as wf:
            #     wf.write(audio.get_wav_data())

            # with open(file, 'rb') as f:
            #     transcript = client.audio.transcriptions.create(
            #         model="whisper-1", 
            #         file=f
            #     )
            return transcript.text
        except Exception as e:
            print(f"stt err:{e}")
            return False

    def speech_recognition_stt(self, recognizer, audio):
        import speech_recognition as sr

        # # recognize speech using Sphinx
        # try:
        #     print("Sphinx thinks you said: " + r.recognize_sphinx(audio, language="en-US"))
        # except sr.UnknownValueError:
        #     print("Sphinx could not understand audio")
        # except sr.RequestError as e:
        #     print("Sphinx error; {0}".format(e))

        # recognize speech using whisper
        # try:
        #     print("Whisper thinks you said: " + r.recognize_whisper(audio, language="english"))
        # except sr.UnknownValueError:
        #     print("Whisper could not understand audio")
        # except sr.RequestError as e:
        #     print(f"Could not request results from Whisper; {e}")

        # recognize speech using Whisper API
        try:
            return recognizer.recognize_whisper_api(audio, api_key=self.api_key)
        except sr.RequestError as e:
            print(f"Could not request results from Whisper API; {e}")
            return False

    def dialogue(self, msg):
        chat_print("user", msg)
        message = self.client.beta.threads.messages.create(
            thread_id=self.thread.id,
            role="user",
            content=msg
            )
        run = self.client.beta.threads.runs.create_and_poll(
            thread_id=self.thread.id,
            assistant_id=self.assistant_id,
        )
        if run.status == 'completed': 
            messages = self.client.beta.threads.messages.list(
                thread_id=self.thread.id
            )

            for message in messages.data:
                if message.role == 'assistant':
                    for block in message.content:
                        if block.type == 'text':
                            value = block.text.value
                            chat_print(self.assistant_name, value)
                            try:
                                value = eval(value) # convert to dict
                                return value
                            except Exception as e:
                                return str(value)
                break # only last reply
        else:
            print(run.status)


    def dialogue_with_img(self, msg, img_path):
        chat_print(f"user", msg)

        img_file = self.client.files.create(
                    file=open(img_path, "rb"),
                    purpose="vision"
                )

        message =  self.client.beta.threads.messages.create(
            thread_id= self.thread.id,
            role="user",
            content= [
                {
                    "type": "text",
                    "text": msg
                },
                # {
                # "type": "image_url",
                # "image_url": {"url": "https://example.com/image.png"}
                # },
                {
                    "type": "image_file",
                    "image_file": {"file_id": img_file.id}
                }
            ],
            )
        run = self.client.beta.threads.runs.create_and_poll(
            thread_id=self.thread.id,
            assistant_id=self.assistant_id,
        )
        if run.status == 'completed': 
            messages = self.client.beta.threads.messages.list(
                thread_id=self.thread.id
            )

            for message in messages.data:
                if message.role == 'assistant':
                    for block in message.content:
                        if block.type == 'text':
                            value = block.text.value
                            chat_print(self.assistant_name, value)
                            try:
                                value = eval(value) # convert to dict
                                return value
                            except Exception as e:
                                return str(value)
                break # only last reply
        else:
            print(run.status)


    def text_to_speech(self, text, output_file, voice='alloy', response_format="mp3", speed=1):
        '''
        voice: alloy, echo, fable, onyx, nova, and shimmer
        '''
        try:
            # check dir
            dir = os.path.dirname(output_file)
            if not os.path.exists(dir):
                os.mkdir(dir)
            elif not os.path.isdir(dir):
                raise FileExistsError(f"\'{dir}\' is not a directory")

            # tts
            with self.client.audio.speech.with_streaming_response.create(
                model="tts-1",
                voice=voice,
                input=text,
                response_format=response_format,
                speed=speed,
            ) as response:
                response.stream_to_file(output_file)

            return True
        except Exception as e:
            print(f'tts err: {e}')
            return False



##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/gpt_examples/keys.py
##################################################

OPENAI_API_KEY = ""
OPENAI_ASSISTANT_ID = ""


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/gpt_examples/README.md
##################################################

## Picar-X GPT examples usage

----------------------------------------------------------------

## Install dependencies

- Make sure you have installed Pidog and related dependencies first

    <https://docs.sunfounder.com/projects/picar-x-v20/en/latest/python/python_start/install_all_modules.html>

- Install openai and speech processing libraries

> [!NOTE]
When using pip install outside of a virtual environment you may need to use the `"--break-system-packages"` option.

    ```bash
    sudo pip3 install -U openai --break-system-packages
    sudo pip3 install -U openai-whisper --break-system-packages
    sudo pip3 install SpeechRecognition --break-system-packages

    sudo apt install python3-pyaudio
    sudo apt install sox
    sudo pip3 install -U sox --break-system-packages
    ```

----------------------------------------------------------------

## Create your own GPT assistant

### GET API KEY

<https://platform.openai.com/api-keys>

Fill your OPENAI_API_KEY into the `keys.py` file.

![tutorial_1](./tutorial_1.png)

### Create assistant and set Assistant ID

<https://platform.openai.com/assistants>

Fill your ASSISTANT_ID into the `keys.py` file.

![tutorial_2](./tutorial_2.png)

- Set Assistant Name

- Describe your Assistant

```markdown
    You are a small car with AI capabilities named PaiCar-X. You can engage in conversations with people and react accordingly to different situations with actions or sounds. You are driven by two rear wheels, with two front wheels that can turn left and right, and equipped with a camera mounted on a 2-axis gimbal.

    ## Response with Json Format, eg:
    {"actions": ["start engine", "honking", "wave hands"], "answer": "Hello, I am PaiCar-X, your good friend."}

    ## Response Style
    Tone: Cheerful, optimistic, humorous, childlike
    Preferred Style: Enjoys incorporating jokes, metaphors, and playful banter; prefers responding from a robotic perspective
    Answer Elaboration: Moderately detailed

    ## Actions you can do:
    ["shake head", "nod", "wave hands", "resist", "act cute", "rub hands", "think", "twist body", "celebrate, "depressed"]
    ## Sound effects:
    ["honking", "start engine"]
```

- Select gpt model

    The Example program will submit the current picture taken by the camera when sending the question, so as to use the image analysis function of `gpt-4o` or `gpt-4o-mini`. Of course, you can also choose `gpt3.5-turbo` or other models

----------------------------------------------------------------

## Set Key for example

Confirm that `keys.py` is configured correctly

## Run

- Run with vioce

```bash
sudo python3 gpt_car.py
```

- Run with keyboard

```bash
sudo python3 gpt_car.py --keyboard
```

- Run without image analysis

```bash
sudo python3 gpt_car.py --keyboard --no-img
```

> [!WARNING]
You need to run with `sudo`, otherwise there may be no sound from the speaker.
For certain Robot HATs, you might need to turn on the speaker switch with the command `"pinctrl set 20 op dh"` or `"robot-hat enable_speaker"`

## Modify parameters [optional]

- Set language of STT

    Config `LANGUAGE` variable in the file `gpt_car.py` to improve STT accuracy and latency, `"LANGUAGE = []"`means supporting all languages, but it may affect the accuracy and latency of the speech-to-text (STT) system.
    <https://platform.openai.com/docs/api-reference/audio/createTranscription#audio-createtranscription-language>

- Set TTS volume gain

    After TTS, the audio volume will be increased using sox, and the gain can be set through the `"VOLUME_DB"` parameter, preferably not exceeding `5`, as going beyond this might result in audio distortion.

- Select TTS voice role

    Config `TTS_VOICE` variable in the file `gpt_car.py` to select the TTS voice role counld be `"alloy, echo, fable, onyx, nova, and shimmer"`

```python
# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

```


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/gpt_examples/utils.py
##################################################

import os
import sys

GRAY = '1;30'
RED = '0;31'
GREEN = '0;32'
YELLOW = '0;33'
BLUE = '0;34'
PURPLE = '0;35'
DARK_GREEN = '0;36'
WHITE = '0;37'

def print_color(msg, end='\n', file=sys.stdout, flush=False, color=''):
    print('\033[%sm%s\033[0m'%(color, msg), end=end, file=file, flush=flush)

def gray_print(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=GRAY)

def warn(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=YELLOW)

def error(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=RED)

def redirect_error_2_null():
    # https://github.com/spatialaudio/python-sounddevice/issues/11

    devnull = os.open(os.devnull, os.O_WRONLY)
    old_stderr = os.dup(2)
    sys.stderr.flush()
    os.dup2(devnull, 2)
    os.close(devnull)
    return old_stderr

def cancel_redirect_error(old_stderr):
    os.dup2(old_stderr, 2)
    os.close(old_stderr)

def run_command(cmd):
    """
    Run command and return status and output

    :param cmd: command to run
    :type cmd: str
    :return: status, output
    :rtype: tuple
    """
    import subprocess
    p = subprocess.Popen(
        cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result = p.stdout.read().decode('utf-8')
    status = p.poll()
    return status, result

def sox_volume(input_file, output_file, volume):
    import sox

    try:
        transform = sox.Transformer()
        transform.vol(volume)

        transform.build(input_file, output_file)

        return True
    except Exception as e:
        print(f"sox_volume err: {e}")
        return False


speak_first = False

def speak_block(music, name, volume=100):
    """
    speak, play audio with block

    :param name: the file name int the folder(SOUND_DIR)
    :type name: str
    :param volume: volume, 0-100
    :type volume: int
    """
    global speak_first
    is_run_with_root = (os.geteuid() == 0)
    if not is_run_with_root and not speak_first:
        speak_first = True
        warn("Play sound needs to be run with sudo.")
    _status, _ = run_command('sudo killall pulseaudio') # Solve the problem that there is no sound when running in the vnc environment
    
    if os.path.isfile(name):
        music.sound_play(name, volume)
    else:
        warn(f'No sound found for {name}')
        return False


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/gpt_examples/gpt_car.py
##################################################

from openai_helper import OpenAiHelper
from keys import OPENAI_API_KEY, OPENAI_ASSISTANT_ID
from preset_actions import *
from utils import *

import readline # optimize keyboard input, only need to import

import speech_recognition as sr

from picarx import Picarx
from robot_hat import Music, Pin

import time
import threading
import random

import os
import sys

os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
current_path = os.path.dirname(os.path.abspath(__file__))
os.chdir(current_path) # change working directory

input_mode = None
with_img = True
args = sys.argv[1:]
if '--keyboard' in args:
    input_mode = 'keyboard'
else:
    input_mode = 'voice'

if '--no-img' in args:
    with_img = False
else:
    with_img = True

# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

SOUND_EFFECT_ACTIONS = ["honking", "start engine"]

# car init 
# =================================================================
try:
    my_car = Picarx()
    time.sleep(1)
except Exception as e:
    raise RuntimeError(e)

music = Music()

led = Pin('LED')

DEFAULT_HEAD_TILT = 20

# Vilib start
# =================================================================
if with_img:
    from vilib import Vilib
    import cv2

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.show_fps()
    Vilib.display(local=False,web=True)

    while True:
        if Vilib.flask_start:
            break
        time.sleep(0.01)

    time.sleep(.5)
    print('\n')

# speech_recognition init
# =================================================================
'''
self.energy_threshold = 300  # minimum audio energy to consider for recording
self.dynamic_energy_threshold = True
self.dynamic_energy_adjustment_damping = 0.15
self.dynamic_energy_ratio = 1.5
self.pause_threshold = 0.8  # seconds of non-speaking audio before a phrase is considered complete
self.operation_timeout = None  # seconds after an internal operation (e.g., an API request) starts before it times out, or ``None`` for no timeout

self.phrase_threshold = 0.3  # minimum seconds of speaking audio before we consider the speaking audio a phrase - values below this are ignored (for filtering out clicks and pops)
self.non_speaking_duration = 0.5  # seconds of non-speaking audio to keep on both sides of the recording

'''
recognizer = sr.Recognizer()
recognizer.dynamic_energy_adjustment_damping = 0.16
recognizer.dynamic_energy_ratio = 1.6

# speak_hanlder
# =================================================================
speech_loaded = False
speech_lock = threading.Lock()
tts_file = None

def speak_hanlder():
    global speech_loaded, tts_file
    while True:
        with speech_lock:
            _isloaded = speech_loaded
        if _isloaded:
            # gray_print('speak start')
            speak_block(music, tts_file)
            # gray_print('speak done')
            with speech_lock:
                speech_loaded = False
        time.sleep(0.05)

speak_thread = threading.Thread(target=speak_hanlder)
speak_thread.daemon = True


# actions thread
# =================================================================
action_status = 'standby' # 'standby', 'think', 'actions', 'actions_done'
led_status = 'standby' # 'standby', 'think' or 'actions', 'actions_done'
last_action_status = 'standby'
last_led_status = 'standby'

LED_DOUBLE_BLINK_INTERVAL = 0.8 # seconds
LED_BLINK_INTERVAL = 0.1 # seconds

actions_to_be_done = []
action_lock = threading.Lock()

def action_handler():
    global action_status, actions_to_be_done, led_status, last_action_status, last_led_status

    # standby_actions = ['waiting', 'feet_left_right']
    # standby_weights = [1, 0.3]

    action_interval = 5 # seconds
    last_action_time = time.time()
    last_led_time = time.time()

    while True:
        with action_lock:
            _state = action_status

        # led
        # ------------------------------
        led_status = _state

        if led_status != last_led_status:
            last_led_time = 0
            last_led_status = led_status

        if led_status == 'standby':
            if time.time() - last_led_time > LED_DOUBLE_BLINK_INTERVAL:
                led.off()
                led.on()
                sleep(.1)
                led.off()
                sleep(.1)
                led.on()
                sleep(.1)
                led.off()
                last_led_time = time.time()
        elif led_status == 'think':
            if time.time() - last_led_time > LED_BLINK_INTERVAL:
                led.off()
                sleep(LED_BLINK_INTERVAL)
                led.on()
                sleep(LED_BLINK_INTERVAL)
                last_led_time = time.time()
        elif led_status == 'actions':
                led.on() 

        # actions
        # ------------------------------
        if _state == 'standby':
            last_action_status = 'standby'
            if time.time() - last_action_time > action_interval:
                # TODO: standby actions
                last_action_time = time.time()
                action_interval = random.randint(2, 6)
        elif _state == 'think':
            if last_action_status != 'think':
                last_action_status = 'think'
                # think(my_car)
                keep_think(my_car)
        elif _state == 'actions':
            last_action_status = 'actions'
            with action_lock:
                _actions = actions_to_be_done
            for _action in _actions:
                try:
                    actions_dict[_action](my_car)
                except Exception as e:
                    print(f'action error: {e}')
                time.sleep(0.5)

            with action_lock:
                action_status = 'actions_done'
            last_action_time = time.time()

        time.sleep(0.01)

action_thread = threading.Thread(target=action_handler)
action_thread.daemon = True


# main
# =================================================================
def main():
    global current_feeling, last_feeling
    global speech_loaded
    global action_status, actions_to_be_done
    global tts_file

    my_car.reset()
    my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

    speak_thread.start()
    action_thread.start()

    while True:
        if input_mode == 'voice':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            # listen
            # ----------------------------------------------------------------
            gray_print("listening ...")

            with action_lock:
                action_status = 'standby'

            _stderr_back = redirect_error_2_null() # ignore error print to ignore ALSA errors
            # If the chunk_size is set too small (default_size=1024), it may cause the program to freeze
            with sr.Microphone(chunk_size=8192) as source:
                cancel_redirect_error(_stderr_back) # restore error print
                recognizer.adjust_for_ambient_noise(source)
                audio = recognizer.listen(source)

            # stt
            # ----------------------------------------------------------------
            st = time.time()
            _result = openai_helper.stt(audio, language=LANGUAGE)
            gray_print(f"stt takes: {time.time() - st:.3f} s")

            if _result == False or _result == "":
                print() # new line
                continue

        elif input_mode == 'keyboard':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            with action_lock:
                action_status = 'standby'

            _result = input(f'\033[1;30m{"intput: "}\033[0m').encode(sys.stdin.encoding).decode('utf-8')

            if _result == False or _result == "":
                print() # new line
                continue

        else:
            raise ValueError("Invalid input mode")

        # chat-gpt
        # ---------------------------------------------------------------- 
        response = {}
        st = time.time()

        with action_lock:
            action_status = 'think'

        if with_img:
            img_path = './img_imput.jpg'
            cv2.imwrite(img_path, Vilib.img)
            response = openai_helper.dialogue_with_img(_result, img_path)
        else:
            response = openai_helper.dialogue(_result)

        gray_print(f'chat takes: {time.time() - st:.3f} s')

        # actions & TTS
        # ----------------------------------------------------------------
        _sound_actions = [] 
        try:
            if isinstance(response, dict):
                if 'actions' in response:
                    actions = list(response['actions'])
                else:
                    actions = ['stop']

                if 'answer' in response:
                    answer = response['answer']
                else:
                    answer = ''

                if len(answer) > 0:
                    _actions = list.copy(actions)
                    for _action in _actions:
                        if _action in SOUND_EFFECT_ACTIONS:
                            _sound_actions.append(_action)
                            actions.remove(_action)

            else:
                response = str(response)
                if len(response) > 0:
                    actions = []
                    answer = response

        except:
            actions = []
            answer = ''
    
        try:
            # ---- tts ----
            _tts_status = False
            if answer != '':
                st = time.time()
                _time = time.strftime("%y-%m-%d_%H-%M-%S", time.localtime())
                _tts_f = f"./tts/{_time}_raw.wav"
                _tts_status = openai_helper.text_to_speech(answer, _tts_f, TTS_VOICE, response_format='wav') # alloy, echo, fable, onyx, nova, and shimmer
                if _tts_status:
                    tts_file = f"./tts/{_time}_{VOLUME_DB}dB.wav"
                    _tts_status = sox_volume(_tts_f, tts_file, VOLUME_DB)
                gray_print(f'tts takes: {time.time() - st:.3f} s')

            # ---- actions ----
            with action_lock:
                actions_to_be_done = actions
                gray_print(f'actions: {actions_to_be_done}')
                action_status = 'actions'

            # --- sound effects and voice ---
            for _sound in _sound_actions:
                try:
                    sounds_dict[_sound](music)
                except Exception as e:
                    print(f'action error: {e}')

            if _tts_status:
                with speech_lock:
                    speech_loaded = True

            # ---- wait speak done ----
            if _tts_status:
                while True:
                    with speech_lock:
                        if not speech_loaded:
                            break
                    time.sleep(.01)

            # ---- wait actions done ----
            while True:
                with action_lock:
                    if action_status != 'actions':
                        break
                time.sleep(.01)

            ##
            print() # new line

        except Exception as e:
            print(f'actions or TTS error: {e}')


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\033[31mERROR: {e}\033[m")
    finally:
        if with_img:
            Vilib.camera_close()
        my_car.reset()



##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/gpt_examples/preset_actions.py
##################################################


from time import sleep
import random
from math import sin, cos, pi

def wave_hands(car):
    car.reset()
    car.set_cam_tilt_angle(20)
    for _ in range(2):
        car.set_dir_servo_angle(-25)
        sleep(.1)
        # car.set_dir_servo_angle(0)
        # sleep(.1)
        car.set_dir_servo_angle(25)
        sleep(.1)
    car.set_dir_servo_angle(0)

def resist(car):
    car.reset()
    car.set_cam_tilt_angle(10)
    for _ in range(3):
        car.set_dir_servo_angle(-15)
        car.set_cam_pan_angle(15)
        sleep(.1)
        car.set_dir_servo_angle(15)
        car.set_cam_pan_angle(-15)
        sleep(.1)
    car.stop()
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)

def act_cute(car):
    car.reset()
    car.set_cam_tilt_angle(-20)
    for i in range(15):
        car.forward(5)
        sleep(0.02)
        car.backward(5)
        sleep(0.02)
    car.set_cam_tilt_angle(0)
    car.stop()

def rub_hands(car):
    car.reset()
    for i in range(5):
        car.set_dir_servo_angle(-6)
        sleep(.5)
        car.set_dir_servo_angle(6)
        sleep(.5)
    car.reset()

def think(car):
    car.reset()

    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)
    sleep(1)
    car.set_cam_pan_angle(15)
    car.set_cam_tilt_angle(-10)
    car.set_dir_servo_angle(10)
    sleep(.1)
    car.reset()

def keep_think(car):
    car.reset()
    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)

def shake_head(car):
    car.stop()
    car.set_cam_pan_angle(0)
    car.set_cam_pan_angle(60)
    sleep(.2)
    car.set_cam_pan_angle(-50)
    sleep(.1)
    car.set_cam_pan_angle(40)
    sleep(.1)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_cam_pan_angle(20)
    sleep(.1)
    car.set_cam_pan_angle(-10)
    sleep(.1)
    car.set_cam_pan_angle(10)
    sleep(.1)
    car.set_cam_pan_angle(-5)
    sleep(.1)
    car.set_cam_pan_angle(0)

def nod(car):
    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(0)


def depressed(car):
    # car.reset()
    # car.set_cam_tilt_angle(0)
    # car.set_cam_tilt_angle(20)
    # sleep(.22)
    # car.set_cam_tilt_angle(-30)
    # sleep(.1)
    # car.set_cam_tilt_angle(15)
    # sleep(.1)
    # car.set_cam_tilt_angle(-20)
    # sleep(.1)
    # car.set_cam_tilt_angle(10)
    # sleep(.1)
    # car.set_cam_tilt_angle(-10)
    # sleep(.1)
    # car.set_cam_tilt_angle(5)
    # sleep(.1)
    # car.set_cam_tilt_angle(-5)
    # sleep(.1)
    # car.set_cam_tilt_angle(2)
    # sleep(.1)
    # car.set_cam_tilt_angle(0)

    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(20)
    sleep(.22)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(0)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-15)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-19)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)

    sleep(1.5)
    car.reset()

def twist_body(car):
    car.reset()
    for i in range(3):
        car.set_motor_speed(1, 20)
        car.set_motor_speed(2, 20)
        car.set_cam_pan_angle(-20)
        car.set_dir_servo_angle(-10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)
        sleep(.1)
        car.set_motor_speed(1, -20)
        car.set_motor_speed(2, -20)
        car.set_cam_pan_angle(20)
        car.set_dir_servo_angle(10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)

        sleep(.1)


def celebrate(car):
    car.reset()
    car.set_cam_tilt_angle(20)

    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(10)
    car.set_cam_pan_angle(30)
    sleep(.1)
    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(-10)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

def honking(music):
    import utils
    # utils.speak_block(music, "../sounds/car-double-horn.wav", 100)
    music.sound_play_threading("../sounds/car-double-horn.wav", 100)

def start_engine(music):
    import utils
    # utils.speak_block(music, "../sounds/car-start-engine.wav", 100)
    music.sound_play_threading("../sounds/car-start-engine.wav", 50)


actions_dict = {
    "shake head":shake_head, 
    "nod": nod,
    "wave hands": wave_hands,
    "resist": resist,
    "act cute": act_cute,
    "rub hands": rub_hands,
    "think": think,
    "twist body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
}

sounds_dict = {
    "honking": honking,
    "start engine": start_engine,
}


if __name__ == "__main__":
    from picarx import Picarx
    from robot_hat import Music
    import os

    os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
    current_path = os.path.dirname(os.path.abspath(__file__))
    os.chdir(current_path) # change working directory

    my_car = Picarx()
    my_car.reset()

    music = Music()

    sleep(.5)

    _actions_num = len(actions_dict)
    actions = list(actions_dict.keys())
    for i, key in enumerate(actions_dict):
        print(f'{i} {key}')
    
    _sounds_num = len(sounds_dict)
    sounds = list(sounds_dict.keys())
    for i, key in enumerate(sounds_dict):
        print(f'{_actions_num+i} {key}')

    last_key = None

    try:
        while True:
            key = input()

            if key == '':
                if last_key > _actions_num - 1:
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    print(actions[last_key])
                    actions_dict[actions[last_key]](my_car)
            else:
                key = int(key)
                if key > (_actions_num + _sounds_num - 1):
                    print("Invalid key")
                elif key > (_actions_num - 1):
                    last_key = key
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    last_key = key
                    print(actions[key])
                    actions_dict[actions[key]](my_car)

            # sleep(2)
            # shake_head(my_car)
            # nod(my_car)
            # wave_hands(my_car)
            # resist(my_car)
            # act_cute(my_car)
            # rub_hands(my_car)
            # think(my_car)
            # twist(my_car)
            # celebrate(my_car)
            # depressed(my_car)

    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f'Error:\n {e}')
    finally:
        my_car.reset()
        sleep(.1)






##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/setup.py
##################################################

# Always prefer setuptools over distutils
from setuptools import setup, find_packages
# To use a consistent encoding
from codecs import open
from os import path
import sys

sys.path.append('./picarx')
from version import __version__

here = path.abspath(path.dirname(__file__))

# Get the long description from the relevant file
with open(path.join(here, 'DESCRIPTION.rst'), encoding='utf-8') as f:
    long_description = f.read()

setup(
    name='picarx',

    # Versions should comply with PEP440.  For a discussion on single-sourcing
    # the version across setup.py and the project code, see
    # https://packaging.python.org/en/latest/single_source_version.html
    version=__version__,

    description='Picarx gait Library for Raspberry Pi',
    long_description=long_description,

    # The project's main homepage.
    url='https://github.com/sunfounder/piarm',

    # Author details
    author='SunFounder',
    author_email='service@sunfounder.com',

    # Choose your license
    license='GNU',
    zip_safe=False,
    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers
    classifiers=[
        # How mature is this project? Common values are
        #   3 - Alpha
        #   4 - Beta
        #   5 - Production/Stable
        'Development Status :: 3 - Alpha',

        # Indicate who your project is intended for
        'Intended Audience :: Developers',
        'Topic :: Software Development :: Build Tools',

        # Pick your license as you wish (should match "license" above)
        'License :: OSI Approved :: GNU License',

        # Specify the Python versions you support here. In particular, ensure
        # that you indicate whether you support Python 2, Python 3 or both.
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.2',
        'Programming Language :: Python :: 3.3',
        'Programming Language :: Python :: 3.4',
    ],

    # What does your project relate to?
    keywords='python raspberry pi GPIO sunfounder',

    # You can just specify the packages manually here if your project is
    # simple. Or you can use find_packages().
    packages=find_packages(exclude=[ 'doc', 'tests*' ,'examples']),

    # List run-time dependencies here.  These will be installed by pip when
    # your project is installed. For an analysis of "install_requires" vs pip's
    # requirements files see:
    # https://packaging.python.org/en/latest/requirements.html
    install_requires=['readchar'],
 
    # To provide executable scripts, use entry points in preference to the
    # "scripts" keyword. Entry points provide cross-platform support and allow
    # pip to create the appropriate form of executable for the target platform.
    entry_points={
        'console_scripts': [
        ],
    },
)


##################################################
# FILE: baseline_code_backup_20250606_120552/picar-x/autostart.service
##################################################

# https://www.freedesktop.org/software/systemd/man/systemd.service.html
[Unit]
Description=picarx service
After=multi-user.target

[Service]
Type=forking
WorkingDirectory=/home/pi/picar-x/
ExecStart=python3 /home/pi/picar-x/examples/minecart_plus.py &&

[Install]
WantedBy=multi-user.target

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/LICENSE
##################################################

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/i2samp.sh
##################################################

#!/bin/bash

# global variables
# =================================================================
VERSION="0.0.4"
USERNAME=${SUDO_USER:-$LOGNAME}
USER_RUN="sudo -u ${USERNAME} env XDG_RUNTIME_DIR=/run/user/$(id -u ${USERNAME})"

CONFIG="/boot/firmware/config.txt"
# Fall back to the old config.txt path
if ! test -f $CONFIG; then
    CONFIG="/boot/config.txt"
fi

ASOUND_CONF="/etc/asound.conf"

# ----- robot hat without onboard mic -----
DTOVERLAY_WITHOUT_MIC="hifiberry-dac"
AUDIO_CARD_NAME_WITHOUT_MIC="sndrpihifiberry"
ALSA_CARD_NAME_WITHOUT_MIC="snd_rpi_hifiberry_dac"

# ----- robot hat with onboard mic -----
DTOVERLAY_WITH_MIC="googlevoicehat-soundcard"
AUDIO_CARD_NAME_WITH_MIC="sndrpigooglevoi"
ALSA_CARD_NAME_WITH_MIC="snd_rpi_googlevoicehat_soundcar"

SOFTVOL_SPEAKER_NAME="robot-hat speaker"
SOFTVOL_MIC_NAME="robot-hat mic"

# ----- robot hat 5 -----
HAT_DEVICE_TREE="/proc/decvice-tree/"
HAT_UUIDs=(
    "9daeea78-0000-076e-0032-582369ac3e02",
)
ROBOTHAT5_PRODUCT_VER=50
robothat_product=""
robothat_product_id=0
robothat_product_ver=0
robothat_uuid=""
robothat_vendor=""

# ---------------------------
robothat_spk_en=20 # robothat4 GPIO20, robothat5 GPIO12
_is_install_deps=true
_is_with_mic=true
dtoverlay_name=""
audio_card_name=""
alsa_card_name=""

# function define
# =================================================================
# black     0
# red       1
# green     2
# yellow    3
# blue      4
# magenta   5
# cyan      6
# white     7
success() {
    echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

info() {
    echo -e "$(tput setaf 6)$1$(tput sgr0)"
}

warning() {
    echo -e "$(tput setaf 3)$1$(tput sgr0)"
}

error() {
    echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

newline() {
    echo ""
}

confirm() {
    if [ "$FORCE" == '-y' ]; then
        true
    else
        read -r -p "$1 [y/N] " response </dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
    fi
}

sudocheck() {
    if [ $(id -u) -ne 0 ]; then
        warning "Install must be run as root. Try 'sudo bash ./i2samp.sh'"
        exit 1
    fi
}

ask_reboot() {
    read -e -p "$(tput setaf 5)$1 (Y/N): $(tput sgr0)" choice
    if [ "$choice" == "Y" ] || [ "$choice" == "y" ]; then
        info "Rebooting now ..."
        sudo sync && sudo reboot
    fi
}

get_soundcard_index() {
    card_name=$1
    if [[ -z "${card_name}" ]]; then
        error "card_name is null"
        return
    fi
    card_index=$(sudo aplay -l | grep $card_name | awk '{print $2}' | tr -d ':')
    echo $card_index
}

config_asound_without_mic() {
    # backup file
    if [ -e "${ASOUND_CONF}" ]; then
        if [ -e "${ASOUND_CONF}.old" ]; then
            sudo rm -f "${ASOUND_CONF}.old"
        fi
        sudo cp "${ASOUND_CONF}" "${ASOUND_CONF}.old"
    fi

    cat >"${ASOUND_CONF}" <<EOF

pcm.speaker {
    type hw
    card ${AUDIO_CARD_NAME_WITHOUT_MIC}
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speaker"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw
    card ${AUDIO_CARD_NAME_WITHOUT_MIC}
}

pcm.softvol {
    type softvol
    slave.pcm "dmixer"
    control {
        name "${SOFTVOL_SPEAKER_NAME} Playback Volume"
        card ${AUDIO_CARD_NAME_WITHOUT_MIC}
    }
    min_dB -51.0
    max_dB 0.0
}

pcm.robothat {
    type plug
    slave.pcm "softvol"
}

ctl.robothat {
    type hw
    card ${AUDIO_CARD_NAME_WITHOUT_MIC}
}

pcm.!default robothat
ctl.!default robothat

EOF
}

config_asound_with_mic() {
    # backup file
    if [ -e "${ASOUND_CONF}" ]; then
        if [ -e "${ASOUND_CONF}.old" ]; then
            sudo rm -f "${ASOUND_CONF}.old"
        fi
        sudo cp "${ASOUND_CONF}" "${ASOUND_CONF}.old"
    fi

    if [ $robothat_product_ver -ge ${ROBOTHAT5_PRODUCT_VER} ]; then

        #
        sudo cat >"${ASOUND_CONF}" <<EOF

pcm.robothat {
    type asym
    playback.pcm {
        type plug
        slave.pcm "speaker"
    }
    capture.pcm {
        type plug
        slave.pcm "mic"
    }
}

pcm.speaker_hw {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
    device 0
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speaker_hw"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
}

pcm.speaker {
    type softvol
    slave {
        pcm "dmixer"
    }
    control {
        name "${SOFTVOL_SPEAKER_NAME} Playback Volume"
        card ${AUDIO_CARD_NAME_WITH_MIC}
    }
    min_dB -51.0
    max_dB 0.0
}

pcm.mic_hw {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
    device 0
}

pcm.mic {
    type softvol
    slave {
        pcm "mic_hw"
    }
    control {
        name "${SOFTVOL_MIC_NAME} Capture Volume"
        card ${AUDIO_CARD_NAME_WITH_MIC}
    }
    min_dB -26.0
    max_dB 25.0
}

ctl.robothat {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
}

pcm.!default robothat
ctl.!default robothat

EOF

    else
        sudo cat >"${ASOUND_CONF}" <<EOF

pcm.robothat {
    type asym
    playback.pcm {
        type plug
        slave.pcm "speaker"
    }
}

pcm.speaker_hw {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
    device 0
}

pcm.speaker {
    type softvol
    slave {
        pcm "speaker_hw"
    }
    control {
        name "${SOFTVOL_SPEAKER_NAME} Playback Volume"
        card ${AUDIO_CARD_NAME_WITH_MIC}
    }
    min_dB -51.0
    max_dB 0.0
}

ctl.robothat {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
}

pcm.!default robothat
ctl.!default robothat

EOF
    fi

}

get_sink_index() {
    card_name=$1
    if [[ -z "${card_name}" ]]; then
        error "card name is null"
        return
    fi
    index=$($USER_RUN \
        pactl -f json list sinks | jq -r \
        '.[] | select(.["properties"]["alsa.card_name"] == "'${card_name}'"
        and .["properties"]["device.class"] == "sound"
        ).index')
    echo $index
}

get_source_index() {
    card_name=$1
    if [[ -z "${card_name}" ]]; then
        error "card name is null"
        return
    fi
    index=$($USER_RUN \
        pactl -f json list sources | jq -r \
        '.[] | select(.["properties"]["alsa.card_name"] == "'${card_name}'"
        and .["properties"]["device.class"] == "sound"
        ).index')
    echo $index
}

set_default_sink() {
    sink_index=$1
    if [[ -z "${sink_index}" ]]; then
        error "sink index is null"
        return
    fi
    $USER_RUN \
        pactl set-default-sink ${sink_index}
}

set_default_source() {
    source_index=$1
    if [[ -z "${source_index}" ]]; then
        error "source index is null"
        return
    fi
    $USER_RUN \
        pactl set-default-source ${source_index}
}

set_default_sink_volume() {
    volume=$1
    if [[ -z "${volume}" ]]; then
        error "volume is null"
        return
    fi
    $USER_RUN \
        pactl set-sink-volume @DEFAULT_SINK@ ${volume}%
}

set_default_source_volume() {
    volume=$1
    if [[ -z "${volume}" ]]; then
        error "volume is null"
        return
    fi
    $USER_RUN \
        pactl set-source-volume @DEFAULT_SOURCE@ ${volume}%
}

check_robothat() {
    # find robothat device-tree directory
    hat_dirs=$(find /proc/device-tree/*hat* -type d)
    # echo $hat_dirs
    hat_dir=""

    for dir in $hat_dirs; do
        if [ ! -e "$dir"/uuid ]; then
            continue
        fi
        uuid=$(tr -d '\0' <"$dir"/uuid)
        # echo uuid:$uuid

        # ----- whether uuid in HAT_UUIDs -----
        # echo HAT_UUIDs:${HAT_UUIDs[@]}
        if [[ -n "${uuid}" && "${HAT_UUIDs[@]}" =~ "${uuid}" ]]; then
            hat_dir=$dir
            break
        fi
    done

    echo hat_dir:$hat_dir
    if [[ -z "${hat_dir}" ]]; then
        echo "No robothat 5 found"
        return
    fi

    # read robothat info
    robothat_product=$(tr -d '\0' <"$hat_dir"/product)
    robothat_product_id_hex=$(tr -d '\0' <"$hat_dir"/product_id)
    robothat_product_ver_hex=$(tr -d '\0' <"$hat_dir"/product_ver)
    let robothat_product_id=$(printf "%d" $robothat_product_id_hex)
    let robothat_product_ver=$(printf "%d" $robothat_product_ver_hex)

    robothat_uuid=$(tr -d '\0' <"$hat_dir"/uuid)
    robothat_vendor=$(tr -d '\0' <"$hat_dir"/vendor)

    success "Found:"
    success "  Product: $robothat_product"
    success "  Product ID: $robothat_product_id ($robothat_product_id_hex)"
    success "  Version: $robothat_product_ver ($robothat_product_ver_hex)"
    success "  Vendor: $robothat_vendor"
    success "  UUID: $robothat_uuid"
}

# main_fuction
# ================================================================================
install_soundcard_driver() {
    info "install robot-hat soundcard driver >>>"
    info "script version: $VERSION"
    info "user: $USERNAME"

    # check root
    # =====================================
    sudocheck

    # apt install packages
    # =====================================
    if $_is_install_deps; then
        newline
        info "apt update..."
        apt update

        info "install alsa-utils ..."
        # alsa-utils includes:
        #  alsamixer, aplay, arecord, amixer, speaker-test
        apt install alsa-utils -y

        info "install pulseaudio ..."
        apt install pulseaudio -y

        info "install pulseaudio-utils ..."
        apt install pulseaudio-utils -y

        info "install jq ..."
        apt install jq -y

        info "install sox ..."
        apt install sox -y
    else
        info "skip install deps ..."
    fi

    # detect robothat 5
    # =====================================
    newline
    info "check robothat 5 ..."
    check_robothat

    if [ $robothat_product_ver -ge ${ROBOTHAT5_PRODUCT_VER} ]; then
        robothat_spk_en=12
        _is_with_mic=true
    else
        robothat_spk_en=20
        _is_with_mic=false
    fi
    success "robothat_spk_en: ${robothat_spk_en}"
    success "is_with_mic: ${_is_with_mic}"

    # config soundcard
    # =====================================
    newline
    if $_is_with_mic; then
        info "config soundcard with mic ..."
        dtoverlay_name=${DTOVERLAY_WITH_MIC}
        audio_card_name=${AUDIO_CARD_NAME_WITH_MIC}
        alsa_card_name=${ALSA_CARD_NAME_WITH_MIC}
    else
        info "config soundcard without mic ..."
        dtoverlay_name=${DTOVERLAY_WITHOUT_MIC}
        audio_card_name=${AUDIO_CARD_NAME_WITHOUT_MIC}
        alsa_card_name=${ALSA_CARD_NAME_WITHOUT_MIC}
    fi

    # --- add dtoverlay to config.txt ---
    newline
    if $_is_with_mic; then
        info "add dtoverlay ${DTOVERLAY_WITH_MIC} in ${CONFIG} ..."
        if [ -e "${CONFIG}" ]; then
            # dtoverlay=googlevoicehat-soundcard
            # #dtoverlay=hifiberry-dac
            if grep -q -e ".*dtoverlay=${DTOVERLAY_WITH_MIC}.*" "${CONFIG}"; then
                echo "activated dtoverlay ${DTOVERLAY_WITH_MIC} ..."
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITH_MIC}.*:dtoverlay=${DTOVERLAY_WITH_MIC}:g" "${CONFIG}"
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*:#dtoverlay=${DTOVERLAY_WITHOUT_MIC}:g" "${CONFIG}"
            else
                echo "add dtoverlay ${DTOVERLAY_WITH_MIC} ..."
                echo "dtoverlay=${DTOVERLAY_WITH_MIC}" | sudo tee -a $CONFIG
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*:#dtoverlay=${DTOVERLAY_WITHOUT_MIC}:g" "${CONFIG}"
            fi
        else
            error "${CONFIG} not found"
        fi
    else
        info "add dtoverlay ${DTOVERLAY_WITHOUT_MIC} in ${CONFIG} ..."
        if [ -e "${CONFIG}" ]; then
            # dtoverlay=googlevoicehat-soundcard
            # #dtoverlay=hifiberry-dac
            if grep -q -e ".*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*" "${CONFIG}"; then
                echo "activated dtoverlay ${DTOVERLAY_WITHOUT_MIC} ..."
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*:dtoverlay=${DTOVERLAY_WITHOUT_MIC}:g" "${CONFIG}"
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITH_MIC}.*:#dtoverlay=${DTOVERLAY_WITH_MIC}:g" "${CONFIG}"
            else
                echo "add dtoverlay ${DTOVERLAY_WITHOUT_MIC} ..."
                echo "dtoverlay=${DTOVERLAY_WITHOUT_MIC}" | sudo tee -a $CONFIG
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITH_MIC}.*:#dtoverlay=${DTOVERLAY_WITH_MIC}:g" "${CONFIG}"
            fi
        else
            error "${CONFIG} not found"
        fi
    fi

    # --- load dtoverlay ---
    newline
    info "Trying to load dtoverlay ${dtoverlay_name} ..."
    dtoverlay ${dtoverlay_name}
    sleep 1

    # --- get sound card ---
    info "get_soundcard_index ..."
    card_index=$(get_soundcard_index $audio_card_name)
    if [[ -z "${card_index}" ]]; then
        error "soundcard index not found. Sometimes you need to reboot to activate the soundcard."
        ask_reboot "Would you like to reboot and retry now?"
        warning "Unfinished"
        exit 1
    else
        success "soundcard ${audio_card_name} index: ${card_index}"
    fi

    # --- config /etc/asound.conf ---
    newline
    if $_is_with_mic; then
        info "config /etc/asound.conf with mic ..."
        # write asound.conf
        config_asound_with_mic
    else
        info "config /etc/asound.conf without mic ..."
        # write asound.conf
        config_asound_without_mic
    fi
    # restart alsa-utils
    sudo systemctl restart alsa-utils 2>/dev/null
    # set volume 100%
    info "set ALSA speker volume to 100% ..."
    play -n trim 0.0 0.5 2>/dev/null # play a short sound to to activate alsamixer speaker vol control
    amixer -c ${audio_card_name} sset "${SOFTVOL_SPEAKER_NAME}" 100%
    if $_is_with_mic; then
        info "set ALSA mic volume to 100% ..."
        rec /tmp/rec_test.wav trim 0 0.5 2>/dev/null # record a short sound to activate alsamixer mic vol control
        amixer -c ${audio_card_name} sset "${SOFTVOL_MIC_NAME}" 100%
    fi

    # --- config pulseaudio ---
    newline
    info "config pulseaudio ..."

    # enable pulseaudio
    # https://www.raspberrypi.com/documentation/computers/configuration.html#audio-config-2
    info "raspi-config enable pulseaudio ..."
    raspi-config nonint do_audioconf 1 2>/dev/null

    # run pulseaudio
    info "run pulseaudio ..."
    # # stop pulseaudio
    # $USER_RUN \
    #     pulseaudio -k 2>/dev/null
    # start pulseaudio
    $USER_RUN \
        pulseaudio -D 2>/dev/null

    # get sink index
    newline
    info "get_sink_index ..."
    sink_index=$(get_sink_index $alsa_card_name)
    if [[ -z "${sink_index}" ]]; then
        error "sink index not found."
        error "Sometimes you need to reboot to activate the soundcard."
    else
        success "sink index: ${sink_index}"
    fi

    # set default sink
    info "set default sink ..."
    set_default_sink "${sink_index}"

    if $_is_with_mic; then
        # get source index
        info "get_source_index ..."
        source_index=$(get_source_index $alsa_card_name)
        if [[ -z "${source_index}" ]]; then
            error "source index not found."
            error "Sometimes you need to reboot to activate the soundcard."
        else
            success "source index: ${source_index}"
        fi
        # set default source
        info "set default source ..."
        set_default_source "${source_index}"
    fi

    # set default volume
    info "set default Pulseaudio volume to 100% ..."
    set_default_sink_volume 100
    if $_is_with_mic; then
        set_default_source_volume 100
    fi

    # --- test speaker ---
    newline
    if confirm "Do you wish to test speaker now?"; then
        info "testing speaker ..."
        # enable speaker
        if command -v pinctrl >/dev/null; then
            pinctrl set $robothat_spk_en op dh
            # play a short sound to fill data and avoid the speaker overheating
            play -n trim 0.0 0.5 2>/dev/null
        elif command -v raspi-gpio >/dev/null; then
            raspi-gpio set $robothat_spk_en op dh
            # play a short sound to fill data and avoid the speaker overheating
            play -n trim 0.0 0.5 2>/dev/null
        else
            warning "Could not find pinctrl or raspi-gpio command."
        fi
        # test speaker
        speaker-test -l3 -c2 -t wav
    fi

    # --- Done ---
    newline
    success "All done!"
    newline
}

# main
# =================================================================
for arg in "$@"; do
    case $arg in
    --no-deps)
        _is_install_deps=false
        ;;
    esac
done

# echo sink_index=$(get_sink_index)
# echo source_index=$(get_source_index)

install_soundcard_driver

exit 0


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/pyproject.toml
##################################################


[build-system]
requires = ["setuptools >= 61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "robot_hat"
authors = [
  { name="sunfounder", email="service@sunfounder.com" },
]
description = "Robot Hat Python library for Raspberry Pi"
readme = "README.md"
requires-python = ">=3.7"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
    "Operating System :: POSIX :: Linux",
]
keywords = ["robot_hat", "sunfounder"]
dynamic = ["version"]

dependencies = [

]

[project.scripts]
robot_hat = "robot_hat:__main__"

[project.urls]
Homepage = "https://www.sunfounder.com/products/sunfounder-robot-hat-expansion-board-designed-for-raspberry-pi"
Documentation = "https://docs.sunfounder.com/projects/robot-hat-v4/en/latest/"
Repository = "https://github.com/sunfounder/robot-hat/tree/dev"
Issues = "https://github.com/sunfounder/robot-hat/issues"
Changelog = "https://github.com/sunfounder/robot-hat/commits/dev/"

[tool.setuptools.packages.find]
include = ["robot_hat"]
exclude = ["setup.py", "docs", 'tests*', 'examples', 'workspace']

[tool.setuptools.dynamic]
version = {attr = "robot_hat.version.__version__"}




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/servo_test.py
##################################################

from robot_hat import Servo
from time import sleep

servos = [Servo(i) for i in range(12)]

while True:
    for servo in servos:
        servo.angle(-20)
        sleep(0.1)
    for servo in servos:
        servo.angle(20)
        sleep(0.1)



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/init_angles_test.py
##################################################

from robot_hat import Robot,PWM,Servo,Music
from robot_hat.utils import reset_mcu
from time import sleep

reset_mcu()
sleep(0.01)


def fuc():
    rubo = Robot([10,11,12],3,init_angles=[10,45,-45])


if __name__ == "__main__":
    fuc()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/motor_robothat5_test.py
##################################################

from robot_hat import Motor, PWM, Pin
from time import sleep

m0 = Motor(PWM('P12'), PWM('P13'), mode=2)
m1 = Motor(PWM('P14'), PWM('P15'), mode=2)
m2 = Motor(PWM('P16'), PWM('P17'), mode=2)
m3 = Motor(PWM('P18'), PWM('P19'), mode=2)


try:
    while True:
        m0.speed(-50)
        m1.speed(-50)
        m2.speed(-50)
        m3.speed(-50)
        sleep(1)
        m0.speed(50)
        m1.speed(50)
        m2.speed(50)
        m3.speed(50)
        sleep(1)
        m0.speed(0)
        m1.speed(0)
        m2.speed(0)
        m3.speed(0)
finally:
    m0.speed(0)
    m1.speed(0)
    m2.speed(0)
    m3.speed(0)
    sleep(.1)



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/button_event_test.py
##################################################

from robot_hat import Pin
import time

btn = Pin("D0") # IO17

def pressed_handler():
    print(f"Pressed - {time.time()}")

def released_handler():
    print(f"Released - {time.time()}")

def both_handler():
    print(f"xxx - {time.time()}")

btn.irq(handler=pressed_handler, trigger=Pin.IRQ_FALLING, bouncetime=20)
print(btn)
btn.irq(handler=released_handler, trigger=Pin.IRQ_RISING, bouncetime=10)
print(btn)
# btn.irq(handler=both_handler, trigger=Pin.IRQ_RISING_FALLING, bouncetime=10)
# print(btn)



while True:
    time.sleep(1)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/tone_test.py
##################################################

from robot_hat import Music, set_volume
import time

# Create a new Music object
music = Music()

set_volume(80)
music.tempo(60, 1/4)

print("Measure 1")
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 2")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("C5"), music.beat(1/8))
music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("D#5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 3")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 4")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 5")
music.play_tone_for(music.note("A4"), music.beat(1/4))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
music.play_tone_for(music.note("D4"), music.beat(1/4))
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 6")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("C5"), music.beat(1/8))
music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("D#5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 7")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 8")
music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("A4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("E4"), music.beat(1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
print("Measure 9")
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
print("Measure 10")
music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("F5"), music.beat(1/8))
music.play_tone_for(music.note("E5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 11")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 12")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 13")
music.play_tone_for(music.note("A4"), music.beat(1/4))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
music.play_tone_for(music.note("D4"), music.beat(1/4 + 1/8))
print("Measure 14")
music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("F5"), music.beat(1/8))
music.play_tone_for(music.note("E5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 15")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 16")
music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("A4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("E4"), music.beat(1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
print("Measure 17")
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))


# Baby shark

# music.tempo(180)
# music.key_signature("#")
# music.time_signature(4, 4)

# print("Measure 0")
# music.play_tone_for(music.note("D4"), music.beat(1/2))
# music.play_tone_for(music.note("E4"), music.beat(1/2))
# print("Measure 1")
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# print("Measure 2")
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("D4"), music.beat(1/4))
# music.play_tone_for(music.note("E4"), music.beat(1/4))
# print("Measure 3")
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# print("Measure 4")
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("D4"), music.beat(1/4))
# music.play_tone_for(music.note("E4"), music.beat(1/4))
# print("Measure 5")
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# print("Measure 6")
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# print("Measure 7")
# music.play_tone_for(music.note("F#4"), music.beat(1))


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/motor_test.py
##################################################

from robot_hat import Motor, PWM, Pin
from time import sleep

m0 = Motor(PWM('P13'), Pin('D4'))
m1= Motor(PWM('P12'), Pin('D5'))

try:
    while True:
        m0.speed(-50)
        m1.speed(-50)
        sleep(1)
        m0.speed(50)
        m1.speed(50)
        sleep(1)
        m0.speed(0)
        m1.speed(0)
finally:
    m0.speed(0)
    m1.speed(0)
    sleep(.1)



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/tests/servo_hat_test.py
##################################################

#!/usr/bin/env python3
from robot_hat import Servo, ADC
from robot_hat.utils import reset_mcu
from time import sleep

reset_mcu()
sleep(1)

adc0 = ADC(0)
adc1 = ADC(1)
adc2 = ADC(2)
adc3 = ADC(3)
adc4 = ADC(4)


if __name__ == '__main__':
    for i in range(16):
        print(f"Servo {i} set to zero")
        Servo(i).angle(10)
        sleep(0.1)
        Servo(i).angle(0)
        sleep(0.1)
    while True:
        v0 = adc0.read()
        v1 = adc1.read()
        v2 = adc2.read()
        v3 = adc3.read()
        v4 = adc4.read()
        print(v0, v1, v2, v3, v4)
        sleep(1)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/requirements.txt
##################################################

# Defining the exact version will make sure things don't break
sphinx==7.3.7
sphinx_rtd_theme==3.0.1
sphinx_copybutton
sphinx_toolbox


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/Makefile
##################################################

# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = source
BUILDDIR      = build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_robot.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_robot:

class ``Robot``
========================================

**Example**

.. code-block:: python

    # Import Robot class
    from robot import Robot

    # Create a robot(PiSloth)
    robot = Robot(pin_list=[0, 1, 2, 3], name="pisloth")

    robot.move_list["forward"] = [
        [0, 40, 0, 15],
        [-30, 40, -30, 15],
        [-30, 0, -30, 0],

        [0, -15, 0, -40],
        [30, -15, 30, -40],
        [30, 0, 30, 0],
        ]
    
    robot.do_action("forward", step=3, speed=90)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Robot
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_servo.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_servo:

class ``Servo``
=============================

**Example**

.. code-block:: python
    
    # Import Servo class
    from robot_hat import Servo

    # Create Servo object with PWM object
    servo0 = Servo("P0")

    # Set servo to position 0, here 0 is the center position,
    # angle ranges from -90 to 90
    servo0.angle(0)

    # Sweep servo from 0 to 90 degrees, then 90 to -90 degrees, finally back to 0
    import time
    for i in range(0, 91):
        servo0.angle(i)
        time.sleep(0.05)
    for i in range(90, -91, -1):
        servo0.angle(i)
        time.sleep(0.05)
    for i in range(-90, 1):
        servo0.angle(i)
        time.sleep(0.05)


    # Servos are all controls with pulse width, some
    # from 500 ~ 2500 like most from SunFounder.
    # You can directly set the pulse width

    # Set servo to 1500 pulse width (-90 degree)
    servo0.pulse_width_time(500)
    # Set servo to 1500 pulse width (0 degree)
    servo0.pulse_width_time(1500)
    # Set servo to 1500 pulse width (90 degree)
    servo0.pulse_width_time(2500)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Servo
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/projects.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Some Projects
=================

Here, you'll find a collection of fascinating projects, all implemented using the Robot HAT. 
We provide you with detailed code, giving you the opportunity to try these projects out for yourself.

.. toctree::
    :maxdepth: 1

    project_control_motor_servo
    project_diy_car
    project_photoresistor
    project_ultrasonic
    project_plant_monitor
    project_say_something
    project_security
    community_tutorials



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/index.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

SunFounder |link_Robot_HAT_kit|
=====================================

* |link_Robot_HAT|

Thanks for choosing our |link_Robot_HAT_kit|.

.. note::
    This document is available in the following languages.

        * |link_german_tutorials|
        * |link_jp_tutorials|
        * |link_en_tutorials|
    
    Please click on the respective links to access the document in your preferred language.

.. image:: img/robot_hat_pic.png
    :width: 500
    :align: center
   

Robot HAT is a multifunctional expansion board that allows Raspberry Pi to be quickly turned into a robot. An MCU is on board to extend the PWM output and ADC input for the Raspberry Pi, as well as a motor driver chip, Bluetooth module, I2S audio module and mono speaker. As well as the GPIOs that lead out of the Raspberry Pi itself.

It also comes with a Speaker, which can be used to play background music, sound effects and implement TTS functions to make your project more interesting.

Accepts 6.0V-8.4V XH2.54 3pin power input with 2 power indicators. The board also has a user available LED and a button for you to quickly test some effects.

In this document, you will get a full understanding of the interface functions of the Robot HAT and the usage of these interfaces through the Python ``robot-hat`` library provided by SunFounder.


.. toctree::
    :maxdepth: 3

    About this HAT<self>
    features
    hardware_introduction
    battery
    installation
    install_i2s_for_speaker
    onboard_mcu
    api
    projects
    faq


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_photoresistor.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Read from Photoresistor Module
================================

In this project, we detect the light intensity and display on the I2C LCD1602.

.. image:: img/photoresistor.jpg

**Steps**

#. In this project, an I2C LCD1602 is used, so it's necessary to download the relevant libraries to make it work.

    .. code-block:: shell

        cd ~/
        wget https://github.com/sunfounder/raphael-kit/blob/master/python/LCD1602.py

#. Install ``smbus2`` for I2C.

    .. code-block:: shell

        sudo pip3 install smbus2

#. Save the following code to your Raspberry Pi and give it a name, for example, ``photoresistor.ty``.

    .. code-block:: python

        from robot_hat import ADC
        import LCD1602
        import time

        # Create an ADC object to read the value from the photoresistor
        a0 = ADC(0)

        def setup():
            # Initialize the LCD1602
            LCD1602.init(0x27, 1)
            time.sleep(2)

        def destroy():
            # Clear the LCD display
            LCD1602.clear()

        def loop():
            while True:
                # Read the value from the photoresistor
                value0 = a0.read()
                # Display the read value on the LCD
                LCD1602.write(0, 0, 'Value: %d  ' % value0)
                # Reduce the refresh rate to update once per second
                time.sleep(0.2)

        if __name__ == '__main__':
            setup()
            try:
                loop()
            except KeyboardInterrupt:
                destroy()
            except Exception as e:
                # Clear the LCD and print error message in case of an exception
                destroy()
                print("Error:", e)


#. Use the command ``sudo python3 photoresistor.ty`` to run this code.



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_control_motor_servo.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Control Servos and Motors
============================

In this project, we have 12 servos and two motors working simultaneously.

.. image:: img/servo_motor.jpg
    :width: 500
    :align: center

However, it's important to note that if your servos and motors have a high starting current, it's recommended to start them separately to avoid insufficient power supply current, which could lead to the Raspberry Pi restarting.

**Code**

.. code-block:: python

    from robot_hat import Servo, Motors
    import time

    # Create objects for 12 servos
    servos = [Servo(f"P{i}") for i in range(12)]

    # Create motor object
    motors = Motors()

    def initialize_servos():
        """Set initial angle of all servos to 0."""
        for servo in servos:
            servo.angle(-90)
            time.sleep(0.1)  # Wait for servos to reach the initial position
        time.sleep(1)


    def sweep_servos(angle_from, angle_to, step):
        """Control all servos to sweep from a start angle to an end angle."""
        if angle_from < angle_to:
            range_func = range(angle_from, angle_to + 1, step)
        else:
            range_func = range(angle_from, angle_to - 1, -step)

        for angle in range_func:
            for servo in servos:
                servo.angle(angle)
            time.sleep(0.05)

    def control_motors_and_servos():
        """Control motors and servos in synchronization."""
        try:
            while True:
                # Motors rotate forward and servos sweep from -90 to 90 degrees
                motors[1].speed(80)
                time.sleep(0.01)
                motors[2].speed(80)
                time.sleep(0.01)
                sweep_servos(-90, 90, 5)
                time.sleep(1)

                # Motors rotate backward and servos sweep from 90 to -90 degrees
                motors[1].speed(-80)
                time.sleep(0.01)
                motors[2].speed(-80)
                time.sleep(0.01)
                sweep_servos(90, -90, 5)
                time.sleep(1)
        except KeyboardInterrupt:
            # Stop motors when Ctrl+C is pressed
            motors.stop()
            print("Motors stopped.")

    # Initialize servos to their initial position
    initialize_servos()

    # Control motors and servos
    control_motors_and_servos()




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_basic_class.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

class ``_Basic_class``
=========================================

``_Basic_class`` is a logger class for all class to log, so if you want to see
logs of a class, just add a debug argument to it.

**Example**

.. code-block:: python

    # See PWM log
    from robot_hat import PWM

    # init the class with a debug argument
    pwm = PWM(0, debug_level="debug")

    # run some functions and see logs
    pwm.freq(1000)
    pwm.pulse_width_percent(100)


**API**

.. currentmodule:: robot_hat.basic

.. autoclass:: _Basic_class
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../api.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api.rst:16
msgid "Reference"
msgstr "参照"

#: of robot_hat:1
msgid "Robot Hat Library"
msgstr "Robot Hatライブラリ"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_photoresistor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_photoresistor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_photoresistor.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_photoresistor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_photoresistor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_photoresistor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_photoresistor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_photoresistor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_photoresistor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_photoresistor.rst:16
msgid "Read from Photoresistor Module"
msgstr "フォトレジスタモジュールから読み取る"

#: ../project_photoresistor.rst:18
msgid ""
"In this project, we detect the light intensity and display on the I2C "
"LCD1602."
msgstr "このプロジェクトでは、光の強度を検出し、I2C LCD1602に表示します。"

#: ../project_photoresistor.rst:22
msgid "**Steps**"
msgstr "**手順**"

#: ../project_photoresistor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr "このプロジェクトではI2C LCD1602を使用しているため、関連するライブラリをダウンロードして機能させる必要があります。"

#: ../project_photoresistor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "I2C用に ``smbus2`` をインストールします。"

#: ../project_photoresistor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``photoresistor.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``photoresistor.ty`` のような名前を付けます。"

#: ../project_photoresistor.rst:78
msgid "Use the command ``sudo python3 photoresistor.ty`` to run this code."
msgstr "このコードを実行するには、コマンド ``sudo python3 photoresistor.ty`` を使用します。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_i2c.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_i2c.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_i2c.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_i2c.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_i2c.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_i2c.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_i2c.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_i2c.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_i2c.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_i2c.rst:18
msgid "class ``I2C``"
msgstr "クラス ``I2C``"

#: ../api_i2c.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_i2c.rst:44
msgid "For more information on the I2C protocol, see checkout adc.py and pwm.py"
msgstr "I2Cプロトコルの詳細については、adc.pyとpwm.pyをご覧ください"

#: ../api_i2c.rst:46
msgid "**API**"
msgstr "**API**"

#: of robot_hat.i2c.I2C:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.i2c.I2C:1
msgid "I2C bus read/write functions"
msgstr "I2Cバスの読み書き機能"

#: of robot_hat.i2c.I2C.__init__:1
msgid "Initialize the I2C bus"
msgstr "I2Cバスを初期化する"

#: of robot_hat.i2c.I2C.__init__ robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.mem_write robot_hat.i2c.I2C.read robot_hat.i2c.I2C.write
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.i2c.I2C.__init__:3
msgid "I2C device address"
msgstr "I2Cデバイスアドレス"

#: of robot_hat.i2c.I2C.__init__:5
msgid "I2C bus number"
msgstr "I2Cバス番号"

#: of robot_hat.i2c.I2C.scan:1
msgid "Scan the I2C bus for devices"
msgstr "I2Cバスをスキャンしてデバイスを検出する"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.i2c.I2C.scan:3
msgid "List of I2C addresses of devices found"
msgstr "見つかったデバイスのI2Cアドレスのリスト"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.i2c.I2C.write:1
msgid "Write data to the I2C device"
msgstr "I2Cデバイスにデータを書き込む"

#: of robot_hat.i2c.I2C.write:3
msgid "Data to write"
msgstr "書き込むデータ"

#: of robot_hat.i2c.I2C.write
msgid "raises"
msgstr "例外"

#: of robot_hat.i2c.I2C.write:5
msgid "ValueError if write is not an int, list or bytearray"
msgstr "書き込みがint、リスト、またはバイト配列でない場合はValueError"

#: of robot_hat.i2c.I2C.read:1
msgid "Read data from I2C device"
msgstr "I2Cデバイスからデータを読み取る"

#: of robot_hat.i2c.I2C.mem_read:3 robot_hat.i2c.I2C.read:3
msgid "Number of bytes to receive"
msgstr "受信するバイト数"

#: of robot_hat.i2c.I2C.read:5
msgid "Received data"
msgstr "受信したデータ"

#: of robot_hat.i2c.I2C.mem_write:1
msgid "Send data to specific register address"
msgstr "特定のレジスタアドレスにデータを送信する"

#: of robot_hat.i2c.I2C.mem_write:3
msgid "Data to send, int, list or bytearray"
msgstr "送信するデータ、int、リスト、またはバイト配列"

#: of robot_hat.i2c.I2C.mem_read:5 robot_hat.i2c.I2C.mem_write:5
msgid "Register address"
msgstr "レジスタアドレス"

#: of robot_hat.i2c.I2C.mem_write
msgid "Raises"
msgstr "例外"

#: of robot_hat.i2c.I2C.mem_write:7
msgid "If data is not int, list, or bytearray"
msgstr "データがint、リスト、またはバイト配列でない場合"

#: of robot_hat.i2c.I2C.mem_read:1
msgid "Read data from specific register address"
msgstr "特定のレジスタアドレスからデータを読み取る"

#: of robot_hat.i2c.I2C.mem_read:7
msgid "Received bytearray data or False if error"
msgstr "エラーがない場合は受信したバイト配列データ、エラーがある場合はFalse"

#: of robot_hat.i2c.I2C.is_avaliable:1
msgid "Check if the I2C device is avaliable"
msgstr "I2Cデバイスが利用可能かどうかを確認する"

#: of robot_hat.i2c.I2C.is_avaliable:3
msgid "True if the I2C device is avaliable, False otherwise"
msgstr "I2Cデバイスが利用可能な場合はTrue、そうでない場合はFalse"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_tts.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_tts.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_tts.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_tts.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_tts.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_tts.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_tts.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_tts.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_tts.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_tts.rst:18
msgid "class ``TTS``"
msgstr "クラス ``TTS``"

#: ../api_tts.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr "スピーカーが動作しない場合、このスクリプトを実行する際には ``sudo`` を追加する必要があります。"

#: ../api_tts.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_tts.rst:24
msgid "**Example**"
msgstr "**例**"

#: ../api_tts.rst:39
msgid "**API**"
msgstr "**API**"

#: of robot_hat.tts.TTS:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.tts.TTS:1
msgid "Text to speech class"
msgstr "テキストから音声への変換クラス"

#: ../docstring of robot_hat.TTS.SUPPORTED_LANGUAUE:1
msgid "Supported TTS language for pico2wave"
msgstr "pico2waveのためのサポートされているTTS言語"

#: ../docstring of robot_hat.TTS.ESPEAK:1
msgid "espeak TTS engine"
msgstr "espeak TTSエンジン"

#: ../docstring of robot_hat.TTS.PICO2WAVE:1
msgid "pico2wave TTS engine"
msgstr "pico2wave TTSエンジン"

#: of robot_hat.tts.TTS.__init__:1
msgid "Initialize TTS class."
msgstr "TTSクラスを初期化する。"

#: of robot_hat.tts.TTS.__init__ robot_hat.tts.TTS.espeak
#: robot_hat.tts.TTS.espeak_params robot_hat.tts.TTS.lang
#: robot_hat.tts.TTS.pico2wave robot_hat.tts.TTS.say
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.tts.TTS.__init__:3
msgid "TTS engine, TTS.PICO2WAVE or TTS.ESPEAK"
msgstr "TTSエンジン、TTS.PICO2WAVEまたはTTS.ESPEAK"

#: of robot_hat.tts.TTS.say:1
msgid "Say words."
msgstr "言葉を話す。"

#: of robot_hat.tts.TTS.espeak:3 robot_hat.tts.TTS.pico2wave:3
#: robot_hat.tts.TTS.say:3
msgid "words to say."
msgstr "話す言葉。"

#: of robot_hat.tts.TTS.espeak:1
msgid "Say words with espeak."
msgstr "espeakで言葉を話す。"

#: of robot_hat.tts.TTS.pico2wave:1
msgid "Say words with pico2wave."
msgstr "pico2waveで言葉を話す。"

#: of robot_hat.tts.TTS.lang:1
msgid "Set/get language. leave empty to get current language."
msgstr "言語を設定/取得する。現在の言語を取得するために空のままにする。"

#: of robot_hat.tts.TTS.lang:3
msgid "language."
msgstr "言語。"

#: of robot_hat.tts.TTS.supported_lang:1
msgid "Get supported language."
msgstr "サポートされている言語を取得する。"

#: of robot_hat.tts.TTS.supported_lang
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.tts.TTS.supported_lang:3
msgid "supported language."
msgstr "サポートされている言語。"

#: of robot_hat.tts.TTS.supported_lang
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.tts.TTS.espeak_params:1
msgid "Set espeak parameters."
msgstr "espeakのパラメータを設定する。"

#: of robot_hat.tts.TTS.espeak_params:3
msgid "amplitude."
msgstr "振幅。"

#: of robot_hat.tts.TTS.espeak_params:5
msgid "speed."
msgstr "速度。"

#: of robot_hat.tts.TTS.espeak_params:7
msgid "gap."
msgstr "ギャップ。"

#: of robot_hat.tts.TTS.espeak_params:9
msgid "pitch."
msgstr "ピッチ。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/hardware_introduction.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../hardware_introduction.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../hardware_introduction.rst:5
msgid "**Why Join?**"
msgstr "**Warum beitreten?**"

#: ../hardware_introduction.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../hardware_introduction.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../hardware_introduction.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../hardware_introduction.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../hardware_introduction.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../hardware_introduction.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../hardware_introduction.rst:16
msgid "Hardware Introduction"
msgstr "ハードウェア紹介"

#: ../hardware_introduction.rst:19
msgid "Pinout"
msgstr "ピン配置"

#: ../hardware_introduction.rst:27
msgid "**Power Port**"
msgstr "**Power Port**"

#: ../hardware_introduction.rst:26
msgid "6.0V-8.4V XH2.54 3pin power input."
msgstr "6.0V-8.4V XH2.54 3ピン電源入力。"

#: ../hardware_introduction.rst:27
msgid "Powering the Raspberry Pi and Robot HAT at the same time."
msgstr "Raspberry PiとRobot HATを同時に給電します。"

#: ../hardware_introduction.rst:30
msgid "**Power Switch**"
msgstr "**Power Switch**"

#: ../hardware_introduction.rst:30
msgid "Turn on/off the power of the robot HAT."
msgstr "Robot HATの電源をオン/オフします。"

#: ../hardware_introduction.rst:36
msgid "**Type-C USB Port**"
msgstr "**Type-C USB Port**"

#: ../hardware_introduction.rst:33
msgid "Insert the Type-C cable to charge the battery."
msgstr "Type-Cケーブルを挿入してバッテリーを充電します。"

#: ../hardware_introduction.rst:34
msgid "At the same time, the charging indicator lights up in red color."
msgstr "同時に、充電インジケータが赤色で点灯します。"

#: ../hardware_introduction.rst:35
msgid "When the battery is fully charged, the charging indicator turns off."
msgstr "バッテリーが完全に充電されると、充電インジケータが消灯します。"

#: ../hardware_introduction.rst:36
msgid ""
"If the USB cable is still plugged in about 4 hours after it is fully "
"charged, the charging indicator will blink to prompt."
msgstr "バッテリーが完全に充電された後、約4時間USBケーブルがまだ接続されている場合、充電インジケータが点滅してプロンプト表示されます。"

#: ../hardware_introduction.rst:41
msgid "**Digital Pin**"
msgstr "**Digital Pin**"

#: ../hardware_introduction.rst:39
msgid "4-channel digital pins, D0-D3."
msgstr "4チャンネルのデジタルピン、D0-D3。"

#: ../hardware_introduction.rst:40
msgid "Pin: :ref:`pin_digital`."
msgstr "ピン： :ref:`pin_digital`。"

#: ../hardware_introduction.rst:41
msgid "API: :ref:`class_pin`."
msgstr "API： :ref:`class_pin`。"

#: ../hardware_introduction.rst:46
msgid "**ADC Pin**"
msgstr "**ADC Pin**"

#: ../hardware_introduction.rst:44
msgid "4-channel ADC pins, A0-A3."
msgstr "4チャンネルADCピン、A0-A3。"

#: ../hardware_introduction.rst:45
msgid "Pin: :ref:`pin_adc`."
msgstr "ピン： :ref:`pin_adc`。"

#: ../hardware_introduction.rst:46
msgid "API: :ref:`class_adc`."
msgstr "API： :ref:`class_adc`。"

#: ../hardware_introduction.rst:51
msgid "**PWM Pin**"
msgstr "**PWM Pin**"

#: ../hardware_introduction.rst:49
msgid "12-channel PWM pins, P0-P11."
msgstr "12チャンネルPWMピン、P0-P11。"

#: ../hardware_introduction.rst:50
msgid "Pin: :ref:`pin_pwm`."
msgstr "ピン： :ref:`pin_pwm`。"

#: ../hardware_introduction.rst:51
msgid "API: :ref:`class_pwm`."
msgstr "API： :ref:`class_pwm`。"

#: ../hardware_introduction.rst:56
msgid "**Left/Right Motor Port**"
msgstr "**Left/Right Motor Port**"

#: ../hardware_introduction.rst:54
msgid "2-channel XH2.54 motor ports."
msgstr "2チャンネルXH2.54モーターポート。"

#: ../hardware_introduction.rst:55
msgid "Pin: :ref:`pin_motor`."
msgstr "ピン： :ref:`pin_motor`。"

#: ../hardware_introduction.rst:56
msgid ""
"API: :ref:`class_motor`, ``1`` for left motor port, ``2`` for right motor"
" port."
msgstr "API： :ref:`class_motor`、 ``1`` は左モーターポート用、 ``2`` は右モーターポート用。"

#: ../hardware_introduction.rst:63
msgid "**I2C Pin and I2C Port**"
msgstr "**I2C Pin and I2C Port**"

#: ../hardware_introduction.rst:59
msgid "**I2C Pin**: P2.54 4-pin interface."
msgstr "**I2C Pin**：P2.54 4ピンインターフェース。"

#: ../hardware_introduction.rst:60
msgid ""
"**I2C Port**: SH1.0 4-pin interface, which is compatible with QWIIC and "
"STEMMA QT."
msgstr "**I2C Port**：SH1.0 4ピンインターフェース、QWIICおよびSTEMMA QTと互換性があります。"

#: ../hardware_introduction.rst:61
msgid ""
"These I2C interfaces are connected to the Raspberry Pi's I2C interface "
"via GPIO2 (SDA) and GPIO3 (SCL)."
msgstr ""
"これらのI2Cインターフェースは、GPIO2 (SDA) および GPIO3 (SCL) を介してRaspberry "
"PiのI2Cインターフェースに接続されています。"

#: ../hardware_introduction.rst:62
msgid "Pin: :ref:`pin_i2c`."
msgstr "ピン： :ref:`pin_i2c`。"

#: ../hardware_introduction.rst:63
msgid "API: :ref:`class_i2c`."
msgstr "API： :ref:`class_i2c`。"

#: ../hardware_introduction.rst:67
msgid "**SPI Pin**"
msgstr "**SPI Pin**"

#: ../hardware_introduction.rst:66
msgid "P2.54 7-pin SPI interface."
msgstr "P2.54 7ピンSPIインターフェース。"

#: ../hardware_introduction.rst:67
msgid "Pin: :ref:`pin_spi`."
msgstr "ピン： :ref:`pin_spi`。"

#: ../hardware_introduction.rst:71
msgid "**UART Pin**"
msgstr "**UART Pin**"

#: ../hardware_introduction.rst:70
msgid "P2.54 4-pin interface."
msgstr "P2.54 4ピンインターフェース。"

#: ../hardware_introduction.rst:71
msgid "Pin: :ref:`pin_uart`."
msgstr "ピン： :ref:`pin_uart`。"

#: ../hardware_introduction.rst:77
msgid "**RST Button**"
msgstr "**RST Button**"

#: ../hardware_introduction.rst:74
msgid ""
"The RST button, when using Ezblock, serves as a button to restart the "
"Ezblock program."
msgstr "Ezblockを使用しているとき、RSTボタンはEzblockプログラムを再起動するためのボタンとして機能します。"

#: ../hardware_introduction.rst:75
msgid ""
"If not using Ezblock, the RST button does not have a predefined function "
"and can be fully customized according to your needs."
msgstr "Ezblockを使用していない場合、RSTボタンにはあらかじめ定義された機能はなく、あなたのニーズに合わせて完全にカスタマイズすることができます。"

#: ../hardware_introduction.rst:76 ../hardware_introduction.rst:82
msgid "Pin: :ref:`pin_button`."
msgstr "ピン： :ref:`pin_button`。"

#: ../hardware_introduction.rst:77
msgid "API: :ref:`class_pin`"
msgstr "API： :ref:`class_pin`"

#: ../hardware_introduction.rst:82
msgid "**USR Button**"
msgstr "**USR Button**"

#: ../hardware_introduction.rst:80
msgid ""
"The functions of USR Button can be set by your programming. (Pressing "
"down leads to a input “0”; releasing produces a input “1”. )"
msgstr "USRボタンの機能はプログラミングによって設定することができます。(押すと入力「0」になり、放すと入力「1」になります。)"

#: ../hardware_introduction.rst:81
msgid "API: :ref:`class_pin`, you can use ``Pin(\"SW\")`` to define it."
msgstr "API： :ref:`class_pin` 、 ``Pin(\"SW\")`` を使用して定義することができます。"

#: ../hardware_introduction.rst:88
msgid "**Battery Indicator**"
msgstr "**Battery Indicator**"

#: ../hardware_introduction.rst:85
msgid "Two LEDs light up when the voltage is higher than 7.6V."
msgstr "電圧が7.6Vを超えると2つのLEDが点灯します。"

#: ../hardware_introduction.rst:86
msgid "One LED lights up in the 7.15V to 7.6V range."
msgstr "7.15Vから7.6Vの範囲では1つのLEDが点灯します。"

#: ../hardware_introduction.rst:87
msgid "Below 7.15V, both LEDs turn off."
msgstr "7.15V以下では両方のLEDが消灯します。"

#: ../hardware_introduction.rst:88
msgid ":ref:`battery_indicator`."
msgstr ":ref:`battery_indicator`。"

#: ../hardware_introduction.rst:96
msgid "**Speaker and Speaker Port**"
msgstr "**Speaker and Speaker Port**"

#: ../hardware_introduction.rst:91
msgid "**Speaker**: This is a 2030 audio chamber speaker."
msgstr "**Speaker**：これは2030オーディオチャンバースピーカーです。"

#: ../hardware_introduction.rst:92
msgid ""
"**Speaker Port**: The Robot HAT is equipped with onboard I2S audio "
"output, along with a 2030 audio chamber speaker, providing a mono sound "
"output."
msgstr ""
"**Speaker Port**：Robot "
"HATは、2030オーディオチャンバースピーカーと共に、オンボードI2Sオーディオ出力を備え、モノサウンド出力を提供します。"

#: ../hardware_introduction.rst:93
msgid "Pin: :ref:`pin_speaker`."
msgstr "ピン： :ref:`pin_speaker`。"

#: ../hardware_introduction.rst:94
msgid "API: :ref:`class_music`"
msgstr "API： :ref:`class_music`"

#: ../hardware_introduction.rst:99
msgid "Pin Mapping"
msgstr "ピンマッピング"

#: ../hardware_introduction.rst:101
msgid "Raspberry Pi IO"
msgstr "Raspberry Pi IO"

#: ../hardware_introduction.rst:105 ../hardware_introduction.rst:108
#: ../hardware_introduction.rst:203 ../hardware_introduction.rst:276
#: ../hardware_introduction.rst:315
msgid "Robot Hat V4"
msgstr "Robot Hat V4"

#: ../hardware_introduction.rst:106 ../hardware_introduction.rst:107
#: ../hardware_introduction.rst:204 ../hardware_introduction.rst:277
#: ../hardware_introduction.rst:316 ../hardware_introduction.rst:337
msgid "Raspberry Pi"
msgstr "Raspberry Pi"

#: ../hardware_introduction.rst:109 ../hardware_introduction.rst:141
#: ../hardware_introduction.rst:160 ../hardware_introduction.rst:161
#: ../hardware_introduction.rst:164 ../hardware_introduction.rst:184
msgid "NC"
msgstr "NC"

#: ../hardware_introduction.rst:110 ../hardware_introduction.rst:142
#: ../hardware_introduction.rst:288
msgid "3V3"
msgstr "3V3"

#: ../hardware_introduction.rst:111 ../hardware_introduction.rst:112
#: ../hardware_introduction.rst:115 ../hardware_introduction.rst:116
msgid "5V"
msgstr "5V"

#: ../hardware_introduction.rst:113 ../hardware_introduction.rst:114
msgid "SDA"
msgstr "SDA"

#: ../hardware_introduction.rst:117 ../hardware_introduction.rst:118
msgid "SCL"
msgstr "SCL"

#: ../hardware_introduction.rst:119 ../hardware_introduction.rst:120
#: ../hardware_introduction.rst:125 ../hardware_introduction.rst:126
#: ../hardware_introduction.rst:135 ../hardware_introduction.rst:136
#: ../hardware_introduction.rst:147 ../hardware_introduction.rst:148
#: ../hardware_introduction.rst:157 ../hardware_introduction.rst:158
#: ../hardware_introduction.rst:167 ../hardware_introduction.rst:168
#: ../hardware_introduction.rst:175 ../hardware_introduction.rst:176
#: ../hardware_introduction.rst:185 ../hardware_introduction.rst:186
#: ../hardware_introduction.rst:290
msgid "GND"
msgstr "GND"

#: ../hardware_introduction.rst:121 ../hardware_introduction.rst:209
msgid "D1"
msgstr "D1"

#: ../hardware_introduction.rst:122 ../hardware_introduction.rst:210
msgid "GPIO4"
msgstr "GPIO4"

#: ../hardware_introduction.rst:123 ../hardware_introduction.rst:124
msgid "TXD"
msgstr "TXD"

#: ../hardware_introduction.rst:127 ../hardware_introduction.rst:128
msgid "RXD"
msgstr "RXD"

#: ../hardware_introduction.rst:129 ../hardware_introduction.rst:206
msgid "D0"
msgstr "D0"

#: ../hardware_introduction.rst:130 ../hardware_introduction.rst:207
msgid "GPIO17"
msgstr "GPIO17"

#: ../hardware_introduction.rst:131 ../hardware_introduction.rst:341
msgid "GPIO18"
msgstr "GPIO18"

#: ../hardware_introduction.rst:132
msgid "I2S BCLK"
msgstr "I2S BCLK"

#: ../hardware_introduction.rst:133 ../hardware_introduction.rst:212
msgid "D2"
msgstr "D2"

#: ../hardware_introduction.rst:134 ../hardware_introduction.rst:213
msgid "GPIO27"
msgstr "GPIO27"

#: ../hardware_introduction.rst:137 ../hardware_introduction.rst:215
msgid "D3"
msgstr "D3"

#: ../hardware_introduction.rst:138 ../hardware_introduction.rst:216
msgid "GPIO22"
msgstr "GPIO22"

#: ../hardware_introduction.rst:139 ../hardware_introduction.rst:360
msgid "GPIO23"
msgstr "GPIO23"

#: ../hardware_introduction.rst:140
msgid "MOTOR 1 DIR"
msgstr "モーター1 DIR"

#: ../hardware_introduction.rst:143 ../hardware_introduction.rst:364
msgid "GPIO24"
msgstr "GPIO24"

#: ../hardware_introduction.rst:144
msgid "MOTOR 2 DIR"
msgstr "モーター2 DIR"

#: ../hardware_introduction.rst:145
msgid "SPI MOSI"
msgstr "SPI MOSI"

#: ../hardware_introduction.rst:146
msgid "MOSI"
msgstr "MOSI"

#: ../hardware_introduction.rst:149
msgid "SPI MISO"
msgstr "SPI MISO"

#: ../hardware_introduction.rst:150
msgid "MISO"
msgstr "MISO"

#: ../hardware_introduction.rst:151 ../hardware_introduction.rst:320
msgid "GPIO25"
msgstr "GPIO25"

#: ../hardware_introduction.rst:152
msgid "USR BUTTON"
msgstr "USRボタン"

#: ../hardware_introduction.rst:153
msgid "SPI SCLK"
msgstr "SPI SCLK"

#: ../hardware_introduction.rst:154
msgid "SCLK"
msgstr "SCLK"

#: ../hardware_introduction.rst:155
msgid "CE0"
msgstr "CE0"

#: ../hardware_introduction.rst:156
msgid "SPI CE0"
msgstr "SPI CE0"

#: ../hardware_introduction.rst:159
msgid "CE1"
msgstr "CE1"

#: ../hardware_introduction.rst:162
msgid "ID_SD"
msgstr "ID_SD"

#: ../hardware_introduction.rst:163
msgid "ID_SC"
msgstr "ID_SC"

#: ../hardware_introduction.rst:165
msgid "MCU Reset"
msgstr "MCUリセット"

#: ../hardware_introduction.rst:166
msgid "GPIO5"
msgstr "GPIO5"

#: ../hardware_introduction.rst:169
msgid "(SPI)BSY"
msgstr "(SPI)BSY"

#: ../hardware_introduction.rst:170 ../hardware_introduction.rst:279
msgid "GPIO6"
msgstr "GPIO6"

#: ../hardware_introduction.rst:171
msgid "GPIO12"
msgstr "GPIO12"

#: ../hardware_introduction.rst:172
msgid "Board Identifier 2"
msgstr "ボード識別子 2"

#: ../hardware_introduction.rst:173
msgid "Board Identifier 1"
msgstr "ボード識別子 1"

#: ../hardware_introduction.rst:174
msgid "GPIO13"
msgstr "GPIO13"

#: ../hardware_introduction.rst:177
msgid "I2S LRCLK"
msgstr "I2S LRCLK"

#: ../hardware_introduction.rst:178 ../hardware_introduction.rst:339
msgid "GPIO19"
msgstr "GPIO19"

#: ../hardware_introduction.rst:179 ../hardware_introduction.rst:322
msgid "GPIO16"
msgstr "GPIO16"

#: ../hardware_introduction.rst:180
msgid "RST BUTTON"
msgstr "RSTボタン"

#: ../hardware_introduction.rst:181
msgid "USER LED"
msgstr "ユーザー LED"

#: ../hardware_introduction.rst:182 ../hardware_introduction.rst:318
msgid "GPIO26"
msgstr "GPIO26"

#: ../hardware_introduction.rst:183
msgid "GPIO20"
msgstr "GPIO20"

#: ../hardware_introduction.rst:187 ../hardware_introduction.rst:343
msgid "GPIO21"
msgstr "GPIO21"

#: ../hardware_introduction.rst:188
msgid "I2S SDATA"
msgstr "I2S SDATA"

#: ../hardware_introduction.rst:193 ../hardware_introduction.rst:199
msgid "Digital IO"
msgstr "Digital IO"

#: ../hardware_introduction.rst:195
msgid "Robot HAT has 4 sets of P2.54 3Pin digital pins."
msgstr "Robot HATには4セットのP2.543ピンデジタルピンがあります。"

#: ../hardware_introduction.rst:221
msgid "ADC"
msgstr "ADC"

#: ../hardware_introduction.rst:225
msgid ""
"The Robot HAT features four sets of 3Pin ADC (Analog to Digital "
"Converter) pins, each spaced 2.54mm apart. These pins operate at a 3.3V "
"power supply. The ADC function, offering 12-bit precision, is facilitated"
" by an onboard microcontroller. Detailed instructions for reading ADC "
"values are provided in the :ref:`on_board_mcu` section."
msgstr ""
"Robot "
"HATは、4セットの3ピンADC（アナログ・デジタルコンバータ）ピンを特長としており、それぞれが2.54mm間隔で配置されています。これらのピンは3.3Vの電源で動作します。12ビットの精度を提供するADC機能は、オンボードのマイクロコントローラによって容易になっています。ADC値の読み取り方法の詳細は、"
" :ref:`on_board_mcu` セクションで提供されています。"

#: ../hardware_introduction.rst:229
msgid ""
"Also, ADC channel A4 is connected to the battery through a voltage "
"divider using resistors, which will be used to measure the battery "
"voltage to estimate the approximate battery charge."
msgstr "また、ADCチャネルA4は抵抗を使用した電圧分割器を介してバッテリーに接続されており、バッテリー電圧を測定しておおよそのバッテリー残量を推定するために使用されます。"

#: ../hardware_introduction.rst:232
msgid "The voltage divider ratio is 20K/10K, so:"
msgstr "電圧分割比は20K/10Kなので："

#: ../hardware_introduction.rst:234
msgid "A4 voltage (Va4) = value_A4 / 4095.0 * 3.3"
msgstr "A4電圧 (Va4) = value_A4 / 4095.0 * 3.3"

#: ../hardware_introduction.rst:235
msgid "Battery voltage (Vbat) = Va4*3"
msgstr "バッテリー電圧 (Vbat) = Va4*3"

#: ../hardware_introduction.rst:236
msgid "Battery voltage (Vbat) = value_A4 / 4095.0 * 3.3 * 3"
msgstr "バッテリー電圧 (Vbat) = value_A4 / 4095.0 * 3.3 * 3"

#: ../hardware_introduction.rst:241
msgid "PWM"
msgstr "PWM"

#: ../hardware_introduction.rst:245
msgid ""
"Robot HAT has 4 sets of 3Pin PWM pins, each spaced 2.54mm apart, and the "
"power supply is 5V. The method of using the PWM is described in detail in"
" :ref:`on_board_mcu`."
msgstr ""
"Robot HATには、2.54mm間隔で配置された4セットの3ピンPWMピンがあり、電源は5Vです。PWMの使用方法は、 "
":ref:`on_board_mcu` で詳しく説明されています。"

#: ../hardware_introduction.rst:248
msgid "PWM13 & 14 channels are used for motor drive."
msgstr "PWM13および14チャンネルはモータードライブ用に使用されます。"

#: ../hardware_introduction.rst:253
msgid "I2C"
msgstr "I2C"

#: ../hardware_introduction.rst:257
msgid ""
"The Robot HAT has two I2C interfaces. One is the P2.54 4-pin interface, "
"and the other is the SH1.0 4-pin interface, which is compatible with "
"QWIIC and STEMMA QT. These I2C interfaces are connected to the Raspberry "
"Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL). The board also "
"features an :ref:`on_board_mcu`, and the two signal lines have 10K pull-"
"up resistors."
msgstr ""
"Robot HATには2つのI2Cインターフェイスがあります。一つはP2.54 4ピンインターフェイス、もう一つはQWIICおよびSTEMMA "
"QTと互換性のあるSH1.0 4ピンインターフェイスです。これらのI2CインターフェイスはGPIO2 (SDA)およびGPIO3 "
"(SCL)を介してRaspberry PiのI2Cインターフェイスに接続されています。ボードには :ref:`on_board_mcu` "
"も搭載されており、2つの信号線には10Kのプルアップ抵抗があります。"

#: ../hardware_introduction.rst:264 ../hardware_introduction.rst:272
msgid "SPI"
msgstr "SPI"

#: ../hardware_introduction.rst:268
msgid ""
"The SPI interface of the Robot HAT is a 7-pin P2.54 interface. It "
"connects to the SPI interface of the Raspberry Pi and includes an "
"additional I/O pin that can be used for purposes such as interrupts or "
"resets."
msgstr ""
"Robot HATのSPIインターフェイスは7ピンのP2.54インターフェイスです。これはRaspberry "
"PiのSPIインターフェイスに接続され、割り込みやリセットなどの目的に使用できる追加のI/Oピンを含んでいます。"

#: ../hardware_introduction.rst:278
msgid "BSY"
msgstr "BSY"

#: ../hardware_introduction.rst:280
msgid "CS"
msgstr "CS"

#: ../hardware_introduction.rst:281
msgid "CE0(GPIO8)"
msgstr "CE0(GPIO8)"

#: ../hardware_introduction.rst:282
msgid "SCK"
msgstr "SCK"

#: ../hardware_introduction.rst:283
msgid "SCLK(GPIO11)"
msgstr "SCLK(GPIO11)"

#: ../hardware_introduction.rst:284
msgid "MI"
msgstr "MI"

#: ../hardware_introduction.rst:285
msgid "MISO(GPIO9)"
msgstr "MISO(GPIO9)"

#: ../hardware_introduction.rst:286
msgid "MO"
msgstr "MO"

#: ../hardware_introduction.rst:287
msgid "MOSI(GPIO10)"
msgstr "MOSI(GPIO10)"

#: ../hardware_introduction.rst:289
msgid "3.3V Power"
msgstr "3.3V 電源"

#: ../hardware_introduction.rst:291
msgid "Ground"
msgstr "グラウンド"

#: ../hardware_introduction.rst:296
msgid "UART"
msgstr "UART"

#: ../hardware_introduction.rst:300
msgid ""
"The UART interface of the Robot HAT is a 4-pin P2.54 interface. It "
"connects to the Raspberry Pi's GPIO14 (TXD) and GPIO15 (RXD) pins."
msgstr ""
"Robot HATのUARTインターフェイスは4ピンのP2.54インターフェイスです。これはRaspberry PiのGPIO14 "
"(TXD)とGPIO15 (RXD)ピンに接続されます。"

#: ../hardware_introduction.rst:305
msgid "Buttons"
msgstr "ボタン"

#: ../hardware_introduction.rst:307
msgid ""
"The Robot HAT comes with 1 LED and 2 buttons, all directly connected to "
"the Raspberry Pi's GPIO pins. The RST button, when using Ezblock, serves "
"as a button to restart the Ezblock program. If not using Ezblock, the RST"
" button does not have a predefined function and can be fully customized "
"according to your needs."
msgstr ""
"Robot HATには1つのLEDと2つのボタンがあり、すべてRaspberry "
"PiのGPIOピンに直接接続されています。Ezblockを使用している場合、RSTボタンはEzblockプログラムを再起動するためのボタンとして機能します。Ezblockを使用していない場合、RSTボタンには事前に定義された機能はなく、必要に応じて完全にカスタマイズすることができます。"

#: ../hardware_introduction.rst:311
msgid "LED & Button"
msgstr "LED＆ボタン"

#: ../hardware_introduction.rst:317
msgid "LED"
msgstr "LED"

#: ../hardware_introduction.rst:319
msgid "USR"
msgstr "USR"

#: ../hardware_introduction.rst:321
msgid "RST"
msgstr "RST"

#: ../hardware_introduction.rst:327
msgid "Speaker and Speaker Port"
msgstr "スピーカーとスピーカーポート"

#: ../hardware_introduction.rst:329
msgid ""
"The Robot HAT is equipped with onboard I2S audio output, along with a "
"2030 audio chamber speaker, providing a mono sound output."
msgstr ""
"Robot "
"HATにはオンボードのI2Sオーディオ出力が搭載されており、2030オーディオチャンバースピーカーと共にモノラルサウンド出力を提供します。"

#: ../hardware_introduction.rst:332 ../hardware_introduction.rst:336
msgid "I2S"
msgstr "I2S"

#: ../hardware_introduction.rst:338
msgid "LRCLK"
msgstr "LRCLK"

#: ../hardware_introduction.rst:340
msgid "BCLK"
msgstr "BCLK"

#: ../hardware_introduction.rst:342
msgid "SDATA"
msgstr "SDATA"

#: ../hardware_introduction.rst:348
msgid "Motor Port"
msgstr "モーターポート"

#: ../hardware_introduction.rst:350
msgid ""
"The motor driver of the Robot HAT supports 2 channels and can be "
"controlled using 2 digital signals for direction and 2 PWM signals for "
"speed control."
msgstr ""
"Robot "
"HATのモータードライバーは2チャンネルをサポートしており、2つのデジタル信号を使用して方向を制御し、2つのPWM信号を使用して速度を制御することができます。"

#: ../hardware_introduction.rst:353
msgid "Motor Driver"
msgstr "モータードライバー"

#: ../hardware_introduction.rst:357
msgid "Motor"
msgstr "モーター"

#: ../hardware_introduction.rst:358
msgid "IO"
msgstr "IO"

#: ../hardware_introduction.rst:359
msgid "Motor1 Dir"
msgstr "モーター1方向"

#: ../hardware_introduction.rst:361
msgid "Motor1 Power"
msgstr "モーター1電源"

#: ../hardware_introduction.rst:362
msgid "PWM13"
msgstr "PWM13"

#: ../hardware_introduction.rst:363
msgid "Motor2 Dir"
msgstr "モーター2方向"

#: ../hardware_introduction.rst:365
msgid "Motor2 Power"
msgstr "モーター2電源"

#: ../hardware_introduction.rst:366
msgid "PWM12"
msgstr "PWM12"

#: ../hardware_introduction.rst:371
msgid "Battery Level Indicator"
msgstr "バッテリーレベルインジケーター"

#: ../hardware_introduction.rst:373
msgid ""
"The battery level indicator on the Robot HAT monitors the battery voltage"
" using a voltage divider method and serves as a reference for estimating "
"the battery level. The relationship between the LED and voltage is as "
"follows:"
msgstr ""
"Robot "
"HATのバッテリーレベルインジケーターは、電圧分割器法を使用してバッテリー電圧を監視し、バッテリーレベルの推定のための参考として機能します。LEDと電圧の関係は以下の通りです："

#: ../hardware_introduction.rst:376
msgid "Battery Level"
msgstr "バッテリーレベル"

#: ../hardware_introduction.rst:380
msgid "LED Battery"
msgstr "LEDバッテリー"

#: ../hardware_introduction.rst:381
msgid "Total Voltage"
msgstr "合計電圧"

#: ../hardware_introduction.rst:382
msgid "2 LEDs on"
msgstr "2つのLED点灯"

#: ../hardware_introduction.rst:383
msgid "Greater than 7.6V"
msgstr "7.6V以上"

#: ../hardware_introduction.rst:384
msgid "1 LED on"
msgstr "1つのLED点灯"

#: ../hardware_introduction.rst:385
msgid "Greater than 7.15V"
msgstr "7.15V以上"

#: ../hardware_introduction.rst:386
msgid "Both LEDs off"
msgstr "両方のLED消灯"

#: ../hardware_introduction.rst:387
msgid "Less than 7.15V"
msgstr "7.15V未満"

#: ../hardware_introduction.rst:389
msgid ""
"When any one of the batteries reaches or exceeds 4.1V while the others "
"are below that threshold, the charging current of that specific battery "
"will be reduced."
msgstr "バッテリーのうちの1つが4.1Vに達するかそれを超えると、他のバッテリーがその閾値以下の場合、その特定のバッテリーの充電電流が減少します。"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/community_tutorials.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../community_tutorials.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../community_tutorials.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../community_tutorials.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../community_tutorials.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../community_tutorials.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../community_tutorials.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../community_tutorials.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../community_tutorials.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../community_tutorials.rst:16
msgid "Community Tutorials"
msgstr "コミュニティチュートリアル"

#: ../community_tutorials.rst:18
msgid "|link_peppe8o|"
msgstr "|link_peppe8o|"

#: ../community_tutorials.rst:20
msgid ""
"This document summarizes the SunFounder Raspberry Pi Robot HAT, covering "
"its purpose, compatibility, specifications, and testing:"
msgstr ""
"この文書は、SunFounder Raspberry Pi Robot "
"HATに関する概要を説明し、その目的、互換性、仕様、テストについて述べています:"

#: ../community_tutorials.rst:22
msgid ""
"**Introduction**: Explains the Robot HAT's role in simplifying control "
"for Raspberry Pi-based DIY robot projects."
msgstr "**はじめに**: Raspberry PiベースのDIYロボットプロジェクトの制御を簡素化するRobot HATの役割について説明します。"

#: ../community_tutorials.rst:23
msgid ""
"**Specifications**: Details the technical specs, including power input, "
"battery details, ports, and motor driver features."
msgstr "**仕様**: 電源入力、バッテリーの詳細、ポート、モータードライバーの機能など、技術的な仕様について詳述します。"

#: ../community_tutorials.rst:24
msgid ""
"**Ports Overview**: Describes various ports like Power, Digital, Analog, "
"PWM, I2C, SPI, UART, and Motor Ports."
msgstr "**ポートの概要**: 電源、デジタル、アナログ、PWM、I2C、SPI、UART、モーターポートなど、各種ポートについて説明します。"

#: ../community_tutorials.rst:25
msgid ""
"**Additional Components**: Highlights extra components like buttons, LED,"
" and speaker, with Raspberry Pi PIN mappings."
msgstr "**追加コンポーネント**: ボタン、LED、スピーカーなどの追加コンポーネントと、Raspberry PiのPIN配置を強調します。"

#: ../community_tutorials.rst:26
msgid ""
"**Setup and Testing**: Guides on mounting the Robot HAT, necessary "
"components, and testing procedures for features like LED and servo "
"motors."
msgstr "**セットアップとテスト**: Robot HATの取り付け、必要なコンポーネント、LEDやサーボモーターなどの機能のテスト手順について案内します。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_robot.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_robot.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_robot.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_robot.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_robot.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_robot.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_robot.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_robot.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_robot.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_robot.rst:18
msgid "class ``Robot``"
msgstr "クラス ``Robot``"

#: ../api_robot.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_robot.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.robot.Robot:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.robot.Robot:1
msgid "Robot class"
msgstr "ロボットクラス"

#: of robot_hat.robot.Robot:3
msgid "This class is for makeing a servo robot with Robot HAT"
msgstr "このクラスはRobot HATを使ってサーボロボットを作るためのものです"

#: of robot_hat.robot.Robot:5
msgid ""
"There are servo initialization, all servo move in specific speed. servo "
"offset and stuff. make it easy to make a robot. All Pi-series robot from "
"SunFounder use this class. Check them out for more details."
msgstr "サーボの初期化、全サーボが特定の速度で動くこと、サーボのオフセットなどがあり、ロボットを作りやすくなっています。SunFounderのPiシリーズロボットはすべてこのクラスを使用しています。詳細はそれらをチェックしてください。"

#: of robot_hat.robot.Robot:8
msgid "PiSloth: https://github.com/sunfounder/pisloth"
msgstr "PiSloth: https://github.com/sunfounder/pisloth"

#: of robot_hat.robot.Robot:10
msgid "PiArm: https://github.com/sunfounder/piarm"
msgstr "PiArm: https://github.com/sunfounder/piarm"

#: of robot_hat.robot.Robot:12
msgid "PiCrawler: https://github.com/sunfounder/picrawler"
msgstr "PiCrawler: https://github.com/sunfounder/picrawler"

#: ../docstring of robot_hat.Robot.move_list:1
msgid "Preset actions"
msgstr "プリセットアクション"

#: ../docstring of robot_hat.Robot.max_dps:1
msgid "Servo max Degree Per Second"
msgstr "サーボの最大度/秒"

#: of robot_hat.robot.Robot.__init__:1
msgid "Initialize the robot class"
msgstr "ロボットクラスを初期化する"

#: of robot_hat.robot.Robot.__init__ robot_hat.robot.Robot.do_action
#: robot_hat.robot.Robot.new_list robot_hat.robot.Robot.servo_move
#: robot_hat.robot.Robot.servo_write_all robot_hat.robot.Robot.servo_write_raw
#: robot_hat.robot.Robot.set_offset
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.robot.Robot.__init__:3
msgid "list of pin number[0-11]"
msgstr "ピン番号のリスト[0-11]"

#: of robot_hat.robot.Robot.__init__:5
msgid "config file path"
msgstr "設定ファイルのパス"

#: of robot_hat.robot.Robot.__init__:7
msgid "robot name"
msgstr "ロボットの名前"

#: of robot_hat.robot.Robot.__init__:9
msgid "list of initial angles"
msgstr "初期角度のリスト"

#: of robot_hat.robot.Robot.__init__:11
msgid ""
"list of initialization order(Servos will init one by one in case of "
"sudden huge current, pulling down the power supply voltage. default order"
" is the pin list. in some cases, you need different order, use this "
"parameter to set it.)"
msgstr "初期化の順序のリスト（突然の大電流の場合、サーボは1つずつ初期化され、電源電圧が下がることがあります。デフォルトの順序はピンリストです。場合によっては異なる順序が必要です。このパラメータを使用して設定してください。）"

#: of robot_hat.robot.Robot.new_list:1
msgid "Create a list of servo angles with default value"
msgstr "デフォルト値でサーボ角度のリストを作成する"

#: of robot_hat.robot.Robot.new_list:3
msgid "default value of servo angles"
msgstr "サーボ角度のデフォルト値"

#: of robot_hat.robot.Robot.new_list
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.robot.Robot.new_list:5 robot_hat.robot.Robot.servo_move:3
#: robot_hat.robot.Robot.servo_write_all:3
#: robot_hat.robot.Robot.servo_write_raw:3 robot_hat.robot.Robot.set_offset:3
msgid "list of servo angles"
msgstr "サーボ角度のリスト"

#: of robot_hat.robot.Robot.new_list
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.robot.Robot.servo_write_raw:1
msgid "Set servo angles to specific raw angles"
msgstr "サーボ角度を特定の生の角度に設定する"

#: of robot_hat.robot.Robot.servo_write_all:1
msgid "Set servo angles to specific angles with original angle and offset"
msgstr "元の角度とオフセットを使ってサーボ角度を特定の角度に設定する"

#: of robot_hat.robot.Robot.servo_move:1
msgid "Move servo to specific angles with speed or bpm"
msgstr "速度またはBPMでサーボを特定の角度に動かす"

#: of robot_hat.robot.Robot.servo_move:5
msgid "speed of servo move"
msgstr "サーボ移動の速度"

#: of robot_hat.robot.Robot.servo_move:7
msgid "beats per minute"
msgstr "分あたりの拍数"

#: of robot_hat.robot.Robot.do_action:1
msgid "Do prefix action with motion_name and step and speed"
msgstr "動作名とステップと速度を使ってプレフィックスアクションを実行する"

#: of robot_hat.robot.Robot.do_action:3
msgid "motion"
msgstr "動作"

#: of robot_hat.robot.Robot.do_action:5
msgid "step of motion"
msgstr "動作のステップ"

#: of robot_hat.robot.Robot.do_action:7
msgid "speed of motion"
msgstr "動作の速度"

#: of robot_hat.robot.Robot.set_offset:1
msgid "Set offset of servo angles"
msgstr "サーボ角度のオフセットを設定する"

#: of robot_hat.robot.Robot.calibration:1
msgid "Move all servos to home position"
msgstr "全てのサーボをホームポジションに動かす"

#: of robot_hat.robot.Robot.reset:1
msgid "Reset servo to original position"
msgstr "サーボを元の位置にリセットする"





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_control_motor_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_control_motor_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_control_motor_servo.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_control_motor_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_control_motor_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_control_motor_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_control_motor_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_control_motor_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_control_motor_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_control_motor_servo.rst:16
msgid "Control Servos and Motors"
msgstr "サーボとモーターの制御"

#: ../project_control_motor_servo.rst:18
msgid "In this project, we have 12 servos and two motors working simultaneously."
msgstr "このプロジェクトでは、12個のサーボと2つのモーターが同時に動作します。"

#: ../project_control_motor_servo.rst:24
msgid ""
"However, it's important to note that if your servos and motors have a "
"high starting current, it's recommended to start them separately to avoid"
" insufficient power supply current, which could lead to the Raspberry Pi "
"restarting."
msgstr ""
"ただし、サーボやモーターの始動電流が高い場合は、それらを個別に起動して、電源電流不足を避けることをお勧めします。電流不足はRaspberry "
"Piの再起動につながる可能性があります。"

#: ../project_control_motor_servo.rst:26
msgid "**Code**"
msgstr "**コード**"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_say_something.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_say_something.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_say_something.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_say_something.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_say_something.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_say_something.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_say_something.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_say_something.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_say_something.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_say_something.rst:16
msgid "Say Something"
msgstr "何かを話す"

#: ../project_say_something.rst:19
msgid ""
"In this section, you'll learn how to convert text into speech and have "
"Robot HAT speak it aloud."
msgstr "このセクションでは、テキストを音声に変換して、Robot HATに大声で話させる方法を学びます。"

#: ../project_say_something.rst:21
msgid "**Steps**"
msgstr "**手順**"

#: ../project_say_something.rst:23
msgid ""
"We retrieve text from the command line to enable Robot HAT to articulate "
"it. To achieve this, save the following code as a ``.py`` file, such as "
"``tts.py``."
msgstr ""
"コマンドラインからテキストを取得してRobot HATがそれを話すようにします。これを実現するために、以下のコードを ``.py`` "
"ファイルとして保存します。例えば ``tts.py`` などです。"

#: ../project_say_something.rst:46
msgid ""
"To make Robot HAT vocalize a specific sentence, you can use the following"
" command: ``sudo python3 tts.py \"any text\"`` - simply replace ``\"any "
"text\"`` with the desired phrase."
msgstr ""
"Robot HATに特定の文章を発声させるには、次のコマンドを使用します： ``sudo python3 tts.py \"任意のテキスト\"``"
" - 単に ``\"任意のテキスト\"`` を希望のフレーズに置き換えてください。"

#: ../project_say_something.rst:50
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/install_i2s_for_speaker.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../install_i2s_for_speaker.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../install_i2s_for_speaker.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../install_i2s_for_speaker.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../install_i2s_for_speaker.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../install_i2s_for_speaker.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../install_i2s_for_speaker.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../install_i2s_for_speaker.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../install_i2s_for_speaker.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../install_i2s_for_speaker.rst:18
msgid "Install ``i2samp.sh`` for the Speaker"
msgstr "スピーカー用の ``i2samp.sh`` をインストールする"

#: ../install_i2s_for_speaker.rst:20
msgid ""
"The ``i2samp.sh`` is a sophisticated Bash script specifically designed "
"for setting up and configuring an I2S (Inter-IC Sound) amplifier on "
"Raspberry Pi and similar devices. Licensed under the MIT license, it "
"ensures compatibility with a range of hardware and operating systems, "
"conducting thorough checks before proceeding with any installation or "
"configuration."
msgstr ""
"``i2samp.sh`` は、Raspberry Piや類似のデバイスでI2S（Inter-IC "
"Sound）アンプを設定し、構成するために特別に設計された高度なBashスクリプトです。MITライセンスのもとで、さまざまなハードウェアとオペレーティングシステムとの互換性を保証し、インストールや構成を進める前に徹底的なチェックを行います。"

#: ../install_i2s_for_speaker.rst:22
msgid ""
"If you want your speaker to work properly, you definitely need to install"
" this script."
msgstr "スピーカーを適切に動作させたい場合は、このスクリプトのインストールが絶対に必要です。"

#: ../install_i2s_for_speaker.rst:24
msgid "The steps are as follows:"
msgstr "手順は以下の通りです："

#: ../install_i2s_for_speaker.rst:31
msgid "Type ``y`` and press ``enter`` to continue running the script."
msgstr "``y`` と入力し ``enter`` を押して、スクリプトの実行を続けます。"

#: ../install_i2s_for_speaker.rst:35
msgid "Type ``y`` and press ``enter`` to run ``/dev/zero`` in the background."
msgstr "``y`` と入力し ``enter`` を押して、バックグラウンドで ``/dev/zero`` を実行します。"

#: ../install_i2s_for_speaker.rst:39
msgid "Type ``y`` and press ``enter`` to restart the Raspberry pi."
msgstr "``y`` と入力し ``enter`` を押して、Raspberry Piを再起動します。"

#: ../install_i2s_for_speaker.rst:45
msgid ""
"If there is no sound after restarting, you may need to run the "
"``i2samp.sh`` script several times."
msgstr "再起動後に音が出ない場合は、 ``i2samp.sh`` スクリプトを数回実行する必要があるかもしれません。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_plant_monitor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_plant_monitor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_plant_monitor.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_plant_monitor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_plant_monitor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_plant_monitor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_plant_monitor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_plant_monitor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_plant_monitor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_plant_monitor.rst:16
msgid "Plant Monitor"
msgstr "プラントモニター"

#: ../project_plant_monitor.rst:18
msgid ""
"In this project, we detect both light intensity and soil moisture levels,"
" and display them on the I2C LCD1602 . When you feel that the soil "
"moisture is insufficient, you can press the button module to water the "
"potted plant."
msgstr ""
"このプロジェクトでは、光の強度と土壌の水分レベルの両方を検出し、I2C "
"LCD1602に表示します。土壌の水分が不足していると感じたら、ボタンモジュールを押して鉢植えに水をやることができます。"

#: ../project_plant_monitor.rst:22
msgid "**Steps**"
msgstr "**手順**"

#: ../project_plant_monitor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr "このプロジェクトではI2C LCD1602を使用しているため、関連するライブラリをダウンロードして機能させる必要があります。"

#: ../project_plant_monitor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "I2C用に ``smbus2`` をインストールします。"

#: ../project_plant_monitor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``plant_monitor.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``plant_monitor.ty`` という名前を付けます。"

#: ../project_plant_monitor.rst:120
msgid "Use the command ``sudo python3 plant_monitor.ty`` to run this code."
msgstr "このコードを実行するには、 ``sudo python3 plant_monitor.ty`` コマンドを使用します。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_modules.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_modules.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_modules.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_modules.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_modules.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_modules.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_modules.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_modules.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_modules.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_modules.rst:16
msgid "module ``modules``"
msgstr "モジュール ``modules``"

#: ../api_modules.rst:21
msgid "class ``Ultrasonic``"
msgstr "クラス ``Ultrasonic``"

#: ../api_modules.rst:23 ../api_modules.rst:46 ../api_modules.rst:80
#: ../api_modules.rst:110 ../api_modules.rst:220
msgid "**Example**"
msgstr "**例**"

#: ../api_modules.rst:37 ../api_modules.rst:70 ../api_modules.rst:101
#: ../api_modules.rst:210 ../api_modules.rst:246
msgid "**API**"
msgstr "**API**"

#: ../api_modules.rst:44
msgid "class ``ADXL345``"
msgstr "クラス ``ADXL345``"

#: of robot_hat.modules.ADXL345:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "基底: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.modules.ADXL345:1
msgid "ADXL345 modules"
msgstr "ADXL345モジュール"

#: ../docstring of robot_hat.ADXL345.X:1
msgid "X"
msgstr "X"

#: ../docstring of robot_hat.ADXL345.Y:1
msgid "Y"
msgstr "Y"

#: ../docstring of robot_hat.ADXL345.Z:1
msgid "Z"
msgstr "Z"

#: of robot_hat.modules.ADXL345.__init__:1
msgid "Initialize ADXL345"
msgstr "ADXL345を初期化する"

#: of robot_hat.modules.ADXL345.__init__ robot_hat.modules.ADXL345.read
#: robot_hat.modules.Buzzer.__init__ robot_hat.modules.Buzzer.freq
#: robot_hat.modules.Buzzer.play robot_hat.modules.Grayscale_Module.__init__
#: robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
#: robot_hat.modules.RGB_LED.__init__ robot_hat.modules.RGB_LED.color
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.modules.ADXL345.__init__:3
msgid "address of the ADXL345"
msgstr "ADXL345のアドレス"

#: of robot_hat.modules.ADXL345.read:1
msgid "Read an axis from ADXL345"
msgstr "ADXL345から軸を読み取る"

#: of robot_hat.modules.ADXL345.read:3
msgid ""
"read value(g) of an axis, ADXL345.X, ADXL345.Y or ADXL345.Z, None for all"
" axis"
msgstr "軸の値(g)を読み取る、ADXL345.X、ADXL345.YまたはADXL345.Z、すべての軸の場合はNone"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.modules.ADXL345.read:5
msgid "value of the axis, or list of all axis"
msgstr "軸の値、またはすべての軸のリスト"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Return type"
msgstr "戻り値の型"

#: ../api_modules.rst:78
msgid "class ``RGB_LED``"
msgstr "クラス ``RGB_LED``"

#: of robot_hat.modules.RGB_LED:1
msgid "Simple 3 pin RGB LED"
msgstr "シンプルな3ピンRGB LED"

#: ../docstring of robot_hat.RGB_LED.ANODE:1
msgid "Common anode"
msgstr "共通アノード"

#: ../docstring of robot_hat.RGB_LED.CATHODE:1
msgid "Common cathode"
msgstr "共通カソード"

#: of robot_hat.modules.RGB_LED.__init__:1
msgid "Initialize RGB LED"
msgstr "RGB LEDを初期化する"

#: of robot_hat.modules.RGB_LED.__init__:3
msgid "PWM object for red"
msgstr "赤用のPWMオブジェクト"

#: of robot_hat.modules.RGB_LED.__init__:5
msgid "PWM object for green"
msgstr "緑用のPWMオブジェクト"

#: of robot_hat.modules.RGB_LED.__init__:7
msgid "PWM object for blue"
msgstr "青用のPWMオブジェクト"

#: of robot_hat.modules.RGB_LED.__init__:9
msgid "RGB_LED.ANODE or RGB_LED.CATHODE, default is ANODE"
msgstr "RGB_LED.ANODEまたはRGB_LED.CATHODE、デフォルトはANODE"

#: of robot_hat.modules.Buzzer.freq robot_hat.modules.Buzzer.play
#: robot_hat.modules.RGB_LED.__init__
msgid "Raises"
msgstr ""

#: of robot_hat.modules.RGB_LED.__init__:11
msgid "if common is not ANODE or CATHODE"
msgstr "共通がANODEまたはCATHODEでない場合"

#: of robot_hat.modules.RGB_LED.__init__:12
msgid "if r_pin, g_pin or b_pin is not PWM object"
msgstr "r_pin、g_pin、またはb_pinがPWMオブジェクトでない場合"

#: of robot_hat.modules.RGB_LED.color:1
msgid "Write color to RGB LED"
msgstr "RGB LEDに色を書き込む"

#: of robot_hat.modules.RGB_LED.color:3
msgid ""
"color to write, hex string starts with \"#\", 24-bit int or tuple of "
"(red, green, blue)"
msgstr "書き込む色、\"#\"で始まる16進数文字列、24ビット整数、または(red, green, blue)のタプル"

#: ../api_modules.rst:108
msgid "class ``Buzzer``"
msgstr "クラス ``Buzzer``"

#: ../api_modules.rst:112
msgid "Imports and initialize"
msgstr "インポートと初期化"

#: ../api_modules.rst:133
msgid "Active buzzer beeping"
msgstr "アクティブブザーのビープ音"

#: ../api_modules.rst:143
msgid "Passive buzzer Simple usage"
msgstr "パッシブブザーの簡単な使用方法"

#: ../api_modules.rst:155
msgid "Passive buzzer Manual control"
msgstr "パッシブブザーの手動制御"

#: ../api_modules.rst:171
msgid "Play a song! Baby shark!"
msgstr "曲を演奏する！ベイビーシャーク！"

#: of robot_hat.modules.Buzzer.__init__:1
msgid "Initialize buzzer"
msgstr "ブザーを初期化する"

#: of robot_hat.modules.Buzzer.__init__:3
msgid "PWM object for passive buzzer or Pin object for active buzzer"
msgstr "パッシブブザー用のPWMオブジェクトまたはアクティブブザー用のピンオブジェクト"

#: of robot_hat.modules.Buzzer.on:1
msgid "Turn on buzzer"
msgstr "ブザーをオンにする"

#: of robot_hat.modules.Buzzer.off:1
msgid "Turn off buzzer"
msgstr "ブザーをオフにする"

#: of robot_hat.modules.Buzzer.freq:1
msgid "Set frequency of passive buzzer"
msgstr "パッシブブザーの周波数を設定する"

#: of robot_hat.modules.Buzzer.freq:3
msgid "frequency of buzzer, use Music.NOTES to get frequency of note"
msgstr "ブザーの周波数、Music.NOTESを使用して音符の周波数を取得する"

#: of robot_hat.modules.Buzzer.freq:5 robot_hat.modules.Buzzer.play:7
msgid "if set to active buzzer"
msgstr "アクティブブザーに設定した場合"

#: of robot_hat.modules.Buzzer.play:1
msgid "Play freq"
msgstr "周波数を演奏する"

#: of robot_hat.modules.Buzzer.play:3
msgid "freq to play, you can use Music.note() to get frequency of note"
msgstr "演奏する周波数、Music.note()を使用して音符の周波数を取得できる"

#: of robot_hat.modules.Buzzer.play:5
msgid "duration of each note, in seconds, None means play continuously"
msgstr "各音符の持続時間（秒）、Noneは連続して演奏することを意味する"

#: ../api_modules.rst:218
msgid "class ``Grayscale_Module``"
msgstr "クラス ``Grayscale_Module``"

#: of robot_hat.modules.Grayscale_Module:1
msgid "3 channel Grayscale Module"
msgstr "3チャンネルグレースケールモジュール"

#: ../docstring of robot_hat.Grayscale_Module.LEFT:1
msgid "Left Channel"
msgstr "左チャンネル"

#: ../docstring of robot_hat.Grayscale_Module.MIDDLE:1
msgid "Middle Channel"
msgstr "中央チャンネル"

#: ../docstring of robot_hat.Grayscale_Module.RIGHT:1
msgid "Right Channel"
msgstr "右チャンネル"

#: of robot_hat.modules.Grayscale_Module.__init__:1
msgid "Initialize Grayscale Module"
msgstr "グレースケールモジュールを初期化する"

#: of robot_hat.modules.Grayscale_Module.__init__:3
msgid "ADC object or int for channel 0"
msgstr "チャンネル0用のADCオブジェクトまたは整数"

#: of robot_hat.modules.Grayscale_Module.__init__:5
msgid "ADC object or int for channel 1"
msgstr "チャンネル1用のADCオブジェクトまたは整数"

#: of robot_hat.modules.Grayscale_Module.__init__:7
msgid "ADC object or int for channel 2"
msgstr "チャンネル2用のADCオブジェクトまたは整数"

#: of robot_hat.modules.Grayscale_Module.__init__:9
msgid "reference voltage"
msgstr "基準電圧"

#: of robot_hat.modules.Grayscale_Module.reference:1
msgid "Get Set reference value"
msgstr "基準値の取得と設定"

#: of robot_hat.modules.Grayscale_Module.reference:3
msgid "reference value, None to get reference value"
msgstr "基準値、基準値を取得する場合はNone"

#: of robot_hat.modules.Grayscale_Module.reference:5
msgid "reference value"
msgstr "基準値"

#: of robot_hat.modules.Grayscale_Module.read_status:1
msgid "Read line status"
msgstr "ライン状態の読み取り"

#: of robot_hat.modules.Grayscale_Module.read_status:3
msgid "list of grayscale datas, if None, read from sensor"
msgstr "グレースケールデータのリスト、Noneの場合はセンサーから読み取り"

#: of robot_hat.modules.Grayscale_Module.read_status:5
msgid "list of line status, 0 for white, 1 for black"
msgstr "ライン状態のリスト、0は白、1は黒"

#: of robot_hat.modules.Grayscale_Module.read:1
msgid "read a channel or all datas"
msgstr "チャンネルまたはすべてのデータを読み取る"

#: of robot_hat.modules.Grayscale_Module.read:3
msgid ""
"channel to read, leave empty to read all. 0, 1, 2 or "
"Grayscale_Module.LEFT, Grayscale_Module.CENTER, Grayscale_Module.RIGHT"
msgstr "読み取るチャンネル、すべてを読み取るには空のままにする。0、1、2またはGrayscale_Module.LEFT、Grayscale_Module.CENTER、Grayscale_Module.RIGHT"

#: of robot_hat.modules.Grayscale_Module.read:5
msgid "list of grayscale data"
msgstr "グレースケールデータのリスト"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_pin.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pin.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_pin.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_pin.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_pin.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_pin.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_pin.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_pin.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_pin.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_pin.rst:18
msgid "class ``Pin``"
msgstr "クラス ``Pin``"

#: ../api_pin.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_pin.rst:52
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pin.Pin:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.pin.Pin:1
msgid "Pin manipulation class"
msgstr "ピン操作クラス"

#: ../docstring of robot_hat.Pin.OUT:1
msgid "Pin mode output"
msgstr "ピンモード出力"

#: ../docstring of robot_hat.Pin.IN:1
msgid "Pin mode input"
msgstr "ピンモード入力"

#: ../docstring of robot_hat.Pin.PULL_UP:1
msgid "Pin internal pull up"
msgstr "ピン内部プルアップ"

#: ../docstring of robot_hat.Pin.PULL_DOWN:1
msgid "Pin internal pull down"
msgstr "ピン内部プルダウン"

#: ../docstring of robot_hat.Pin.PULL_NONE:1
msgid "Pin internal pull none"
msgstr "ピン内部プルなし"

#: ../docstring of robot_hat.Pin.IRQ_FALLING:1 robot_hat.Pin.IRQ_RISING:1
msgid "Pin interrupt falling"
msgstr "ピン割り込みフォーリング"

#: ../docstring of robot_hat.Pin.IRQ_RISING_FALLING:1
msgid "Pin interrupt both rising and falling"
msgstr "ピン割り込みライジングとフォーリングの両方"

#: of robot_hat.pin.Pin.__init__:1
msgid "Initialize a pin"
msgstr "ピンの初期化"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.__init__
#: robot_hat.pin.Pin.dict robot_hat.pin.Pin.irq robot_hat.pin.Pin.setup
#: robot_hat.pin.Pin.value
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.pin.Pin.__init__:3
msgid "pin number of Raspberry Pi"
msgstr "Raspberry Piのピン番号"

#: of robot_hat.pin.Pin.__init__:5 robot_hat.pin.Pin.setup:3
msgid "pin mode(IN/OUT)"
msgstr "ピンモード(IN/OUT)"

#: of robot_hat.pin.Pin.__init__:7 robot_hat.pin.Pin.setup:5
msgid "pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)"
msgstr "ピンプルアップ/ダウン(PUD_UP/PUD_DOWN/PUD_NONE)"

#: of robot_hat.pin.Pin.setup:1
msgid "Setup the pin"
msgstr "ピンのセットアップ"

#: of robot_hat.pin.Pin.dict:1
msgid "Set/get the pin dictionary"
msgstr "ピン辞書の設定/取得"

#: of robot_hat.pin.Pin.dict:3
msgid "pin dictionary, leave it empty to get the dictionary"
msgstr "ピン辞書、辞書を取得するには空のままにしてください"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.pin.Pin.dict:5
msgid "pin dictionary"
msgstr "ピン辞書"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.pin.Pin.__call__:1 robot_hat.pin.Pin.value:1
msgid "Set/get the pin value"
msgstr "ピン値の設定/取得"

#: of robot_hat.pin.Pin.__call__:3 robot_hat.pin.Pin.value:3
msgid "pin value, leave it empty to get the value(0/1)"
msgstr "ピン値、値を取得する場合は空にしておく(0/1)"

#: of robot_hat.pin.Pin.__call__:5 robot_hat.pin.Pin.value:5
msgid "pin value(0/1)"
msgstr "ピン値(0/1)"

#: of robot_hat.pin.Pin.on:1
msgid "Set pin on(high)"
msgstr "ピンをオン(ハイ)に設定"

#: of robot_hat.pin.Pin.high:3 robot_hat.pin.Pin.on:3
msgid "pin value(1)"
msgstr "ピン値(1)"

#: of robot_hat.pin.Pin.off:1
msgid "Set pin off(low)"
msgstr "ピンをオフ(ロー)に設定"

#: of robot_hat.pin.Pin.low:3 robot_hat.pin.Pin.off:3
msgid "pin value(0)"
msgstr "ピン値(0)"

#: of robot_hat.pin.Pin.high:1
msgid "Set pin high(1)"
msgstr "ピンをハイ(1)に設定"

#: of robot_hat.pin.Pin.low:1
msgid "Set pin low(0)"
msgstr "ピンをロー(0)に設定"

#: of robot_hat.pin.Pin.irq:1
msgid "Set the pin interrupt"
msgstr "ピン割り込みを設定"

#: of robot_hat.pin.Pin.irq:3
msgid "interrupt handler callback function"
msgstr "割り込みハンドラコールバック関数"

#: of robot_hat.pin.Pin.irq:5
msgid "interrupt trigger(RISING, FALLING, RISING_FALLING)"
msgstr "割り込みトリガー(RISING, FALLING, RISING_FALLING)"

#: of robot_hat.pin.Pin.irq:7
msgid "interrupt bouncetime in miliseconds"
msgstr "割り込みバウンスタイム（ミリ秒）"

#: of robot_hat.pin.Pin.name:1
msgid "Get the pin name"
msgstr "ピン名を取得"

#: of robot_hat.pin.Pin.name:3
msgid "pin name"
msgstr "ピン名"





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/faq.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../faq.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../faq.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../faq.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../faq.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../faq.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../faq.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../faq.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../faq.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../faq.rst:16
msgid "FAQ"
msgstr "よくある質問"

#: ../faq.rst:19
msgid ""
"Q1: Can the battery be connected while providing power to the Raspberry "
"Pi at the same time?"
msgstr "Q1: バッテリーを接続しながら、同時にRaspberry Piに電力を供給することは可能ですか？"

#: ../faq.rst:20
msgid ""
"A: Yes, the Robot HAT has a built-in anti-backflow diode that prevents "
"the Raspberry Pi's power from flowing back into the Robot HAT."
msgstr "A: はい、Robot HATには逆流防止ダイオードが内蔵されており、Raspberry Piの電力がRobot HATに逆流するのを防ぎます。"

#: ../faq.rst:23
msgid "Q2: Can the Robot HAT be used while charging?"
msgstr "Q2: 充電中にRobot HATを使用することは可能ですか？"

#: ../faq.rst:24
msgid ""
"A: Yes, the Robot HAT can be used while charging. When charging, the "
"input power is boosted by the charging chip to charge the batteries, "
"while also providing power to the DC-DC step-down for external use. The "
"charging power is approximately 10W. If the external power consumption is"
" too high for an extended period, the batteries may supplement the power,"
" similar to how a mobile phone charges while in use. However, it is "
"important to be mindful of the battery's capacity to avoid draining it "
"completely during simultaneous charging and usage."
msgstr ""
"A: はい、充電中でもRobot HATを使用できます。充電中、入力電力は充電チップによって増幅され"
"、バッテリーを充電しながら外部使用のためのDC-"
"DC降圧にも電力を供給します。充電電力は約10Wです。外部電力消費が長期間にわたって高すぎる場合、バッテリーが電力を補うことがあります。これは、使用中の携帯電話が充電されるのと同様です。ただし、同時に充電と使用を行う際には、バッテリーの容量に注意し、完全に消耗させないようにすることが重要です。"

#: ../faq.rst:29
msgid "Q3: Why is there no sound from the speaker?"
msgstr "Q3: スピーカーから音が出ないのはなぜですか？"

#: ../faq.rst:31
msgid ""
"When your script is running but the speaker is not producing sound, there"
" could be several reasons:"
msgstr "スクリプトが実行されているにもかかわらずスピーカーから音が出ない場合、いくつかの理由が考えられます："

#: ../faq.rst:33
msgid ""
"Check if the ``i2samp.sh`` script has been installed. For detailed "
"instructions, please refer to: :ref:`install_i2s`."
msgstr ""
"``i2samp.sh`` スクリプトがインストールされているか確認してください。詳細な指示については、 :ref:`install_i2s` "
"を参照してください。"

#: ../faq.rst:34
msgid ""
"When running scripts related to speakers, it's necessary to add ``sudo`` "
"to obtain administrative privileges. For example, ``sudo python3 "
"tts.py``."
msgstr ""
"スピーカー関連のスクリプトを実行する際には、管理者権限を得るために ``sudo`` を追加する必要があります。例えば、 ``sudo "
"python3 tts.py`` とします。"

#: ../faq.rst:35
msgid ""
"Don't using Raspberry Pi's built-in programming tools, like Geany to run "
"Speaker-related scripts. These tools run with standard user privileges, "
"while hardware control, such as managing speakers, often requires higher "
"permissions."
msgstr ""
"スピーカー関連のスクリプトを実行する際に、Raspberry "
"Piの組み込みプログラミングツール（例えばGeany）を使用しないでください。これらのツールは標準ユーザー権限で実行されますが、スピーカーの管理などのハードウェア制御にはより高い権限がしばしば必要です。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/projects.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../projects.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../projects.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../projects.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../projects.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../projects.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../projects.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../projects.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../projects.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../projects.rst:16
msgid "Some Projects"
msgstr "いくつかのプロジェクト"

#: ../projects.rst:18
msgid ""
"Here, you'll find a collection of fascinating projects, all implemented "
"using the Robot HAT. We provide you with detailed code, giving you the "
"opportunity to try these projects out for yourself."
msgstr ""
"ここでは、Robot "
"HATを使用して実装された魅力的なプロジェクトのコレクションを紹介します。詳細なコードを提供し、これらのプロジェクトを自分で試す機会を提供します。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_utils.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_utils.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_utils.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_utils.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_utils.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_utils.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_utils.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_utils.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_utils.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_utils.rst:16
msgid "module ``utils``"
msgstr "モジュール ``utils``"

#: of robot_hat.utils.set_volume:1
msgid "Set volume"
msgstr "音量を設定する"

#: of robot_hat.utils.get_ip robot_hat.utils.is_installed
#: robot_hat.utils.mapping robot_hat.utils.run_command
#: robot_hat.utils.set_volume
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.utils.set_volume:3
msgid "volume(0~100)"
msgstr "音量（0〜100）"

#: of robot_hat.utils.run_command:1
msgid "Run command and return status and output"
msgstr "コマンドを実行し、状態と出力を返す"

#: of robot_hat.utils.run_command:3
msgid "command to run"
msgstr "実行するコマンド"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.utils.run_command:5
msgid "status, output"
msgstr "状態、出力"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.utils.is_installed:1
msgid "Check if command is installed"
msgstr "コマンドがインストールされているかどうかを確認する"

#: of robot_hat.utils.is_installed:3
msgid "command to check"
msgstr "確認するコマンド"

#: of robot_hat.utils.is_installed:5
msgid "True if installed"
msgstr "インストールされている場合はTrue"

#: of robot_hat.utils.mapping:1
msgid "Map value from one range to another range"
msgstr "ある範囲の値を別の範囲にマップする"

#: of robot_hat.utils.mapping:3
msgid "value to map"
msgstr "マップする値"

#: of robot_hat.utils.mapping:5
msgid "input minimum"
msgstr "入力最小値"

#: of robot_hat.utils.mapping:7
msgid "input maximum"
msgstr "入力最大値"

#: of robot_hat.utils.mapping:9
msgid "output minimum"
msgstr "出力最小値"

#: of robot_hat.utils.mapping:11
msgid "output maximum"
msgstr "出力最大値"

#: of robot_hat.utils.mapping:13
msgid "mapped value"
msgstr "マップされた値"

#: of robot_hat.utils.get_ip:1
msgid "Get IP address"
msgstr "IPアドレスを取得する"

#: of robot_hat.utils.get_ip:3
msgid "interfaces to check"
msgstr "チェックするインターフェース"

#: of robot_hat.utils.get_ip:5
msgid "IP address or False if not found"
msgstr "見つかった場合はIPアドレス、見つからない場合はFalse"

#: of robot_hat.utils.reset_mcu:1
msgid "Reset mcu on Robot Hat."
msgstr "Robot Hat上のMCUをリセットする。"

#: of robot_hat.utils.reset_mcu:3
msgid ""
"This is helpful if the mcu somehow stuck in a I2C data transfer loop, and"
" Raspberry Pi getting IOError while Reading ADC, manipulating PWM, etc."
msgstr ""
"これは、MCUが何らかの理由でI2Cデータ転送ループに固まり、Raspberry "
"PiがADCの読み取り、PWMの操作などでIOErrorを取得している場合に役立ちます。"

#: of robot_hat.utils.get_battery_voltage:1
msgid "Get battery voltage"
msgstr "バッテリー電圧を取得する"

#: of robot_hat.utils.get_battery_voltage:3
msgid "battery voltage(V)"
msgstr "バッテリー電圧（V）"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_pwm.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pwm.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_pwm.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_pwm.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_pwm.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_pwm.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_pwm.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_pwm.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_pwm.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_pwm.rst:18
msgid "class ``PWM``"
msgstr "クラス ``PWM``"

#: ../api_pwm.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_pwm.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pwm.PWM:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "基底: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.pwm.PWM:1
msgid "Pulse width modulation (PWM)"
msgstr "パルス幅変調（PWM）"

#: ../docstring of robot_hat.PWM.REG_CHN:1
msgid "Channel register prefix"
msgstr "チャンネルレジスタの接頭辞"

#: ../docstring of robot_hat.PWM.REG_PSC:1
msgid "Prescaler register prefix"
msgstr "プリスケーラーレジスタの接頭辞"

#: ../docstring of robot_hat.PWM.REG_ARR:1
msgid "Period registor prefix"
msgstr "周期レジスタの接頭辞"

#: ../docstring of robot_hat.PWM.CLOCK:1
msgid "Clock frequency"
msgstr "クロック周波数"

#: of robot_hat.pwm.PWM.__init__:1
msgid "Initialize PWM"
msgstr "PWMの初期化"

#: of robot_hat.pwm.PWM.__init__ robot_hat.pwm.PWM.freq
#: robot_hat.pwm.PWM.period robot_hat.pwm.PWM.prescaler
#: robot_hat.pwm.PWM.pulse_width robot_hat.pwm.PWM.pulse_width_percent
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.pwm.PWM.__init__:3
msgid "PWM channel number(0-13/P0-P13)"
msgstr "PWMチャンネル番号(0-13/P0-P13)"

#: of robot_hat.pwm.PWM.freq:1
msgid "Set/get frequency, leave blank to get frequency"
msgstr "周波数の設定/取得、周波数を取得するには空白にしておく"

#: of robot_hat.pwm.PWM.freq:3
msgid "frequency(0-65535)(Hz)"
msgstr "周波数(0-65535)(Hz)"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.pwm.PWM.freq:5
msgid "frequency"
msgstr "周波数"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.pwm.PWM.prescaler:1
msgid "Set/get prescaler, leave blank to get prescaler"
msgstr "プリスケーラーを設定/取得、プリスケーラーを取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.prescaler:3
msgid "prescaler(0-65535)"
msgstr "プリスケーラー(0-65535)"

#: of robot_hat.pwm.PWM.prescaler:5
msgid "prescaler"
msgstr "プリスケーラー"

#: of robot_hat.pwm.PWM.period:1
msgid "Set/get period, leave blank to get period"
msgstr "周期を設定/取得、周期を取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.period:3
msgid "period(0-65535)"
msgstr "周期(0-65535)"

#: of robot_hat.pwm.PWM.period:5
msgid "period"
msgstr "周期"

#: of robot_hat.pwm.PWM.pulse_width:1
msgid "Set/get pulse width, leave blank to get pulse width"
msgstr "パルス幅を設定/取得、パルス幅を取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.pulse_width:3
msgid "pulse width(0-65535)"
msgstr "パルス幅(0-65535)"

#: of robot_hat.pwm.PWM.pulse_width:5
msgid "pulse width"
msgstr "パルス幅"

#: of robot_hat.pwm.PWM.pulse_width_percent:1
msgid "Set/get pulse width percentage, leave blank to get pulse width percentage"
msgstr "パルス幅のパーセンテージを設定/取得、パルス幅のパーセンテージを取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.pulse_width_percent:3
msgid "pulse width percentage(0-100)"
msgstr "パルス幅のパーセンテージ(0-100)"

#: of robot_hat.pwm.PWM.pulse_width_percent:5
msgid "pulse width percentage"
msgstr "パルス幅のパーセンテージ"





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_music.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_music.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_music.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_music.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_music.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_music.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_music.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_music.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_music.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_music.rst:18
msgid "class ``Music``"
msgstr "クラス ``Music``"

#: ../api_music.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr "スピーカーが動作しない場合、このスクリプトを実行する際には ``sudo`` を追加する必要があります。"

#: ../api_music.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_music.rst:24
msgid "**Example**"
msgstr "**例**"

#: ../api_music.rst:26
msgid "Initialize"
msgstr "初期化"

#: ../api_music.rst:36
msgid "Play tones"
msgstr "トーンを演奏する"

#: ../api_music.rst:144
msgid "Play sound"
msgstr "サウンドを演奏する"

#: ../api_music.rst:155
msgid "Play Music"
msgstr "音楽を演奏する"

#: ../api_music.rst:176
msgid "**API**"
msgstr "**API**"

#: of robot_hat.music.Music:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.music.Music:1
msgid "Play music, sound affect and note control"
msgstr "音楽、サウンドエフェクト、音符の制御を演奏する"

#: ../docstring of robot_hat.Music.NOTE_BASE_FREQ:1
msgid "Base note frequency for calculation (A4)"
msgstr "計算用の基準音の周波数（A4）"

#: ../docstring of robot_hat.Music.NOTE_BASE_INDEX:1
msgid "Base note index for calculation (A4) MIDI compatible"
msgstr "計算用の基準音のインデックス（A4）MIDI互換"

#: ../docstring of robot_hat.Music.NOTES:1
msgid "Notes name, MIDI compatible"
msgstr "音符の名前、MIDI互換"

#: of robot_hat.music.Music.__init__:1
msgid "Initialize the basic class"
msgstr "基本クラスを初期化する"

#: of robot_hat.music.Music.__init__ robot_hat.music.Music.beat
#: robot_hat.music.Music.get_tone_data robot_hat.music.Music.key_signature
#: robot_hat.music.Music.music_play robot_hat.music.Music.music_set_volume
#: robot_hat.music.Music.note robot_hat.music.Music.play_tone_for
#: robot_hat.music.Music.sound_length robot_hat.music.Music.sound_play
#: robot_hat.music.Music.sound_play_threading robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.music.Music.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "デバッグレベル、0（クリティカル）、1（エラー）、2（警告）、3（情報）または4（デバッグ）"

#: of robot_hat.music.Music.time_signature:1
msgid "Set/get time signature"
msgstr "拍子記号の設定/取得"

#: of robot_hat.music.Music.time_signature:3
msgid "top number of time signature"
msgstr "拍子記号の上部の数字"

#: of robot_hat.music.Music.time_signature:5
msgid "bottom number of time signature"
msgstr "拍子記号の下部の数字"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.music.Music.time_signature:7
msgid "time signature"
msgstr "拍子記号"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.music.Music.key_signature:1
msgid "Set/get key signature"
msgstr "キー記号の設定/取得"

#: of robot_hat.music.Music.key_signature:3
msgid ""
"key signature use KEY_XX_MAJOR or String \"#\", \"##\", or \"bbb\", "
"\"bbbb\""
msgstr "キー記号はKEY_XX_MAJORまたは\\「#\\」、\\「##\\」、\\「bbb\\」、\\「bbbb\\」の文字列を使用"

#: of robot_hat.music.Music.key_signature:5
msgid "key signature"
msgstr "キー記号"

#: of robot_hat.music.Music.tempo:1
msgid "Set/get tempo beat per minute(bpm)"
msgstr "テンポ（分あたりの拍数）の設定/取得"

#: of robot_hat.music.Music.tempo:3 robot_hat.music.Music.tempo:6
msgid "tempo"
msgstr "テンポ"

#: of robot_hat.music.Music.tempo:5
msgid "note value(1, 1/2, Music.HALF_NOTE, etc)"
msgstr "音価（1、1/2、Music.HALF_NOTEなど）"

#: of robot_hat.music.Music.beat:1
msgid "Calculate beat delay in seconds from tempo"
msgstr "テンポから拍子の遅延を秒単位で計算する"

#: of robot_hat.music.Music.beat:3
msgid "beat index"
msgstr "拍子インデックス"

#: of robot_hat.music.Music.beat:5
msgid "beat delay"
msgstr "拍子の遅延"

#: of robot_hat.music.Music.note:1
msgid "Get frequency of a note"
msgstr "音符の周波数を取得する"

#: of robot_hat.music.Music.note:3
msgid "note name(See NOTES)"
msgstr "音符の名前（NOTES参照）"

#: of robot_hat.music.Music.note:5
msgid "if natural note"
msgstr "ナチュラルノートの場合"

#: of robot_hat.music.Music.note:7
msgid "frequency of note"
msgstr "音符の周波数"

#: of robot_hat.music.Music.sound_play:1
msgid "Play sound effect file"
msgstr "サウンドエフェクトファイルを再生する"

#: of robot_hat.music.Music.sound_length:3 robot_hat.music.Music.sound_play:3
#: robot_hat.music.Music.sound_play_threading:3
msgid "sound effect file name"
msgstr "サウンドエフェクトファイル名"

#: of robot_hat.music.Music.sound_play_threading:1
msgid "Play sound effect in thread(in the background)"
msgstr "サウンドエフェクトをスレッドで再生する（バックグラウンドで）"

#: of robot_hat.music.Music.music_play:9
#: robot_hat.music.Music.sound_play_threading:5
msgid "volume 0-100, leave empty will not change volume"
msgstr "音量0-100、空欄にすると音量は変わらない"

#: of robot_hat.music.Music.music_play:1
msgid "Play music file"
msgstr "音楽ファイルを再生する"

#: of robot_hat.music.Music.music_play:3
msgid "sound file name"
msgstr "サウンドファイル名"

#: of robot_hat.music.Music.music_play:5
msgid "number of loops, 0:loop forever, 1:play once, 2:play twice, ..."
msgstr "ループ回数、0:無限ループ、1:1回再生、2:2回再生、..."

#: of robot_hat.music.Music.music_play:7
msgid "start time in seconds"
msgstr "開始時間（秒）"

#: of robot_hat.music.Music.music_set_volume:1
msgid "Set music volume"
msgstr "音楽の音量を設定する"

#: of robot_hat.music.Music.music_set_volume:3
msgid "volume 0-100"
msgstr "音量 0-100"

#: of robot_hat.music.Music.music_stop:1
msgid "Stop music"
msgstr "音楽を停止する"

#: of robot_hat.music.Music.music_pause:1
msgid "Pause music"
msgstr "音楽を一時停止する"

#: of robot_hat.music.Music.music_resume:1
msgid "Resume music"
msgstr "音楽を再開する"

#: of robot_hat.music.Music.music_unpause:1
msgid "Unpause music(resume music)"
msgstr "音楽の一時停止を解除する（音楽を再開する）"

#: of robot_hat.music.Music.sound_length:1
msgid "Get sound effect length in seconds"
msgstr "サウンドエフェクトの長さを秒で取得する"

#: of robot_hat.music.Music.sound_length:5
msgid "length in seconds"
msgstr "長さ（秒）"

#: of robot_hat.music.Music.get_tone_data:1
msgid "Get tone data for playing"
msgstr "演奏用のトーンデータを取得する"

#: of robot_hat.music.Music.get_tone_data:3
msgid "frequency"
msgstr "周波数"

#: of robot_hat.music.Music.get_tone_data:5
#: robot_hat.music.Music.play_tone_for:5
msgid "duration in seconds"
msgstr "持続時間（秒）"

#: of robot_hat.music.Music.get_tone_data:7
msgid "tone data"
msgstr "トーンデータ"

#: of robot_hat.music.Music.play_tone_for:1
msgid "Play tone for duration seconds"
msgstr "指定された持続時間のトーンを演奏する"

#: of robot_hat.music.Music.play_tone_for:3
msgid "frequency, you can use NOTES to get frequency"
msgstr "周波数、NOTESを使用して周波数を取得できる"





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_adc.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_adc.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_adc.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_adc.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_adc.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_adc.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_adc.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_adc.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_adc.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_adc.rst:18
msgid "class ``ADC``"
msgstr "クラス ``ADC``"

#: ../api_adc.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_adc.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.adc.ADC:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "基底: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.adc.ADC:1 robot_hat.adc.ADC.__init__:1
msgid "Analog to digital converter"
msgstr "アナログからデジタルへの変換器"

#: of robot_hat.adc.ADC.__init__
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.adc.ADC.__init__:3
msgid "channel number (0-7/A0-A7)"
msgstr "チャンネル番号 (0-7/A0-A7)"

#: of robot_hat.adc.ADC.read:1
msgid "Read the ADC value"
msgstr "ADC値を読む"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.adc.ADC.read:3
msgid "ADC value(0-4095)"
msgstr "ADC値(0-4095)"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.adc.ADC.read_voltage:1
msgid "Read the ADC value and convert to voltage"
msgstr "ADC値を読み取り電圧に変換する"

#: of robot_hat.adc.ADC.read_voltage:3
msgid "Voltage value(0-3.3(V))"
msgstr "電圧値(0-3.3(V))"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_basic_class.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_basic_class.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_basic_class.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_basic_class.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_basic_class.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_basic_class.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_basic_class.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_basic_class.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_basic_class.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_basic_class.rst:16
msgid "class ``_Basic_class``"
msgstr "クラス ``_Basic_class``"

#: ../api_basic_class.rst:18
msgid ""
"``_Basic_class`` is a logger class for all class to log, so if you want "
"to see logs of a class, just add a debug argument to it."
msgstr "``_Basic_class`` はすべてのクラスのロガークラスで、特定のクラスのログを見たい場合は、デバッグ引数を追加するだけです。"

#: ../api_basic_class.rst:21
msgid "**Example**"
msgstr "**例**"

#: ../api_basic_class.rst:36
msgid "**API**"
msgstr "**API**"

#: of robot_hat.basic._Basic_class:1
msgid "Basic Class for all classes"
msgstr "すべてのクラスの基本クラス"

#: of robot_hat.basic._Basic_class:3
msgid "with debug function"
msgstr "デバッグ機能付き"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_LEVELS:1
#: robot_hat.basic._Basic_class.debug_level:1
msgid "Debug level"
msgstr "デバッグレベル"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_NAMES:1
msgid "Debug level names"
msgstr "デバッグレベルの名称"

#: of robot_hat.basic._Basic_class.__init__:1
msgid "Initialize the basic class"
msgstr "基本クラスを初期化する"

#: of robot_hat.basic._Basic_class.__init__
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.basic._Basic_class.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "デバッグレベル、0（重大）、1（エラー）、2（警告）、3（情報）または4（デバッグ）"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_diy_car.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_diy_car.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_diy_car.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_diy_car.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_diy_car.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_diy_car.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_diy_car.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_diy_car.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_diy_car.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_diy_car.rst:16
msgid "DIY Car"
msgstr "DIYカー"

#: ../project_diy_car.rst:18
msgid ""
"In addition to being suitable for simple experiments, the Robot HAT is "
"ideal for use as a central controller in robotics, such as for smart "
"cars."
msgstr "シンプルな実験に適しているだけでなく、スマートカーなどのロボティクスにおける中央コントローラとしても、Robot HATは理想的です。"

#: ../project_diy_car.rst:20
msgid "In this project, we built a simple line-following car."
msgstr "このプロジェクトでは、シンプルなラインフォローイングカーを作りました。"

#: ../project_diy_car.rst:24
msgid "**Code**"
msgstr "**コード**"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/index.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../index.rst:43
msgid "About this HAT"
msgstr "このHATについて"

#: ../index.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../index.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../index.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../index.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../index.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../index.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../index.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../index.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../index.rst:16
msgid "SunFounder Robot HAT"
msgstr "SunFounder Robot HAT"

#: ../index.rst:18
msgid "Thanks for choosing our Robot HAT."
msgstr "SunFounder Robot HATをお選びいただき、ありがとうございます。"

#: ../index.rst:21
msgid "This document is available in the following languages."
msgstr "このドキュメントは以下の言語で利用可能です。"

#: ../index.rst:23
msgid "|link_german_tutorials|"
msgstr "|link_german_tutorials|"

#: ../index.rst:24
msgid "|link_jp_tutorials|"
msgstr "|link_jp_tutorials|"

#: ../index.rst:25
msgid "|link_en_tutorials|"
msgstr "|link_en_tutorials|"

#: ../index.rst:27
msgid ""
"Please click on the respective links to access the document in your "
"preferred language."
msgstr "ご希望の言語でドキュメントにアクセスするために、それぞれのリンクをクリックしてください。"

#: ../index.rst:34
msgid ""
"Robot HAT is a multifunctional expansion board that allows Raspberry Pi "
"to be quickly turned into a robot. An MCU is on board to extend the PWM "
"output and ADC input for the Raspberry Pi, as well as a motor driver "
"chip, Bluetooth module, I2S audio module and mono speaker. As well as the"
" GPIOs that lead out of the Raspberry Pi itself."
msgstr ""
"Robot HATは、Raspberry Piを迅速にロボットに変換できる多機能拡張ボードです。MCUが搭載されており、Raspberry "
"PiのPWM出力とADC入力を拡張するとともに、モータードライバーチップ、Bluetoothモジュール、I2Sオーディオモジュール、モノラルスピーカー、そしてRaspberry"
" Pi自体から出るGPIOも搭載しています。"

#: ../index.rst:36
msgid ""
"It also comes with a Speaker, which can be used to play background music,"
" sound effects and implement TTS functions to make your project more "
"interesting."
msgstr "また、背景音楽や効果音を再生し、TTS機能を実装してプロジェクトをより魅力的にするためのスピーカーも付属しています。"

#: ../index.rst:38
msgid ""
"Accepts 6.0V-8.4V XH2.54 3pin power input with 2 power indicators. The "
"board also has a user available LED and a button for you to quickly test "
"some effects."
msgstr ""
"6.0V-8.4V XH2.54 "
"3ピン電源入力と2つの電源インジケータを受け入れます。このボードには、ユーザーが使用可能なLEDと、いくつかの効果を迅速にテストするためのボタンも備えています。"

#: ../index.rst:40
msgid ""
"In this document, you will get a full understanding of the interface "
"functions of the Robot HAT and the usage of these interfaces through the "
"Python ``robot-hat`` library provided by SunFounder."
msgstr ""
"この文書では、SunFounderが提供するPython ``robot-hat`` ライブラリを通じて、Robot "
"HATのインターフェイス機能とこれらのインターフェイスの使用方法を完全に理解できます。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_filedb.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_filedb.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_filedb.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_filedb.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_filedb.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_filedb.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_filedb.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_filedb.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_filedb.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_filedb.rst:16
msgid "class ``FileDB``"
msgstr "クラス ``FileDB``"

#: ../api_filedb.rst:18
msgid "**Example**"
msgstr "**例**"

#: ../api_filedb.rst:41
msgid "Now you can checkout the config file ``config`` in bash."
msgstr "これでbashで設定ファイル ``config`` を確認できます。"

#: ../api_filedb.rst:47
msgid "**API**"
msgstr "**API**"

#: of robot_hat.filedb.fileDB:1
msgid "Bases: :py:class:`object`"
msgstr "基底: :py:class:`object`"

#: of robot_hat.filedb.fileDB:1
msgid "A file based database."
msgstr "ファイルベースのデータベース。"

#: of robot_hat.filedb.fileDB:3
msgid "A file based database, read and write arguements in the specific file."
msgstr "特定のファイルで引数を読み書きするファイルベースのデータベースです。"

#: of robot_hat.filedb.fileDB.__init__:1
msgid "Init the db_file is a file to save the datas."
msgstr "db_fileを初期化すると、データを保存するファイルになります。"

#: of robot_hat.filedb.fileDB.__init__
#: robot_hat.filedb.fileDB.file_check_create robot_hat.filedb.fileDB.get
#: robot_hat.filedb.fileDB.set
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.filedb.fileDB.__init__:3
msgid "the file to save the datas."
msgstr "データを保存するファイル。"

#: of robot_hat.filedb.fileDB.__init__:5
#: robot_hat.filedb.fileDB.file_check_create:5
msgid "the mode of the file."
msgstr "ファイルのモード。"

#: of robot_hat.filedb.fileDB.__init__:7
#: robot_hat.filedb.fileDB.file_check_create:7
msgid "the owner of the file."
msgstr "ファイルの所有者。"

#: of robot_hat.filedb.fileDB.file_check_create:1
msgid "Check if file is existed, otherwise create one."
msgstr "ファイルが存在するかチェックし、存在しない場合は作成する。"

#: of robot_hat.filedb.fileDB.file_check_create:3
msgid "the file to check"
msgstr "チェックするファイル"

#: of robot_hat.filedb.fileDB.get:1
msgid "Get value with data's name"
msgstr "データの名前で値を取得する"

#: of robot_hat.filedb.fileDB.get:3 robot_hat.filedb.fileDB.set:3
msgid "the name of the arguement"
msgstr "引数の名前"

#: of robot_hat.filedb.fileDB.get:5
msgid "the default value of the arguement"
msgstr "引数のデフォルト値"

#: of robot_hat.filedb.fileDB.get
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.filedb.fileDB.get:7 robot_hat.filedb.fileDB.set:5
msgid "the value of the arguement"
msgstr "引数の値"

#: of robot_hat.filedb.fileDB.get
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.filedb.fileDB.set:1
msgid "Set value by with name. Or create one if the arguement does not exist"
msgstr "名前で値を設定する。または、引数が存在しない場合は作成する"





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_security.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_security.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_security.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_security.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_security.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_security.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_security.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_security.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_security.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_security.rst:16
msgid "Security System"
msgstr "セキュリティシステム"

#: ../project_security.rst:18
msgid ""
"In this project, we've created a simple security system. The PIR sensor "
"detects if someone passes by, and then the camera activates. If a face is"
" detected, it takes a picture and simultaneously delivers a warning "
"message."
msgstr "このプロジェクトでは、シンプルなセキュリティシステムを作成しました。PIRセンサーが人の動きを検出すると、カメラが起動します。顔が検出されると、写真を撮り、同時に警告メッセージを発信します。"

#: ../project_security.rst:22
msgid "**Steps**"
msgstr "**手順**"

#: ../project_security.rst:24
msgid "Install the ``vilib`` library for face detection."
msgstr "顔検出のための ``vilib`` ライブラリをインストールします。"

#: ../project_security.rst:33
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``security.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``security.ty`` という名前を付けます。"

#: ../project_security.rst:106
msgid "Use the command ``sudo python3 security.py`` to run this code."
msgstr "このコードを実行するには、 ``sudo python3 security.py`` コマンドを使用します。"

#: ../project_security.rst:106
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"

#: ../project_security.rst:108
msgid ""
"Open a web browser and enter ``http://rpi_ip:9000/mjpg`` to view the "
"captured footage. Additionally, you can find the captured face images in "
"``/home/{username}/Pictures/``."
msgstr ""
"ウェブブラウザを開いて ``http://rpi_ip:9000/mjpg`` "
"にアクセスし、キャプチャされた映像を視聴できます。さらに、キャプチャされた顔の画像は ``/home/{username}/Pictures/``"
" で見つけることができます。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/installation.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../installation.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../installation.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../installation.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../installation.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../installation.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../installation.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../installation.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../installation.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../installation.rst:16
msgid "Install the ``robot-hat`` Module"
msgstr "``robot-hat`` モジュールのインストール"

#: ../installation.rst:18
msgid "``robot-hat`` is the supported library for the Robot HAT."
msgstr "``robot-hat`` はRobot HATに対応したライブラリです。"

#: ../installation.rst:20
msgid "Update your system."
msgstr "システムをアップデートしてください。"

#: ../installation.rst:22
msgid "Make sure you are connected to the Internet and update your system:"
msgstr "インターネットに接続していることを確認し、システムをアップデートしてください:"

#: ../installation.rst:35
msgid ""
"Python3 related packages must be installed if you are installing the "
"**Lite** version OS."
msgstr "OSの **Lite** バージョンをインストールする場合、Python3関連のパッケージをインストールする必要があります。"

#: ../installation.rst:45
msgid "Type this command into the terminal to install the ``robot-hat`` package."
msgstr "このコマンドをターミナルに入力して、``robot-hat`` パッケージをインストールします。"

#: ../installation.rst:59
msgid ""
"Run ``setup.py`` to download some necessary components. You may have a "
"network problem and the download may fail. At this point you may need to "
"download again. In the following cases, type ``Y`` and press ``Enter`` to"
" continue the process."
msgstr ""
"``setup.py`` "
"を実行して必要なコンポーネントをダウンロードします。ネットワークの問題でダウンロードが失敗することがあります。その場合は、再度ダウンロードが必要になるかもしれません。次のような場合には、"
" ``Y`` と入力し ``Enter`` を押してプロセスを続行してください。"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/battery.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../battery.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../battery.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../battery.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../battery.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../battery.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../battery.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../battery.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../battery.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../battery.rst:16
msgid "About the Battery"
msgstr "バッテリーについて"

#: ../battery.rst:17
msgid "**Battery**"
msgstr "**バッテリー**"

#: ../battery.rst:23
msgid ""
"**VCC**: Battery positive terminal, here there are two sets of VCC and "
"GND is to increase the current and reduce the resistance."
msgstr "**VCC**: バッテリーの正極端子。ここにはVCCとGNDの2組があり、電流を増やし抵抗を減らすためです。"

#: ../battery.rst:24
msgid ""
"**Middle**: To balance the voltage between the two cells and thus protect"
" the battery."
msgstr "**Middle**: 二つのセル間の電圧をバランスさせ、バッテリーを保護します。"

#: ../battery.rst:25
msgid "**GND**: Negative battery terminal."
msgstr "**GND**: バッテリーの負極端子。"

#: ../battery.rst:28
msgid ""
"This is a custom battery pack made by SunFounder consisting of two 18650 "
"batteries with a capacity of 2000mAh. The connector is XH2.54 3pin, which"
" can be charged directly after being inserted into the shield."
msgstr ""
"これはSunFounderによって製造されたカスタムバッテリーパックで、2000mAhの容量を持つ18650バッテリー2個で構成されています。コネクターは"
" XH2.54-3Pで、シールドに挿入後、直接充電が可能です。"

#: ../battery.rst:32
msgid "**Features**"
msgstr "**特徴**"

#: ../battery.rst:34
msgid "Composition: Li-ion"
msgstr "構成: Li Battery (リチウムイオン二次電池)"

#: ../battery.rst:35
msgid "Battery Capacity: 2000mAh, 14.8Wh"
msgstr "バッテリー容量: 2000mAh, 14.8Wh"

#: ../battery.rst:36
msgid "Battery Weight: 90.8g"
msgstr "バッテリー重量：90.8g"

#: ../battery.rst:37
msgid "Number of Cells: 2"
msgstr "セル数：2"

#: ../battery.rst:38
msgid "Connector: XH2.54 3pin"
msgstr "コネクター: XH2.54 3pin"

#: ../battery.rst:39
msgid "Over-discharge protection: 6.0V"
msgstr "過放電保護 6.0V"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_motor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_motor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_motor.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_motor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_motor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_motor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_motor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_motor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_motor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_motor.rst:18
msgid "module ``motor``"
msgstr "モジュール ``motor``"

#: ../api_motor.rst:21
msgid "class ``Motors``"
msgstr "クラス ``Motors``"

#: ../api_motor.rst:23 ../api_motor.rst:95
msgid "**Example**"
msgstr "**例**"

#: ../api_motor.rst:25
msgid "Initilize"
msgstr "初期化"

#: ../api_motor.rst:35
msgid "Directly control a motor. Motor 1/2 is according to PCB mark"
msgstr "モーターを直接制御します。モーター1/2はPCBのマークに従います"

#: ../api_motor.rst:46
msgid ""
"Setup for high level control, high level control provides functions from "
"simple forword, backward, left, right, stop to more complex like joystick"
" control, motor directions calibration, etc."
msgstr "ハイレベル制御の設定を行います。ハイレベル制御は、単純な前進、後退、左、右、停止から、ジョイスティック制御、モーター方向のキャリブレーションなどの複雑な機能を提供します。"

#: ../api_motor.rst:51
msgid ""
"All these setup only need to run once, and will save in a config file. "
"Next time you load Motors class, it will load from config file."
msgstr "これらの設定は一度だけ実行する必要があり、設定ファイルに保存されます。次にMotorsクラスをロードするときは、設定ファイルからロードされます。"

#: ../api_motor.rst:67
msgid "Now control the robot"
msgstr "これでロボットを制御できます"

#: ../api_motor.rst:83 ../api_motor.rst:113
msgid "**API**"
msgstr "**API**"

#: of robot_hat.motor.Motors:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.motor.Motors.__init__:1
msgid "Initialize motors with robot_hat.motor.Motor"
msgstr "robot_hat.motor.Motorでモーターを初期化"

#: of robot_hat.motor.Motor.__init__ robot_hat.motor.Motor.set_is_reverse
#: robot_hat.motor.Motor.speed robot_hat.motor.Motors.__init__
#: robot_hat.motor.Motors.backward robot_hat.motor.Motors.forward
#: robot_hat.motor.Motors.set_left_id robot_hat.motor.Motors.set_right_id
#: robot_hat.motor.Motors.speed robot_hat.motor.Motors.turn_left
#: robot_hat.motor.Motors.turn_right
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.motor.Motors.__init__:3
msgid "config file path"
msgstr "設定ファイルのパス"

#: of robot_hat.motor.Motors.__getitem__:1
msgid "Get specific motor"
msgstr "特定のモーターを取得する"

#: of robot_hat.motor.Motors.stop:1
msgid "Stop all motors"
msgstr "すべてのモーターを停止する"

#: of robot_hat.Motors.left:1
msgid "left motor"
msgstr "左のモーター"

#: of robot_hat.Motors.right:1
msgid "right motor"
msgstr "右のモーター"

#: of robot_hat.motor.Motors.set_left_id:1
msgid ""
"Set left motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr "左のモーターIDを設定します。この機能は一度だけ実行する必要があり、モーターIDを設定ファイルに保存し、クラスが初期化されるときにモーターIDをロードします。"

#: of robot_hat.motor.Motors.set_left_id:5
#: robot_hat.motor.Motors.set_right_id:5
msgid "motor id (1 or 2)"
msgstr "モーターID（1または2）"

#: of robot_hat.motor.Motors.set_right_id:1
msgid ""
"Set right motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr "右のモーターIDを設定します。この機能は一度だけ実行する必要があり、モーターIDを設定ファイルに保存し、クラスが初期化されるときにモーターIDをロードします。"

#: of robot_hat.motor.Motors.set_left_reverse:1
msgid ""
"Set left motor reverse, this function only need to run once It will save "
"the reversed status to config file, and load the reversed status when the"
" class is initialized"
msgstr "左のモーターを逆回転に設定します。この機能は一度だけ実行する必要があり、逆回転の状態を設定ファイルに保存し、クラスが初期化されるときに逆回転の状態をロードします。"

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Returns"
msgstr ""

#: of robot_hat.motor.Motors.set_left_reverse:5
#: robot_hat.motor.Motors.set_right_reverse:5
msgid "if currently is reversed"
msgstr "現在逆回転しているかどうか"

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.motor.Motors.set_right_reverse:1
msgid ""
"Set right motor reverse, this function only need to run once It will save"
" the reversed status to config file, and load the reversed status when "
"the class is initialized"
msgstr "右のモーターを逆回転に設定します。この機能は一度だけ実行する必要があり、逆回転の状態を設定ファイルに保存し、クラスが初期化されるときに逆回転の状態をロードします。"

#: of robot_hat.motor.Motors.speed:1
msgid "Set motor speed"
msgstr "モーター速度を設定する"

#: of robot_hat.motor.Motors.speed:3
msgid "left motor speed(-100.0~100.0)"
msgstr "左モーターの速度(-100.0~100.0)"

#: of robot_hat.motor.Motors.speed:5
msgid "right motor speed(-100.0~100.0)"
msgstr "右モーターの速度(-100.0~100.0)"

#: of robot_hat.motor.Motors.forward:1
msgid "Forward"
msgstr "前進"

#: of robot_hat.motor.Motor.speed:3 robot_hat.motor.Motors.backward:3
#: robot_hat.motor.Motors.forward:3 robot_hat.motor.Motors.turn_left:3
#: robot_hat.motor.Motors.turn_right:3
msgid "Motor speed(-100.0~100.0)"
msgstr "モーター速度(-100.0~100.0)"

#: of robot_hat.motor.Motors.backward:1
msgid "Backward"
msgstr "後退"

#: of robot_hat.motor.Motors.turn_left:1
msgid "Left turn"
msgstr "左折"

#: of robot_hat.motor.Motors.turn_right:1
msgid "Right turn"
msgstr "右折"

#: ../api_motor.rst:93
msgid "class ``Motor``"
msgstr "クラス ``Motor``"

#: of robot_hat.motor.Motor:1
msgid "Bases: :py:class:`object`"
msgstr "基底: :py:class:`object`"

#: of robot_hat.motor.Motor.__init__:1
msgid "Initialize a motor"
msgstr "モーターを初期化する"

#: of robot_hat.motor.Motor.__init__:3
msgid "Motor speed control pwm pin"
msgstr "モーター速度制御用PWMピン"

#: of robot_hat.motor.Motor.__init__:5
msgid "Motor direction control pin"
msgstr "モーター方向制御ピン"

#: of robot_hat.motor.Motor.speed:1
msgid "Get or set motor speed"
msgstr "モーター速度の取得または設定"

#: of robot_hat.motor.Motor.set_is_reverse:1
msgid "Set motor is reversed or not"
msgstr "モーターの逆転を設定するかどうか"

#: of robot_hat.motor.Motor.set_is_reverse:3
msgid "True or False"
msgstr "True または False"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_servo.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_servo.rst:18
msgid "class ``Servo``"
msgstr "クラス ``Servo``"

#: ../api_servo.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_servo.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.servo.Servo:1
msgid "Bases: :py:class:`~robot_hat.pwm.PWM`"
msgstr "基底: :py:class:`~robot_hat.pwm.PWM`"

#: of robot_hat.servo.Servo:1
msgid "Servo motor class"
msgstr "サーボモータークラス"

#: of robot_hat.servo.Servo.__init__:1
msgid "Initialize the servo motor class"
msgstr "サーボモータークラスを初期化する"

#: of robot_hat.servo.Servo.__init__ robot_hat.servo.Servo.angle
#: robot_hat.servo.Servo.pulse_width_time
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.servo.Servo.__init__:3
msgid "PWM channel number(0-14/P0-P14)"
msgstr "PWMチャンネル番号(0-14/P0-P14)"

#: of robot_hat.servo.Servo.angle:1
msgid "Set the angle of the servo motor"
msgstr "サーボモーターの角度を設定する"

#: of robot_hat.servo.Servo.angle:3
msgid "angle(-90~90)"
msgstr "角度(-90~90)"

#: of robot_hat.servo.Servo.pulse_width_time:1
msgid "Set the pulse width of the servo motor"
msgstr "サーボモーターのパルス幅を設定する"

#: of robot_hat.servo.Servo.pulse_width_time:3
msgid "pulse width time(500~2500)"
msgstr "パルス幅時間(500~2500)"




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_ultrasonic.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_ultrasonic.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_ultrasonic.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_ultrasonic.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_ultrasonic.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_ultrasonic.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_ultrasonic.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_ultrasonic.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_ultrasonic.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_ultrasonic.rst:16
msgid "Read from Ultrasonic Module"
msgstr "超音波モジュールからの読み取り"

#: ../project_ultrasonic.rst:19
msgid ""
"In this project, we use ultrasonic sensors to measure distance and "
"display the readings on the I2C LCD1602."
msgstr "このプロジェクトでは、超音波センサーを使用して距離を測定し、その読み取り値をI2C LCD1602に表示します。"

#: ../project_ultrasonic.rst:23
msgid "**Steps**"
msgstr "**手順**"

#: ../project_ultrasonic.rst:25
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr "このプロジェクトではI2C LCD1602を使用しているため、関連するライブラリをダウンロードして機能させる必要があります。"

#: ../project_ultrasonic.rst:32
msgid "Install ``smbus2`` for I2C."
msgstr "I2C用に ``smbus2`` をインストールします。"

#: ../project_ultrasonic.rst:38
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``ultrasonic.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``ultrasonic.ty`` という名前を付けます。"

#: ../project_ultrasonic.rst:88
msgid "Use the command ``sudo python3 ultrasonic.ty`` to run this code."
msgstr "このコードを実行するには、 ``sudo python3 ultrasonic.ty`` コマンドを使用します。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/features.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../features.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../features.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../features.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../features.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../features.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../features.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../features.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../features.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../features.rst:16
msgid "Features"
msgstr "特徴"

#: ../features.rst:18
msgid "Shutdown Current: < 0.5mA"
msgstr "シャットダウン電流：<0.5mA"

#: ../features.rst:19
msgid "Power Input: USB Type-C, 5V/2A"
msgstr "電源入力：USB Type-C、5V/2A"

#: ../features.rst:20
msgid "Charging Power: 5V/2A 10W"
msgstr "充電電力：5V/2A 10W"

#: ../features.rst:21
msgid "Output Power: 5V/3A"
msgstr "出力電力：5V/3A"

#: ../features.rst:22
msgid ""
"Included Batteries: 2 x 3.7V 18650 Lithium-ion Batteries, XH2.54 3P "
"Interface"
msgstr "付属のバッテリー：2 x 3.7V 18650リチウムイオンバッテリー、XH2.54 3Pインターフェース"

#: ../features.rst:23
msgid "Battery Protection: Reverse polarity protection"
msgstr "バッテリー保護：逆極性保護"

#: ../features.rst:24
msgid ""
"Charging Protection: Input undervoltage protection, input overvoltage "
"protection, charging balance, overheat protection"
msgstr "充電保護：入力低電圧保護、入力過電圧保護、充電バランス、過熱保護"

#: ../features.rst:25
msgid "Onboard Charging Indicator Light: CHG"
msgstr "オンボード充電指示灯：CHG"

#: ../features.rst:26
msgid "Onboard Power Indicator Light: PWR"
msgstr "オンボード電源指示灯：PWR"

#: ../features.rst:27
msgid "Onboard 2 Battery Level Indicator LEDs"
msgstr "オンボード2つのバッテリーレベル指示LED"

#: ../features.rst:28
msgid "Onboard User LED, 2 tactile switches"
msgstr "オンボードユーザーLED、2つの触覚スイッチ"

#: ../features.rst:29
msgid "Motor Driver: 5V/1.8A x 2"
msgstr "モータードライバー：5V/1.8A x 2"

#: ../features.rst:30
msgid "4-channel 12-bit ADC"
msgstr "4チャンネル12ビットADC"

#: ../features.rst:31
msgid "12-channel PWM"
msgstr "12チャンネルPWM"

#: ../features.rst:32
msgid "4-channel digital signals"
msgstr "4チャンネルデジタル信号"

#: ../features.rst:33
msgid "Onboard SPI interface, UART interface, I2C interface"
msgstr "オンボードSPIインターフェース、UARTインターフェース、I2Cインターフェース"

#: ../features.rst:34
msgid "Mono Speaker: 8Ω1W"
msgstr "モノスピーカー：8Ω1W"

#: ../features.rst:36
msgid "Electrical Characteristics"
msgstr "電気特性"

#: ../features.rst:40
msgid "Parameters:"
msgstr "パラメータ："

#: ../features.rst:41
msgid "Minimum Value:"
msgstr "最小値："

#: ../features.rst:42
msgid "Typical Value:"
msgstr "典型値："

#: ../features.rst:43
msgid "Maximum Value:"
msgstr "最大値："

#: ../features.rst:44
msgid "Unit:"
msgstr "単位："

#: ../features.rst:45
msgid "Input Voltage:"
msgstr "入力電圧："

#: ../features.rst:46 ../features.rst:62
msgid "4.25"
msgstr "4.25"

#: ../features.rst:47
msgid "5"
msgstr "5"

#: ../features.rst:48 ../features.rst:53 ../features.rst:67
msgid "8.4"
msgstr "8.4"

#: ../features.rst:49 ../features.rst:54 ../features.rst:59 ../features.rst:64
#: ../features.rst:69 ../features.rst:84
msgid "V"
msgstr "V"

#: ../features.rst:50
msgid "Battery Input Voltage:"
msgstr "バッテリー入力電圧："

#: ../features.rst:51
msgid "6.0"
msgstr "6.0"

#: ../features.rst:52
msgid "7.4"
msgstr "7.4"

#: ../features.rst:55
msgid "Overcharge Protection (Battery):"
msgstr "過充電保護（バッテリー）："

#: ../features.rst:57 ../features.rst:66
msgid "8.3"
msgstr "8.3"

#: ../features.rst:60
msgid "Input Undervoltage Protection:"
msgstr "入力低電圧保護："

#: ../features.rst:61
msgid "4.15"
msgstr "4.15"

#: ../features.rst:63
msgid "4.35"
msgstr "4.35"

#: ../features.rst:65
msgid "Input Overvoltage Protection:"
msgstr "入力過電圧保護："

#: ../features.rst:68
msgid "8.5"
msgstr "8.5"

#: ../features.rst:70
msgid "Charging Current (5V):"
msgstr "充電電流（5V）："

#: ../features.rst:73
msgid "2.0"
msgstr "2.0"

#: ../features.rst:74 ../features.rst:79 ../features.rst:99
msgid "A"
msgstr "A"

#: ../features.rst:75
msgid "Output Current (5V):"
msgstr "出力電流（5V）："

#: ../features.rst:78
msgid "3.0"
msgstr "3.0"

#: ../features.rst:80
msgid "Output Voltage:"
msgstr "出力電圧："

#: ../features.rst:81
msgid "5.166"
msgstr "5.166"

#: ../features.rst:82
msgid "5.246"
msgstr "5.246"

#: ../features.rst:83
msgid "5.327"
msgstr "5.327"

#: ../features.rst:85
msgid "Charging Overheat Protection:"
msgstr "充電過熱保護："

#: ../features.rst:86
msgid "125"
msgstr "125"

#: ../features.rst:87
msgid "135"
msgstr "135"

#: ../features.rst:88
msgid "145"
msgstr "145"

#: ../features.rst:89 ../features.rst:94
msgid "°C"
msgstr "°C"

#: ../features.rst:90
msgid "DC-DC Overheat Protection:"
msgstr "DC-DC過熱保護："

#: ../features.rst:91
msgid "70"
msgstr "70"

#: ../features.rst:92
msgid "75"
msgstr "75"

#: ../features.rst:93
msgid "80"
msgstr "80"

#: ../features.rst:95
msgid "Motor Output Current:"
msgstr "モーター出力電流："

#: ../features.rst:98
msgid "1.8"
msgstr "1.8"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/ja/LC_MESSAGES/onboard_mcu.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../onboard_mcu.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../onboard_mcu.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../onboard_mcu.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../onboard_mcu.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../onboard_mcu.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../onboard_mcu.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../onboard_mcu.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../onboard_mcu.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../onboard_mcu.rst:18
msgid "On-Board MCU"
msgstr "オンボードMCU"

#: ../onboard_mcu.rst:20
msgid ""
"The Robot HAT comes with an AT32F413CBT7 microcontroller from Artery. It "
"is an ARM Cortex-M4 processor with a maximum clock frequency of 200MHz. "
"The microcontroller has 128KB of Flash memory and 32KB of SRAM."
msgstr ""
"Robot "
"HATは、ArteryのAT32F415CBT7マイクロコントローラーを搭載しています。これは、最大クロック周波数が150MHzのARM "
"Cortex-M4プロセッサーです。マイクロコントローラーには、256KBのフラッシュメモリと32KBのSRAMがあります。"

#: ../onboard_mcu.rst:22
msgid ""
"The onboard PWM and ADC are driven by the microcontroller. Communication "
"between the Raspberry Pi and the microcontroller is established via the "
"I2C interface. The I2C address used for communication is 0x14 (7-bit "
"address format)."
msgstr ""
"オンボードのPWMとADCは、マイクロコントローラによって駆動されます。Raspberry "
"Piとマイクロコントローラ間の通信は、I2Cインターフェイスを通じて確立されます。通信に使用されるI2Cアドレスは0x14（7ビットアドレス形式）です。"

#: ../onboard_mcu.rst:28
msgid "Introduce"
msgstr "紹介"

#: ../onboard_mcu.rst:30
msgid ""
"The on board MCU RESET pin is connected to Raspberry Pi GPIO 5, or "
"``MCURST`` for :py:class:`robot_hat.Pin`. The MCU using 7-bit address "
"``0x14``."
msgstr ""
"オンボードMCUのRESETピンは、Raspberry PiのGPIO 5、または :py:class:`robot_hat.Pin` の "
"``MCURST`` に接続されています。MCUは7ビットアドレスの ``0x14`` を使用しています。"

#: ../onboard_mcu.rst:33
msgid "ADC"
msgstr "ADC"

#: ../onboard_mcu.rst:35
msgid ""
"Register addresses is 3 byte, 0x170000 to 0x140000 are ADC channels 0 to "
"3. The ADC precision is 12 bit, and the value is 0 to 4095. See more "
"details in :py:class:`robot_hat.ADC`."
msgstr ""
"レジスタアドレスは3バイトで、0x170000から0x140000までがADCチャンネル0から3です。ADCの精度は12ビットで、値は0から4095までです。:py:class:`robot_hat.ADC`"
" で詳細を確認してください。"

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Address"
msgstr "アドレス"

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Description"
msgstr "説明"

#: ../onboard_mcu.rst:44
msgid "``0x170000``"
msgstr "``0x170000``"

#: ../onboard_mcu.rst:44
msgid "ADC channel 0"
msgstr "ADCチャンネル0"

#: ../onboard_mcu.rst:46
msgid "``0x160000``"
msgstr "``0x160000``"

#: ../onboard_mcu.rst:46
msgid "ADC channel 1"
msgstr "ADCチャンネル1"

#: ../onboard_mcu.rst:48
msgid "``0x150000``"
msgstr "``0x150000``"

#: ../onboard_mcu.rst:48
msgid "ADC channel 2"
msgstr "ADCチャンネル2"

#: ../onboard_mcu.rst:50
msgid "``0x140000``"
msgstr "``0x140000``"

#: ../onboard_mcu.rst:50
msgid "ADC channel 3"
msgstr "ADCチャンネル3"

#: ../onboard_mcu.rst:52
msgid "``0x130000``"
msgstr "``0x130000``"

#: ../onboard_mcu.rst:52
msgid "ADC channel 4 (Battery Level)"
msgstr "ADCチャンネル4（バッテリーレベル）"

#: ../onboard_mcu.rst:55
msgid "**Example:**"
msgstr "**例:**"

#: ../onboard_mcu.rst:57
msgid "Read Channel 0 ADC value:"
msgstr "チャンネル0のADC値を読む:"

#: ../onboard_mcu.rst:72
msgid "PWM"
msgstr "PWM"

#: ../onboard_mcu.rst:74
msgid "PWM have 1 byte register with 2 byte values."
msgstr "PWMは1バイトのレジスタと2バイトの値を持っています。"

#: ../onboard_mcu.rst:77
msgid "Changing PWM Frequency"
msgstr "PWM周波数の変更"

#: ../onboard_mcu.rst:79
msgid "Frequency is defined with prescaler and period."
msgstr "周波数はプリスケーラと周期で定義されます。"

#: ../onboard_mcu.rst:81
msgid ""
"To set frequency first you need to define the period you want. Like on "
"Arduino, normaly is 255, or like PCA9685 is 4095."
msgstr "周波数を設定するには、まず設定したい周期を定義する必要があります。Arduinoでは通常255、PCA9685では4095です。"

#: ../onboard_mcu.rst:84
msgid ""
"CPU clock is 72MHz, Then you can calculate the prescaler from your desire"
" frequency"
msgstr "CPUクロックは72MHzです。そこから、希望の周波数に応じたプリスケーラを計算できます"

#: ../onboard_mcu.rst:87
msgid "prescaler = 72MHz / (Period + 1) / Frequency - 1"
msgstr "プリスケーラ = 72MHz / (周期 + 1) / 周波数 - 1"

#: ../onboard_mcu.rst:89
msgid ""
"Or if you don't care about the period, there's a way to calculate both "
"period and prescaler from frequency. See :py:func:`robot_hat.PWM.freq`."
msgstr ""
"周期にこだわらない場合は、周波数から周期とプリスケーラの両方を計算する方法があります。 :py:func:`robot_hat.PWM.freq`"
" を参照してください。"

#: ../onboard_mcu.rst:93
msgid "Pulse width"
msgstr "パルス幅"

#: ../onboard_mcu.rst:95
msgid ""
"To control the channel pulse width is rather simple, just write the value"
" to the register."
msgstr "チャンネルのパルス幅を制御するのは簡単で、値をレジスタに書き込むだけです。"

#: ../onboard_mcu.rst:97
msgid ""
"**But** what is the value? If you want to set the PWM to 50% pulse width,"
" you need to know exactly what the period is. Base on the above "
"calculation, if you set the period to 4095, then set pulse value to 2048 "
"is about 50% pulse width."
msgstr ""
"**しかし** "
"値とは何か？PWMを50%のパルス幅に設定したい場合、周期が正確に何であるかを知る必要があります。上記の計算に基づき、周期を4095に設定した場合、パルス値を2048に設定すると、約50%のパルス幅になります。"

#: ../onboard_mcu.rst:106
msgid "``0x20``"
msgstr "``0x20``"

#: ../onboard_mcu.rst:106
msgid "Set PWM channel 0 **On Value**"
msgstr "PWMチャンネル0 **オン値** を設定"

#: ../onboard_mcu.rst:108
msgid "``0x21``"
msgstr "``0x21``"

#: ../onboard_mcu.rst:108
msgid "Set PWM channel 1 **On Value**"
msgstr "PWMチャンネル1 **オン値** を設定"

#: ../onboard_mcu.rst:110
msgid "``0x22``"
msgstr "``0x22``"

#: ../onboard_mcu.rst:110
msgid "Set PWM channel 2 **On Value**"
msgstr "PWMチャンネル2の **オン値** を設定"

#: ../onboard_mcu.rst:112
msgid "``0x23``"
msgstr "``0x23``"

#: ../onboard_mcu.rst:112
msgid "Set PWM channel 3 **On Value**"
msgstr "PWMチャンネル3の **オン値** を設定"

#: ../onboard_mcu.rst:114
msgid "``0x24``"
msgstr "``0x24``"

#: ../onboard_mcu.rst:114
msgid "Set PWM channel 4 **On Value**"
msgstr "PWMチャンネル4の **オン値** を設定"

#: ../onboard_mcu.rst:116
msgid "``0x25``"
msgstr "``0x25``"

#: ../onboard_mcu.rst:116
msgid "Set PWM channel 5 **On Value**"
msgstr "PWMチャンネル5の **オン値** を設定"

#: ../onboard_mcu.rst:118
msgid "``0x26``"
msgstr "``0x26``"

#: ../onboard_mcu.rst:118
msgid "Set PWM channel 6 **On Value**"
msgstr "PWMチャンネル6の **オン値** を設定"

#: ../onboard_mcu.rst:120
msgid "``0x27``"
msgstr "``0x27``"

#: ../onboard_mcu.rst:120
msgid "Set PWM channel 7 **On Value**"
msgstr "PWMチャンネル7の **オン値** を設定"

#: ../onboard_mcu.rst:122
msgid "``0x28``"
msgstr "``0x28``"

#: ../onboard_mcu.rst:122
msgid "Set PWM channel 8 **On Value**"
msgstr "PWMチャンネル8の **オン値** を設定"

#: ../onboard_mcu.rst:124
msgid "``0x29``"
msgstr "``0x29``"

#: ../onboard_mcu.rst:124
msgid "Set PWM channel 9 **On Value**"
msgstr "PWMチャンネル9の **オン値** を設定"

#: ../onboard_mcu.rst:126
msgid "``0x2A``"
msgstr "``0x2A``"

#: ../onboard_mcu.rst:126
msgid "Set PWM channel 10 **On Value**"
msgstr "PWMチャンネル10の **オン値** を設定"

#: ../onboard_mcu.rst:128
msgid "``0x2B``"
msgstr "``0x2B``"

#: ../onboard_mcu.rst:128
msgid "Set PWM channel 11 **On Value**"
msgstr "PWMチャンネル11の **オン値** を設定"

#: ../onboard_mcu.rst:130
msgid "``0x2C``"
msgstr "``0x2C``"

#: ../onboard_mcu.rst:130
msgid "Set Motor 2 speed **On Value**"
msgstr "モーター2の速度 **オン値** を設定"

#: ../onboard_mcu.rst:132
msgid "``0x2D``"
msgstr "``0x2D``"

#: ../onboard_mcu.rst:132
msgid "Set Motor 1 speed **On Value**"
msgstr "モーター1の速度 **オン値** を設定"

#: ../onboard_mcu.rst:136
msgid "Prescaler"
msgstr "プリスケーラー"

#: ../onboard_mcu.rst:138
msgid ""
"Register from 0x40 is to set the PWM prescaler. ranges from 0~65535. "
"There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"0x40から始まるレジスタはPWMプリスケーラーを設定するためのもので、範囲は0〜65535です。全14チャンネルに対してタイマーは4つのみです。"
" `PWMタイマー(重要)`_ を参照してください。"

#: ../onboard_mcu.rst:146
msgid "``0x40``"
msgstr "``0x40``"

#: ../onboard_mcu.rst:146
msgid "Set timer 0 **Prescaler**"
msgstr "タイマー0の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:148
msgid "``0x41``"
msgstr "``0x41``"

#: ../onboard_mcu.rst:148
msgid "Set timer 1 **Prescaler**"
msgstr "タイマー1の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:150
msgid "``0x42``"
msgstr "``0x42``"

#: ../onboard_mcu.rst:150
msgid "Set timer 2 **Prescaler**"
msgstr "タイマー2の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:152
msgid "``0x43``"
msgstr "``0x43``"

#: ../onboard_mcu.rst:152
msgid "Set timer 3 **Prescaler**"
msgstr "タイマー3の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:156
msgid "Period"
msgstr "周期"

#: ../onboard_mcu.rst:158
msgid ""
"Register from 0x44 is to set the PWM period. ranges from 0~65535. There "
"are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"0x44から始まるレジスタはPWM周期を設定するためのもので、範囲は0〜65535です。全14チャンネルに対してタイマーは4つのみです。 "
"`PWMタイマー(重要)`_ を参照してください。"

#: ../onboard_mcu.rst:166
msgid "``0x44``"
msgstr "``0x44``"

#: ../onboard_mcu.rst:166
msgid "Set timer 0 **Period**"
msgstr "タイマー0の **周期** を設定"

#: ../onboard_mcu.rst:168
msgid "``0x45``"
msgstr "``0x45``"

#: ../onboard_mcu.rst:168
msgid "Set timer 1 **Period**"
msgstr "タイマー1の **周期** を設定"

#: ../onboard_mcu.rst:170
msgid "``0x46``"
msgstr "``0x46``"

#: ../onboard_mcu.rst:170
msgid "Set timer 2 **Period**"
msgstr "タイマー2の **周期** を設定"

#: ../onboard_mcu.rst:172
msgid "``0x47``"
msgstr "``0x47``"

#: ../onboard_mcu.rst:172
msgid "Set timer 3 **Period**"
msgstr "タイマー3の **周期** を設定"

#: ../onboard_mcu.rst:176
msgid "PWM Timer(IMPORTANT)"
msgstr "PWMタイマー（重要）"

#: ../onboard_mcu.rst:178
msgid ""
"What is PWM Timer? PWM Timer is a tool to turn on and off the PWM channel"
" for you."
msgstr "PWMタイマーとは何ですか？PWMタイマーは、PWMチャンネルをオン・オフするためのツールです。"

#: ../onboard_mcu.rst:180
msgid ""
"The MCU only have 4 timers for PWM: which means you cannot set frequency "
"on different channels at with the same timer."
msgstr "MCUにはPWM用のタイマーが4つしかありません：つまり、同じタイマーで異なるチャンネルの周波数を設定することはできません。"

#: ../onboard_mcu.rst:183
msgid ""
"Example: if you set frequency on channel 0, channel 1, 2, 3 will be "
"affected. If you change channel 2 frequency, channel 0, 1, 3 will be "
"override."
msgstr "例：チャンネル0に周波数を設定すると、チャンネル1、2、3に影響が及びます。チャンネル2の周波数を変更すると、チャンネル0、1、3が上書きされます。"

#: ../onboard_mcu.rst:186
msgid ""
"This happens like if you want to control both a passive buzzer (who "
"changes frequency all the time) and servo (who needs a fix frequency of "
"50Hz). Then you should seperate them into two different timer."
msgstr "これは、常に周波数を変更するパッシブブザーと固定周波数50Hzが必要なサーボを同時に制御したい場合のような状況です。この場合、それらを2つの異なるタイマーに分けるべきです。"

#: ../onboard_mcu.rst:192
msgid "Timer"
msgstr "タイマー"

#: ../onboard_mcu.rst:192
msgid "PWM Channel"
msgstr "PWMチャンネル"

#: ../onboard_mcu.rst:194
msgid "Timer 0"
msgstr "タイマー0"

#: ../onboard_mcu.rst:194
msgid "0, 1, 2, 3"
msgstr "0, 1, 2, 3"

#: ../onboard_mcu.rst:196
msgid "Timer 1"
msgstr "タイマー1"

#: ../onboard_mcu.rst:196
msgid "4, 5, 6, 7"
msgstr "4, 5, 6, 7"

#: ../onboard_mcu.rst:198
msgid "Timer 2"
msgstr "タイマー2"

#: ../onboard_mcu.rst:198
msgid "8, 9, 10, 11"
msgstr "8, 9, 10, 11"

#: ../onboard_mcu.rst:200
msgid "Timer 3"
msgstr "タイマー3"

#: ../onboard_mcu.rst:200
msgid "12, 13(for motors)"
msgstr "12, 13（モーター用）"

#: ../onboard_mcu.rst:204
msgid "Example"
msgstr "例"

#: ../onboard_mcu.rst:224
msgid "Reset MCU"
msgstr "MCUをリセット"

#: ../onboard_mcu.rst:226
msgid ""
"Currently the firmware reads a fix 3 byte value, then it can return ADC "
"values or control PWM. Thats why ADC register need 3byte with the latter "
"2 byte is 0."
msgstr "現在のファームウェアは固定3バイトの値を読み取り、その後ADC値を返すかPWMを制御できます。そのためADCレジスタは最後の2バイトが0の3バイトが必要です。"

#: ../onboard_mcu.rst:229
msgid ""
"And if your program is interrupted in the middle of the communication, "
"the firmware may stuck and offset the data. Even we have timeout on "
"waiting on 3 byte datas."
msgstr "そして、通信の途中でプログラムが中断されると、ファームウェアが固まってデータがずれる可能性があります。3バイトのデータ待ちにはタイムアウトも設定しています。"

#: ../onboard_mcu.rst:231
msgid ""
"If so, you need to reset the MCU. To reset it. You can use the robot_hat "
"command:"
msgstr "そのような場合は、MCUをリセットする必要があります。リセットするには、robot_hatコマンドを使用できます："

#: ../onboard_mcu.rst:237
msgid "Or you can do it in your python code:"
msgstr "または、Pythonコードで行うこともできます："

#: ../onboard_mcu.rst:244
msgid ""
"Or you can just pull down the reset pin (GPIO 5) for 10 ms, then pull it "
"back up for another 10ms, as that's what ``reset_mcu`` dose."
msgstr "あるいは、リセットピン（GPIO 5）を10ms引き下げてから、さらに10ms引き上げるだけで、それが ``reset_mcu`` が行うことです。"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../api.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../api.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../api.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../api.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../api.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api.rst:16
msgid "Reference"
msgstr "Referenz"

#: of robot_hat:1
msgid "Robot Hat Library"
msgstr "Robot Hat Bibliothek"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_photoresistor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_photoresistor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_photoresistor.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_photoresistor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_photoresistor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_photoresistor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_photoresistor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_photoresistor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_photoresistor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_photoresistor.rst:16
msgid "Read from Photoresistor Module"
msgstr "Lesen vom Fotowiderstandsmodul"

#: ../project_photoresistor.rst:18
msgid ""
"In this project, we detect the light intensity and display on the I2C "
"LCD1602."
msgstr ""
"In diesem Projekt erfassen wir die Lichtintensität und zeigen sie auf dem"
" I2C LCD1602 an."

#: ../project_photoresistor.rst:22
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_photoresistor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr ""
"In diesem Projekt wird ein I2C LCD1602 verwendet, daher ist es notwendig,"
" die relevanten Bibliotheken herunterzuladen, damit es funktioniert."

#: ../project_photoresistor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "Installieren Sie ``smbus2`` für I2C."

#: ../project_photoresistor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``photoresistor.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``photoresistor.ty``."

#: ../project_photoresistor.rst:78
msgid "Use the command ``sudo python3 photoresistor.ty`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 photoresistor.ty``, um diesen "
"Code auszuführen."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_i2c.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_i2c.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_i2c.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_i2c.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_i2c.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_i2c.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_i2c.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_i2c.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_i2c.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_i2c.rst:18
msgid "class ``I2C``"
msgstr "Klasse ``I2C``"

#: ../api_i2c.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_i2c.rst:44
msgid "For more information on the I2C protocol, see checkout adc.py and pwm.py"
msgstr "Für weitere Informationen zum I2C-Protokoll siehe adc.py und pwm.py"

#: ../api_i2c.rst:46
msgid "**API**"
msgstr "**API**"

#: of robot_hat.i2c.I2C:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.i2c.I2C:1
msgid "I2C bus read/write functions"
msgstr "I2C-Bus Lese-/Schreibfunktionen"

#: of robot_hat.i2c.I2C.__init__:1
msgid "Initialize the I2C bus"
msgstr "Initialisierung des I2C-Busses"

#: of robot_hat.i2c.I2C.__init__ robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.mem_write robot_hat.i2c.I2C.read robot_hat.i2c.I2C.write
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.i2c.I2C.__init__:3
msgid "I2C device address"
msgstr "I2C-Geräteadresse"

#: of robot_hat.i2c.I2C.__init__:5
msgid "I2C bus number"
msgstr "I2C-Busnummer"

#: of robot_hat.i2c.I2C.scan:1
msgid "Scan the I2C bus for devices"
msgstr "I2C-Bus nach Geräten scannen"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.i2c.I2C.scan:3
msgid "List of I2C addresses of devices found"
msgstr "Liste der gefundenen I2C-Adressen von Geräten"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.i2c.I2C.write:1
msgid "Write data to the I2C device"
msgstr "Daten an das I2C-Gerät schreiben"

#: of robot_hat.i2c.I2C.write:3
msgid "Data to write"
msgstr "Zu schreibende Daten"

#: of robot_hat.i2c.I2C.write
msgid "raises"
msgstr "Wirft"

#: of robot_hat.i2c.I2C.write:5
msgid "ValueError if write is not an int, list or bytearray"
msgstr ""
"ValueError, falls die Schreiboperation kein int, keine Liste oder kein "
"Bytearray ist"

#: of robot_hat.i2c.I2C.read:1
msgid "Read data from I2C device"
msgstr "Daten vom I2C-Gerät lesen"

#: of robot_hat.i2c.I2C.mem_read:3 robot_hat.i2c.I2C.read:3
msgid "Number of bytes to receive"
msgstr "Anzahl der zu empfangenden Bytes"

#: of robot_hat.i2c.I2C.read:5
msgid "Received data"
msgstr "Empfangene Daten"

#: of robot_hat.i2c.I2C.mem_write:1
msgid "Send data to specific register address"
msgstr "Daten an eine spezifische Registeradresse senden"

#: of robot_hat.i2c.I2C.mem_write:3
msgid "Data to send, int, list or bytearray"
msgstr "Zu sendende Daten, int, Liste oder Bytearray"

#: of robot_hat.i2c.I2C.mem_read:5 robot_hat.i2c.I2C.mem_write:5
msgid "Register address"
msgstr "Registeradresse"

#: of robot_hat.i2c.I2C.mem_write
msgid "Raises"
msgstr "Wirft"

#: of robot_hat.i2c.I2C.mem_write:7
msgid "If data is not int, list, or bytearray"
msgstr "Falls die Daten kein int, keine Liste oder kein Bytearray sind"

#: of robot_hat.i2c.I2C.mem_read:1
msgid "Read data from specific register address"
msgstr "Daten von einer spezifischen Registeradresse lesen"

#: of robot_hat.i2c.I2C.mem_read:7
msgid "Received bytearray data or False if error"
msgstr "Empfangene Bytearray-Daten oder False bei einem Fehler"

#: of robot_hat.i2c.I2C.is_avaliable:1
msgid "Check if the I2C device is avaliable"
msgstr "Überprüfen, ob das I2C-Gerät verfügbar ist"

#: of robot_hat.i2c.I2C.is_avaliable:3
msgid "True if the I2C device is avaliable, False otherwise"
msgstr "True, wenn das I2C-Gerät verfügbar ist, andernfalls False"




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_tts.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_tts.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_tts.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_tts.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_tts.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_tts.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_tts.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_tts.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_tts.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_tts.rst:18
msgid "class ``TTS``"
msgstr "Klasse ``TTS``"

#: ../api_tts.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr ""
"Sie müssen ``sudo`` hinzufügen, wenn Sie dieses Skript ausführen, falls "
"der Lautsprecher nicht funktioniert."

#: ../api_tts.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_tts.rst:24
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_tts.rst:39
msgid "**API**"
msgstr "**API**"

#: of robot_hat.tts.TTS:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.tts.TTS:1
msgid "Text to speech class"
msgstr "Text-zu-Sprache-Klasse"

#: ../docstring of robot_hat.TTS.SUPPORTED_LANGUAUE:1
msgid "Supported TTS language for pico2wave"
msgstr "Unterstützte TTS-Sprache für pico2wave"

#: ../docstring of robot_hat.TTS.ESPEAK:1
msgid "espeak TTS engine"
msgstr "espeak TTS-Engine"

#: ../docstring of robot_hat.TTS.PICO2WAVE:1
msgid "pico2wave TTS engine"
msgstr "pico2wave TTS-Engine"

#: of robot_hat.tts.TTS.__init__:1
msgid "Initialize TTS class."
msgstr "TTS-Klasse initialisieren."

#: of robot_hat.tts.TTS.__init__ robot_hat.tts.TTS.espeak
#: robot_hat.tts.TTS.espeak_params robot_hat.tts.TTS.lang
#: robot_hat.tts.TTS.pico2wave robot_hat.tts.TTS.say
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.tts.TTS.__init__:3
msgid "TTS engine, TTS.PICO2WAVE or TTS.ESPEAK"
msgstr "TTS-Engine, TTS.PICO2WAVE oder TTS.ESPEAK"

#: of robot_hat.tts.TTS.say:1
msgid "Say words."
msgstr "Worte aussprechen."

#: of robot_hat.tts.TTS.espeak:3 robot_hat.tts.TTS.pico2wave:3
#: robot_hat.tts.TTS.say:3
msgid "words to say."
msgstr "Zu sprechende Worte."

#: of robot_hat.tts.TTS.espeak:1
msgid "Say words with espeak."
msgstr "Worte mit espeak sprechen."

#: of robot_hat.tts.TTS.pico2wave:1
msgid "Say words with pico2wave."
msgstr "Worte mit pico2wave sprechen."

#: of robot_hat.tts.TTS.lang:1
msgid "Set/get language. leave empty to get current language."
msgstr ""
"Sprache einstellen/abfragen. Leer lassen, um die aktuelle Sprache zu "
"erhalten."

#: of robot_hat.tts.TTS.lang:3
msgid "language."
msgstr "Sprache."

#: of robot_hat.tts.TTS.supported_lang:1
msgid "Get supported language."
msgstr "Unterstützte Sprache abrufen."

#: of robot_hat.tts.TTS.supported_lang
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.tts.TTS.supported_lang:3
msgid "supported language."
msgstr "Unterstützte Sprache."

#: of robot_hat.tts.TTS.supported_lang
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.tts.TTS.espeak_params:1
msgid "Set espeak parameters."
msgstr "Espeak-Parameter einstellen."

#: of robot_hat.tts.TTS.espeak_params:3
msgid "amplitude."
msgstr "Amplitude."

#: of robot_hat.tts.TTS.espeak_params:5
msgid "speed."
msgstr "Geschwindigkeit."

#: of robot_hat.tts.TTS.espeak_params:7
msgid "gap."
msgstr "Lücke."

#: of robot_hat.tts.TTS.espeak_params:9
msgid "pitch."
msgstr "Tonhöhe."


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/hardware_introduction.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../hardware_introduction.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../hardware_introduction.rst:5
msgid "**Why Join?**"
msgstr "**Warum beitreten?**"

#: ../hardware_introduction.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../hardware_introduction.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../hardware_introduction.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../hardware_introduction.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../hardware_introduction.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../hardware_introduction.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../hardware_introduction.rst:16
msgid "Hardware Introduction"
msgstr "Hardware-Einführung"

#: ../hardware_introduction.rst:19
msgid "Pinout"
msgstr "Pinbelegung"

#: ../hardware_introduction.rst:27
msgid "**Power Port**"
msgstr "**Power Port**"

#: ../hardware_introduction.rst:26
msgid "6.0V-8.4V XH2.54 3pin power input."
msgstr "6.0V-8.4V XH2.54 3-Pin-Stromeingang."

#: ../hardware_introduction.rst:27
msgid "Powering the Raspberry Pi and Robot HAT at the same time."
msgstr "Gleichzeitige Stromversorgung des Raspberry Pi und des Robot HAT."

#: ../hardware_introduction.rst:30
msgid "**Power Switch**"
msgstr "**Power Switch**"

#: ../hardware_introduction.rst:30
msgid "Turn on/off the power of the robot HAT."
msgstr "Den Strom des Robot HAT ein-/ausschalten."

#: ../hardware_introduction.rst:36
msgid "**Type-C USB Port**"
msgstr "**Type-C USB Port**"

#: ../hardware_introduction.rst:33
msgid "Insert the Type-C cable to charge the battery."
msgstr "Stecken Sie das Type-C-Kabel ein, um die Batterie zu laden."

#: ../hardware_introduction.rst:34
msgid "At the same time, the charging indicator lights up in red color."
msgstr "Gleichzeitig leuchtet die Ladeanzeige in roter Farbe."

#: ../hardware_introduction.rst:35
msgid "When the battery is fully charged, the charging indicator turns off."
msgstr "Wenn die Batterie vollständig geladen ist, erlischt die Ladeanzeige."

#: ../hardware_introduction.rst:36
msgid ""
"If the USB cable is still plugged in about 4 hours after it is fully "
"charged, the charging indicator will blink to prompt."
msgstr ""
"Wenn das USB-Kabel etwa 4 Stunden nach vollständiger Aufladung noch "
"eingesteckt ist, blinkt die Ladeanzeige zur Erinnerung."

#: ../hardware_introduction.rst:41
msgid "**Digital Pin**"
msgstr "**Digital Pin**"

#: ../hardware_introduction.rst:39
msgid "4-channel digital pins, D0-D3."
msgstr "4-Kanal digitale Pins, D0-D3."

#: ../hardware_introduction.rst:40
msgid "Pin: :ref:`pin_digital`."
msgstr "Pin: :ref:`pin_digital`."

#: ../hardware_introduction.rst:41
msgid "API: :ref:`class_pin`."
msgstr "API: :ref:`class_pin`."

#: ../hardware_introduction.rst:46
msgid "**ADC Pin**"
msgstr "**ADC Pin**"

#: ../hardware_introduction.rst:44
msgid "4-channel ADC pins, A0-A3."
msgstr "4-Kanal ADC-Pins, A0-A3."

#: ../hardware_introduction.rst:45
msgid "Pin: :ref:`pin_adc`."
msgstr "Pin: :ref:`pin_adc`."

#: ../hardware_introduction.rst:46
msgid "API: :ref:`class_adc`."
msgstr "API: :ref:`class_adc`."

#: ../hardware_introduction.rst:51
msgid "**PWM Pin**"
msgstr "**PWM Pin**"

#: ../hardware_introduction.rst:49
msgid "12-channel PWM pins, P0-P11."
msgstr "12-Kanal PWM-Pins, P0-P11."

#: ../hardware_introduction.rst:50
msgid "Pin: :ref:`pin_pwm`."
msgstr "Pin: :ref:`pin_pwm`."

#: ../hardware_introduction.rst:51
msgid "API: :ref:`class_pwm`."
msgstr "API: :ref:`class_pwm`."

#: ../hardware_introduction.rst:56
msgid "**Left/Right Motor Port**"
msgstr "**Left/Right Motor Port**"

#: ../hardware_introduction.rst:54
msgid "2-channel XH2.54 motor ports."
msgstr "2-Kanal XH2.54 Motoranschlüsse."

#: ../hardware_introduction.rst:55
msgid "Pin: :ref:`pin_motor`."
msgstr "Pin: :ref:`pin_motor`."

#: ../hardware_introduction.rst:56
msgid ""
"API: :ref:`class_motor`, ``1`` for left motor port, ``2`` for right motor"
" port."
msgstr ""
"API: :ref:`class_motor`, ``1`` für den linken Motoranschluss, ``2`` für "
"den rechten Motoranschluss."

#: ../hardware_introduction.rst:63
msgid "**I2C Pin and I2C Port**"
msgstr "**I2C Pin und I2C Port**"

#: ../hardware_introduction.rst:59
msgid "**I2C Pin**: P2.54 4-pin interface."
msgstr "**I2C Pin**: P2.54 4-Pin-Schnittstelle."

#: ../hardware_introduction.rst:60
msgid ""
"**I2C Port**: SH1.0 4-pin interface, which is compatible with QWIIC and "
"STEMMA QT."
msgstr ""
"**I2C Port**: SH1.0 4-Pin-Schnittstelle, kompatibel mit QWIIC und STEMMA "
"QT."

#: ../hardware_introduction.rst:61
msgid ""
"These I2C interfaces are connected to the Raspberry Pi's I2C interface "
"via GPIO2 (SDA) and GPIO3 (SCL)."
msgstr ""
"Diese I2C-Schnittstellen sind über GPIO2 (SDA) und GPIO3 (SCL) mit der "
"I2C-Schnittstelle des Raspberry Pi verbunden."

#: ../hardware_introduction.rst:62
msgid "Pin: :ref:`pin_i2c`."
msgstr "Pin: :ref:`pin_i2c`."

#: ../hardware_introduction.rst:63
msgid "API: :ref:`class_i2c`."
msgstr "API: :ref:`class_i2c`."

#: ../hardware_introduction.rst:67
msgid "**SPI Pin**"
msgstr "**SPI Pin**"

#: ../hardware_introduction.rst:66
msgid "P2.54 7-pin SPI interface."
msgstr "P2.54 7-Pin SPI-Schnittstelle."

#: ../hardware_introduction.rst:67
msgid "Pin: :ref:`pin_spi`."
msgstr "Pin: :ref:`pin_spi`."

#: ../hardware_introduction.rst:71
msgid "**UART Pin**"
msgstr "**UART Pin**"

#: ../hardware_introduction.rst:70
msgid "P2.54 4-pin interface."
msgstr "P2.54 4-Pin-Schnittstelle."

#: ../hardware_introduction.rst:71
msgid "Pin: :ref:`pin_uart`."
msgstr "Pin: :ref:`pin_uart`."

#: ../hardware_introduction.rst:77
msgid "**RST Button**"
msgstr "**RST Button**"

#: ../hardware_introduction.rst:74
msgid ""
"The RST button, when using Ezblock, serves as a button to restart the "
"Ezblock program."
msgstr ""
"Der RST-Knopf dient bei Verwendung von Ezblock als Knopf zum Neustarten "
"des Ezblock-Programms."

#: ../hardware_introduction.rst:75
msgid ""
"If not using Ezblock, the RST button does not have a predefined function "
"and can be fully customized according to your needs."
msgstr ""
"Wenn Ezblock nicht verwendet wird, hat der RST-Knopf keine vordefinierte "
"Funktion und kann ganz nach Ihren Bedürfnissen angepasst werden."

#: ../hardware_introduction.rst:76 ../hardware_introduction.rst:82
msgid "Pin: :ref:`pin_button`."
msgstr "Pin: :ref:`pin_button`."

#: ../hardware_introduction.rst:77
msgid "API: :ref:`class_pin`"
msgstr "API: :ref:`class_pin`"

#: ../hardware_introduction.rst:82
msgid "**USR Button**"
msgstr "**USR Button**"

#: ../hardware_introduction.rst:80
msgid ""
"The functions of USR Button can be set by your programming. (Pressing "
"down leads to a input “0”; releasing produces a input “1”. )"
msgstr ""
"Die Funktionen des USR-Knopfs können durch Ihre Programmierung festgelegt"
" werden. (Herunterdrücken führt zu einem Eingang „0“; Loslassen erzeugt "
"einen Eingang „1“.)"

#: ../hardware_introduction.rst:81
msgid "API: :ref:`class_pin`, you can use ``Pin(\"SW\")`` to define it."
msgstr ""
"API: :ref:`class_pin`, Sie können ``Pin(\"SW\")`` verwenden, um ihn zu "
"definieren."

#: ../hardware_introduction.rst:88
msgid "**Battery Indicator**"
msgstr "**Battery Indicator**"

#: ../hardware_introduction.rst:85
msgid "Two LEDs light up when the voltage is higher than 7.6V."
msgstr "Zwei LEDs leuchten auf, wenn die Spannung höher als 7,6V ist."

#: ../hardware_introduction.rst:86
msgid "One LED lights up in the 7.15V to 7.6V range."
msgstr "Eine LED leuchtet im Bereich von 7,15V bis 7,6V."

#: ../hardware_introduction.rst:87
msgid "Below 7.15V, both LEDs turn off."
msgstr "Unter 7,15V schalten sich beide LEDs aus."

#: ../hardware_introduction.rst:88
msgid ":ref:`battery_indicator`."
msgstr ":ref:`battery_indicator`."

#: ../hardware_introduction.rst:96
msgid "**Speaker and Speaker Port**"
msgstr "**Speaker and Speaker Port**"

#: ../hardware_introduction.rst:91
msgid "**Speaker**: This is a 2030 audio chamber speaker."
msgstr "**Speaker**: Dies ist ein 2030 Audio-Kammerlautsprecher."

#: ../hardware_introduction.rst:92
msgid ""
"**Speaker Port**: The Robot HAT is equipped with onboard I2S audio "
"output, along with a 2030 audio chamber speaker, providing a mono sound "
"output."
msgstr ""
"**Speaker Port**: Der Robot HAT ist mit einem Onboard-I2S-Audioausgang "
"ausgestattet, zusammen mit einem 2030 Audio-Kammerlautsprecher, der einen"
" Mono-Soundausgang bietet."

#: ../hardware_introduction.rst:93
msgid "Pin: :ref:`pin_speaker`."
msgstr "Pin: :ref:`pin_speaker`."

#: ../hardware_introduction.rst:94
msgid "API: :ref:`class_music`"
msgstr "API: :ref:`class_music`"

#: ../hardware_introduction.rst:99
msgid "Pin Mapping"
msgstr "Pin-Belegung"

#: ../hardware_introduction.rst:101
msgid "Raspberry Pi IO"
msgstr "Raspberry Pi IO"

#: ../hardware_introduction.rst:105 ../hardware_introduction.rst:108
#: ../hardware_introduction.rst:203 ../hardware_introduction.rst:276
#: ../hardware_introduction.rst:315
msgid "Robot Hat V4"
msgstr "Robot Hat V4"

#: ../hardware_introduction.rst:106 ../hardware_introduction.rst:107
#: ../hardware_introduction.rst:204 ../hardware_introduction.rst:277
#: ../hardware_introduction.rst:316 ../hardware_introduction.rst:337
msgid "Raspberry Pi"
msgstr "Raspberry Pi"

#: ../hardware_introduction.rst:109 ../hardware_introduction.rst:141
#: ../hardware_introduction.rst:160 ../hardware_introduction.rst:161
#: ../hardware_introduction.rst:164 ../hardware_introduction.rst:184
msgid "NC"
msgstr "NC"

#: ../hardware_introduction.rst:110 ../hardware_introduction.rst:142
#: ../hardware_introduction.rst:288
msgid "3V3"
msgstr "3V3"

#: ../hardware_introduction.rst:111 ../hardware_introduction.rst:112
#: ../hardware_introduction.rst:115 ../hardware_introduction.rst:116
msgid "5V"
msgstr "5V"

#: ../hardware_introduction.rst:113 ../hardware_introduction.rst:114
msgid "SDA"
msgstr "SDA"

#: ../hardware_introduction.rst:117 ../hardware_introduction.rst:118
msgid "SCL"
msgstr "SCL"

#: ../hardware_introduction.rst:119 ../hardware_introduction.rst:120
#: ../hardware_introduction.rst:125 ../hardware_introduction.rst:126
#: ../hardware_introduction.rst:135 ../hardware_introduction.rst:136
#: ../hardware_introduction.rst:147 ../hardware_introduction.rst:148
#: ../hardware_introduction.rst:157 ../hardware_introduction.rst:158
#: ../hardware_introduction.rst:167 ../hardware_introduction.rst:168
#: ../hardware_introduction.rst:175 ../hardware_introduction.rst:176
#: ../hardware_introduction.rst:185 ../hardware_introduction.rst:186
#: ../hardware_introduction.rst:290
msgid "GND"
msgstr "GND"

#: ../hardware_introduction.rst:121 ../hardware_introduction.rst:209
msgid "D1"
msgstr "D1"

#: ../hardware_introduction.rst:122 ../hardware_introduction.rst:210
msgid "GPIO4"
msgstr "GPIO4"

#: ../hardware_introduction.rst:123 ../hardware_introduction.rst:124
msgid "TXD"
msgstr "TXD"

#: ../hardware_introduction.rst:127 ../hardware_introduction.rst:128
msgid "RXD"
msgstr "RXD"

#: ../hardware_introduction.rst:129 ../hardware_introduction.rst:206
msgid "D0"
msgstr "D0"

#: ../hardware_introduction.rst:130 ../hardware_introduction.rst:207
msgid "GPIO17"
msgstr "GPIO17"

#: ../hardware_introduction.rst:131 ../hardware_introduction.rst:341
msgid "GPIO18"
msgstr "GPIO18"

#: ../hardware_introduction.rst:132
msgid "I2S BCLK"
msgstr "I2S BCLK"

#: ../hardware_introduction.rst:133 ../hardware_introduction.rst:212
msgid "D2"
msgstr "D2"

#: ../hardware_introduction.rst:134 ../hardware_introduction.rst:213
msgid "GPIO27"
msgstr "GPIO27"

#: ../hardware_introduction.rst:137 ../hardware_introduction.rst:215
msgid "D3"
msgstr "D3"

#: ../hardware_introduction.rst:138 ../hardware_introduction.rst:216
msgid "GPIO22"
msgstr "GPIO22"

#: ../hardware_introduction.rst:139 ../hardware_introduction.rst:360
msgid "GPIO23"
msgstr "GPIO23"

#: ../hardware_introduction.rst:140
msgid "MOTOR 1 DIR"
msgstr "MOTOR 1 DIR"

#: ../hardware_introduction.rst:143 ../hardware_introduction.rst:364
msgid "GPIO24"
msgstr "GPIO24"

#: ../hardware_introduction.rst:144
msgid "MOTOR 2 DIR"
msgstr "MOTOR 2 RICHTUNG"

#: ../hardware_introduction.rst:145
msgid "SPI MOSI"
msgstr "SPI MOSI"

#: ../hardware_introduction.rst:146
msgid "MOSI"
msgstr "MOSI"

#: ../hardware_introduction.rst:149
msgid "SPI MISO"
msgstr "SPI MISO"

#: ../hardware_introduction.rst:150
msgid "MISO"
msgstr "MISO"

#: ../hardware_introduction.rst:151 ../hardware_introduction.rst:320
msgid "GPIO25"
msgstr "GPIO25"

#: ../hardware_introduction.rst:152
msgid "USR BUTTON"
msgstr "USR-TASTE"

#: ../hardware_introduction.rst:153
msgid "SPI SCLK"
msgstr "SPI SCLK"

#: ../hardware_introduction.rst:154
msgid "SCLK"
msgstr "SCLK"

#: ../hardware_introduction.rst:155
msgid "CE0"
msgstr "CE0"

#: ../hardware_introduction.rst:156
msgid "SPI CE0"
msgstr "SPI CE0"

#: ../hardware_introduction.rst:159
msgid "CE1"
msgstr "CE1"

#: ../hardware_introduction.rst:162
msgid "ID_SD"
msgstr "ID_SD"

#: ../hardware_introduction.rst:163
msgid "ID_SC"
msgstr "ID_SC"

#: ../hardware_introduction.rst:165
msgid "MCU Reset"
msgstr "MCU-Reset"

#: ../hardware_introduction.rst:166
msgid "GPIO5"
msgstr "GPIO5"

#: ../hardware_introduction.rst:169
msgid "(SPI)BSY"
msgstr "(SPI)BSY"

#: ../hardware_introduction.rst:170 ../hardware_introduction.rst:279
msgid "GPIO6"
msgstr "GPIO6"

#: ../hardware_introduction.rst:171
msgid "GPIO12"
msgstr "GPIO12"

#: ../hardware_introduction.rst:172
msgid "Board Identifier 2"
msgstr "Platinen-Identifikator 2"

#: ../hardware_introduction.rst:173
msgid "Board Identifier 1"
msgstr "Platinen-Identifikator 1"

#: ../hardware_introduction.rst:174
msgid "GPIO13"
msgstr "GPIO13"

#: ../hardware_introduction.rst:177
msgid "I2S LRCLK"
msgstr "I2S LRCLK"

#: ../hardware_introduction.rst:178 ../hardware_introduction.rst:339
msgid "GPIO19"
msgstr "GPIO19"

#: ../hardware_introduction.rst:179 ../hardware_introduction.rst:322
msgid "GPIO16"
msgstr "GPIO16"

#: ../hardware_introduction.rst:180
msgid "RST BUTTON"
msgstr "RST-TASTE"

#: ../hardware_introduction.rst:181
msgid "USER LED"
msgstr "BENUTZER-LED"

#: ../hardware_introduction.rst:182 ../hardware_introduction.rst:318
msgid "GPIO26"
msgstr "GPIO26"

#: ../hardware_introduction.rst:183
msgid "GPIO20"
msgstr "GPIO20"

#: ../hardware_introduction.rst:187 ../hardware_introduction.rst:343
msgid "GPIO21"
msgstr "GPIO21"

#: ../hardware_introduction.rst:188
msgid "I2S SDATA"
msgstr "I2S SDATA"

#: ../hardware_introduction.rst:193 ../hardware_introduction.rst:199
msgid "Digital IO"
msgstr "Digitaler IO"

#: ../hardware_introduction.rst:195
msgid "Robot HAT has 4 sets of P2.54 3Pin digital pins."
msgstr "Der Robot HAT hat 4 Sätze von P2.54 3Pin digitalen Pins."

#: ../hardware_introduction.rst:221
msgid "ADC"
msgstr "ADC"

#: ../hardware_introduction.rst:225
msgid ""
"The Robot HAT features four sets of 3Pin ADC (Analog to Digital "
"Converter) pins, each spaced 2.54mm apart. These pins operate at a 3.3V "
"power supply. The ADC function, offering 12-bit precision, is facilitated"
" by an onboard microcontroller. Detailed instructions for reading ADC "
"values are provided in the :ref:`on_board_mcu` section."
msgstr ""
"Der Robot HAT verfügt über vier Sätze von 3Pin ADC (Analog-Digital-"
"Wandler) Pins, jeweils im Abstand von 2,54 mm. Diese Pins arbeiten mit "
"einer 3,3V Stromversorgung. Die ADC-Funktion, die eine 12-Bit-Präzision "
"bietet, wird durch einen Mikrocontroller an Bord erleichtert. "
"Detaillierte Anweisungen zum Lesen der ADC-Werte finden Sie im Abschnitt "
":ref:`on_board_mcu`."

#: ../hardware_introduction.rst:229
msgid ""
"Also, ADC channel A4 is connected to the battery through a voltage "
"divider using resistors, which will be used to measure the battery "
"voltage to estimate the approximate battery charge."
msgstr ""
"Außerdem ist der ADC-Kanal A4 über einen Spannungsteiler mit Widerständen"
" mit der Batterie verbunden, der zur Messung der Batteriespannung zur "
"Schätzung der ungefähren Batterieladung verwendet wird."

#: ../hardware_introduction.rst:232
msgid "The voltage divider ratio is 20K/10K, so:"
msgstr "Das Verhältnis des Spannungsteilers beträgt 20K/10K, also:"

#: ../hardware_introduction.rst:234
msgid "A4 voltage (Va4) = value_A4 / 4095.0 * 3.3"
msgstr "A4-Spannung (Va4) = Wert_A4 / 4095.0 * 3.3"

#: ../hardware_introduction.rst:235
msgid "Battery voltage (Vbat) = Va4*3"
msgstr "Batteriespannung (Vbat) = Va4*3"

#: ../hardware_introduction.rst:236
msgid "Battery voltage (Vbat) = value_A4 / 4095.0 * 3.3 * 3"
msgstr "Batteriespannung (Vbat) = Wert_A4 / 4095.0 * 3.3 * 3"

#: ../hardware_introduction.rst:241
msgid "PWM"
msgstr "PWM"

#: ../hardware_introduction.rst:245
msgid ""
"Robot HAT has 4 sets of 3Pin PWM pins, each spaced 2.54mm apart, and the "
"power supply is 5V. The method of using the PWM is described in detail in"
" :ref:`on_board_mcu`."
msgstr ""
"Der Robot HAT hat 4 Sätze von 3Pin PWM-Pins, jeweils im Abstand von 2,54 "
"mm, und die Stromversorgung beträgt 5V. Die Methode zur Verwendung des "
"PWM wird im Detail in :ref:`on_board_mcu` beschrieben."

#: ../hardware_introduction.rst:248
msgid "PWM13 & 14 channels are used for motor drive."
msgstr "Die Kanäle PWM13 & 14 werden für den Motorantrieb verwendet."

#: ../hardware_introduction.rst:253
msgid "I2C"
msgstr "I2C"

#: ../hardware_introduction.rst:257
msgid ""
"The Robot HAT has two I2C interfaces. One is the P2.54 4-pin interface, "
"and the other is the SH1.0 4-pin interface, which is compatible with "
"QWIIC and STEMMA QT. These I2C interfaces are connected to the Raspberry "
"Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL). The board also "
"features an :ref:`on_board_mcu`, and the two signal lines have 10K pull-"
"up resistors."
msgstr ""
"Der Robot HAT verfügt über zwei I2C-Schnittstellen. Eine davon ist die "
"P2.54 4-Pin-Schnittstelle und die andere ist die SH1.0 4-Pin-"
"Schnittstelle, die mit QWIIC und STEMMA QT kompatibel ist. Diese I2C-"
"Schnittstellen sind über GPIO2 (SDA) und GPIO3 (SCL) mit der I2C-"
"Schnittstelle des Raspberry Pi verbunden. Das Board verfügt auch über "
"einen :ref:`on_board_mcu`, und die beiden Signalleitungen haben 10K Pull-"
"up-Widerstände."

#: ../hardware_introduction.rst:264 ../hardware_introduction.rst:272
msgid "SPI"
msgstr "SPI"

#: ../hardware_introduction.rst:268
msgid ""
"The SPI interface of the Robot HAT is a 7-pin P2.54 interface. It "
"connects to the SPI interface of the Raspberry Pi and includes an "
"additional I/O pin that can be used for purposes such as interrupts or "
"resets."
msgstr ""
"Die SPI-Schnittstelle des Robot HAT ist eine 7-Pin P2.54-Schnittstelle. "
"Sie verbindet sich mit der SPI-Schnittstelle des Raspberry Pi und umfasst"
" einen zusätzlichen I/O-Pin, der für Zwecke wie Interrupts oder Resets "
"verwendet werden kann."

#: ../hardware_introduction.rst:278
msgid "BSY"
msgstr "BSY"

#: ../hardware_introduction.rst:280
msgid "CS"
msgstr "CS"

#: ../hardware_introduction.rst:281
msgid "CE0(GPIO8)"
msgstr "CE0(GPIO8)"

#: ../hardware_introduction.rst:282
msgid "SCK"
msgstr "SCK"

#: ../hardware_introduction.rst:283
msgid "SCLK(GPIO11)"
msgstr "SCLK(GPIO11)"

#: ../hardware_introduction.rst:284
msgid "MI"
msgstr "MI"

#: ../hardware_introduction.rst:285
msgid "MISO(GPIO9)"
msgstr "MISO(GPIO9)"

#: ../hardware_introduction.rst:286
msgid "MO"
msgstr "MO"

#: ../hardware_introduction.rst:287
msgid "MOSI(GPIO10)"
msgstr "MOSI(GPIO10)"

#: ../hardware_introduction.rst:289
msgid "3.3V Power"
msgstr "3.3V Strom"

#: ../hardware_introduction.rst:291
msgid "Ground"
msgstr "Masse"

#: ../hardware_introduction.rst:296
msgid "UART"
msgstr "UART"

#: ../hardware_introduction.rst:300
msgid ""
"The UART interface of the Robot HAT is a 4-pin P2.54 interface. It "
"connects to the Raspberry Pi's GPIO14 (TXD) and GPIO15 (RXD) pins."
msgstr ""
"Die UART-Schnittstelle des Robot HAT ist eine 4-Pin P2.54-Schnittstelle. "
"Sie verbindet sich mit den GPIO14 (TXD) und GPIO15 (RXD) Pins des "
"Raspberry Pi."

#: ../hardware_introduction.rst:305
msgid "Buttons"
msgstr "Tasten"

#: ../hardware_introduction.rst:307
msgid ""
"The Robot HAT comes with 1 LED and 2 buttons, all directly connected to "
"the Raspberry Pi's GPIO pins. The RST button, when using Ezblock, serves "
"as a button to restart the Ezblock program. If not using Ezblock, the RST"
" button does not have a predefined function and can be fully customized "
"according to your needs."
msgstr ""
"Der Robot HAT wird mit 1 LED und 2 Tasten geliefert, die alle direkt mit "
"den GPIO-Pins des Raspberry Pi verbunden sind. Die RST-Taste dient bei "
"der Verwendung von Ezblock als Taste zum Neustart des Ezblock-Programms. "
"Wird Ezblock nicht verwendet, hat die RST-Taste keine vordefinierte "
"Funktion und kann ganz nach Ihren Bedürfnissen angepasst werden."

#: ../hardware_introduction.rst:311
msgid "LED & Button"
msgstr "LED & Taste"

#: ../hardware_introduction.rst:317
msgid "LED"
msgstr "LED"

#: ../hardware_introduction.rst:319
msgid "USR"
msgstr "USR"

#: ../hardware_introduction.rst:321
msgid "RST"
msgstr "RST"

#: ../hardware_introduction.rst:327
msgid "Speaker and Speaker Port"
msgstr "Lautsprecher und Lautsprecheranschluss"

#: ../hardware_introduction.rst:329
msgid ""
"The Robot HAT is equipped with onboard I2S audio output, along with a "
"2030 audio chamber speaker, providing a mono sound output."
msgstr ""
"Der Robot HAT ist mit einem Onboard-I2S-Audioausgang sowie einem 2030 "
"Audio-Kammerlautsprecher ausgestattet, der einen Monoklang-Ausgang "
"bietet."

#: ../hardware_introduction.rst:332 ../hardware_introduction.rst:336
msgid "I2S"
msgstr "I2S"

#: ../hardware_introduction.rst:338
msgid "LRCLK"
msgstr "LRCLK"

#: ../hardware_introduction.rst:340
msgid "BCLK"
msgstr "BCLK"

#: ../hardware_introduction.rst:342
msgid "SDATA"
msgstr "SDATA"

#: ../hardware_introduction.rst:348
msgid "Motor Port"
msgstr "Motoranschluss"

#: ../hardware_introduction.rst:350
msgid ""
"The motor driver of the Robot HAT supports 2 channels and can be "
"controlled using 2 digital signals for direction and 2 PWM signals for "
"speed control."
msgstr ""
"Der Motortreiber des Robot HAT unterstützt 2 Kanäle und kann mit 2 "
"digitalen Signalen zur Richtungssteuerung und 2 PWM-Signalen zur "
"Geschwindigkeitsregelung gesteuert werden."

#: ../hardware_introduction.rst:353
msgid "Motor Driver"
msgstr "Motortreiber"

#: ../hardware_introduction.rst:357
msgid "Motor"
msgstr "Motor"

#: ../hardware_introduction.rst:358
msgid "IO"
msgstr "IO"

#: ../hardware_introduction.rst:359
msgid "Motor1 Dir"
msgstr "Motor1 Richtung"

#: ../hardware_introduction.rst:361
msgid "Motor1 Power"
msgstr "Motor1 Leistung"

#: ../hardware_introduction.rst:362
msgid "PWM13"
msgstr "PWM13"

#: ../hardware_introduction.rst:363
msgid "Motor2 Dir"
msgstr "Motor2 Richtung"

#: ../hardware_introduction.rst:365
msgid "Motor2 Power"
msgstr "Motor2 Leistung"

#: ../hardware_introduction.rst:366
msgid "PWM12"
msgstr "PWM12"

#: ../hardware_introduction.rst:371
msgid "Battery Level Indicator"
msgstr "Batteriestandsanzeige"

#: ../hardware_introduction.rst:373
msgid ""
"The battery level indicator on the Robot HAT monitors the battery voltage"
" using a voltage divider method and serves as a reference for estimating "
"the battery level. The relationship between the LED and voltage is as "
"follows:"
msgstr ""
"Die Batteriestandsanzeige auf dem Robot HAT überwacht die "
"Batteriespannung mithilfe einer Spannungsteiler-Methode und dient als "
"Referenz zur Schätzung des Batteriestands. Die Beziehung zwischen der LED"
" und der Spannung ist wie folgt:"

#: ../hardware_introduction.rst:376
msgid "Battery Level"
msgstr "Batteriestand"

#: ../hardware_introduction.rst:380
msgid "LED Battery"
msgstr "LED Batterie"

#: ../hardware_introduction.rst:381
msgid "Total Voltage"
msgstr "Gesamtspannung"

#: ../hardware_introduction.rst:382
msgid "2 LEDs on"
msgstr "2 LEDs an"

#: ../hardware_introduction.rst:383
msgid "Greater than 7.6V"
msgstr "Mehr als 7,6V"

#: ../hardware_introduction.rst:384
msgid "1 LED on"
msgstr "1 LED an"

#: ../hardware_introduction.rst:385
msgid "Greater than 7.15V"
msgstr "Mehr als 7,15V"

#: ../hardware_introduction.rst:386
msgid "Both LEDs off"
msgstr "Beide LEDs aus"

#: ../hardware_introduction.rst:387
msgid "Less than 7.15V"
msgstr "Weniger als 7,15V"

#: ../hardware_introduction.rst:389
msgid ""
"When any one of the batteries reaches or exceeds 4.1V while the others "
"are below that threshold, the charging current of that specific battery "
"will be reduced."
msgstr ""
"Wenn eine der Batterien 4,1V erreicht oder überschreitet, während die "
"anderen darunter liegen, wird der Ladestrom dieser spezifischen Batterie "
"reduziert."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/community_tutorials.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../community_tutorials.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../community_tutorials.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../community_tutorials.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../community_tutorials.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../community_tutorials.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../community_tutorials.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../community_tutorials.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../community_tutorials.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../community_tutorials.rst:16
msgid "Community Tutorials"
msgstr "Community-Tutorials"

#: ../community_tutorials.rst:18
msgid "|link_peppe8o|"
msgstr "|link_peppe8o|"

#: ../community_tutorials.rst:20
msgid ""
"This document summarizes the SunFounder Raspberry Pi Robot HAT, covering "
"its purpose, compatibility, specifications, and testing:"
msgstr ""
"Dieses Dokument fasst den SunFounder Raspberry Pi Robot HAT zusammen und "
"beschreibt seinen Zweck, Kompatibilität, Spezifikationen und "
"Testverfahren:"

#: ../community_tutorials.rst:22
msgid ""
"**Introduction**: Explains the Robot HAT's role in simplifying control "
"for Raspberry Pi-based DIY robot projects."
msgstr ""
"**Einführung**: Erklärt die Rolle des Robot HAT bei der Vereinfachung der"
" Steuerung für DIY-Roboterprojekte basierend auf dem Raspberry Pi."

#: ../community_tutorials.rst:23
msgid ""
"**Specifications**: Details the technical specs, including power input, "
"battery details, ports, and motor driver features."
msgstr ""
"**Spezifikationen**: Beschreibt die technischen Daten, einschließlich "
"Stromzufuhr, Batterieangaben, Anschlüsse und Merkmale des Motortreibers."

#: ../community_tutorials.rst:24
msgid ""
"**Ports Overview**: Describes various ports like Power, Digital, Analog, "
"PWM, I2C, SPI, UART, and Motor Ports."
msgstr ""
"**Übersicht der Anschlüsse**: Beschreibt verschiedene Anschlüsse wie "
"Strom, Digital, Analog, PWM, I2C, SPI, UART und Motoranschlüsse."

#: ../community_tutorials.rst:25
msgid ""
"**Additional Components**: Highlights extra components like buttons, LED,"
" and speaker, with Raspberry Pi PIN mappings."
msgstr ""
"**Zusätzliche Komponenten**: Hebt zusätzliche Komponenten wie Tasten, LED"
" und Lautsprecher hervor, mit Zuordnung zu den Raspberry Pi-Pins."

#: ../community_tutorials.rst:26
msgid ""
"**Setup and Testing**: Guides on mounting the Robot HAT, necessary "
"components, and testing procedures for features like LED and servo "
"motors."
msgstr ""
"**Einrichtung und Testen**: Anleitungen zum Montieren des Robot HAT, zu "
"den notwendigen Komponenten und zu Testverfahren für Funktionen wie LED "
"und Servomotoren."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_robot.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_robot.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_robot.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_robot.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_robot.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_robot.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_robot.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_robot.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_robot.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_robot.rst:18
msgid "class ``Robot``"
msgstr "Klasse ``Robot``"

#: ../api_robot.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_robot.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.robot.Robot:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.robot.Robot:1
msgid "Robot class"
msgstr "Robot-Klasse"

#: of robot_hat.robot.Robot:3
msgid "This class is for makeing a servo robot with Robot HAT"
msgstr "Diese Klasse dient zum Erstellen eines Servo-Roboters mit dem Robot HAT"

#: of robot_hat.robot.Robot:5
msgid ""
"There are servo initialization, all servo move in specific speed. servo "
"offset and stuff. make it easy to make a robot. All Pi-series robot from "
"SunFounder use this class. Check them out for more details."
msgstr ""
"Es gibt eine Servo-Initialisierung, alle Servos bewegen sich mit einer "
"spezifischen Geschwindigkeit. Servo-Offset und so weiter. Es erleichtert "
"das Erstellen eines Roboters. Alle Pi-Serie Roboter von SunFounder "
"verwenden diese Klasse. Schauen Sie sich diese für weitere Details an."

#: of robot_hat.robot.Robot:8
msgid "PiSloth: https://github.com/sunfounder/pisloth"
msgstr "PiSloth: https://github.com/sunfounder/pisloth"

#: of robot_hat.robot.Robot:10
msgid "PiArm: https://github.com/sunfounder/piarm"
msgstr "PiArm: https://github.com/sunfounder/piarm"

#: of robot_hat.robot.Robot:12
msgid "PiCrawler: https://github.com/sunfounder/picrawler"
msgstr "PiCrawler: https://github.com/sunfounder/picrawler"

#: ../docstring of robot_hat.Robot.move_list:1
msgid "Preset actions"
msgstr "Voreingestellte Aktionen"

#: ../docstring of robot_hat.Robot.max_dps:1
msgid "Servo max Degree Per Second"
msgstr "Servo maximale Grad pro Sekunde"

#: of robot_hat.robot.Robot.__init__:1
msgid "Initialize the robot class"
msgstr "Die Robot-Klasse initialisieren"

#: of robot_hat.robot.Robot.__init__ robot_hat.robot.Robot.do_action
#: robot_hat.robot.Robot.new_list robot_hat.robot.Robot.servo_move
#: robot_hat.robot.Robot.servo_write_all robot_hat.robot.Robot.servo_write_raw
#: robot_hat.robot.Robot.set_offset
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.robot.Robot.__init__:3
msgid "list of pin number[0-11]"
msgstr "Liste der Pin-Nummern [0-11]"

#: of robot_hat.robot.Robot.__init__:5
msgid "config file path"
msgstr "Pfad zur Konfigurationsdatei"

#: of robot_hat.robot.Robot.__init__:7
msgid "robot name"
msgstr "Robotername"

#: of robot_hat.robot.Robot.__init__:9
msgid "list of initial angles"
msgstr "Liste der Anfangswinkel"

#: of robot_hat.robot.Robot.__init__:11
msgid ""
"list of initialization order(Servos will init one by one in case of "
"sudden huge current, pulling down the power supply voltage. default order"
" is the pin list. in some cases, you need different order, use this "
"parameter to set it.)"
msgstr ""
"Liste der Initialisierungsreihenfolge (Servos werden einzeln "
"initialisiert, falls es zu einem plötzlichen starken Strom kommt, der die"
" Spannung der Stromversorgung herunterzieht. Die Standardreihenfolge ist "
"die Pin-Liste. In einigen Fällen benötigen Sie eine andere Reihenfolge, "
"verwenden Sie diesen Parameter, um sie festzulegen.)"

#: of robot_hat.robot.Robot.new_list:1
msgid "Create a list of servo angles with default value"
msgstr "Erstellen Sie eine Liste von Servowinkeln mit Standardwert"

#: of robot_hat.robot.Robot.new_list:3
msgid "default value of servo angles"
msgstr "Standardwert der Servowinkel"

#: of robot_hat.robot.Robot.new_list
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.robot.Robot.new_list:5 robot_hat.robot.Robot.servo_move:3
#: robot_hat.robot.Robot.servo_write_all:3
#: robot_hat.robot.Robot.servo_write_raw:3 robot_hat.robot.Robot.set_offset:3
msgid "list of servo angles"
msgstr "Liste der Servowinkel"

#: of robot_hat.robot.Robot.new_list
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.robot.Robot.servo_write_raw:1
msgid "Set servo angles to specific raw angles"
msgstr "Servowinkel auf spezifische Rohwinkel einstellen"

#: of robot_hat.robot.Robot.servo_write_all:1
msgid "Set servo angles to specific angles with original angle and offset"
msgstr ""
"Servowinkel mit ursprünglichem Winkel und Offset auf spezifische Winkel "
"einstellen"

#: of robot_hat.robot.Robot.servo_move:1
msgid "Move servo to specific angles with speed or bpm"
msgstr "Servo mit Geschwindigkeit oder bpm auf spezifische Winkel bewegen"

#: of robot_hat.robot.Robot.servo_move:5
msgid "speed of servo move"
msgstr "Geschwindigkeit der Servobewegung"

#: of robot_hat.robot.Robot.servo_move:7
msgid "beats per minute"
msgstr "Schläge pro Minute"

#: of robot_hat.robot.Robot.do_action:1
msgid "Do prefix action with motion_name and step and speed"
msgstr ""
"Führen Sie eine vordefinierte Aktion mit Bewegungsname, Schritt und "
"Geschwindigkeit aus"

#: of robot_hat.robot.Robot.do_action:3
msgid "motion"
msgstr "Bewegung"

#: of robot_hat.robot.Robot.do_action:5
msgid "step of motion"
msgstr "Schritt der Bewegung"

#: of robot_hat.robot.Robot.do_action:7
msgid "speed of motion"
msgstr "Geschwindigkeit der Bewegung"

#: of robot_hat.robot.Robot.set_offset:1
msgid "Set offset of servo angles"
msgstr "Offset der Servowinkel einstellen"

#: of robot_hat.robot.Robot.calibration:1
msgid "Move all servos to home position"
msgstr "Alle Servos in die Ausgangsposition bewegen"

#: of robot_hat.robot.Robot.reset:1
msgid "Reset servo to original position"
msgstr "Servo in die ursprüngliche Position zurücksetzen"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_control_motor_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_control_motor_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_control_motor_servo.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_control_motor_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_control_motor_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_control_motor_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_control_motor_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_control_motor_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_control_motor_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_control_motor_servo.rst:16
msgid "Control Servos and Motors"
msgstr "Servos und Motoren steuern"

#: ../project_control_motor_servo.rst:18
msgid "In this project, we have 12 servos and two motors working simultaneously."
msgstr ""
"In diesem Projekt haben wir 12 Servos und zwei Motoren, die gleichzeitig "
"arbeiten."

#: ../project_control_motor_servo.rst:24
msgid ""
"However, it's important to note that if your servos and motors have a "
"high starting current, it's recommended to start them separately to avoid"
" insufficient power supply current, which could lead to the Raspberry Pi "
"restarting."
msgstr ""
"Es ist jedoch wichtig zu beachten, dass, wenn Ihre Servos und Motoren "
"einen hohen Anlaufstrom haben, es empfohlen wird, sie separat zu starten,"
" um unzureichenden Stromversorgungsstrom zu vermeiden, der zum Neustart "
"des Raspberry Pi führen könnte."

#: ../project_control_motor_servo.rst:26
msgid "**Code**"
msgstr "**Code**"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_say_something.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_say_something.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_say_something.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_say_something.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_say_something.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_say_something.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_say_something.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_say_something.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_say_something.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_say_something.rst:16
msgid "Say Something"
msgstr "Sage etwas"

#: ../project_say_something.rst:19
msgid ""
"In this section, you'll learn how to convert text into speech and have "
"Robot HAT speak it aloud."
msgstr ""
"In diesem Abschnitt lernen Sie, wie Sie Text in Sprache umwandeln und vom"
" Robot HAT laut aussprechen lassen."

#: ../project_say_something.rst:21
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_say_something.rst:23
msgid ""
"We retrieve text from the command line to enable Robot HAT to articulate "
"it. To achieve this, save the following code as a ``.py`` file, such as "
"``tts.py``."
msgstr ""
"Wir holen Text von der Kommandozeile ab, damit der Robot HAT ihn "
"artikulieren kann. Um dies zu erreichen, speichern Sie den folgenden Code"
" als eine ``.py``-Datei, wie zum Beispiel ``tts.py``."

#: ../project_say_something.rst:46
msgid ""
"To make Robot HAT vocalize a specific sentence, you can use the following"
" command: ``sudo python3 tts.py \"any text\"`` - simply replace ``\"any "
"text\"`` with the desired phrase."
msgstr ""
"Um den Robot HAT eine bestimmte Satz aussprechen zu lassen, können Sie "
"den folgenden Befehl verwenden: ``sudo python3 tts.py „any text“`` - "
"ersetzen Sie einfach ``„any text“`` durch den gewünschten Satz."

#: ../project_say_something.rst:50
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/install_i2s_for_speaker.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../install_i2s_for_speaker.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../install_i2s_for_speaker.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../install_i2s_for_speaker.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../install_i2s_for_speaker.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../install_i2s_for_speaker.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../install_i2s_for_speaker.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../install_i2s_for_speaker.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../install_i2s_for_speaker.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../install_i2s_for_speaker.rst:18
msgid "Install ``i2samp.sh`` for the Speaker"
msgstr "Installieren Sie ``i2samp.sh`` für den Lautsprecher"

#: ../install_i2s_for_speaker.rst:20
msgid ""
"The ``i2samp.sh`` is a sophisticated Bash script specifically designed "
"for setting up and configuring an I2S (Inter-IC Sound) amplifier on "
"Raspberry Pi and similar devices. Licensed under the MIT license, it "
"ensures compatibility with a range of hardware and operating systems, "
"conducting thorough checks before proceeding with any installation or "
"configuration."
msgstr ""
"Das ``i2samp.sh`` ist ein ausgefeiltes Bash-Skript, das speziell für die "
"Einrichtung und Konfiguration eines I2S (Inter-IC Sound) Verstärkers auf "
"Raspberry Pi und ähnlichen Geräten entwickelt wurde. Unter der MIT-Lizenz"
" lizenziert, gewährleistet es die Kompatibilität mit einer Vielzahl von "
"Hardware- und Betriebssystemen und führt gründliche Überprüfungen durch, "
"bevor mit irgendeiner Installation oder Konfiguration fortgefahren wird."

#: ../install_i2s_for_speaker.rst:22
msgid ""
"If you want your speaker to work properly, you definitely need to install"
" this script."
msgstr ""
"Wenn Sie möchten, dass Ihr Lautsprecher ordnungsgemäß funktioniert, "
"müssen Sie dieses Skript definitiv installieren."

#: ../install_i2s_for_speaker.rst:24
msgid "The steps are as follows:"
msgstr "Die Schritte sind wie folgt:"

#: ../install_i2s_for_speaker.rst:31
msgid "Type ``y`` and press ``enter`` to continue running the script."
msgstr ""
"Geben Sie ``y`` ein und drücken Sie ``Enter``, um das Skript weiter "
"auszuführen."

#: ../install_i2s_for_speaker.rst:35
msgid "Type ``y`` and press ``enter`` to run ``/dev/zero`` in the background."
msgstr ""
"Geben Sie ``y`` ein und drücken Sie ``Enter``, um ``/dev/zero`` im "
"Hintergrund auszuführen."

#: ../install_i2s_for_speaker.rst:39
msgid "Type ``y`` and press ``enter`` to restart the Raspberry pi."
msgstr ""
"Geben Sie ``y`` ein und drücken Sie ``Enter``, um den Raspberry Pi neu zu"
" starten."

#: ../install_i2s_for_speaker.rst:45
msgid ""
"If there is no sound after restarting, you may need to run the "
"``i2samp.sh`` script several times."
msgstr ""
"Wenn nach dem Neustart kein Ton vorhanden ist, müssen Sie möglicherweise "
"das ``i2samp.sh``-Skript mehrmals ausführen."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_plant_monitor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_plant_monitor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_plant_monitor.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_plant_monitor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_plant_monitor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_plant_monitor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_plant_monitor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_plant_monitor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_plant_monitor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_plant_monitor.rst:16
msgid "Plant Monitor"
msgstr "Pflanzenmonitor"

#: ../project_plant_monitor.rst:18
msgid ""
"In this project, we detect both light intensity and soil moisture levels,"
" and display them on the I2C LCD1602 . When you feel that the soil "
"moisture is insufficient, you can press the button module to water the "
"potted plant."
msgstr ""
"In diesem Projekt erfassen wir sowohl die Lichtintensität als auch den "
"Feuchtigkeitsgehalt des Bodens und zeigen diese auf dem I2C LCD1602 an. "
"Wenn Sie denken, dass die Bodenfeuchtigkeit unzureichend ist, können Sie "
"das Tastenmodul drücken, um die Topfpflanze zu bewässern."

#: ../project_plant_monitor.rst:22
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_plant_monitor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr ""
"In diesem Projekt wird ein I2C LCD1602 verwendet, daher ist es notwendig,"
" die relevanten Bibliotheken herunterzuladen, um es zum Laufen zu "
"bringen."

#: ../project_plant_monitor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "Installieren Sie ``smbus2`` für I2C."

#: ../project_plant_monitor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``plant_monitor.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``plant_monitor.ty``."

#: ../project_plant_monitor.rst:120
msgid "Use the command ``sudo python3 plant_monitor.ty`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 plant_monitor.ty``, um diesen "
"Code auszuführen."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_modules.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_modules.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_modules.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_modules.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_modules.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_modules.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_modules.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_modules.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_modules.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_modules.rst:16
msgid "module ``modules``"
msgstr "Modul ``modules``"

#: ../api_modules.rst:21
msgid "class ``Ultrasonic``"
msgstr "Klasse ``Ultrasonic``"

#: ../api_modules.rst:23 ../api_modules.rst:46 ../api_modules.rst:80
#: ../api_modules.rst:110 ../api_modules.rst:220
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_modules.rst:37 ../api_modules.rst:70 ../api_modules.rst:101
#: ../api_modules.rst:210 ../api_modules.rst:246
msgid "**API**"
msgstr "**API**"

#: ../api_modules.rst:44
msgid "class ``ADXL345``"
msgstr "Klasse ``ADXL345``"

#: of robot_hat.modules.ADXL345:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "Basisklasse: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.modules.ADXL345:1
msgid "ADXL345 modules"
msgstr "ADXL345-Module"

#: ../docstring of robot_hat.ADXL345.X:1
msgid "X"
msgstr "X"

#: ../docstring of robot_hat.ADXL345.Y:1
msgid "Y"
msgstr "Y"

#: ../docstring of robot_hat.ADXL345.Z:1
msgid "Z"
msgstr "Z"

#: of robot_hat.modules.ADXL345.__init__:1
msgid "Initialize ADXL345"
msgstr "ADXL345 initialisieren"

#: of robot_hat.modules.ADXL345.__init__ robot_hat.modules.ADXL345.read
#: robot_hat.modules.Buzzer.__init__ robot_hat.modules.Buzzer.freq
#: robot_hat.modules.Buzzer.play robot_hat.modules.Grayscale_Module.__init__
#: robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
#: robot_hat.modules.RGB_LED.__init__ robot_hat.modules.RGB_LED.color
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.modules.ADXL345.__init__:3
msgid "address of the ADXL345"
msgstr "Adresse des ADXL345"

#: of robot_hat.modules.ADXL345.read:1
msgid "Read an axis from ADXL345"
msgstr "Eine Achse des ADXL345 lesen"

#: of robot_hat.modules.ADXL345.read:3
msgid ""
"read value(g) of an axis, ADXL345.X, ADXL345.Y or ADXL345.Z, None for all"
" axis"
msgstr ""
"Wert (g) einer Achse lesen, ADXL345.X, ADXL345.Y oder ADXL345.Z, None für"
" alle Achsen"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.modules.ADXL345.read:5
msgid "value of the axis, or list of all axis"
msgstr "Wert der Achse oder Liste aller Achsen"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Return type"
msgstr "Rückgabetyp"

#: ../api_modules.rst:78
msgid "class ``RGB_LED``"
msgstr "Klasse ``RGB_LED``"

#: of robot_hat.modules.RGB_LED:1
msgid "Simple 3 pin RGB LED"
msgstr "Einfache 3-Pin-RGB-LED"

#: ../docstring of robot_hat.RGB_LED.ANODE:1
msgid "Common anode"
msgstr "Gemeinsame Anode"

#: ../docstring of robot_hat.RGB_LED.CATHODE:1
msgid "Common cathode"
msgstr "Gemeinsame Kathode"

#: of robot_hat.modules.RGB_LED.__init__:1
msgid "Initialize RGB LED"
msgstr "RGB-LED initialisieren"

#: of robot_hat.modules.RGB_LED.__init__:3
msgid "PWM object for red"
msgstr "PWM-Objekt für Rot"

#: of robot_hat.modules.RGB_LED.__init__:5
msgid "PWM object for green"
msgstr "PWM-Objekt für Grün"

#: of robot_hat.modules.RGB_LED.__init__:7
msgid "PWM object for blue"
msgstr "PWM-Objekt für Blau"

#: of robot_hat.modules.RGB_LED.__init__:9
msgid "RGB_LED.ANODE or RGB_LED.CATHODE, default is ANODE"
msgstr "RGB_LED.ANODE oder RGB_LED.CATHODE, Standard ist ANODE"

#: of robot_hat.modules.Buzzer.freq robot_hat.modules.Buzzer.play
#: robot_hat.modules.RGB_LED.__init__
msgid "Raises"
msgstr "Wirft"

#: of robot_hat.modules.RGB_LED.__init__:11
msgid "if common is not ANODE or CATHODE"
msgstr "wenn gemeinsam weder ANODE noch CATHODE ist"

#: of robot_hat.modules.RGB_LED.__init__:12
msgid "if r_pin, g_pin or b_pin is not PWM object"
msgstr "wenn r_pin, g_pin oder b_pin kein PWM-Objekt ist"

#: of robot_hat.modules.RGB_LED.color:1
msgid "Write color to RGB LED"
msgstr "Farbe an RGB-LED schreiben"

#: of robot_hat.modules.RGB_LED.color:3
msgid ""
"color to write, hex string starts with \"#\", 24-bit int or tuple of "
"(red, green, blue)"
msgstr ""
"Zu schreibende Farbe, Hex-String beginnend mit \"#\", 24-Bit-Integer oder"
" Tupel aus (Rot, Grün, Blau)"

#: ../api_modules.rst:108
msgid "class ``Buzzer``"
msgstr "Klasse ``Buzzer``"

#: ../api_modules.rst:112
msgid "Imports and initialize"
msgstr "Importieren und Initialisieren"

#: ../api_modules.rst:133
msgid "Active buzzer beeping"
msgstr "Aktives Summer-Signal"

#: ../api_modules.rst:143
msgid "Passive buzzer Simple usage"
msgstr "Passiver Summer Einfache Nutzung"

#: ../api_modules.rst:155
msgid "Passive buzzer Manual control"
msgstr "Passiver Summer Manuelle Steuerung"

#: ../api_modules.rst:171
msgid "Play a song! Baby shark!"
msgstr "Ein Lied spielen! Babyhai!"

#: of robot_hat.modules.Buzzer.__init__:1
msgid "Initialize buzzer"
msgstr "Summer initialisieren"

#: of robot_hat.modules.Buzzer.__init__:3
msgid "PWM object for passive buzzer or Pin object for active buzzer"
msgstr "PWM-Objekt für passiven Summer oder Pin-Objekt für aktiven Summer"

#: of robot_hat.modules.Buzzer.on:1
msgid "Turn on buzzer"
msgstr "Summer einschalten"

#: of robot_hat.modules.Buzzer.off:1
msgid "Turn off buzzer"
msgstr "Summer ausschalten"

#: of robot_hat.modules.Buzzer.freq:1
msgid "Set frequency of passive buzzer"
msgstr "Frequenz des passiven Summers einstellen"

#: of robot_hat.modules.Buzzer.freq:3
msgid "frequency of buzzer, use Music.NOTES to get frequency of note"
msgstr ""
"Frequenz des Summers, verwenden Sie Music.NOTES, um die Frequenz der Note"
" zu erhalten"

#: of robot_hat.modules.Buzzer.freq:5 robot_hat.modules.Buzzer.play:7
msgid "if set to active buzzer"
msgstr "wenn auf aktiven Summer eingestellt"

#: of robot_hat.modules.Buzzer.play:1
msgid "Play freq"
msgstr "Frequenz abspielen"

#: of robot_hat.modules.Buzzer.play:3
msgid "freq to play, you can use Music.note() to get frequency of note"
msgstr ""
"abzuspielende Frequenz, Sie können Music.note() verwenden, um die "
"Frequenz der Note zu erhalten"

#: of robot_hat.modules.Buzzer.play:5
msgid "duration of each note, in seconds, None means play continuously"
msgstr "Dauer jeder Note in Sekunden, None bedeutet kontinuierliches Abspielen"

#: ../api_modules.rst:218
msgid "class ``Grayscale_Module``"
msgstr "Klasse ``Grayscale_Module``"

#: of robot_hat.modules.Grayscale_Module:1
msgid "3 channel Grayscale Module"
msgstr "3-Kanal-Graustufen-Modul"

#: ../docstring of robot_hat.Grayscale_Module.LEFT:1
msgid "Left Channel"
msgstr "Linker Kanal"

#: ../docstring of robot_hat.Grayscale_Module.MIDDLE:1
msgid "Middle Channel"
msgstr "Mittlerer Kanal"

#: ../docstring of robot_hat.Grayscale_Module.RIGHT:1
msgid "Right Channel"
msgstr "Rechter Kanal"

#: of robot_hat.modules.Grayscale_Module.__init__:1
msgid "Initialize Grayscale Module"
msgstr "Graustufen-Modul initialisieren"

#: of robot_hat.modules.Grayscale_Module.__init__:3
msgid "ADC object or int for channel 0"
msgstr "ADC-Objekt oder Integer für Kanal 0"

#: of robot_hat.modules.Grayscale_Module.__init__:5
msgid "ADC object or int for channel 1"
msgstr "ADC-Objekt oder Integer für Kanal 1"

#: of robot_hat.modules.Grayscale_Module.__init__:7
msgid "ADC object or int for channel 2"
msgstr "ADC-Objekt oder Integer für Kanal 2"

#: of robot_hat.modules.Grayscale_Module.__init__:9
msgid "reference voltage"
msgstr "Referenzspannung"

#: of robot_hat.modules.Grayscale_Module.reference:1
msgid "Get Set reference value"
msgstr "Referenzwert abrufen oder einstellen"

#: of robot_hat.modules.Grayscale_Module.reference:3
msgid "reference value, None to get reference value"
msgstr "Referenzwert, None um den Referenzwert abzurufen"

#: of robot_hat.modules.Grayscale_Module.reference:5
msgid "reference value"
msgstr "Referenzwert"

#: of robot_hat.modules.Grayscale_Module.read_status:1
msgid "Read line status"
msgstr "Zeilenstatus lesen"

#: of robot_hat.modules.Grayscale_Module.read_status:3
msgid "list of grayscale datas, if None, read from sensor"
msgstr "Liste der Graustufendaten, falls None, vom Sensor lesen"

#: of robot_hat.modules.Grayscale_Module.read_status:5
msgid "list of line status, 0 for white, 1 for black"
msgstr "Liste des Zeilenstatus, 0 für Weiß, 1 für Schwarz"

#: of robot_hat.modules.Grayscale_Module.read:1
msgid "read a channel or all datas"
msgstr "einen Kanal oder alle Daten lesen"

#: of robot_hat.modules.Grayscale_Module.read:3
msgid ""
"channel to read, leave empty to read all. 0, 1, 2 or "
"Grayscale_Module.LEFT, Grayscale_Module.CENTER, Grayscale_Module.RIGHT"
msgstr ""
"zu lesender Kanal, leer lassen, um alle zu lesen. 0, 1, 2 oder "
"Grayscale_Module.LEFT, Grayscale_Module.MIDDLE, Grayscale_Module.RIGHT"

#: of robot_hat.modules.Grayscale_Module.read:5
msgid "list of grayscale data"
msgstr "Liste der Graustufendaten"





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_pin.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pin.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_pin.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_pin.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_pin.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_pin.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_pin.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_pin.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_pin.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_pin.rst:18
msgid "class ``Pin``"
msgstr "Klasse ``Pin``"

#: ../api_pin.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_pin.rst:52
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pin.Pin:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.pin.Pin:1
msgid "Pin manipulation class"
msgstr "Pin-Manipulationsklasse"

#: ../docstring of robot_hat.Pin.OUT:1
msgid "Pin mode output"
msgstr "Pin-Modus Ausgang"

#: ../docstring of robot_hat.Pin.IN:1
msgid "Pin mode input"
msgstr "Pin-Modus Eingang"

#: ../docstring of robot_hat.Pin.PULL_UP:1
msgid "Pin internal pull up"
msgstr "Pin interner Pull-Up"

#: ../docstring of robot_hat.Pin.PULL_DOWN:1
msgid "Pin internal pull down"
msgstr "Pin interner Pull-Down"

#: ../docstring of robot_hat.Pin.PULL_NONE:1
msgid "Pin internal pull none"
msgstr "Pin ohne internen Pull"

#: ../docstring of robot_hat.Pin.IRQ_FALLING:1 robot_hat.Pin.IRQ_RISING:1
msgid "Pin interrupt falling"
msgstr "Pin-Interrupt abfallend"

#: ../docstring of robot_hat.Pin.IRQ_RISING_FALLING:1
msgid "Pin interrupt both rising and falling"
msgstr "Pin-Interrupt steigend und fallend"

#: of robot_hat.pin.Pin.__init__:1
msgid "Initialize a pin"
msgstr "Einen Pin initialisieren"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.__init__
#: robot_hat.pin.Pin.dict robot_hat.pin.Pin.irq robot_hat.pin.Pin.setup
#: robot_hat.pin.Pin.value
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.pin.Pin.__init__:3
msgid "pin number of Raspberry Pi"
msgstr "Pin-Nummer des Raspberry Pi"

#: of robot_hat.pin.Pin.__init__:5 robot_hat.pin.Pin.setup:3
msgid "pin mode(IN/OUT)"
msgstr "Pin-Modus (IN/OUT)"

#: of robot_hat.pin.Pin.__init__:7 robot_hat.pin.Pin.setup:5
msgid "pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)"
msgstr "Pin Pull-Up/Down (PUD_UP/PUD_DOWN/PUD_NONE)"

#: of robot_hat.pin.Pin.setup:1
msgid "Setup the pin"
msgstr "Den Pin einrichten"

#: of robot_hat.pin.Pin.dict:1
msgid "Set/get the pin dictionary"
msgstr "Das Pin-Wörterbuch setzen/erhalten"

#: of robot_hat.pin.Pin.dict:3
msgid "pin dictionary, leave it empty to get the dictionary"
msgstr "Pin-Wörterbuch, lassen Sie es leer, um das Wörterbuch zu erhalten"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.pin.Pin.dict:5
msgid "pin dictionary"
msgstr "Pin-Wörterbuch"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.pin.Pin.__call__:1 robot_hat.pin.Pin.value:1
msgid "Set/get the pin value"
msgstr "Pin-Wert setzen/erhalten"

#: of robot_hat.pin.Pin.__call__:3 robot_hat.pin.Pin.value:3
msgid "pin value, leave it empty to get the value(0/1)"
msgstr "Pin-Wert, lassen Sie es leer, um den Wert zu erhalten (0/1)"

#: of robot_hat.pin.Pin.__call__:5 robot_hat.pin.Pin.value:5
msgid "pin value(0/1)"
msgstr "Pin-Wert (0/1)"

#: of robot_hat.pin.Pin.on:1
msgid "Set pin on(high)"
msgstr "Pin einschalten (high)"

#: of robot_hat.pin.Pin.high:3 robot_hat.pin.Pin.on:3
msgid "pin value(1)"
msgstr "Pin-Wert (1)"

#: of robot_hat.pin.Pin.off:1
msgid "Set pin off(low)"
msgstr "Pin ausschalten (low)"

#: of robot_hat.pin.Pin.low:3 robot_hat.pin.Pin.off:3
msgid "pin value(0)"
msgstr "Pin-Wert (0)"

#: of robot_hat.pin.Pin.high:1
msgid "Set pin high(1)"
msgstr "Pin auf high setzen (1)"

#: of robot_hat.pin.Pin.low:1
msgid "Set pin low(0)"
msgstr "Pin auf low setzen (0)"

#: of robot_hat.pin.Pin.irq:1
msgid "Set the pin interrupt"
msgstr "Pin-Interrupt setzen"

#: of robot_hat.pin.Pin.irq:3
msgid "interrupt handler callback function"
msgstr "Callback-Funktion des Interrupt-Handlers"

#: of robot_hat.pin.Pin.irq:5
msgid "interrupt trigger(RISING, FALLING, RISING_FALLING)"
msgstr "Interrupt-Auslöser (RISING, FALLING, RISING_FALLING)"

#: of robot_hat.pin.Pin.irq:7
msgid "interrupt bouncetime in miliseconds"
msgstr "Interrupt-Entprellzeit in Millisekunden"

#: of robot_hat.pin.Pin.name:1
msgid "Get the pin name"
msgstr "Pin-Name abrufen"

#: of robot_hat.pin.Pin.name:3
msgid "pin name"
msgstr "Pin-Name"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/faq.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../faq.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../faq.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../faq.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../faq.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../faq.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../faq.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../faq.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../faq.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../faq.rst:16
msgid "FAQ"
msgstr "FAQ"

#: ../faq.rst:19
msgid ""
"Q1: Can the battery be connected while providing power to the Raspberry "
"Pi at the same time?"
msgstr ""
"F1: Kann die Batterie angeschlossen werden, während gleichzeitig Strom an"
" den Raspberry Pi geliefert wird?"

#: ../faq.rst:20
msgid ""
"A: Yes, the Robot HAT has a built-in anti-backflow diode that prevents "
"the Raspberry Pi's power from flowing back into the Robot HAT."
msgstr ""
"A: Ja, der Robot HAT hat eine eingebaute Anti-Rückflussdiode, die "
"verhindert, dass die Stromversorgung des Raspberry Pi zurück in den Robot"
" HAT fließt."

#: ../faq.rst:23
msgid "Q2: Can the Robot HAT be used while charging?"
msgstr "F2: Kann der Robot HAT während des Ladens verwendet werden?"

#: ../faq.rst:24
msgid ""
"A: Yes, the Robot HAT can be used while charging. When charging, the "
"input power is boosted by the charging chip to charge the batteries, "
"while also providing power to the DC-DC step-down for external use. The "
"charging power is approximately 10W. If the external power consumption is"
" too high for an extended period, the batteries may supplement the power,"
" similar to how a mobile phone charges while in use. However, it is "
"important to be mindful of the battery's capacity to avoid draining it "
"completely during simultaneous charging and usage."
msgstr ""
"A: Ja, der Robot HAT kann während des Ladens verwendet werden. Beim Laden"
" wird die Eingangsleistung durch den Ladungschip verstärkt, um die "
"Batterien zu laden, während gleichzeitig Strom für die DC-DC-Herabsetzung"
" für den externen Gebrauch bereitgestellt wird. Die Ladeleistung beträgt "
"etwa 10W. Wenn der externe Stromverbrauch über einen längeren Zeitraum zu"
" hoch ist, können die Batterien die Stromversorgung ergänzen, ähnlich wie"
" ein Mobiltelefon beim Gebrauch aufgeladen wird. Es ist jedoch wichtig, "
"auf die Kapazität der Batterie zu achten, um ein vollständiges Entleeren "
"während des gleichzeitigen Ladens und Gebrauchs zu vermeiden."

#: ../faq.rst:29
msgid "Q3: Why is there no sound from the speaker?"
msgstr "F3: Warum kommt kein Ton aus dem Lautsprecher?"

#: ../faq.rst:31
msgid ""
"When your script is running but the speaker is not producing sound, there"
" could be several reasons:"
msgstr ""
"Wenn Ihr Skript läuft, aber der Lautsprecher keinen Ton erzeugt, könnte "
"es mehrere Gründe geben:"

#: ../faq.rst:33
msgid ""
"Check if the ``i2samp.sh`` script has been installed. For detailed "
"instructions, please refer to: :ref:`install_i2s`."
msgstr ""
"Überprüfen Sie, ob das Skript ``i2samp.sh`` installiert wurde. Für "
"detaillierte Anweisungen siehe: :ref:`install_i2s`."

#: ../faq.rst:34
msgid ""
"When running scripts related to speakers, it's necessary to add ``sudo`` "
"to obtain administrative privileges. For example, ``sudo python3 "
"tts.py``."
msgstr ""
"Beim Ausführen von Skripten, die mit Lautsprechern zusammenhängen, ist es"
" notwendig, ``sudo`` hinzuzufügen, um administrative Rechte zu erhalten. "
"Zum Beispiel ``sudo python3 tts.py``."

#: ../faq.rst:35
msgid ""
"Don't using Raspberry Pi's built-in programming tools, like Geany to run "
"Speaker-related scripts. These tools run with standard user privileges, "
"while hardware control, such as managing speakers, often requires higher "
"permissions."
msgstr ""
"Verwenden Sie keine integrierten Programmierwerkzeuge des Raspberry Pi, "
"wie Geany, um lautsprecherbezogene Skripte auszuführen. Diese Werkzeuge "
"laufen mit Standardbenutzerrechten, während die Hardwaresteuerung, wie "
"die Verwaltung von Lautsprechern, oft höhere Berechtigungen erfordert."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/projects.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../projects.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../projects.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../projects.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../projects.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../projects.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../projects.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../projects.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../projects.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../projects.rst:16
msgid "Some Projects"
msgstr "Einige Projekte"

#: ../projects.rst:18
msgid ""
"Here, you'll find a collection of fascinating projects, all implemented "
"using the Robot HAT. We provide you with detailed code, giving you the "
"opportunity to try these projects out for yourself."
msgstr ""
"Hier finden Sie eine Sammlung faszinierender Projekte, alle umgesetzt mit"
" dem Robot HAT. Wir stellen Ihnen detaillierten Code zur Verfügung, der "
"Ihnen die Möglichkeit bietet, diese Projekte selbst auszuprobieren."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_utils.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_utils.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_utils.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_utils.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_utils.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_utils.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_utils.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_utils.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_utils.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_utils.rst:16
msgid "module ``utils``"
msgstr "Modul ``utils``"

#: of robot_hat.utils.set_volume:1
msgid "Set volume"
msgstr "Lautstärke einstellen"

#: of robot_hat.utils.get_ip robot_hat.utils.is_installed
#: robot_hat.utils.mapping robot_hat.utils.run_command
#: robot_hat.utils.set_volume
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.utils.set_volume:3
msgid "volume(0~100)"
msgstr "Lautstärke(0~100)"

#: of robot_hat.utils.run_command:1
msgid "Run command and return status and output"
msgstr "Befehl ausführen und Status sowie Ausgabe zurückgeben"

#: of robot_hat.utils.run_command:3
msgid "command to run"
msgstr "auszuführender Befehl"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.utils.run_command:5
msgid "status, output"
msgstr "Status, Ausgabe"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.utils.is_installed:1
msgid "Check if command is installed"
msgstr "Überprüfen, ob Befehl installiert ist"

#: of robot_hat.utils.is_installed:3
msgid "command to check"
msgstr "zu überprüfender Befehl"

#: of robot_hat.utils.is_installed:5
msgid "True if installed"
msgstr "Wahr, wenn installiert"

#: of robot_hat.utils.mapping:1
msgid "Map value from one range to another range"
msgstr "Wert von einem Bereich in einen anderen Bereich abbilden"

#: of robot_hat.utils.mapping:3
msgid "value to map"
msgstr "abzubildender Wert"

#: of robot_hat.utils.mapping:5
msgid "input minimum"
msgstr "Eingangsminimum"

#: of robot_hat.utils.mapping:7
msgid "input maximum"
msgstr "Eingangsmaximum"

#: of robot_hat.utils.mapping:9
msgid "output minimum"
msgstr "Ausgangsminimum"

#: of robot_hat.utils.mapping:11
msgid "output maximum"
msgstr "Ausgangsmaximum"

#: of robot_hat.utils.mapping:13
msgid "mapped value"
msgstr "Abgebildeter Wert"

#: of robot_hat.utils.get_ip:1
msgid "Get IP address"
msgstr "IP-Adresse abrufen"

#: of robot_hat.utils.get_ip:3
msgid "interfaces to check"
msgstr "Zu überprüfende Schnittstellen"

#: of robot_hat.utils.get_ip:5
msgid "IP address or False if not found"
msgstr "IP-Adresse oder False, wenn nicht gefunden"

#: of robot_hat.utils.reset_mcu:1
msgid "Reset mcu on Robot Hat."
msgstr "MCU auf dem Robot Hat zurücksetzen."

#: of robot_hat.utils.reset_mcu:3
msgid ""
"This is helpful if the mcu somehow stuck in a I2C data transfer loop, and"
" Raspberry Pi getting IOError while Reading ADC, manipulating PWM, etc."
msgstr ""
"Dies ist hilfreich, wenn der MCU irgendwie in einer I2C-"
"Datenübertragungsschleife steckt und der Raspberry Pi einen IOError beim "
"Lesen des ADC, Manipulieren des PWM usw. erhält."

#: of robot_hat.utils.get_battery_voltage:1
msgid "Get battery voltage"
msgstr "Batteriespannung abrufen"

#: of robot_hat.utils.get_battery_voltage:3
msgid "battery voltage(V)"
msgstr "Batteriespannung (V)"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_pwm.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pwm.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_pwm.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_pwm.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_pwm.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_pwm.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_pwm.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_pwm.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_pwm.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_pwm.rst:18
msgid "class ``PWM``"
msgstr "Klasse ``PWM``"

#: ../api_pwm.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_pwm.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pwm.PWM:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "Basisklasse: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.pwm.PWM:1
msgid "Pulse width modulation (PWM)"
msgstr "Pulsweitenmodulation (PWM)"

#: ../docstring of robot_hat.PWM.REG_CHN:1
msgid "Channel register prefix"
msgstr "Kanalregister-Präfix"

#: ../docstring of robot_hat.PWM.REG_PSC:1
msgid "Prescaler register prefix"
msgstr "Vorteiler-Register-Präfix"

#: ../docstring of robot_hat.PWM.REG_ARR:1
msgid "Period registor prefix"
msgstr "Periodenregister-Präfix"

#: ../docstring of robot_hat.PWM.CLOCK:1
msgid "Clock frequency"
msgstr "Taktfrequenz"

#: of robot_hat.pwm.PWM.__init__:1
msgid "Initialize PWM"
msgstr "PWM initialisieren"

#: of robot_hat.pwm.PWM.__init__ robot_hat.pwm.PWM.freq
#: robot_hat.pwm.PWM.period robot_hat.pwm.PWM.prescaler
#: robot_hat.pwm.PWM.pulse_width robot_hat.pwm.PWM.pulse_width_percent
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.pwm.PWM.__init__:3
msgid "PWM channel number(0-13/P0-P13)"
msgstr "PWM-Kanalnummer (0-13/P0-P13)"

#: of robot_hat.pwm.PWM.freq:1
msgid "Set/get frequency, leave blank to get frequency"
msgstr "Frequenz setzen/abfragen, leer lassen, um die Frequenz zu erhalten"

#: of robot_hat.pwm.PWM.freq:3
msgid "frequency(0-65535)(Hz)"
msgstr "Frequenz (0-65535) (Hz)"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.pwm.PWM.freq:5
msgid "frequency"
msgstr "Frequenz"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.pwm.PWM.prescaler:1
msgid "Set/get prescaler, leave blank to get prescaler"
msgstr "Vorteiler setzen/abfragen, leer lassen, um den Vorteiler zu erhalten"

#: of robot_hat.pwm.PWM.prescaler:3
msgid "prescaler(0-65535)"
msgstr "Vorteiler (0-65535)"

#: of robot_hat.pwm.PWM.prescaler:5
msgid "prescaler"
msgstr "Vorteiler"

#: of robot_hat.pwm.PWM.period:1
msgid "Set/get period, leave blank to get period"
msgstr "Periode setzen/abfragen, leer lassen, um die Periode zu erhalten"

#: of robot_hat.pwm.PWM.period:3
msgid "period(0-65535)"
msgstr "Periode (0-65535)"

#: of robot_hat.pwm.PWM.period:5
msgid "period"
msgstr "Periode"

#: of robot_hat.pwm.PWM.pulse_width:1
msgid "Set/get pulse width, leave blank to get pulse width"
msgstr "Pulsbreite setzen/abfragen, leer lassen, um die Pulsbreite zu erhalten"

#: of robot_hat.pwm.PWM.pulse_width:3
msgid "pulse width(0-65535)"
msgstr "Pulsbreite (0-65535)"

#: of robot_hat.pwm.PWM.pulse_width:5
msgid "pulse width"
msgstr "Pulsbreite"

#: of robot_hat.pwm.PWM.pulse_width_percent:1
msgid "Set/get pulse width percentage, leave blank to get pulse width percentage"
msgstr ""
"Pulsbreitenprozentsatz setzen/abfragen, leer lassen, um den "
"Pulsbreitenprozentsatz zu erhalten"

#: of robot_hat.pwm.PWM.pulse_width_percent:3
msgid "pulse width percentage(0-100)"
msgstr "Pulsbreitenprozentsatz (0-100)"

#: of robot_hat.pwm.PWM.pulse_width_percent:5
msgid "pulse width percentage"
msgstr "Pulsbreitenprozentsatz"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_music.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_music.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_music.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_music.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_music.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_music.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_music.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_music.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_music.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_music.rst:18
msgid "class ``Music``"
msgstr "Klasse ``Music``"

#: ../api_music.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr ""
"Sie müssen ``sudo`` beim Ausführen dieses Skripts hinzufügen, falls der "
"Lautsprecher nicht funktioniert."

#: ../api_music.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_music.rst:24
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_music.rst:26
msgid "Initialize"
msgstr "Initialisieren"

#: ../api_music.rst:36
msgid "Play tones"
msgstr "Töne abspielen"

#: ../api_music.rst:144
msgid "Play sound"
msgstr "Ton abspielen"

#: ../api_music.rst:155
msgid "Play Music"
msgstr "Musik abspielen"

#: ../api_music.rst:176
msgid "**API**"
msgstr "**API**"

#: of robot_hat.music.Music:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.music.Music:1
msgid "Play music, sound affect and note control"
msgstr "Musik, Soundeffekte und Notenkontrolle abspielen"

#: ../docstring of robot_hat.Music.NOTE_BASE_FREQ:1
msgid "Base note frequency for calculation (A4)"
msgstr "Basisnotenfrequenz für die Berechnung (A4)"

#: ../docstring of robot_hat.Music.NOTE_BASE_INDEX:1
msgid "Base note index for calculation (A4) MIDI compatible"
msgstr "Basisnotenindex für die Berechnung (A4), MIDI-kompatibel"

#: ../docstring of robot_hat.Music.NOTES:1
msgid "Notes name, MIDI compatible"
msgstr "Notennamen, MIDI-kompatibel"

#: of robot_hat.music.Music.__init__:1
msgid "Initialize the basic class"
msgstr "Die Basisklasse initialisieren"

#: of robot_hat.music.Music.__init__ robot_hat.music.Music.beat
#: robot_hat.music.Music.get_tone_data robot_hat.music.Music.key_signature
#: robot_hat.music.Music.music_play robot_hat.music.Music.music_set_volume
#: robot_hat.music.Music.note robot_hat.music.Music.play_tone_for
#: robot_hat.music.Music.sound_length robot_hat.music.Music.sound_play
#: robot_hat.music.Music.sound_play_threading robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.music.Music.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "Debug-Level, 0(kritisch), 1(Fehler), 2(Warnung), 3(Info) oder 4(Debug)"

#: of robot_hat.music.Music.time_signature:1
msgid "Set/get time signature"
msgstr "Taktart einstellen/abrufen"

#: of robot_hat.music.Music.time_signature:3
msgid "top number of time signature"
msgstr "Oberzahl der Taktart"

#: of robot_hat.music.Music.time_signature:5
msgid "bottom number of time signature"
msgstr "Unterzahl der Taktart"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.music.Music.time_signature:7
msgid "time signature"
msgstr "Taktart"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.music.Music.key_signature:1
msgid "Set/get key signature"
msgstr "Tonart einstellen/abrufen"

#: of robot_hat.music.Music.key_signature:3
msgid ""
"key signature use KEY_XX_MAJOR or String \"#\", \"##\", or \"bbb\", "
"\"bbbb\""
msgstr "Tonart verwenden KEY_XX_MAJOR oder String \"#\", \"##\", \"bbb\", \"bbbb\""

#: of robot_hat.music.Music.key_signature:5
msgid "key signature"
msgstr "Tonart"

#: of robot_hat.music.Music.tempo:1
msgid "Set/get tempo beat per minute(bpm)"
msgstr "Tempo einstellen/abrufen (Schläge pro Minute, bpm)"

#: of robot_hat.music.Music.tempo:3 robot_hat.music.Music.tempo:6
msgid "tempo"
msgstr "Tempo"

#: of robot_hat.music.Music.tempo:5
msgid "note value(1, 1/2, Music.HALF_NOTE, etc)"
msgstr "Notenwert (1, 1/2, Music.HALF_NOTE usw.)"

#: of robot_hat.music.Music.beat:1
msgid "Calculate beat delay in seconds from tempo"
msgstr "Berechnen der Schlagverzögerung in Sekunden aus dem Tempo"

#: of robot_hat.music.Music.beat:3
msgid "beat index"
msgstr "Schlagindex"

#: of robot_hat.music.Music.beat:5
msgid "beat delay"
msgstr "Schlagverzögerung"

#: of robot_hat.music.Music.note:1
msgid "Get frequency of a note"
msgstr "Frequenz einer Note abrufen"

#: of robot_hat.music.Music.note:3
msgid "note name(See NOTES)"
msgstr "Notenname (siehe NOTES)"

#: of robot_hat.music.Music.note:5
msgid "if natural note"
msgstr "ob natürliche Note"

#: of robot_hat.music.Music.note:7
msgid "frequency of note"
msgstr "Frequenz der Note"

#: of robot_hat.music.Music.sound_play:1
msgid "Play sound effect file"
msgstr "Soundeffekt-Datei abspielen"

#: of robot_hat.music.Music.sound_length:3 robot_hat.music.Music.sound_play:3
#: robot_hat.music.Music.sound_play_threading:3
msgid "sound effect file name"
msgstr "Name der Soundeffekt-Datei"

#: of robot_hat.music.Music.sound_play_threading:1
msgid "Play sound effect in thread(in the background)"
msgstr "Soundeffekt im Hintergrund abspielen"

#: of robot_hat.music.Music.music_play:9
#: robot_hat.music.Music.sound_play_threading:5
msgid "volume 0-100, leave empty will not change volume"
msgstr "Lautstärke 0-100, leer lassen, um die Lautstärke nicht zu ändern"

#: of robot_hat.music.Music.music_play:1
msgid "Play music file"
msgstr "Musikdatei abspielen"

#: of robot_hat.music.Music.music_play:3
msgid "sound file name"
msgstr "Name der Sounddatei"

#: of robot_hat.music.Music.music_play:5
msgid "number of loops, 0:loop forever, 1:play once, 2:play twice, ..."
msgstr ""
"Anzahl der Wiederholungen, 0: endlos wiederholen, 1: einmal abspielen, 2:"
" zweimal abspielen, ..."

#: of robot_hat.music.Music.music_play:7
msgid "start time in seconds"
msgstr "Startzeit in Sekunden"

#: of robot_hat.music.Music.music_set_volume:1
msgid "Set music volume"
msgstr "Musiklautstärke einstellen"

#: of robot_hat.music.Music.music_set_volume:3
msgid "volume 0-100"
msgstr "Lautstärke 0-100"

#: of robot_hat.music.Music.music_stop:1
msgid "Stop music"
msgstr "Musik stoppen"

#: of robot_hat.music.Music.music_pause:1
msgid "Pause music"
msgstr "Musik pausieren"

#: of robot_hat.music.Music.music_resume:1
msgid "Resume music"
msgstr "Musik fortsetzen"

#: of robot_hat.music.Music.music_unpause:1
msgid "Unpause music(resume music)"
msgstr "Musikwiedergabe fortsetzen"

#: of robot_hat.music.Music.sound_length:1
msgid "Get sound effect length in seconds"
msgstr "Länge des Soundeffekts in Sekunden abrufen"

#: of robot_hat.music.Music.sound_length:5
msgid "length in seconds"
msgstr "Länge in Sekunden"

#: of robot_hat.music.Music.get_tone_data:1
msgid "Get tone data for playing"
msgstr "Ton-Daten zum Abspielen abrufen"

#: of robot_hat.music.Music.get_tone_data:3
msgid "frequency"
msgstr "Frequenz"

#: of robot_hat.music.Music.get_tone_data:5
#: robot_hat.music.Music.play_tone_for:5
msgid "duration in seconds"
msgstr "Dauer in Sekunden"

#: of robot_hat.music.Music.get_tone_data:7
msgid "tone data"
msgstr "Ton-Daten"

#: of robot_hat.music.Music.play_tone_for:1
msgid "Play tone for duration seconds"
msgstr "Ton für angegebene Dauer abspielen"

#: of robot_hat.music.Music.play_tone_for:3
msgid "frequency, you can use NOTES to get frequency"
msgstr "Frequenz, Sie können NOTES verwenden, um die Frequenz zu erhalten"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_adc.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_adc.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_adc.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_adc.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_adc.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_adc.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_adc.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_adc.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_adc.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_adc.rst:18
msgid "class ``ADC``"
msgstr "Klasse ``ADC``"

#: ../api_adc.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_adc.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.adc.ADC:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "Basisklasse: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.adc.ADC:1 robot_hat.adc.ADC.__init__:1
msgid "Analog to digital converter"
msgstr "Analog-Digital-Wandler"

#: of robot_hat.adc.ADC.__init__
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.adc.ADC.__init__:3
msgid "channel number (0-7/A0-A7)"
msgstr "Kanalnummer (0-7/A0-A7)"

#: of robot_hat.adc.ADC.read:1
msgid "Read the ADC value"
msgstr "ADC-Wert lesen"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Returns"
msgstr "Rückgabewert"

#: of robot_hat.adc.ADC.read:3
msgid "ADC value(0-4095)"
msgstr "ADC-Wert (0-4095)"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.adc.ADC.read_voltage:1
msgid "Read the ADC value and convert to voltage"
msgstr "ADC-Wert lesen und in Spannung umwandeln"

#: of robot_hat.adc.ADC.read_voltage:3
msgid "Voltage value(0-3.3(V))"
msgstr "Spannungswert (0-3.3(V))"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_basic_class.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_basic_class.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_basic_class.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_basic_class.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_basic_class.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_basic_class.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_basic_class.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_basic_class.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_basic_class.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_basic_class.rst:16
msgid "class ``_Basic_class``"
msgstr "Klasse ``_Basic_class``"

#: ../api_basic_class.rst:18
msgid ""
"``_Basic_class`` is a logger class for all class to log, so if you want "
"to see logs of a class, just add a debug argument to it."
msgstr ""
"``_Basic_class`` ist eine Logger-Klasse für alle Klassen zur "
"Protokollierung. Wenn Sie Protokolle einer Klasse sehen möchten, fügen "
"Sie einfach ein Debug-Argument hinzu."

#: ../api_basic_class.rst:21
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_basic_class.rst:36
msgid "**API**"
msgstr "**API**"

#: of robot_hat.basic._Basic_class:1
msgid "Basic Class for all classes"
msgstr "Grundklasse für alle Klassen"

#: of robot_hat.basic._Basic_class:3
msgid "with debug function"
msgstr "mit Debug-Funktion"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_LEVELS:1
#: robot_hat.basic._Basic_class.debug_level:1
msgid "Debug level"
msgstr "Debug-Level"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_NAMES:1
msgid "Debug level names"
msgstr "Namen der Debug-Levels"

#: of robot_hat.basic._Basic_class.__init__:1
msgid "Initialize the basic class"
msgstr "Initialisierung der Grundklasse"

#: of robot_hat.basic._Basic_class.__init__
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.basic._Basic_class.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "Debug-Level, 0(kritisch), 1(Fehler), 2(Warnung), 3(Info) oder 4(Debug)"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_diy_car.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_diy_car.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_diy_car.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_diy_car.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_diy_car.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_diy_car.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_diy_car.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_diy_car.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_diy_car.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_diy_car.rst:16
msgid "DIY Car"
msgstr "DIY-Auto"

#: ../project_diy_car.rst:18
msgid ""
"In addition to being suitable for simple experiments, the Robot HAT is "
"ideal for use as a central controller in robotics, such as for smart "
"cars."
msgstr ""
"Neben der Eignung für einfache Experimente ist der Robot HAT ideal als "
"zentraler Controller in der Robotik, wie zum Beispiel für intelligente "
"Autos, geeignet."

#: ../project_diy_car.rst:20
msgid "In this project, we built a simple line-following car."
msgstr "In diesem Projekt haben wir ein einfaches linienfolgendes Auto gebaut."

#: ../project_diy_car.rst:24
msgid "**Code**"
msgstr "**Code**"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/index.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../index.rst:43
msgid "About this HAT"
msgstr "Über dieses HAT"

#: ../index.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../index.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../index.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../index.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../index.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../index.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../index.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../index.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../index.rst:16
msgid "SunFounder Robot HAT"
msgstr "SunFounder Robot HAT"

#: ../index.rst:18
msgid "Thanks for choosing our Robot HAT."
msgstr "Danke, dass Sie sich für unser Robot HAT entschieden haben."

#: ../index.rst:21
msgid "This document is available in the following languages."
msgstr "Dieses Dokument ist in den folgenden Sprachen verfügbar."

#: ../index.rst:23
msgid "|link_german_tutorials|"
msgstr "|link_german_tutorials|"

#: ../index.rst:24
msgid "|link_jp_tutorials|"
msgstr "|link_jp_tutorials|"

#: ../index.rst:25
msgid "|link_en_tutorials|"
msgstr "|link_en_tutorials|"

#: ../index.rst:27
msgid ""
"Please click on the respective links to access the document in your "
"preferred language."
msgstr ""
"Bitte klicken Sie auf die jeweiligen Links, um das Dokument in Ihrer "
"bevorzugten Sprache aufzurufen."

#: ../index.rst:34
msgid ""
"Robot HAT is a multifunctional expansion board that allows Raspberry Pi "
"to be quickly turned into a robot. An MCU is on board to extend the PWM "
"output and ADC input for the Raspberry Pi, as well as a motor driver "
"chip, Bluetooth module, I2S audio module and mono speaker. As well as the"
" GPIOs that lead out of the Raspberry Pi itself."
msgstr ""
"Das Robot HAT ist eine multifunktionale Erweiterungsplatine, die es "
"ermöglicht, einen Raspberry Pi schnell in einen Roboter zu verwandeln. "
"Ein MCU an Bord erweitert den PWM-Ausgang und den ADC-Eingang für den "
"Raspberry Pi sowie einen Motorantriebschip, ein Bluetooth-Modul, ein I2S-"
"Audiomodul und einen Monolautsprecher, sowie die GPIOs, die aus dem "
"Raspberry Pi selbst herausführen."

#: ../index.rst:36
msgid ""
"It also comes with a Speaker, which can be used to play background music,"
" sound effects and implement TTS functions to make your project more "
"interesting."
msgstr ""
"Es verfügt auch über einen Lautsprecher, der zur Wiedergabe von "
"Hintergrundmusik, Soundeffekten und zur Implementierung von TTS-"
"Funktionen genutzt werden kann, um Ihr Projekt interessanter zu "
"gestalten."

#: ../index.rst:38
msgid ""
"Accepts 6.0V-8.4V XH2.54 3pin power input with 2 power indicators. The "
"board also has a user available LED and a button for you to quickly test "
"some effects."
msgstr ""
"Akzeptiert einen 6.0V-8.4V XH2.54 3pin-Stromanschluss mit 2 "
"Leistungsindikatoren. Die Platine verfügt außerdem über eine "
"benutzerzugängliche LED und einen Knopf, um schnell einige Effekte zu "
"testen."

#: ../index.rst:40
msgid ""
"In this document, you will get a full understanding of the interface "
"functions of the Robot HAT and the usage of these interfaces through the "
"Python ``robot-hat`` library provided by SunFounder."
msgstr ""
"In diesem Dokument erhalten Sie ein vollständiges Verständnis der "
"Schnittstellenfunktionen des Robot HAT und der Nutzung dieser "
"Schnittstellen über die von SunFounder bereitgestellte Python-Bibliothek "
"``robot-hat``."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_filedb.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_filedb.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_filedb.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_filedb.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_filedb.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_filedb.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_filedb.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_filedb.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_filedb.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_filedb.rst:16
msgid "class ``FileDB``"
msgstr "Klasse ``FileDB``"

#: ../api_filedb.rst:18
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_filedb.rst:41
msgid "Now you can checkout the config file ``config`` in bash."
msgstr "Jetzt können Sie die Konfigurationsdatei ``config`` in Bash überprüfen."

#: ../api_filedb.rst:47
msgid "**API**"
msgstr "**API**"

#: of robot_hat.filedb.fileDB:1
msgid "Bases: :py:class:`object`"
msgstr "Basen: :py:class:`object`"

#: of robot_hat.filedb.fileDB:1
msgid "A file based database."
msgstr "Eine dateibasierte Datenbank."

#: of robot_hat.filedb.fileDB:3
msgid "A file based database, read and write arguements in the specific file."
msgstr ""
"Eine dateibasierte Datenbank zum Lesen und Schreiben von Argumenten in "
"einer bestimmten Datei."

#: of robot_hat.filedb.fileDB.__init__:1
msgid "Init the db_file is a file to save the datas."
msgstr "Initialisiere db_file als Datei zum Speichern der Daten."

#: of robot_hat.filedb.fileDB.__init__
#: robot_hat.filedb.fileDB.file_check_create robot_hat.filedb.fileDB.get
#: robot_hat.filedb.fileDB.set
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.filedb.fileDB.__init__:3
msgid "the file to save the datas."
msgstr "Die Datei zum Speichern der Daten."

#: of robot_hat.filedb.fileDB.__init__:5
#: robot_hat.filedb.fileDB.file_check_create:5
msgid "the mode of the file."
msgstr "Der Modus der Datei."

#: of robot_hat.filedb.fileDB.__init__:7
#: robot_hat.filedb.fileDB.file_check_create:7
msgid "the owner of the file."
msgstr "Der Besitzer der Datei."

#: of robot_hat.filedb.fileDB.file_check_create:1
msgid "Check if file is existed, otherwise create one."
msgstr "Überprüfen, ob die Datei existiert, ansonsten eine erstellen."

#: of robot_hat.filedb.fileDB.file_check_create:3
msgid "the file to check"
msgstr "Die zu überprüfende Datei"

#: of robot_hat.filedb.fileDB.get:1
msgid "Get value with data's name"
msgstr "Wert mit dem Namen der Daten abrufen"

#: of robot_hat.filedb.fileDB.get:3 robot_hat.filedb.fileDB.set:3
msgid "the name of the arguement"
msgstr "Der Name des Arguments"

#: of robot_hat.filedb.fileDB.get:5
msgid "the default value of the arguement"
msgstr "Der Standardwert des Arguments"

#: of robot_hat.filedb.fileDB.get
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.filedb.fileDB.get:7 robot_hat.filedb.fileDB.set:5
msgid "the value of the arguement"
msgstr "Der Wert des Arguments"

#: of robot_hat.filedb.fileDB.get
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.filedb.fileDB.set:1
msgid "Set value by with name. Or create one if the arguement does not exist"
msgstr ""
"Wert anhand des Namens setzen. Oder eines erstellen, falls das Argument "
"nicht existiert"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_security.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_security.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_security.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_security.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_security.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_security.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_security.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_security.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_security.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_security.rst:16
msgid "Security System"
msgstr "Sicherheitssystem"

#: ../project_security.rst:18
msgid ""
"In this project, we've created a simple security system. The PIR sensor "
"detects if someone passes by, and then the camera activates. If a face is"
" detected, it takes a picture and simultaneously delivers a warning "
"message."
msgstr ""
"In diesem Projekt haben wir ein einfaches Sicherheitssystem erstellt. Der"
" PIR-Sensor erkennt, ob jemand vorbeigeht, und dann wird die Kamera "
"aktiviert. Wenn ein Gesicht erkannt wird, macht sie ein Bild und liefert "
"gleichzeitig eine Warnmeldung."

#: ../project_security.rst:22
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_security.rst:24
msgid "Install the ``vilib`` library for face detection."
msgstr "Installieren Sie die ``vilib``-Bibliothek zur Gesichtserkennung."

#: ../project_security.rst:33
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``security.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``security.ty``."

#: ../project_security.rst:106
msgid "Use the command ``sudo python3 security.py`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 security.py``, um diesen Code "
"auszuführen."

#: ../project_security.rst:106
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"

#: ../project_security.rst:108
msgid ""
"Open a web browser and enter ``http://rpi_ip:9000/mjpg`` to view the "
"captured footage. Additionally, you can find the captured face images in "
"``/home/{username}/Pictures/``."
msgstr ""
"Öffnen Sie einen Webbrowser und geben Sie ``http://rpi_ip:9000/mjpg`` "
"ein, um das aufgenommene Filmmaterial anzusehen. Zusätzlich finden Sie "
"die aufgenommenen Gesichtsbilder in ``/home/{Benutzername}/Bilder/``."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/installation.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../installation.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../installation.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../installation.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../installation.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../installation.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../installation.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../installation.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../installation.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../installation.rst:16
msgid "Install the ``robot-hat`` Module"
msgstr "Installieren Sie das Modul ``robot-hat``"

#: ../installation.rst:18
msgid "``robot-hat`` is the supported library for the Robot HAT."
msgstr "``robot-hat`` ist die unterstützte Bibliothek für den Robot HAT."

#: ../installation.rst:20
msgid "Aktualisieren Sie Ihr System."
msgstr ""

#: ../installation.rst:22
msgid "Make sure you are connected to the Internet and update your system:"
msgstr "Stellen Sie sicher, dass Sie mit dem Internet verbunden sind und aktualisieren Sie Ihr System:"

#: ../installation.rst:35
msgid ""
"Python3 related packages must be installed if you are installing the "
"**Lite** version OS."
msgstr "Python3-bezogene Pakete müssen installiert werden, wenn Sie die "
"**Lite** Version OS."

#: ../installation.rst:45
msgid "Type this command into the terminal to install the ``robot-hat`` package."
msgstr ""
"Geben Sie diesen Befehl im Terminal ein, um das ``robot-hat`` Paket zu "
"installieren."

#: ../installation.rst:59
msgid ""
"Run ``setup.py`` to download some necessary components. You may have a "
"network problem and the download may fail. At this point you may need to "
"download again. In the following cases, type ``Y`` and press ``Enter`` to"
" continue the process."
msgstr ""
"Führen Sie ``setup.py`` aus, um einige notwendige Komponenten "
"herunterzuladen. Es könnte ein Netzwerkproblem auftreten und der Download"
" fehlschlagen. In diesem Fall müssen Sie möglicherweise erneut "
"herunterladen. Geben Sie in den folgenden Fällen ``Y`` ein und drücken "
"Sie ``Enter``, um den Prozess fortzusetzen."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/battery.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../battery.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../battery.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../battery.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../battery.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../battery.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../battery.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../battery.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../battery.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../battery.rst:16
msgid "About the Battery"
msgstr "Über den Akku"

#: ../battery.rst:17
msgid "**Battery**"
msgstr "**Akku**"

#: ../battery.rst:23
msgid ""
"**VCC**: Battery positive terminal, here there are two sets of VCC and "
"GND is to increase the current and reduce the resistance."
msgstr ""
"**VCC**: Positiver Batteriepol, hier gibt es zwei Sätze von VCC und GND, "
"um den Strom zu erhöhen und den Widerstand zu verringern."

#: ../battery.rst:24
msgid ""
"**Middle**: To balance the voltage between the two cells and thus protect"
" the battery."
msgstr ""
"**Middle**: Um die Spannung zwischen den beiden Zellen auszugleichen und "
"so den Akku zu schützen."

#: ../battery.rst:25
msgid "**GND**: Negative battery terminal."
msgstr "**GND**: Negativer Batteriepol."

#: ../battery.rst:28
msgid ""
"This is a custom battery pack made by SunFounder consisting of two 18650 "
"batteries with a capacity of 2000mAh. The connector is XH2.54 3pin, which"
" can be charged directly after being inserted into the shield."
msgstr ""
"Dies ist ein benutzerdefinierter Akkupack von SunFounder, bestehend aus "
"zwei 18650 Akkus mit einer Kapazität von 2000mAh. Der Anschluss ist "
"XH2.54 3pin, der direkt nach dem Einsetzen in das Shield geladen werden "
"kann."

#: ../battery.rst:32
msgid "**Features**"
msgstr "**Eigenschaften**"

#: ../battery.rst:34
msgid "Composition: Li-ion"
msgstr "Zusammensetzung: Li-Ion"

#: ../battery.rst:35
msgid "Battery Capacity: 2000mAh, 14.8Wh"
msgstr "Batteriekapazität: 2000mAh, 14.8Wh"

#: ../battery.rst:36
msgid "Battery Weight: 90.8g"
msgstr "Batterie Gewicht: 90.8g"

#: ../battery.rst:37
msgid "Number of Cells: 2"
msgstr "Anzahl der Zellen: 2"

#: ../battery.rst:38
msgid "Connector: XH2.54 3pin"
msgstr "Anschluss: XH2.54 3pin"

#: ../battery.rst:39
msgid "Over-discharge protection: 6.0V"
msgstr "Überentladungsschutz: 6.0V"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_motor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_motor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_motor.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_motor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_motor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_motor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_motor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_motor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_motor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_motor.rst:18
msgid "module ``motor``"
msgstr "Modul ``motor``"

#: ../api_motor.rst:21
msgid "class ``Motors``"
msgstr "Klasse ``Motors``"

#: ../api_motor.rst:23 ../api_motor.rst:95
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_motor.rst:25
msgid "Initilize"
msgstr "Initialisieren"

#: ../api_motor.rst:35
msgid "Directly control a motor. Motor 1/2 is according to PCB mark"
msgstr ""
"Direkte Steuerung eines Motors. Motor 1/2 entspricht der Kennzeichnung "
"auf der Platine"

#: ../api_motor.rst:46
msgid ""
"Setup for high level control, high level control provides functions from "
"simple forword, backward, left, right, stop to more complex like joystick"
" control, motor directions calibration, etc."
msgstr ""
"Einrichtung für hochrangige Steuerung, welche Funktionen von einfachen "
"Bewegungen wie Vorwärts, Rückwärts, Links, Rechts, Stopp bis zu "
"komplexeren wie Joysticksteuerung, Kalibrierung der Motorenrichtung usw. "
"bereitstellt."

#: ../api_motor.rst:51
msgid ""
"All these setup only need to run once, and will save in a config file. "
"Next time you load Motors class, it will load from config file."
msgstr ""
"All diese Einrichtungen müssen nur einmal ausgeführt werden und werden in"
" einer Konfigurationsdatei gespeichert. Wenn Sie das nächste Mal die "
"Klasse Motors laden, wird sie aus der Konfigurationsdatei geladen."

#: ../api_motor.rst:67
msgid "Now control the robot"
msgstr "Jetzt den Roboter steuern"

#: ../api_motor.rst:83 ../api_motor.rst:113
msgid "**API**"
msgstr "**API**"

#: of robot_hat.motor.Motors:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.motor.Motors.__init__:1
msgid "Initialize motors with robot_hat.motor.Motor"
msgstr "Motoren mit robot_hat.motor.Motor initialisieren"

#: of robot_hat.motor.Motor.__init__ robot_hat.motor.Motor.set_is_reverse
#: robot_hat.motor.Motor.speed robot_hat.motor.Motors.__init__
#: robot_hat.motor.Motors.backward robot_hat.motor.Motors.forward
#: robot_hat.motor.Motors.set_left_id robot_hat.motor.Motors.set_right_id
#: robot_hat.motor.Motors.speed robot_hat.motor.Motors.turn_left
#: robot_hat.motor.Motors.turn_right
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.motor.Motors.__init__:3
msgid "config file path"
msgstr "Pfad zur Konfigurationsdatei"

#: of robot_hat.motor.Motors.__getitem__:1
msgid "Get specific motor"
msgstr "Spezifischen Motor abrufen"

#: of robot_hat.motor.Motors.stop:1
msgid "Stop all motors"
msgstr "Alle Motoren stoppen"

#: of robot_hat.Motors.left:1
msgid "left motor"
msgstr "linker Motor"

#: of robot_hat.Motors.right:1
msgid "right motor"
msgstr "rechter Motor"

#: of robot_hat.motor.Motors.set_left_id:1
msgid ""
"Set left motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr ""
"Linke Motor-ID einstellen, diese Funktion muss nur einmal ausgeführt "
"werden. Sie speichert die Motor-ID in der Konfigurationsdatei und lädt "
"sie beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.set_left_id:5
#: robot_hat.motor.Motors.set_right_id:5
msgid "motor id (1 or 2)"
msgstr "Motor-ID (1 oder 2)"

#: of robot_hat.motor.Motors.set_right_id:1
msgid ""
"Set right motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr ""
"Rechte Motor-ID einstellen, diese Funktion muss nur einmal ausgeführt "
"werden. Sie speichert die Motor-ID in der Konfigurationsdatei und lädt "
"sie beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.set_left_reverse:1
msgid ""
"Set left motor reverse, this function only need to run once It will save "
"the reversed status to config file, and load the reversed status when the"
" class is initialized"
msgstr ""
"Linken Motor umkehren, diese Funktion muss nur einmal ausgeführt werden. "
"Sie speichert den umgekehrten Status in der Konfigurationsdatei und lädt "
"diesen beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.motor.Motors.set_left_reverse:5
#: robot_hat.motor.Motors.set_right_reverse:5
msgid "if currently is reversed"
msgstr "ob derzeit umgekehrt ist"

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.motor.Motors.set_right_reverse:1
msgid ""
"Set right motor reverse, this function only need to run once It will save"
" the reversed status to config file, and load the reversed status when "
"the class is initialized"
msgstr ""
"Rechten Motor umkehren, diese Funktion muss nur einmal ausgeführt werden."
" Sie speichert den umgekehrten Status in der Konfigurationsdatei und lädt"
" diesen beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.speed:1
msgid "Set motor speed"
msgstr "Motorgeschwindigkeit einstellen"

#: of robot_hat.motor.Motors.speed:3
msgid "left motor speed(-100.0~100.0)"
msgstr "Geschwindigkeit des linken Motors (-100,0 bis 100,0)"

#: of robot_hat.motor.Motors.speed:5
msgid "right motor speed(-100.0~100.0)"
msgstr "Geschwindigkeit des rechten Motors (-100,0 bis 100,0)"

#: of robot_hat.motor.Motors.forward:1
msgid "Forward"
msgstr "Vorwärts"

#: of robot_hat.motor.Motor.speed:3 robot_hat.motor.Motors.backward:3
#: robot_hat.motor.Motors.forward:3 robot_hat.motor.Motors.turn_left:3
#: robot_hat.motor.Motors.turn_right:3
msgid "Motor speed(-100.0~100.0)"
msgstr "Motorgeschwindigkeit (-100,0 bis 100,0)"

#: of robot_hat.motor.Motors.backward:1
msgid "Backward"
msgstr "Rückwärts"

#: of robot_hat.motor.Motors.turn_left:1
msgid "Left turn"
msgstr "Links abbiegen"

#: of robot_hat.motor.Motors.turn_right:1
msgid "Right turn"
msgstr "Rechts abbiegen"

#: ../api_motor.rst:93
msgid "class ``Motor``"
msgstr "Klasse ``Motor``"

#: of robot_hat.motor.Motor:1
msgid "Bases: :py:class:`object`"
msgstr "Basisklasse: :py:class:`object`"

#: of robot_hat.motor.Motor.__init__:1
msgid "Initialize a motor"
msgstr "Einen Motor initialisieren"

#: of robot_hat.motor.Motor.__init__:3
msgid "Motor speed control pwm pin"
msgstr "PWM-Pin zur Geschwindigkeitssteuerung des Motors"

#: of robot_hat.motor.Motor.__init__:5
msgid "Motor direction control pin"
msgstr "Pin zur Steuerung der Motorenrichtung"

#: of robot_hat.motor.Motor.speed:1
msgid "Get or set motor speed"
msgstr "Motorgeschwindigkeit abrufen oder einstellen"

#: of robot_hat.motor.Motor.set_is_reverse:1
msgid "Set motor is reversed or not"
msgstr "Motor umkehren oder nicht"

#: of robot_hat.motor.Motor.set_is_reverse:3
msgid "True or False"
msgstr "Wahr oder Falsch"




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/api_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_servo.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_servo.rst:18
msgid "class ``Servo``"
msgstr "Klasse ``Servo``"

#: ../api_servo.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_servo.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.servo.Servo:1
msgid "Bases: :py:class:`~robot_hat.pwm.PWM`"
msgstr "Basisklasse: :py:class:`~robot_hat.pwm.PWM`"

#: of robot_hat.servo.Servo:1
msgid "Servo motor class"
msgstr "Servomotorklasse"

#: of robot_hat.servo.Servo.__init__:1
msgid "Initialize the servo motor class"
msgstr "Die Servomotorklasse initialisieren"

#: of robot_hat.servo.Servo.__init__ robot_hat.servo.Servo.angle
#: robot_hat.servo.Servo.pulse_width_time
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.servo.Servo.__init__:3
msgid "PWM channel number(0-14/P0-P14)"
msgstr "PWM-Kanalnummer (0-14/P0-P14)"

#: of robot_hat.servo.Servo.angle:1
msgid "Set the angle of the servo motor"
msgstr "Den Winkel des Servomotors einstellen"

#: of robot_hat.servo.Servo.angle:3
msgid "angle(-90~90)"
msgstr "Winkel (-90~90)"

#: of robot_hat.servo.Servo.pulse_width_time:1
msgid "Set the pulse width of the servo motor"
msgstr "Die Pulsbreite des Servomotors einstellen"

#: of robot_hat.servo.Servo.pulse_width_time:3
msgid "pulse width time(500~2500)"
msgstr "Pulsbreitenzeit (500~2500)"

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/project_ultrasonic.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_ultrasonic.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_ultrasonic.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_ultrasonic.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_ultrasonic.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_ultrasonic.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_ultrasonic.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_ultrasonic.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_ultrasonic.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_ultrasonic.rst:16
msgid "Read from Ultrasonic Module"
msgstr "Lesen vom Ultraschallmodul"

#: ../project_ultrasonic.rst:19
msgid ""
"In this project, we use ultrasonic sensors to measure distance and "
"display the readings on the I2C LCD1602."
msgstr ""
"In diesem Projekt verwenden wir Ultraschallsensoren, um Entfernungen zu "
"messen und die Messwerte auf dem I2C LCD1602 anzuzeigen."

#: ../project_ultrasonic.rst:23
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_ultrasonic.rst:25
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr ""
"In diesem Projekt wird ein I2C LCD1602 verwendet, daher ist es notwendig,"
" die relevanten Bibliotheken herunterzuladen, um es zum Laufen zu "
"bringen."

#: ../project_ultrasonic.rst:32
msgid "Install ``smbus2`` for I2C."
msgstr "Installieren Sie ``smbus2`` für I2C."

#: ../project_ultrasonic.rst:38
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``ultrasonic.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``ultrasonic.ty``."

#: ../project_ultrasonic.rst:88
msgid "Use the command ``sudo python3 ultrasonic.ty`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 ultrasonic.ty``, um diesen Code "
"auszuführen."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/features.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../features.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../features.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../features.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../features.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../features.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../features.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../features.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../features.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../features.rst:16
msgid "Features"
msgstr "Eigenschaften"

#: ../features.rst:18
msgid "Shutdown Current: < 0.5mA"
msgstr "Abschaltstrom: < 0.5mA"

#: ../features.rst:19
msgid "Power Input: USB Type-C, 5V/2A"
msgstr "Stromversorgung: USB Typ-C, 5V/2A"

#: ../features.rst:20
msgid "Charging Power: 5V/2A 10W"
msgstr "Ladeleistung: 5V/2A 10W"

#: ../features.rst:21
msgid "Output Power: 5V/3A"
msgstr "Ausgangsleistung: 5V/3A"

#: ../features.rst:22
msgid ""
"Included Batteries: 2 x 3.7V 18650 Lithium-ion Batteries, XH2.54 3P "
"Interface"
msgstr ""
"Enthaltene Batterien: 2 x 3.7V 18650 Lithium-Ionen-Batterien, XH2.54 3P "
"Schnittstelle"

#: ../features.rst:23
msgid "Battery Protection: Reverse polarity protection"
msgstr "Batterieschutz: Verpolungsschutz"

#: ../features.rst:24
msgid ""
"Charging Protection: Input undervoltage protection, input overvoltage "
"protection, charging balance, overheat protection"
msgstr ""
"Ladeschutz: Eingangsunterspannungsschutz, Eingangsüberspannungsschutz, "
"Ladebalance, Überhitzungsschutz"

#: ../features.rst:25
msgid "Onboard Charging Indicator Light: CHG"
msgstr "An Bord Ladeanzeigeleuchte: CHG"

#: ../features.rst:26
msgid "Onboard Power Indicator Light: PWR"
msgstr "An Bord Leistungsanzeigeleuchte: PWR"

#: ../features.rst:27
msgid "Onboard 2 Battery Level Indicator LEDs"
msgstr "An Bord 2 Batteriestatusanzeige LEDs"

#: ../features.rst:28
msgid "Onboard User LED, 2 tactile switches"
msgstr "An Bord Benutzer-LED, 2 Tastschalter"

#: ../features.rst:29
msgid "Motor Driver: 5V/1.8A x 2"
msgstr "Motorsteuerung: 5V/1.8A x 2"

#: ../features.rst:30
msgid "4-channel 12-bit ADC"
msgstr "4-Kanal 12-Bit-ADC"

#: ../features.rst:31
msgid "12-channel PWM"
msgstr "12-Kanal-PWM"

#: ../features.rst:32
msgid "4-channel digital signals"
msgstr "4-Kanal Digitalsignale"

#: ../features.rst:33
msgid "Onboard SPI interface, UART interface, I2C interface"
msgstr "An Bord SPI-Schnittstelle, UART-Schnittstelle, I2C-Schnittstelle"

#: ../features.rst:34
msgid "Mono Speaker: 8Ω1W"
msgstr "Mono Lautsprecher: 8Ω1W"

#: ../features.rst:36
msgid "Electrical Characteristics"
msgstr "Elektrische Eigenschaften"

#: ../features.rst:40
msgid "Parameters:"
msgstr "Parameter:"

#: ../features.rst:41
msgid "Minimum Value:"
msgstr "Mindestwert:"

#: ../features.rst:42
msgid "Typical Value:"
msgstr "Typischer Wert:"

#: ../features.rst:43
msgid "Maximum Value:"
msgstr "Höchstwert:"

#: ../features.rst:44
msgid "Unit:"
msgstr "Einheit:"

#: ../features.rst:45
msgid "Input Voltage:"
msgstr "Eingangsspannung:"

#: ../features.rst:46 ../features.rst:62
msgid "4.25"
msgstr "4.25"

#: ../features.rst:47
msgid "5"
msgstr "5"

#: ../features.rst:48 ../features.rst:53 ../features.rst:67
msgid "8.4"
msgstr "8.4"

#: ../features.rst:49 ../features.rst:54 ../features.rst:59 ../features.rst:64
#: ../features.rst:69 ../features.rst:84
msgid "V"
msgstr "V"

#: ../features.rst:50
msgid "Battery Input Voltage:"
msgstr "Batterie-Eingangsspannung:"

#: ../features.rst:51
msgid "6.0"
msgstr "6.0"

#: ../features.rst:52
msgid "7.4"
msgstr "7.4"

#: ../features.rst:55
msgid "Overcharge Protection (Battery):"
msgstr "Überladungsschutz (Batterie):"

#: ../features.rst:57 ../features.rst:66
msgid "8.3"
msgstr "8.3"

#: ../features.rst:60
msgid "Input Undervoltage Protection:"
msgstr "Eingangsunterspannungsschutz:"

#: ../features.rst:61
msgid "4.15"
msgstr "4.15"

#: ../features.rst:63
msgid "4.35"
msgstr "4.35"

#: ../features.rst:65
msgid "Input Overvoltage Protection:"
msgstr "Eingangsüberspannungsschutz:"

#: ../features.rst:68
msgid "8.5"
msgstr "8.5"

#: ../features.rst:70
msgid "Charging Current (5V):"
msgstr "Ladestrom (5V):"

#: ../features.rst:73
msgid "2.0"
msgstr "2.0"

#: ../features.rst:74 ../features.rst:79 ../features.rst:99
msgid "A"
msgstr "A"

#: ../features.rst:75
msgid "Output Current (5V):"
msgstr "Ausgangsstrom (5V):"

#: ../features.rst:78
msgid "3.0"
msgstr "3.0"

#: ../features.rst:80
msgid "Output Voltage:"
msgstr "Ausgangsspannung:"

#: ../features.rst:81
msgid "5.166"
msgstr "5.166"

#: ../features.rst:82
msgid "5.246"
msgstr "5.246"

#: ../features.rst:83
msgid "5.327"
msgstr "5.327"

#: ../features.rst:85
msgid "Charging Overheat Protection:"
msgstr "Überhitzungsschutz beim Laden:"

#: ../features.rst:86
msgid "125"
msgstr "125"

#: ../features.rst:87
msgid "135"
msgstr "135"

#: ../features.rst:88
msgid "145"
msgstr "145"

#: ../features.rst:89 ../features.rst:94
msgid "°C"
msgstr "°C"

#: ../features.rst:90
msgid "DC-DC Overheat Protection:"
msgstr "Überhitzungsschutz DC-DC:"

#: ../features.rst:91
msgid "70"
msgstr "70"

#: ../features.rst:92
msgid "75"
msgstr "75"

#: ../features.rst:93
msgid "80"
msgstr "80"

#: ../features.rst:95
msgid "Motor Output Current:"
msgstr "Motor-Ausgangsstrom:"

#: ../features.rst:98
msgid "1.8"
msgstr "1.8"



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/locale/de/LC_MESSAGES/onboard_mcu.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../onboard_mcu.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../onboard_mcu.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../onboard_mcu.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../onboard_mcu.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../onboard_mcu.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../onboard_mcu.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../onboard_mcu.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../onboard_mcu.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../onboard_mcu.rst:18
msgid "On-Board MCU"
msgstr "On-Board-MCU"

#: ../onboard_mcu.rst:20
msgid ""
"The Robot HAT comes with an AT32F413CBT7 microcontroller from Artery. It "
"is an ARM Cortex-M4 processor with a maximum clock frequency of 200MHz. "
"The microcontroller has 128KB of Flash memory and 32KB of SRAM."
msgstr ""
"Der Robot HAT ist mit einem AT32F415CBT7 Mikrocontroller von Artery "
"ausgestattet. Es handelt sich um einen ARM Cortex-M4 Prozessor mit einer "
"maximalen Taktfrequenz von 150MHz. Der Mikrocontroller verfügt über 256KB"
" Flash-Speicher und 32KB SRAM."

#: ../onboard_mcu.rst:22
msgid ""
"The onboard PWM and ADC are driven by the microcontroller. Communication "
"between the Raspberry Pi and the microcontroller is established via the "
"I2C interface. The I2C address used for communication is 0x14 (7-bit "
"address format)."
msgstr ""
"Das Onboard-PWM und ADC werden vom Mikrocontroller gesteuert. Die "
"Kommunikation zwischen dem Raspberry Pi und dem Mikrocontroller erfolgt "
"über die I2C-Schnittstelle. Die für die Kommunikation verwendete I2C-"
"Adresse ist 0x14 (7-Bit-Adressformat)."

#: ../onboard_mcu.rst:28
msgid "Introduce"
msgstr "Einführung"

#: ../onboard_mcu.rst:30
msgid ""
"The on board MCU RESET pin is connected to Raspberry Pi GPIO 5, or "
"``MCURST`` for :py:class:`robot_hat.Pin`. The MCU using 7-bit address "
"``0x14``."
msgstr ""
"Der RESET-Pin des Onboard-MCU ist mit dem Raspberry Pi GPIO 5 oder "
"``MCURST`` für :py:class:`robot_hat.Pin` verbunden. Der MCU verwendet die"
" 7-Bit-Adresse ``0x14``."

#: ../onboard_mcu.rst:33
msgid "ADC"
msgstr "ADC"

#: ../onboard_mcu.rst:35
msgid ""
"Register addresses is 3 byte, 0x170000 to 0x140000 are ADC channels 0 to "
"3. The ADC precision is 12 bit, and the value is 0 to 4095. See more "
"details in :py:class:`robot_hat.ADC`."
msgstr ""
"Registeradressen sind 3 Byte, von 0x170000 bis 0x140000 sind es ADC-"
"Kanäle 0 bis 3. Die ADC-Präzision beträgt 12 Bit, und der Wert liegt "
"zwischen 0 und 4095. Weitere Einzelheiten finden Sie in "
":py:class:`robot_hat.ADC`."

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Address"
msgstr "Adresse"

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Description"
msgstr "Beschreibung"

#: ../onboard_mcu.rst:44
msgid "``0x170000``"
msgstr "``0x170000``"

#: ../onboard_mcu.rst:44
msgid "ADC channel 0"
msgstr "ADC-Kanal 0"

#: ../onboard_mcu.rst:46
msgid "``0x160000``"
msgstr "``0x160000``"

#: ../onboard_mcu.rst:46
msgid "ADC channel 1"
msgstr "ADC-Kanal 1"

#: ../onboard_mcu.rst:48
msgid "``0x150000``"
msgstr "``0x150000``"

#: ../onboard_mcu.rst:48
msgid "ADC channel 2"
msgstr "ADC-Kanal 2"

#: ../onboard_mcu.rst:50
msgid "``0x140000``"
msgstr "``0x140000``"

#: ../onboard_mcu.rst:50
msgid "ADC channel 3"
msgstr "ADC-Kanal 3"

#: ../onboard_mcu.rst:52
msgid "``0x130000``"
msgstr "``0x130000``"

#: ../onboard_mcu.rst:52
msgid "ADC channel 4 (Battery Level)"
msgstr "ADC-Kanal 4 (Batteriestand)"

#: ../onboard_mcu.rst:55
msgid "**Example:**"
msgstr "**Beispiel:**"

#: ../onboard_mcu.rst:57
msgid "Read Channel 0 ADC value:"
msgstr "ADC-Wert des Kanals 0 lesen:"

#: ../onboard_mcu.rst:72
msgid "PWM"
msgstr "PWM"

#: ../onboard_mcu.rst:74
msgid "PWM have 1 byte register with 2 byte values."
msgstr "PWM hat ein 1-Byte-Register mit 2-Byte-Werten."

#: ../onboard_mcu.rst:77
msgid "Changing PWM Frequency"
msgstr "Ändern der PWM-Frequenz"

#: ../onboard_mcu.rst:79
msgid "Frequency is defined with prescaler and period."
msgstr "Die Frequenz wird mit Vorwähler und Periode definiert."

#: ../onboard_mcu.rst:81
msgid ""
"To set frequency first you need to define the period you want. Like on "
"Arduino, normaly is 255, or like PCA9685 is 4095."
msgstr ""
"Um die Frequenz einzustellen, müssen Sie zuerst die gewünschte Periode "
"definieren. Wie bei Arduino ist dies normalerweise 255, oder wie bei "
"PCA9685 4095."

#: ../onboard_mcu.rst:84
msgid ""
"CPU clock is 72MHz, Then you can calculate the prescaler from your desire"
" frequency"
msgstr ""
"Die CPU-Taktfrequenz beträgt 72 MHz. Dann können Sie den Vorwähler aus "
"Ihrer gewünschten Frequenz berechnen"

#: ../onboard_mcu.rst:87
msgid "prescaler = 72MHz / (Period + 1) / Frequency - 1"
msgstr "Vorwähler = 72MHz / (Periode + 1) / Frequenz - 1"

#: ../onboard_mcu.rst:89
msgid ""
"Or if you don't care about the period, there's a way to calculate both "
"period and prescaler from frequency. See :py:func:`robot_hat.PWM.freq`."
msgstr ""
"Wenn Ihnen die Periode egal ist, gibt es eine Möglichkeit, sowohl die "
"Periode als auch den Vorwähler aus der Frequenz zu berechnen. Siehe "
":py:func:`robot_hat.PWM.freq`."

#: ../onboard_mcu.rst:93
msgid "Pulse width"
msgstr "Pulsbreite"

#: ../onboard_mcu.rst:95
msgid ""
"To control the channel pulse width is rather simple, just write the value"
" to the register."
msgstr ""
"Die Kontrolle der Pulsbreite des Kanals ist recht einfach, schreiben Sie "
"einfach den Wert in das Register."

#: ../onboard_mcu.rst:97
msgid ""
"**But** what is the value? If you want to set the PWM to 50% pulse width,"
" you need to know exactly what the period is. Base on the above "
"calculation, if you set the period to 4095, then set pulse value to 2048 "
"is about 50% pulse width."
msgstr ""
"**Aber** was ist der Wert? Wenn Sie die PWM auf eine 50%-Pulsbreite "
"einstellen möchten, müssen Sie genau wissen, was die Periode ist. "
"Basierend auf der oben genannten Berechnung, wenn Sie die Periode auf "
"4095 einstellen, dann entspricht das Setzen des Puls-Wertes auf 2048 "
"ungefähr einer 50%-Pulsbreite."

#: ../onboard_mcu.rst:106
msgid "``0x20``"
msgstr "``0x20``"

#: ../onboard_mcu.rst:106
msgid "Set PWM channel 0 **On Value**"
msgstr "PWM-Kanal 0 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:108
msgid "``0x21``"
msgstr "``0x21``"

#: ../onboard_mcu.rst:108
msgid "Set PWM channel 1 **On Value**"
msgstr "PWM-Kanal 1 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:110
msgid "``0x22``"
msgstr "``0x22``"

#: ../onboard_mcu.rst:110
msgid "Set PWM channel 2 **On Value**"
msgstr "PWM-Kanal 2 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:112
msgid "``0x23``"
msgstr "``0x23``"

#: ../onboard_mcu.rst:112
msgid "Set PWM channel 3 **On Value**"
msgstr "PWM-Kanal 3 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:114
msgid "``0x24``"
msgstr "``0x24``"

#: ../onboard_mcu.rst:114
msgid "Set PWM channel 4 **On Value**"
msgstr "PWM-Kanal 4 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:116
msgid "``0x25``"
msgstr "``0x25``"

#: ../onboard_mcu.rst:116
msgid "Set PWM channel 5 **On Value**"
msgstr "PWM-Kanal 5 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:118
msgid "``0x26``"
msgstr "``0x26``"

#: ../onboard_mcu.rst:118
msgid "Set PWM channel 6 **On Value**"
msgstr "PWM-Kanal 6 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:120
msgid "``0x27``"
msgstr "``0x27``"

#: ../onboard_mcu.rst:120
msgid "Set PWM channel 7 **On Value**"
msgstr "PWM-Kanal 7 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:122
msgid "``0x28``"
msgstr "``0x28``"

#: ../onboard_mcu.rst:122
msgid "Set PWM channel 8 **On Value**"
msgstr "PWM-Kanal 8 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:124
msgid "``0x29``"
msgstr "``0x29``"

#: ../onboard_mcu.rst:124
msgid "Set PWM channel 9 **On Value**"
msgstr "PWM-Kanal 9 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:126
msgid "``0x2A``"
msgstr "``0x2A``"

#: ../onboard_mcu.rst:126
msgid "Set PWM channel 10 **On Value**"
msgstr "PWM-Kanal 10 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:128
msgid "``0x2B``"
msgstr "``0x2B``"

#: ../onboard_mcu.rst:128
msgid "Set PWM channel 11 **On Value**"
msgstr "PWM-Kanal 11 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:130
msgid "``0x2C``"
msgstr "``0x2C``"

#: ../onboard_mcu.rst:130
msgid "Set Motor 2 speed **On Value**"
msgstr "Geschwindigkeit von Motor 2 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:132
msgid "``0x2D``"
msgstr "``0x2D``"

#: ../onboard_mcu.rst:132
msgid "Set Motor 1 speed **On Value**"
msgstr "Geschwindigkeit von Motor 1 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:136
msgid "Prescaler"
msgstr "Vorteiler"

#: ../onboard_mcu.rst:138
msgid ""
"Register from 0x40 is to set the PWM prescaler. ranges from 0~65535. "
"There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"Register ab 0x40 dienen zur Einstellung des PWM-Vorteilers. Der Bereich "
"umfasst 0~65535. Es gibt nur 4 Timer für alle 14 Kanäle. Siehe `PWM "
"Timer(WICHTIG)`_"

#: ../onboard_mcu.rst:146
msgid "``0x40``"
msgstr "``0x40``"

#: ../onboard_mcu.rst:146
msgid "Set timer 0 **Prescaler**"
msgstr "Timer 0 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:148
msgid "``0x41``"
msgstr "``0x41``"

#: ../onboard_mcu.rst:148
msgid "Set timer 1 **Prescaler**"
msgstr "Timer 1 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:150
msgid "``0x42``"
msgstr "``0x42``"

#: ../onboard_mcu.rst:150
msgid "Set timer 2 **Prescaler**"
msgstr "Timer 2 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:152
msgid "``0x43``"
msgstr "``0x43``"

#: ../onboard_mcu.rst:152
msgid "Set timer 3 **Prescaler**"
msgstr "Timer 3 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:156
msgid "Period"
msgstr "Periode"

#: ../onboard_mcu.rst:158
msgid ""
"Register from 0x44 is to set the PWM period. ranges from 0~65535. There "
"are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"Register ab 0x44 dienen zur Einstellung der PWM-Periode. Der Bereich "
"umfasst 0~65535. Es gibt nur 4 Timer für alle 14 Kanäle. Siehe `PWM "
"Timer(WICHTIG)`_"

#: ../onboard_mcu.rst:166
msgid "``0x44``"
msgstr "``0x44``"

#: ../onboard_mcu.rst:166
msgid "Set timer 0 **Period**"
msgstr "Timer 0 **Periode** einstellen"

#: ../onboard_mcu.rst:168
msgid "``0x45``"
msgstr "``0x45``"

#: ../onboard_mcu.rst:168
msgid "Set timer 1 **Period**"
msgstr "Timer 1 **Periode** einstellen"

#: ../onboard_mcu.rst:170
msgid "``0x46``"
msgstr "``0x46``"

#: ../onboard_mcu.rst:170
msgid "Set timer 2 **Period**"
msgstr "Timer 2 **Periode** einstellen"

#: ../onboard_mcu.rst:172
msgid "``0x47``"
msgstr "``0x47``"

#: ../onboard_mcu.rst:172
msgid "Set timer 3 **Period**"
msgstr "Timer 3 **Periode** einstellen"

#: ../onboard_mcu.rst:176
msgid "PWM Timer(IMPORTANT)"
msgstr "PWM-Timer(WICHTIG)"

#: ../onboard_mcu.rst:178
msgid ""
"What is PWM Timer? PWM Timer is a tool to turn on and off the PWM channel"
" for you."
msgstr ""
"Was ist ein PWM-Timer? Der PWM-Timer ist ein Werkzeug, um den PWM-Kanal "
"für Sie ein- und auszuschalten."

#: ../onboard_mcu.rst:180
msgid ""
"The MCU only have 4 timers for PWM: which means you cannot set frequency "
"on different channels at with the same timer."
msgstr ""
"Der MCU hat nur 4 Timer für PWM: Das bedeutet, Sie können die Frequenz "
"nicht für verschiedene Kanäle mit demselben Timer einstellen."

#: ../onboard_mcu.rst:183
msgid ""
"Example: if you set frequency on channel 0, channel 1, 2, 3 will be "
"affected. If you change channel 2 frequency, channel 0, 1, 3 will be "
"override."
msgstr ""
"Beispiel: Wenn Sie die Frequenz auf Kanal 0 einstellen, werden die Kanäle"
" 1, 2, 3 beeinflusst. Wenn Sie die Frequenz von Kanal 2 ändern, werden "
"die Kanäle 0, 1, 3 überschrieben."

#: ../onboard_mcu.rst:186
msgid ""
"This happens like if you want to control both a passive buzzer (who "
"changes frequency all the time) and servo (who needs a fix frequency of "
"50Hz). Then you should seperate them into two different timer."
msgstr ""
"Dies geschieht beispielsweise, wenn Sie sowohl einen passiven Summer (der"
" ständig die Frequenz ändert) als auch einen Servo (der eine feste "
"Frequenz von 50 Hz benötigt) steuern möchten. Dann sollten Sie diese auf "
"zwei verschiedene Timer aufteilen."

#: ../onboard_mcu.rst:192
msgid "Timer"
msgstr "Timer"

#: ../onboard_mcu.rst:192
msgid "PWM Channel"
msgstr "PWM-Kanal"

#: ../onboard_mcu.rst:194
msgid "Timer 0"
msgstr "Timer 0"

#: ../onboard_mcu.rst:194
msgid "0, 1, 2, 3"
msgstr "0, 1, 2, 3"

#: ../onboard_mcu.rst:196
msgid "Timer 1"
msgstr "Timer 1"

#: ../onboard_mcu.rst:196
msgid "4, 5, 6, 7"
msgstr "4, 5, 6, 7"

#: ../onboard_mcu.rst:198
msgid "Timer 2"
msgstr "Timer 2"

#: ../onboard_mcu.rst:198
msgid "8, 9, 10, 11"
msgstr "8, 9, 10, 11"

#: ../onboard_mcu.rst:200
msgid "Timer 3"
msgstr "Timer 3"

#: ../onboard_mcu.rst:200
msgid "12, 13(for motors)"
msgstr "12, 13 (für Motoren)"

#: ../onboard_mcu.rst:204
msgid "Example"
msgstr "Beispiel"

#: ../onboard_mcu.rst:224
msgid "Reset MCU"
msgstr "MCU zurücksetzen"

#: ../onboard_mcu.rst:226
msgid ""
"Currently the firmware reads a fix 3 byte value, then it can return ADC "
"values or control PWM. Thats why ADC register need 3byte with the latter "
"2 byte is 0."
msgstr ""
"Derzeit liest die Firmware einen festen 3-Byte-Wert, dann kann sie ADC-"
"Werte zurückgeben oder PWM steuern. Deshalb benötigt das ADC-Register 3 "
"Byte, wobei die letzten 2 Byte 0 sind."

#: ../onboard_mcu.rst:229
msgid ""
"And if your program is interrupted in the middle of the communication, "
"the firmware may stuck and offset the data. Even we have timeout on "
"waiting on 3 byte datas."
msgstr ""
"Wenn Ihr Programm mitten in der Kommunikation unterbrochen wird, kann die"
" Firmware hängen bleiben und die Daten verschieben. Selbst wenn wir ein "
"Timeout beim Warten auf 3-Byte-Daten haben."

#: ../onboard_mcu.rst:231
msgid ""
"If so, you need to reset the MCU. To reset it. You can use the robot_hat "
"command:"
msgstr ""
"Wenn dies der Fall ist, müssen Sie den MCU zurücksetzen. Um ihn "
"zurückzusetzen, können Sie den Befehl robot_hat verwenden:"

#: ../onboard_mcu.rst:237
msgid "Or you can do it in your python code:"
msgstr "Oder Sie können es in Ihrem Python-Code tun:"

#: ../onboard_mcu.rst:244
msgid ""
"Or you can just pull down the reset pin (GPIO 5) for 10 ms, then pull it "
"back up for another 10ms, as that's what ``reset_mcu`` dose."
msgstr ""
"Oder Sie können einfach den Reset-Pin (GPIO 5) für 10 ms herunterziehen "
"und dann für weitere 10 ms wieder hochziehen, denn das ist es, was "
"``reset_mcu`` macht."



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/battery.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

About the Battery
========================
**Battery**

.. image:: img/3pin_battery.jpg
    :width: 500
    :align: center

* **VCC**: Battery positive terminal, here there are two sets of VCC and GND is to increase the current and reduce the resistance.
* **Middle**: To balance the voltage between the two cells and thus protect the battery.
* **GND**: Negative battery terminal.


This is a custom battery pack made by SunFounder consisting of two 18650 batteries with a capacity of 2000mAh. 
The connector is XH2.54 3pin, which can be charged directly after being inserted into the shield.


**Features**

* Composition: Li-ion
* Battery Capacity: 2000mAh, 14.8Wh
* Battery Weight: 90.8g
* Number of Cells: 2
* Connector: XH2.54 3pin
* Over-discharge protection: 6.0V


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_say_something.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Say Something
====================


In this section, you'll learn how to convert text into speech and have Robot HAT speak it aloud.

**Steps**

#. We retrieve text from the command line to enable Robot HAT to articulate it. To achieve this, save the following code as a ``.py`` file, such as ``tts.py``.


    .. code-block:: python

        import sys
        from robot_hat import TTS

        # Check if there are enough command line arguments
        if len(sys.argv) > 1:
            text_to_say = sys.argv[1]  # Get the first argument passed from the command line
        else:
            text_to_say = "Hello SunFounder"  # Default text if no arguments are provided

        # Initialize the TTS class
        tts = TTS(lang='en-US')

        # Read the text
        tts.say(text_to_say)

        # Display all supported languages
        print(tts.supported_lang())

#. To make Robot HAT vocalize a specific sentence, you can use the following command: ``sudo python3 tts.py "any text"`` - simply replace ``"any text"`` with the desired phrase.

    .. note::

        * :ref:`faq_speaker`



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/features.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Features
==============

    * Shutdown Current: < 0.5mA
    * Power Input: USB Type-C, 5V/2A
    * Charging Power: 5V/2A 10W
    * Output Power: 5V/3A
    * Included Batteries: 2 x 3.7V 18650 Lithium-ion Batteries, XH2.54 3P Interface
    * Battery Protection: Reverse polarity protection
    * Charging Protection: Input undervoltage protection, input overvoltage protection, charging balance, overheat protection
    * Onboard Charging Indicator Light: CHG
    * Onboard Power Indicator Light: PWR
    * Onboard 2 Battery Level Indicator LEDs
    * Onboard User LED, 2 tactile switches
    * Motor Driver: 5V/1.8A x 2
    * 4-channel 12-bit ADC
    * 12-channel PWM
    * 4-channel digital signals
    * Onboard SPI interface, UART interface, I2C interface
    * Mono Speaker: 8Ω1W

.. list-table:: Electrical Characteristics
   :widths: 50 25 25 25 25
   :header-rows: 1

   * - Parameters:
     - Minimum Value:
     - Typical Value:
     - Maximum Value:
     - Unit:
   * - Input Voltage:
     - 4.25
     - 5
     - 8.4
     - V
   * - Battery Input Voltage:
     - 6.0
     - 7.4
     - 8.4
     - V
   * - Overcharge Protection (Battery):
     -
     - 8.3
     -
     - V
   * - Input Undervoltage Protection:
     - 4.15
     - 4.25
     - 4.35
     - V
   * - Input Overvoltage Protection:
     - 8.3
     - 8.4
     - 8.5
     - V
   * - Charging Current (5V):
     -
     -
     - 2.0
     - A
   * - Output Current (5V):
     -
     -
     - 3.0
     - A
   * - Output Voltage:
     - 5.166
     - 5.246
     - 5.327
     - V
   * - Charging Overheat Protection:
     - 125
     - 135
     - 145
     - °C
   * - DC-DC Overheat Protection:
     - 70
     - 75
     - 80
     - °C
   * - Motor Output Current:  
     -
     -
     - 1.8
     - A  

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/_templates/layout.html
##################################################

{%- extends "!layout.html" %}

{% block extrabody %}
<nav id="nav-bar">
  <ul class="nav-bar-items" id="nav-bar-items">
    <li class="nav-bar-logo">
      <a href="https://sunfounder.com">
        <img class="logo-img" src="https://ezblock.cc/readDocFile/sunfounder_LOGO_160x@2x.png"/>
      </a>
    </li>
  </ul>
</nav>
{% endblock %}

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_i2c.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_i2c:

class ``I2C``
========================================

**Example**

.. code-block:: python

    # Import the I2C class
    from robot_hat import I2C

    # You can scan for available I2C devices
    print([f"0x{addr:02X}" for addr in I2C().scan()])
    # You should see at least one device address 0x14, which is the 
    # on board MCU for PWM and ADC

    # Initialize a I2C object with device address, for example
    # to communicate with on board MCU 0x14
    mcu = I2C(0x14)
    # Send ADC channel register to read ADC, 0x10 is Channel 0, 0x11 is Channel 1, etc.
    mcu.write([0x10, 0x00, 0x00])
    # Read 2 byte for MSB and LSB
    msb, lsb = mcu.read(2)
    # Convert to integer
    value = (msb << 8) + lsb
    # Print the value
    print(value)

For more information on the I2C protocol, see checkout adc.py and pwm.py

**API**

.. currentmodule:: robot_hat

.. autoclass:: I2C
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/install_i2s_for_speaker.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _install_i2s:

Install ``i2samp.sh`` for the Speaker
==============================================

The ``i2samp.sh`` is a sophisticated Bash script specifically designed for setting up and configuring an I2S (Inter-IC Sound) amplifier on Raspberry Pi and similar devices. Licensed under the MIT license, it ensures compatibility with a range of hardware and operating systems, conducting thorough checks before proceeding with any installation or configuration.

If you want your speaker to work properly, you definitely need to install this script. 

The steps are as follows:

.. code-block::

    cd ~/robot-hat
    sudo bash i2samp.sh

Type ``y`` and press ``enter`` to continue running the script.

    .. image:: img/install_i2s1.png

Type ``y`` and press ``enter`` to run ``/dev/zero`` in the background.

    .. image:: img/install_i2s2.png

Type ``y`` and press ``enter`` to restart the Raspberry pi.

    .. image:: img/install_i2s2.png

.. warning::

    If there is no sound after restarting, you may need to run the ``i2samp.sh`` script several times.

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_filedb.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

class ``FileDB``
======================

**Example**

.. code-block:: python
    
    # Import fileDB class
    from robot_hat import fileDB

    # Create fileDB object with a config file
    db = fileDB("./config")

    # Set some values
    db.set("apple", "10")
    db.set("orange", "5")
    db.set("banana", "13")

    # Read the values
    print(db.get("apple"))
    print(db.get("orange"))
    print(db.get("banana"))

    # Read an none existing value with a default value
    print(db.get("pineapple", default_value="-1"))

Now you can checkout the config file ``config`` in bash.

.. code-block:: bash

    cat config

**API**

.. currentmodule:: robot_hat

.. autoclass:: fileDB
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/conf.py
##################################################

# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
# import os
# import sys
# sys.path.insert(0, os.path.abspath('.'))


# -- Project information -----------------------------------------------------
import sphinx_rtd_theme
import os
import sys
import time
sys.path.insert(0, os.path.abspath('../../'))

autodoc_mock_imports = ["smbus2", "RPi", "pyaudio", "numpy", "spidev", "gpiozero"]
autodoc_default_options = {'member-order': 'bysource', }

project = 'SunFounder Robot HAT'
copyright = f'{time.localtime().tm_year}, SunFounder'
author = 'www.sunfounder.com'

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autosectionlabel',
    'sphinx_copybutton',
    'sphinx_rtd_theme',
    'sphinx_toolbox.collapse',
    'sphinx.ext.autodoc',
    'sphinx.ext.autosummary',
    'sphinx.ext.napoleon',
    #'sphinx.ext.imgmath',
]

html_theme_options = {
    'flyout_display': 'attached'
}
#latex_engine = 'xelatex'

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = []


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'
html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]


#### RTD+

html_js_files = [
    'https://ezblock.cc/readDocFile/custom.js',
    './lang.js', # new
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/ace.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/ext-language_tools.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/theme-chrome.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/mode-python.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/mode-sh.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/monokai.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/xterm.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/FitAddon.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/readTheDocIndex.js',
]
html_css_files = [
    'https://ezblock.cc/readDocFile/custom.css',
    'https://ezblock.cc/readDocFile/readTheDoc/src/css/index.css',
    'https://ezblock.cc/readDocFile/readTheDoc/src/css/xterm.css',
]




# Multi-language

language = 'en' # Before running make html, set the language.
# language = 'de' # Before running make html, set the language.
# language = 'ja' # Before running make html, set the language.
locale_dirs = ['locale/'] # .po files for other languages are placed in the locale/ folder.

gettext_compact = False # Support for generating the contents of the folders inside source/ into other languages.



# links

rst_epilog = """

.. |link_sf_facebook| raw:: html

    <a href="https://bit.ly/raphaelkit" target="_blank">here</a>

.. |link_german_tutorials| raw:: html

    <a href="https://docs.sunfounder.com/projects/robot-hat-v4/de/latest/" target="_blank">Deutsch Online-Kurs</a>

.. |link_jp_tutorials| raw:: html

    <a href="https://docs.sunfounder.com/projects/robot-hat-v4/ja/latest/" target="_blank">日本語オンライン教材</a>

.. |link_en_tutorials| raw:: html

    <a href="https://docs.sunfounder.com/projects/robot-hat-v4/en/latest/" target="_blank">English Online-tutorials</a>

.. |link_peppe8o| raw:: html

    <a href="https://peppe8o.com/raspberry-pi-robot-hat-sunfounder/" target="_blank">Introduce Raspberry Pi Robot HAT Posted by Peppe8o</a>

.. |link_Robot_HAT| raw:: html

    <a href="https://www.sunfounder.com/products/sunfounder-robot-hat-expansion-board-designed-for-raspberry-pi?_pos=1&_sid=761470ec5&_ss=r" target="_blank">Purchase Link for Robot HAT</a>

.. |link_Robot_HAT_kit| raw:: html

    <a href="https://www.sunfounder.com/products/sunfounder-robot-hat-expansion-board-designed-for-raspberry-pi?_pos=1&_sid=761470ec5&_ss=r" target="_blank">Robot HAT</a>

"""




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/community_tutorials.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Community Tutorials
=======================

* |link_peppe8o|

This document summarizes the SunFounder Raspberry Pi Robot HAT, covering its purpose, compatibility, specifications, and testing:

* **Introduction**: Explains the Robot HAT's role in simplifying control for Raspberry Pi-based DIY robot projects.
* **Specifications**: Details the technical specs, including power input, battery details, ports, and motor driver features.
* **Ports Overview**: Describes various ports like Power, Digital, Analog, PWM, I2C, SPI, UART, and Motor Ports.
* **Additional Components**: Highlights extra components like buttons, LED, and speaker, with Raspberry Pi PIN mappings.
* **Setup and Testing**: Guides on mounting the Robot HAT, necessary components, and testing procedures for features like LED and servo motors.








##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_modules.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

module ``modules``
==================================================

.. currentmodule:: robot_hat.modules

class ``Ultrasonic``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import Ultrasonic and Pin class
        from robot_hat import Ultrasonic, Pin

        # Create Motor object
        us = Ultrasonic(Pin("D2"), Pin("D3"))

        # Read distance
        distance = us.read()
        print(f"Distance: {distance}cm")

    **API**

    .. autoclass:: Ultrasonic
        :special-members: __init__
        :members:

class ``ADXL345``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import ADXL345 class
        from robot_hat import ADXL345

        # Create ADXL345 object
        adxl = ADXL345()
        # or with a custom I2C address
        adxl = ADXL345(address=0x53)

        # Read acceleration of each axis
        x = adxl.read(adxl.X)
        y = adxl.read(adxl.Y)
        z = adxl.read(adxl.Z)
        print(f"Acceleration: {x}, {y}, {z}")

        # Or read all axis at once
        x, y, z = adxl.read()
        print(f"Acceleration: {x}, {y}, {z}")
        # Or print all axis at once
        print(f"Acceleration: {adxl.read()}")

    **API**

    .. autoclass:: robot_hat.ADXL345
        :show-inheritance:
        :special-members: __init__
        :members:

class ``RGB_LED``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import RGB_LED and PWM class
        from robot_hat import RGB_LED, PWM

        # Create RGB_LED object for common anode RGB LED
        rgb = RGB_LED(PWM(0), PWM(1), PWM(2), common=RGB_LED.ANODE)
        # or for common cathode RGB LED
        rgb = RGB_LED(PWM(0), PWM(1), PWM(2), common=RGB_LED.CATHODE)

        # Set color with 24 bit int
        rgb.color(0xFF0000) # Red
        # Set color with RGB tuple
        rgb.color((0, 255, 0)) # Green
        # Set color with RGB List
        rgb.color([0, 0, 255]) # Blue
        # Set color with RGB hex string starts with “#”
        rgb.color("#FFFF00") # Yellow

    **API**

    .. autoclass:: robot_hat.RGB_LED
        :special-members: __init__
        :members:

class ``Buzzer``
-----------------------------------------

    **Example**

    Imports and initialize

    .. code-block:: python

        # Import Buzzer class
        from robot_hat import Buzzer
        # Import Pin for active buzzer
        from robot_hat import Pin
        # Import PWM for passive buzzer
        from robot_hat import PWM
        # import Music class for tones
        from robot_hat import Music
        # Import time for sleep
        import time
    
        music = Music()
        # Create Buzzer object for passive buzzer
        p_buzzer = Buzzer(PWM(0))
        # Create Buzzer object for active buzzer
        a_buzzer = Buzzer(Pin("D0"))

    Active buzzer beeping

    .. code-block:: python

        while True:
            a_buzzer.on()
            time.sleep(0.5)
            a_buzzer.off()
            time.sleep(0.5)
    
    Passive buzzer Simple usage

    .. code-block:: python

        # Play a Tone for 1 second
        p_buzzer.play(music.note("C3"), duration=1)
        # take adventage of the music beat as duration
        # set song tempo of the beat value
        music.tempo(120, 1/4)
        # Play note with a quarter beat
        p_buzzer.play(music.note("C3"), music.beat(1/4))

    Passive buzzer Manual control

    .. code-block:: python

        # Play a tone
        p_buzzer.play(music.note("C4"))
        # Pause for 1 second
        time.sleep(1)
        # Play another tone
        p_buzzer.play(music.note("C5"))
        # Pause for 1 second
        time.sleep(1)
        # Stop playing
        p_buzzer.off()


    Play a song! Baby shark!

    .. code-block:: python

        music.tempo(120, 1/4)

        # Make a Shark-doo-doo function as is all about it
        def shark_doo_doo():
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/16))
            p_buzzer.play(music.note("C5"), music.beat(1/16 + 1/16))
            p_buzzer.play(music.note("C5"), music.beat(1/16))
            p_buzzer.play(music.note("C5"), music.beat(1/8))

        # loop any times you want from baby to maybe great great great grandpa!
        for _ in range(3):
            print("Measure 1")
            p_buzzer.play(music.note("G4"), music.beat(1/4))
            p_buzzer.play(music.note("A4"), music.beat(1/4))
            print("Measure 2")
            shark_doo_doo()
            p_buzzer.play(music.note("G4"), music.beat(1/8))
            p_buzzer.play(music.note("A4"), music.beat(1/8))
            print("Measure 3")
            shark_doo_doo()
            p_buzzer.play(music.note("G4"), music.beat(1/8))
            p_buzzer.play(music.note("A4"), music.beat(1/8))
            print("Measure 4")
            shark_doo_doo()
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            print("Measure 5")
            p_buzzer.play(music.note("B4"), music.beat(1/4))
            time.sleep(music.beat(1/4))



    **API**

    .. autoclass:: robot_hat.Buzzer
        :special-members: __init__
        :members:


class ``Grayscale_Module``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import Grayscale_Module and ADC class
        from robot_hat import Grayscale_Module, ADC
        
        # Create Grayscale_Module object, reference should be calculate from the value reads on white
        # and black ground, then take the middle as reference
        gs = Grayscale_Module(ADC(0), ADC(1), ADC(2), reference=2000)
        
        # Read Grayscale_Module datas
        datas = gs.read()
        print(f"Grayscale Module datas: {datas}")
        # or read a specific channel
        l = gs.read(gs.LEFT)
        m = gs.read(gs.MIDDLE)
        r = gs.read(gs.RIGHT)
        print(f"Grayscale Module left channel: {l}")
        print(f"Grayscale Module middle channel: {m}")
        print(f"Grayscale Module right channel: {r}")

        # Read Grayscale_Module simple states
        state = gs.read_status()
        print(f"Grayscale_Module state: {state}")

    **API**

    .. autoclass:: robot_hat.Grayscale_Module
        :special-members: __init__
        :members:


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_diy_car.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

DIY Car
==============

In addition to being suitable for simple experiments, the Robot HAT is ideal for use as a central controller in robotics, such as for smart cars.

In this project, we built a simple line-following car.

.. image:: img/diy_car.jpg

**Code**

.. code-block:: python

    from robot_hat import Motors, Pin
    import time

    # Create motor object
    motors = Motors()

    # Initialize line tracking sensor
    line_track = Pin('D0')

    def main():
        while True:
            # print("value", line_track.value())
            # time.sleep(0.01)
            if line_track.value() == 1:
                # If line is detected
                motors[1].speed(-60)  # Motor 1 forward
                motors[2].speed(20) # Motor 2 backward
                time.sleep(0.01)
            else:
                # If line is not detected
                motors[1].speed(-20) # Motor 1 backward
                motors[2].speed(60)  # Motor 2 forward
                time.sleep(0.01)

    def destroy():
        # Stop motors when Ctrl+C is pressed
        motors.stop()
        print("Motors stopped.")

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_utils.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

module ``utils``
==================================================

.. automodule:: robot_hat.utils
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/onboard_mcu.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _on_board_mcu:

On-Board MCU
=======================

The Robot HAT comes with an AT32F413CBT7 microcontroller from Artery. It is an ARM Cortex-M4 processor with a maximum clock frequency of 200MHz. The microcontroller has 128KB of Flash memory and 32KB of SRAM.

The onboard PWM and ADC are driven by the microcontroller. 
Communication between the Raspberry Pi and the microcontroller is established via the I2C interface. 
The I2C address used for communication is 0x14 (7-bit address format).


Introduce
-----------------------

The on board MCU RESET pin is connected to Raspberry Pi GPIO 5, or ``MCURST`` for :py:class:`robot_hat.Pin`. The MCU using 7-bit address ``0x14``.

ADC
-----------------------

Register addresses is 3 byte, 0x170000 to 0x140000 are ADC channels 0 to 3.
The ADC precision is 12 bit, and the value is 0 to 4095.
See more details in :py:class:`robot_hat.ADC`.

.. table::

    +-------------------+-------------------------------+
    | Address           | Description                   |
    +===================+===============================+
    | ``0x170000``      | ADC channel 0                 |
    +-------------------+-------------------------------+
    | ``0x160000``      | ADC channel 1                 |
    +-------------------+-------------------------------+
    | ``0x150000``      | ADC channel 2                 |
    +-------------------+-------------------------------+
    | ``0x140000``      | ADC channel 3                 |
    +-------------------+-------------------------------+
    | ``0x130000``      | ADC channel 4 (Battery Level) |
    +-------------------+-------------------------------+

**Example:**

Read Channel 0 ADC value:

.. code-block:: python

    from smbus import SMBus
    bus = SMBus(1)

    # smbus only support 8 bit register address, so write 2 byte 0 first
    bus.write_word_data(0x14, 0x17, 0)
    msb = bus.read_byte(0x14)
    lsb = bus.read_byte(0x14)
    value = (msb << 8) | lsb


PWM
-----------------------

PWM have 1 byte register with 2 byte values.

Changing PWM Frequency
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Frequency is defined with prescaler and period.

To set frequency first you need to define the period you want.
Like on Arduino, normaly is 255, or like PCA9685 is 4095.

CPU clock is 72MHz, Then you can calculate the prescaler from your desire frequency


    prescaler = 72MHz / (Period + 1) / Frequency - 1

Or if you don't care about the period, there's a way to calculate both period and prescaler from
frequency. See :py:func:`robot_hat.PWM.freq`.

Pulse width
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To control the channel pulse width is rather simple, just write the value to the register.

**But** what is the value? If you want to set the PWM to 50% pulse width, you need to know
exactly what the period is. Base on the above calculation, if you set the period to 4095,
then set pulse value to 2048 is about 50% pulse width.

.. table::

    +-------------------+----------------------------------+
    | Address           | Description                      |
    +===================+==================================+
    | ``0x20``          | Set PWM channel 0 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x21``          | Set PWM channel 1 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x22``          | Set PWM channel 2 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x23``          | Set PWM channel 3 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x24``          | Set PWM channel 4 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x25``          | Set PWM channel 5 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x26``          | Set PWM channel 6 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x27``          | Set PWM channel 7 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x28``          | Set PWM channel 8 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x29``          | Set PWM channel 9 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x2A``          | Set PWM channel 10 **On Value**  |
    +-------------------+----------------------------------+
    | ``0x2B``          | Set PWM channel 11 **On Value**  |
    +-------------------+----------------------------------+
    | ``0x2C``          | Set Motor 2 speed **On Value**   |
    +-------------------+----------------------------------+
    | ``0x2D``          | Set Motor 1 speed **On Value**   |
    +-------------------+----------------------------------+

Prescaler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Register from 0x40 is to set the PWM prescaler. ranges from 0~65535.
There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_

.. table::

    +-------------------+----------------------------------+
    | Address           | Description                      |
    +===================+==================================+
    | ``0x40``          | Set timer 0 **Prescaler**        |
    +-------------------+----------------------------------+
    | ``0x41``          | Set timer 1 **Prescaler**        |
    +-------------------+----------------------------------+
    | ``0x42``          | Set timer 2 **Prescaler**        |
    +-------------------+----------------------------------+
    | ``0x43``          | Set timer 3 **Prescaler**        |
    +-------------------+----------------------------------+

Period
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Register from 0x44 is to set the PWM period. ranges from 0~65535.
There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_

.. table::

    +-------------------+----------------------------------+
    | Address           | Description                      |
    +===================+==================================+
    | ``0x44``          | Set timer 0 **Period**           |
    +-------------------+----------------------------------+
    | ``0x45``          | Set timer 1 **Period**           |
    +-------------------+----------------------------------+
    | ``0x46``          | Set timer 2 **Period**           |
    +-------------------+----------------------------------+
    | ``0x47``          | Set timer 3 **Period**           |
    +-------------------+----------------------------------+

PWM Timer(IMPORTANT)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What is PWM Timer? PWM Timer is a tool to turn on and off the PWM channel for you.

The MCU only have 4 timers for PWM: which means you cannot set frequency on different channels
at with the same timer.

Example: if you set frequency on channel 0, channel 1, 2, 3 will be affected.
If you change channel 2 frequency, channel 0, 1, 3 will be override.

This happens like if you want to control both a passive buzzer (who changes frequency all the time)
and servo (who needs a fix frequency of 50Hz). Then you should seperate them into two different timer.

.. table::

    +---------------+-------------------+
    | Timer         | PWM Channel       |
    +===============+===================+
    | Timer 0       | 0, 1, 2, 3        |
    +---------------+-------------------+
    | Timer 1       | 4, 5, 6, 7        |
    +---------------+-------------------+
    | Timer 2       | 8, 9, 10, 11      |
    +---------------+-------------------+
    | Timer 3       | 12, 13(for motors)|
    +---------------+-------------------+

Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from smbus import SMBus
    bus = SMBus(1)

    # Set timer 0 period to 4095
    bus.write_word_data(0x14, 0x44, 4095)
    # Set frequency to 50Hz,
    freq = 50
    # Calculate prescaler
    prescaler = int(72000000 / (4095 + 1) / freq) - 1
    # Set prescaler
    bus.write_word_data(0x14, 0x40, prescaler)
    
    # Set channel 0 to 50% pulse width
    bus.write_word_data(0x14, 0x20, 2048)

Reset MCU
-----------------------------

Currently the firmware reads a fix 3 byte value, then it can return ADC values or control PWM.
Thats why ADC register need 3byte with the latter 2 byte is 0.

And if your program is interrupted in the middle of the communication, the firmware may stuck and offset the data. Even we have timeout on waiting on 3 byte datas.

If so, you need to reset the MCU. To reset it. You can use the robot_hat command:

.. code-block:: bash

    robot_hat reset_mcu

Or you can do it in your python code:

.. code-block:: python

    from robot_hat import reset_mcu
    reset_mcu()

Or you can just pull down the reset pin (GPIO 5) for 10 ms, then pull it back up for another 10ms, as that's what ``reset_mcu`` dose.

.. code-block:: python

    import RPi.GPIO as GPIO
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(5, GPIO.OUT)
    GPIO.output(5, GPIO.LOW)
    time.sleep(0.01)
    GPIO.output(5, GPIO.HIGH)
    time.sleep(0.01)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_ultrasonic.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Read from Ultrasonic Module
===============================


In this project, we use ultrasonic sensors to measure distance and display the readings on the I2C LCD1602.

.. image:: img/ultrasonic.jpg

**Steps**

#. In this project, an I2C LCD1602 is used, so it's necessary to download the relevant libraries to make it work.

    .. code-block:: shell

        cd ~/
        wget https://github.com/sunfounder/raphael-kit/blob/master/python/LCD1602.py

#. Install ``smbus2`` for I2C.

    .. code-block:: shell

        sudo pip3 install smbus2

#. Save the following code to your Raspberry Pi and give it a name, for example, ``ultrasonic.ty``.

    .. code-block:: python

        from robot_hat import ADC, Ultrasonic, Pin
        import LCD1602
        import time

        # Create ADC object for photoresistor
        a0 = ADC(0)

        # Create Ultrasonic object
        us = Ultrasonic(Pin("D2"), Pin("D3")) //Trig to digital pin 2, echo to pin 3

        def setup():
            # Initialize LCD1602
            LCD1602.init(0x27, 1)
            # Initial message on LCD
            LCD1602.write(0, 0, 'Measuring...')
            time.sleep(2)

        def destroy():
            # Clear the LCD display
            LCD1602.clear()

        def loop():
            while True:
                # Read distance from ultrasonic sensor
                distance = us.read()
                # Display the distance on the LCD
                if distance != -1:
                    # Display the valid distance on the LCD
                    LCD1602.write(0, 0, 'Dist: %.2f cm   ' % distance)
                
                # Update every 0.5 seconds
                time.sleep(0.2)

        if __name__ == '__main__':
            setup()
            try:
                loop()
            except KeyboardInterrupt:
                destroy()
            except Exception as e:
                # Clear the LCD and print error message in case of an exception
                destroy()
                print("Error:", e)



#. Use the command ``sudo python3 ultrasonic.ty`` to run this code.



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_adc.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_adc:

class ``ADC``
=========================================

**Example**

.. code-block:: python
    
    # Import ADC class
    from robot_hat import ADC

    # Create ADC object with numeric pin numbering
    a0 = ADC(0)
    # Create ADC object with named pin numbering
    a1 = ADC('A1')

    # Read ADC value
    value0 = a0.read()
    value1 = a1.read()
    voltage0 = a0.read_voltage()
    voltage1 = a1.read_voltage()
    print(f"ADC 0 value: {value0}")
    print(f"ADC 1 value: {value1}")
    print(f"ADC 0 voltage: {voltage0}")
    print(f"ADC 1 voltage: {voltage1}")

**API**

.. currentmodule:: robot_hat

.. autoclass:: ADC
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_pin.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_pin:

class ``Pin``
===========================

**Example**

.. code-block:: python
    
    # Import Pin class
    from robot_hat import Pin

    # Create Pin object with numeric pin numbering and default input pullup enabled
    d0 = Pin(0, Pin.IN, Pin.PULL_UP)
    # Create Pin object with named pin numbering
    d1 = Pin('D1')

    # read value
    value0 = d0.value()
    value1 = d1.value()
    print(value0, value1)

    # write value
    d0.value(1) # force input to output
    d1.value(0)

    # set pin high/low
    d0.high()
    d1.off()

    # set interrupt
    led = Pin('LED', Pin.OUT)
    switch = Pin('SW', Pin.IN, Pin.PULL_DOWN)
    def onPressed(chn):
        led.value(not switch.value())
    switch.irq(handler=onPressed, trigger=Pin.IRQ_RISING_FALLING)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Pin
    :show-inheritance:
    :special-members: __init__, __call__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/installation.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Install the ``robot-hat`` Module
==========================================

``robot-hat`` is the supported library for the Robot HAT.

#. Update your system.

   Make sure you are connected to the Internet and update your system:

   .. raw:: html

      <run></run>

   .. code-block::

      sudo apt update
      sudo apt upgrade

   .. note::

      Python3 related packages must be installed if you are installing the **Lite** version OS.

      .. raw:: html

         <run></run>

      .. code-block::
        
         sudo apt install git python3-pip python3-setuptools python3-smbus

#. Type this command into the terminal to install the ``robot-hat`` package.

    .. raw:: html

        <run></run>

    .. code-block::

        cd ~/
        git clone -b v2.0 https://github.com/sunfounder/robot-hat.git
        cd robot-hat
        sudo python3 setup.py install

   .. note::
      Run ``setup.py`` to download some necessary components. You may have a network problem and the download may fail. At this point you may need to download again. In the following cases, type ``Y`` and press ``Enter`` to continue the process.

   .. image:: img/dowload_code.png

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/hardware_introduction.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Hardware Introduction
=========================

Pinout
---------------

.. image:: img/robot_hat_pinout.png
  :width: 800
  :align: center

**Power Port**
    * 6.0V-8.4V XH2.54 3pin power input.
    * Powering the Raspberry Pi and Robot HAT at the same time.

**Power Switch**
    * Turn on/off the power of the robot HAT.

**Type-C USB Port**
    * Insert the Type-C cable to charge the battery.
    * At the same time, the charging indicator lights up in red color.
    * When the battery is fully charged, the charging indicator turns off.
    * If the USB cable is still plugged in about 4 hours after it is fully charged, the charging indicator will blink to prompt.

**Digital Pin**
    * 4-channel digital pins, D0-D3.
    * Pin: :ref:`pin_digital`.
    * API: :ref:`class_pin`.

**ADC Pin**
    * 4-channel ADC pins, A0-A3.
    * Pin: :ref:`pin_adc`.
    * API: :ref:`class_adc`.

**PWM Pin**
    * 12-channel PWM pins, P0-P11.
    * Pin: :ref:`pin_pwm`.
    * API: :ref:`class_pwm`.

**Left/Right Motor Port**
    * 2-channel XH2.54 motor ports.
    * Pin: :ref:`pin_motor`.
    * API: :ref:`class_motor`, ``1`` for left motor port, ``2`` for right motor port.

**I2C Pin and I2C Port**
    * **I2C Pin**: P2.54 4-pin interface.
    * **I2C Port**: SH1.0 4-pin interface, which is compatible with QWIIC and STEMMA QT. 
    * These I2C interfaces are connected to the Raspberry Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL).
    * Pin: :ref:`pin_i2c`.
    * API: :ref:`class_i2c`.

**SPI Pin**
    * P2.54 7-pin SPI interface.
    * Pin: :ref:`pin_spi`.

**UART Pin**
    * P2.54 4-pin interface.
    * Pin: :ref:`pin_uart`.

**RST Button**
    * The RST button, when using Ezblock, serves as a button to restart the Ezblock program. 
    * If not using Ezblock, the RST button does not have a predefined function and can be fully customized according to your needs.
    * Pin: :ref:`pin_button`.
    * API: :ref:`class_pin`

**USR Button**
    * The functions of USR Button can be set by your programming. (Pressing down leads to a input “0”; releasing produces a input “1”. ) 
    * API: :ref:`class_pin`, you can use ``Pin("SW")`` to define it.
    * Pin: :ref:`pin_button`.

**Battery Indicator**
    * Two LEDs light up when the voltage is higher than 7.6V.
    * One LED lights up in the 7.15V to 7.6V range. 
    * Below 7.15V, both LEDs turn off.
    * :ref:`battery_indicator`.

**Speaker and Speaker Port**
    * **Speaker**: This is a 2030 audio chamber speaker.
    * **Speaker Port**: The Robot HAT is equipped with onboard I2S audio output, along with a 2030 audio chamber speaker, providing a mono sound output.
    * Pin: :ref:`pin_speaker`.
    * API: :ref:`class_music`



Pin Mapping
------------------

.. list-table:: Raspberry Pi IO
    :widths: 50 50 50 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi
      - Raspberry Pi
      - Robot Hat V4
    * - NC
      - 3V3    
      - 5V
      - 5V
    * - SDA
      - SDA    
      - 5V
      - 5V
    * - SCL
      - SCL    
      - GND
      - GND
    * - D1
      - GPIO4    
      - TXD
      - TXD
    * - GND
      - GND    
      - RXD
      - RXD
    * - D0
      - GPIO17    
      - GPIO18
      - I2S BCLK
    * - D2
      - GPIO27    
      - GND
      - GND
    * - D3
      - GPIO22    
      - GPIO23
      - MOTOR 1 DIR
    * - NC
      - 3V3    
      - GPIO24
      - MOTOR 2 DIR
    * - SPI MOSI
      - MOSI    
      - GND
      - GND
    * - SPI MISO
      - MISO    
      - GPIO25
      - USR BUTTON
    * - SPI SCLK
      - SCLK    
      - CE0
      - SPI CE0
    * - GND
      - GND    
      - CE1
      - NC
    * - NC
      - ID_SD    
      - ID_SC
      - NC
    * - MCU Reset
      - GPIO5    
      - GND
      - GND
    * - (SPI)BSY 
      - GPIO6    
      - GPIO12
      - Board Identifier 2
    * - Board Identifier 1
      - GPIO13    
      - GND
      - GND
    * - I2S LRCLK
      - GPIO19    
      - GPIO16
      - RST BUTTON
    * - USER LED
      - GPIO26    
      - GPIO20
      - NC
    * - GND
      - GND    
      - GPIO21
      - I2S SDATA

.. _pin_digital:

Digital IO
---------------
    
Robot HAT has 4 sets of P2.54 3Pin digital pins.

.. image:: img/digitalio.png

.. list-table:: Digital IO
    :widths: 25 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi 

    * - D0
      - GPIO17

    * - D1
      - GPIO4

    * - D2
      - GPIO27

    * - D3
      - GPIO22

.. _pin_adc:

ADC
-------

.. image:: img/adcpin.png

The Robot HAT features four sets of 3Pin ADC (Analog to Digital Converter) pins, each spaced 2.54mm apart. These pins operate at a 3.3V power supply. The ADC function, offering 12-bit precision, is facilitated by an onboard microcontroller. Detailed instructions for reading ADC values are provided in the :ref:`on_board_mcu` section.

.. image:: img/btradc.png

Also, ADC channel A4 is connected to the battery through a voltage divider using resistors, 
which will be used to measure the battery voltage to estimate the approximate battery charge.

The voltage divider ratio is 20K/10K, so:

* A4 voltage (Va4) = value_A4 / 4095.0 * 3.3
* Battery voltage (Vbat) = Va4*3
* Battery voltage (Vbat) = value_A4 / 4095.0 * 3.3 * 3

.. _pin_pwm:

PWM
--------

.. image:: img/pwmpin.png

Robot HAT has 4 sets of 3Pin PWM pins, each spaced 2.54mm apart, and the power supply is 5V.
The method of using the PWM is described in detail in :ref:`on_board_mcu`.

.. note:: PWM13 & 14 channels are used for motor drive.

.. _pin_i2c:

I2C
----------

.. image:: img/i2cpin.png

The Robot HAT has two I2C interfaces. One is the P2.54 4-pin interface, and the other is the SH1.0 4-pin interface, which is compatible with QWIIC and STEMMA QT. 
These I2C interfaces are connected to the Raspberry Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL). 
The board also features an :ref:`on_board_mcu`, and the two signal lines have 10K pull-up resistors.

.. _pin_spi:

SPI
---------

.. image:: img/spipin.png

The SPI interface of the Robot HAT is a 7-pin P2.54 interface. 
It connects to the SPI interface of the Raspberry Pi and includes an additional I/O pin that can be used for purposes such as interrupts or resets.


.. list-table:: SPI
    :widths: 50 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi 
    * - BSY
      - GPIO6
    * - CS
      - CE0(GPIO8)
    * - SCK
      - SCLK(GPIO11)
    * - MI
      - MISO(GPIO9)
    * - MO
      - MOSI(GPIO10)
    * - 3V3
      - 3.3V Power
    * - GND
      - Ground

.. _pin_uart:

UART
----------

.. image:: img/uartpin.png

The UART interface of the Robot HAT is a 4-pin P2.54 interface. It connects to the Raspberry Pi's GPIO14 (TXD) and GPIO15 (RXD) pins.

.. _pin_button:

Buttons
----------------

The Robot HAT comes with 1 LED and 2 buttons, all directly connected to the Raspberry Pi's GPIO pins. 
The RST button, when using Ezblock, serves as a button to restart the Ezblock program. 
If not using Ezblock, the RST button does not have a predefined function and can be fully customized according to your needs.

.. list-table:: LED & Button
    :widths: 50 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi 
    * - LED
      - GPIO26
    * - USR
      - GPIO25
    * - RST
      - GPIO16

.. _pin_speaker:

Speaker and Speaker Port
----------------------------

The Robot HAT is equipped with onboard I2S audio output, along with a 2030 audio chamber speaker, providing a mono sound output.


.. list-table:: I2S
    :widths: 50 50
    :header-rows: 1

    * - I2S
      - Raspberry Pi
    * - LRCLK
      - GPIO19
    * - BCLK
      - GPIO18
    * - SDATA
      - GPIO21

.. _pin_motor:

Motor Port
-----------------

The motor driver of the Robot HAT supports 2 channels and can be controlled using 2 digital signals for direction and 2 PWM signals for speed control.


.. list-table:: Motor Driver
    :widths: 50 50
    :header-rows: 1

    * - Motor
      - IO
    * - Motor1 Dir
      - GPIO23
    * - Motor1 Power
      - PWM13
    * - Motor2 Dir
      - GPIO24
    * - Motor2 Power
      - PWM12

.. _battery_indicator:

Battery Level Indicator
------------------------------

The battery level indicator on the Robot HAT monitors the battery voltage using a voltage divider method and serves as a reference for estimating the battery level. 
The relationship between the LED and voltage is as follows:

.. list-table:: Battery Level
    :widths: 50 50
    :header-rows: 1

    * - LED Battery
      - Total Voltage
    * - 2 LEDs on
      - Greater than 7.6V
    * - 1 LED on
      - Greater than 7.15V
    * - Both LEDs off
      - Less than 7.15V

When any one of the batteries reaches or exceeds 4.1V while the others are below that threshold, 
the charging current of that specific battery will be reduced.




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_tts.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_tts:

class ``TTS``
==================================================

.. warning::
    * You need to add ``sudo`` when running this script, in case the speaker doesn't work.
    * :ref:`faq_speaker`.

**Example**

.. code-block:: python

    # Import TTS class
    from robot_hat import TTS

    # Initialize TTS class
    tts = TTS(lang='en-US')
    # Speak text
    tts.say("Hello World")
    # show all supported languages
    print(tts.supported_lang())


**API**

.. currentmodule:: robot_hat

.. autoclass:: TTS
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_plant_monitor.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Plant Monitor
======================

In this project, we detect both light intensity and soil moisture levels, and display them on the I2C LCD1602 . When you feel that the soil moisture is insufficient, you can press the button module to water the potted plant.

.. image:: img/plant_monitor.jpg

**Steps**

#. In this project, an I2C LCD1602 is used, so it's necessary to download the relevant libraries to make it work.

    .. code-block:: shell

        cd ~/
        wget https://github.com/sunfounder/raphael-kit/blob/master/python/LCD1602.py

#. Install ``smbus2`` for I2C.

    .. code-block:: shell

        sudo pip3 install smbus2

#. Save the following code to your Raspberry Pi and give it a name, for example, ``plant_monitor.ty``.

    .. code-block:: python

        from robot_hat import ADC, Motors, Pin
        import LCD1602
        import time
        import threading

        from robot_hat.utils import reset_mcu

        reset_mcu()
        time.sleep(.1)


        # Initialize objects
        light_sensor = ADC(1)
        moisture_sensor = ADC(0)
        motors = Motors()
        button = Pin('D0')

        # Thread running flag
        running = True

        def init_lcd():
            LCD1602.init(0x27, 1)
            time.sleep(2)

        def update_lcd(light_value, moisture_value):
            LCD1602.write(0, 0, 'Light: %d  ' % light_value)
            LCD1602.write(0, 1, 'Moisture: %d  ' % moisture_value)

        def read_sensors():
            light_value = light_sensor.read()
            time.sleep(0.2)
            moisture_value = moisture_sensor.read()
            time.sleep(0.2)
            return light_value, moisture_value

        def control_motor():
            global running
            while running:
                button_pressed = button.value() == 0
                if button_pressed:
                    motors[1].speed(80)
                    time.sleep(0.1)
                else:
                    motors[1].speed(0)
                    time.sleep(0.1)
                time.sleep(0.1)

        def setup():
            init_lcd()

        def destroy():
            global running
            running = False
            LCD1602.clear()

        def loop():
            global running
            while running:
                light_value, moisture_value = read_sensors()
                update_lcd(light_value, moisture_value)
                time.sleep(.2)

        if __name__ == '__main__':
            try:
                setup()
                motor_thread = threading.Thread(target=control_motor)
                motor_thread.start()
                loop()
            except KeyboardInterrupt:
                motor_thread.join()  # Wait for motor_thread to finish
                print("Program stopped")
            except Exception as e:
                print("Error:", e)
            finally:
                motors[1].speed(0)
                time.sleep(.1)
                destroy()
                print('end')

#. Use the command ``sudo python3 plant_monitor.ty`` to run this code.



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_motor.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_motor:

module ``motor``
========================================

class ``Motors``
----------------------------------------

**Example**

Initilize

.. code-block:: python
    
    # Import Motor class
    from robot_hat import Motors

    # Create Motor object
    motors = Motors()

Directly control a motor. Motor 1/2 is according to PCB mark

.. code-block:: python

    # Motor 1 clockwise at 100% speed
    motors[1].speed(100)
    # Motor 2 counter-clockwise at 100% speed
    motors[2].speed(-100)
    # Stop all motors
    motors.stop()

Setup for high level control, high level control provides functions
from simple forword, backward, left, right, stop to more complex
like joystick control, motor directions calibration, etc.

.. note:: 
    All these setup only need to run once, and will save in a config file. Next time you load Motors class, it will load from config file.

.. code-block:: python

    # Setup left and right motors
    motors.set_left_id(1)
    motors.set_right_id(2)
    # Go forward and see if both motor directions are correct
    motors.forward(100)
    # if you found a motor is running in the wrong direction
    # Use these function to correct it
    motors.set_left_reverse()
    motors.set_right_reverse()
    # Run forward again and see if both motor directions are correct
    motors.forward(100)

Now control the robot

.. code-block:: python

    import time

    motors.forward(100)
    time.sleep(1)
    motors.backward(100)
    time.sleep(1)
    motors.turn_left(100)
    time.sleep(1)
    motors.turn_right(100)
    time.sleep(1)
    motors.stop()

**API**

.. currentmodule:: robot_hat

.. autoclass:: Motors
    :show-inheritance:
    :special-members: __init__, __getitem__
    :members:

class ``Motor``
----------------------------------------

**Example**

.. code-block:: python
    
    # Import Motor class
    from robot_hat import Motor, PWM, Pin

    # Create Motor object
    motor = Motor(PWM("P13"), Pin("D4"))

    # Motor clockwise at 100% speed
    motor.speed(100)
    # Motor counter-clockwise at 100% speed
    motor.speed(-100)

    # If you like to reverse the motor direction
    motor.set_is_reverse(True)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Motor
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_pwm.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_pwm:

class ``PWM``
========================================

**Example**

.. code-block:: python
    
    # Import PWM class
    from robot_hat import PWM

    # Create PWM object with numeric pin numbering and default input pullup enabled
    p0 = PWM(0)
    # Create PWM object with named pin numbering
    p1 = PWM('P1')


    # Set frequency will automatically set prescaller and period
    # This is easy for device like Buzzer or LED, which you care
    # about the frequency and pulse width percentage.
    # this usually use with pulse_width_percent function.
    # Set frequency to 1000Hz
    p0.freq(1000)
    print(f"Frequence: {p0.freq()} Hz")
    print(f"Prescaler: {p0.prescaler()}")
    print(f"Period: {p0.period()}")
    # Set pulse width to 50%
    p0.pulse_width_percent(50)

    # Or set prescaller and period, will get a frequency from:
    # frequency = PWM.CLOCK / prescaler / period
    # With this setup you can tune the period as you wish.
    # set prescaler to 64
    p1.prescaler(64)
    # set period to 4096 ticks
    p1.period(4096)
    print(f"Frequence: {p1.freq()} Hz")
    print(f"Prescaler: {p1.prescaler()}")
    print(f"Period: {p1.period()}")
    # Set pulse width to 2048 which is also 50%
    p1.pulse_width(2048)

**API**

.. currentmodule:: robot_hat

.. autoclass:: PWM
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/project_security.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Security System
=======================

In this project, we've created a simple security system. The PIR sensor detects if someone passes by, and then the camera activates. If a face is detected, it takes a picture and simultaneously delivers a warning message.

.. image:: img/camera.jpg

**Steps**

#. Install the ``vilib`` library for face detection.

    .. code-block:: shell

        cd ~/
        git clone -b picamera2 https://github.com/sunfounder/vilib.git
        cd vilib
        sudo python3 install.py

#. Save the following code to your Raspberry Pi and give it a name, for example, ``security.ty``.


    .. code-block:: python

        import os
        from time import sleep, time, strftime, localtime
        from vilib import Vilib
        from robot_hat import Pin, TTS


        # Initialize the TTS class
        tts = TTS(lang='en-US')

        # Display all supported languages
        print(tts.supported_lang())

        # Initialize the PIR sensor
        pir = Pin('D0')

        def camera_start():
            Vilib.camera_start()
            Vilib.display()
            Vilib.face_detect_switch(True)

        def take_photo():
            _time = strftime('%Y-%m-%d-%H-%M-%S', localtime(time()))
            name = f'photo_{_time}'
            username = os.getlogin()
            path = f"/home/{username}/Pictures/"
            Vilib.take_photo(name, path)
            print(f'Photo saved as {path}{name}.jpg')

        def main():
            motion_detected = False
            while True:
                # Check for motion
                if pir.value() == 1:
                    if not motion_detected:
                        print("Motion detected! Initializing camera...")
                        camera_start()
                        motion_detected = True
                        sleep(2)  # Stabilization delay to confirm motion

                    # Check for human face and take a photo
                    if Vilib.detect_obj_parameter['human_n'] != 0:
                        take_photo()
                        # Read the text
                        tts.say("Security alert: Unrecognized Individual detected. Please verify identity")
                        sleep(2)  # Delay after taking a photo

                # If no motion is detected, turn off the camera
                elif motion_detected:
                    print("No motion detected. Finalizing camera...")
                    Vilib.camera_close()
                    motion_detected = False
                    sleep(2)  # Delay before re-enabling motion detection

                sleep(0.1)  # Short delay to prevent CPU overuse

        def destroy():
            Vilib.camera_close()
            print("Camera and face detection stopped.")

        if __name__ == '__main__':
            try:
                main()
            except KeyboardInterrupt:
                destroy()

#. Use the command ``sudo python3 security.py`` to run this code.
    .. note::

        * :ref:`faq_speaker`

#. Open a web browser and enter ``http://rpi_ip:9000/mjpg`` to view the captured footage. Additionally, you can find the captured face images in ``/home/{username}/Pictures/``.

    .. image:: img/browser_camera.jpg



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/faq.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

FAQ
================

Q1: Can the battery be connected while providing power to the Raspberry Pi at the same time?
------------------------------------------------------------------------------------------------------------
A: Yes, the Robot HAT has a built-in anti-backflow diode that prevents the Raspberry Pi's power from flowing back into the Robot HAT.

Q2: Can the Robot HAT be used while charging?
--------------------------------------------------------
A: Yes, the Robot HAT can be used while charging. When charging, the input power is boosted by the charging chip to charge the batteries, while also providing power to the DC-DC step-down for external use. The charging power is approximately 10W. If the external power consumption is too high for an extended period, the batteries may supplement the power, similar to how a mobile phone charges while in use. However, it is important to be mindful of the battery's capacity to avoid draining it completely during simultaneous charging and usage.

.. _faq_speaker:

Q3: Why is there no sound from the speaker?
--------------------------------------------------

When your script is running but the speaker is not producing sound, there could be several reasons:

#. Check if the ``i2samp.sh`` script has been installed. For detailed instructions, please refer to: :ref:`install_i2s`.
#. When running scripts related to speakers, it's necessary to add ``sudo`` to obtain administrative privileges. For example, ``sudo python3 tts.py``.
#. Don't using Raspberry Pi's built-in programming tools, like Geany to run Speaker-related scripts. These tools run with standard user privileges, while hardware control, such as managing speakers, often requires higher permissions.


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Reference
==========================

.. automodule:: robot_hat

.. toctree::
   :maxdepth: 2

   api_pin
   api_adc
   api_pwm
   api_servo
   api_motor
   api_modules
   api_robot
   api_music
   api_tts
   api_utils
   api_filedb
   api_i2c
   api_basic_class





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/source/api_music.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_music:

class ``Music``
========================================

.. warning::
    * You need to add ``sudo`` when running this script, in case the speaker doesn't work.
    * :ref:`faq_speaker`.

**Example**

Initialize

.. code-block:: python

    # Import Music class
    from robot_hat import Music

    # Create a new Music object
    music = Music()

Play tones

.. code-block:: python

    # You can directly play a frequency for specific duration in seconds
    music.play_tone_for(400, 1)

    # Or use note to get the frequency
    music.play_tone_for(music.note("Middle C"), 0.5)
    # and set tempo and use beat to get the duration in seconds
    # Which make's it easy to code a song according to a sheet!
    music.tempo(120)
    music.play_tone_for(music.note("Middle C"), music.beat(1))
    
    # Here's an example playing Greensleeves
    set_volume(80)
    music.tempo(60, 1/4)

    print("Measure 1")
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 2")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("C5"), music.beat(1/8))
    music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("D#5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 3")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 4")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 5")
    music.play_tone_for(music.note("A4"), music.beat(1/4))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    music.play_tone_for(music.note("D4"), music.beat(1/4))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 6")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("C5"), music.beat(1/8))
    music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("D#5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 7")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 8")
    music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("E4"), music.beat(1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    print("Measure 9")
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
    print("Measure 10")
    music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("F5"), music.beat(1/8))
    music.play_tone_for(music.note("E5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 11")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 12")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 13")
    music.play_tone_for(music.note("A4"), music.beat(1/4))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    music.play_tone_for(music.note("D4"), music.beat(1/4 + 1/8))
    print("Measure 14")
    music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("F5"), music.beat(1/8))
    music.play_tone_for(music.note("E5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 15")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 16")
    music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("E4"), music.beat(1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    print("Measure 17")
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))

Play sound

.. code-block:: python

    # Play a sound
    music.sound_play("file.wav", volume=50)
    # Play a sound in the background
    music.sound_play_threading("file.wav", volume=80)
    # Get sound length
    music.sound_length("file.wav")

Play Music

.. code-block:: python

    # Play music
    music.music_play("file.mp3")
    # Play music in loop
    music.music_play("file.mp3", loop=0)
    # Play music in 3 times
    music.music_play("file.mp3", loop=3)
    # Play music in starts from 2 second
    music.music_play("file.mp3", start=2)
    # Set music volume
    music.music_set_volume(50)
    # Stop music
    music.music_stop()
    # Pause music
    music.music_pause()
    # Resume music
    music.music_resume()

**API**

.. currentmodule:: robot_hat

.. autoclass:: Music
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/docs/make.bat
##################################################

@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=source
set BUILDDIR=build

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/README.md
##################################################

# Robot Hat

Robot Hat Python library for Raspberry Pi.

Quick Links:

- [Robot Hat](#robot-hat)
  - [About Robot Hat](#about-robot-hat)
  - [Update](#update)
  - [Installation](#installation)
  - [Trouble Shooting](#trouble-shooting)
  - [About SunFounder](#about-sunfounder)
  - [License](#license)
  - [Contact us](#contact-us)

## About Robot Hat

Robot HAT is a multifunctional expansion board that allows Raspberry Pi to be quickly turned into a robot. An MCU is on board to extend the PWM output and ADC input for the Raspberry Pi, as well as a motor driver chip, Bluetooth module, I2S audio module and mono speaker. As well as the GPIOs that lead out of the Raspberry Pi itself.


## Update
2023-11-29:
- Add more about Robot HAT's Hardware Introduction


2022-08-26:
- New Release

## Installation

```bash
git clone https://github.com/sunfounder/robot-hat.git -b v2.0
cd robot-hat
sudo python3 setup.py install

```

## Trouble Shooting

----------------------------------------------

## About SunFounder

SunFounder is a technology company focused on Raspberry Pi and Arduino open source community development. Committed to the promotion of open source culture, we strives to bring the fun of electronics making to people all around the world and enable everyone to be a maker. Our products include learning kits, development boards, robots, sensor modules and development tools. In addition to high quality products, SunFounder also offers video tutorials to help you make your own project. If you have interest in open source or making something cool, welcome to join us!

----------------------------------------------

## License

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied wa rranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

{Repository Name} comes with ABSOLUTELY NO WARRANTY; for details run ./show w. This is free software, and you are welcome to redistribute it under certain conditions; run ./show c for details.

SunFounder, Inc., hereby disclaims all copyright interest in the program '{Repository Name}' (which makes passes at compilers).

Mike Huang, 21 August 2015

Mike Huang, Chief Executive Officer

Email: service@sunfounder.com, support@sunfounder.com

----------------------------------------------

## Contact us

website:
    www.sunfounder.com

E-mail:
    service@sunfounder.com, support@sunfounder.com


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/setup.py
##################################################

#!/usr/bin/env python3
from os import path
import sys
import os

print('\033[0;33mThe "setup.py" installation method is planned to be abandoned.\n'
    'Please execute "install.py" to install.\n\033[0m')

if 'install' in sys.argv:
    here = path.abspath(path.dirname(__file__))
    os.chdir(here)
    args = ' '.join(sys.argv[1:])
    os.system(f'python3 install.py {args}')

    exit()

# necessary for pip3 install ./ , 
# if you need both `setup.py`` and `pyproject.toml`` to exist
from setuptools import setup
setup()



##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/install.py
##################################################

#!/usr/bin/env python3
from os import path
import sys
import os
import time
import threading

here = path.abspath(path.dirname(__file__))
os.chdir(here)
sys.path.append('./robot_hat')
from version import __version__

print("Robot Hat Python Library v%s" % __version__)

avaiable_options = ["--no-dep", "--only-lib", "--no-build-isolation"]
options = []
if len(sys.argv) > 1:
    options = list.copy(sys.argv[1:])


# define color print
# =================================================================
def warn(msg, end='\n', file=sys.stdout, flush=False):
    print(f'\033[0;33m{msg}\033[0m', end=end, file=file, flush=flush)

def error(msg, end='\n', file=sys.stdout, flush=False):
    print(f'\033[0;31m{msg}\033[0m', end=end, file=file, flush=flush)

# check if run as root
# =================================================================
if os.geteuid() != 0:
    warn("Script must be run as root. Try \"sudo python3 install.py\".")
    sys.exit(1)

# utils
# =================================================================
def run_command(cmd=""):
    import subprocess
    p = subprocess.Popen(cmd,
                         shell=True,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    result = p.stdout.read().decode('utf-8')
    status = p.poll()
    return status, result

errors = []
at_work_tip_sw = False

def working_tip():
    char = ['/', '-', '\\', '|']
    i = 0
    global at_work_tip_sw
    while at_work_tip_sw:
        i = (i + 1) % 4
        sys.stdout.write('\033[?25l')  # cursor invisible
        sys.stdout.write('%s\033[1D' % char[i])
        sys.stdout.flush()
        time.sleep(0.5)

    sys.stdout.write(' \033[1D')
    sys.stdout.write('\033[?25h')  # cursor visible
    sys.stdout.flush()


def do(msg="", cmd=""):
    print(" - %s ... " % (msg), end='', flush=True)
    # at_work_tip start
    global at_work_tip_sw
    at_work_tip_sw = True
    _thread = threading.Thread(target=working_tip)
    _thread.daemon = True
    _thread.start()
    # process run
    status, result = run_command(cmd)
    # print(status, result)
    # at_work_tip stop
    at_work_tip_sw = False
    _thread.join()  # wait for thread to finish
    # status
    if status == 0 or status == None or result == "":
        print('Done')
    else:
        print('Error')
        errors.append("%s error:\n  Status:%s\n  Error:%s" %
                      (msg, status, result))


def check_raspbain_version():
    _, result = run_command("cat /etc/debian_version|awk -F. '{print $1}'")
    return int(result.strip())


def check_os_bit():
    '''
    # import platform
    # machine_type = platform.machine() 
    latest bullseye uses a 64-bit kernel
    This method is no longer applicable, the latest raspbian will uses 64-bit kernel 
    (kernel 6.1.x) by default, "uname -m" shows "aarch64", 
    but the system is still 32-bit.
    '''
    _, os_bit = run_command("getconf LONG_BIT")
    return int(os_bit)

# check system
# =================================================================
raspbain_version = check_raspbain_version()
os_bit = check_os_bit()

# Dependencies list installed with apt
# =================================================================
APT_INSTALL_LIST = [
    'raspi-config',
    "i2c-tools",
    "espeak",
    'libsdl2-dev',
    'libsdl2-mixer-dev',
    'portaudio19-dev',  # pyaudio
    'sox',
]
if raspbain_version in [12] and os_bit == 64:
    APT_INSTALL_LIST.append("libttspico-utils")  # tts -> pico2wave

# Dependencies list installed with pip3
# =================================================================
PIP_INSTALL_LIST = [
    'smbus2',
    'gpiozero',
    'pyaudio',
    'spidev',
    'pyserial',
    'pillow',
    "'pygame>=2.1.2'",
]


# main
# =================================================================
def install():
    # check whether pip has the option "--break-system-packages"
    _is_bsps = ''
    status, _ = run_command("pip3 help install|grep break-system-packages")
    if status == 0: # if true
        _is_bsps = "--break-system-packages"

    # --- install robot_hat package ---
    _if_build_isolation = ""
    if "--no-build-isolation" in options:
        _if_build_isolation = "--no-build-isolation"
    do(msg=f"install robot_hat package {_if_build_isolation}",
       cmd=f'pip3 install ./ {_is_bsps} {_if_build_isolation}')

    # --- only-library ---
    if "--only-lib" not in options:
        # --- install dependencies ---
        if "--no-dep" not in options:
            # --------------------------------
            print("Install dependencies with apt-get:")
            # update apt-get
            do(msg="update apt-get", cmd='apt-get update')
            #
            for dep in APT_INSTALL_LIST:
                do(msg=f"install {dep}", cmd=f'apt-get install {dep} -y')
            #
            if 'libttspico-utils' not in APT_INSTALL_LIST:
                _pool = 'http://ftp.debian.org/debian/pool/non-free/s/svox/'
                if raspbain_version >= 12:
                    libttspico= 'libttspico0t64_1.0+git20130326-14.1_armhf.deb'
                    libttspico_utils = 'libttspico-utils_1.0+git20130326-14.1_armhf.deb'
                elif raspbain_version < 12:
                    libttspico = 'libttspico0_1.0+git20130326-11_armhf.deb'
                    libttspico_utils = 'libttspico-utils_1.0+git20130326-11_armhf.deb'
                do(msg="install pico2wave",
                    cmd=f'wget {_pool}{libttspico}' +
                    f' &&wget {_pool}{libttspico_utils}' +
                    f' && apt-get install -f ./{libttspico} ./{libttspico_utils} -y'
                    )
            # --------------------------------
            print("Install dependencies with pip3:")
            # check whether pip has the option "--break-system-packages"
            if _is_bsps != '':
                _is_bsps = "--break-system-packages"
                print(
                    "\033[38;5;8m pip3 install with --break-system-packages\033[0m"
                )
            # update pip
            do(msg="update pip3",
                cmd=f'python3 -m pip install --upgrade pip {_is_bsps}')
            #
            for dep in PIP_INSTALL_LIST:
                do(msg=f"install {dep}",
                    cmd=f'pip3 install {dep} {_is_bsps}')

        # --- Setup interfaces ---
        print("Setup interfaces")
        do(msg="turn on I2C", cmd='raspi-config nonint do_i2c 0')
        do(msg="turn on SPI", cmd='raspi-config nonint do_spi 0')

        # --- Copy servohat dtoverlay ---
        print("Copy dtoverlay")
        DEFAULT_OVERLAYS_PATH = "/boot/firmware/overlays/"
        LEGACY_OVERLAYS_PATH = "/boot/overlays/"
        _overlays_path = None
        if os.path.exists(DEFAULT_OVERLAYS_PATH):
            _overlays_path = DEFAULT_OVERLAYS_PATH
        elif os.path.exists(LEGACY_OVERLAYS_PATH):
            _overlays_path = LEGACY_OVERLAYS_PATH
        else:
            _overlays_path = None

        if _overlays_path is not None:
            do(msg="copy dtoverlay",
            cmd=f'cp ./dtoverlays/* {_overlays_path}')

    # --- Report error ---
    if len(errors) == 0:
        print("Finished")
    else:
        print("\n\nError happened in install process:")
        for error in errors:
            print(error)
        print(
            "Try to fix it yourself, or contact service@sunfounder.com with this message"
        )


if __name__ == "__main__":
    try:
        install()
    except KeyboardInterrupt:
        if len(errors) > 0:
            print("\n\nError happened in install process:")
            for error in errors:
                print(error)
            print(
                "Try to fix it yourself, or contact service@sunfounder.com with this message"
            )
        print("\n\nCanceled.")
    finally:
        sys.stdout.write(' \033[1D')
        sys.stdout.write('\033[?25h') # cursor visible 
        sys.stdout.flush()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/backup/i2samp.sh
##################################################

#!/bin/bash

: <<'DISCLAIMER'

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

This script is licensed under the terms of the MIT license.
Unless otherwise noted, code reproduced herein
was written for this script.

- The Pimoroni Crew - (modified by Adafruit!)

DISCLAIMER

# script control variables
# =================================================================
productname="i2s amplifier"                         # the name of the product to install
scriptname="i2samp"                                 # the name of this script
spacereq=1                                          # minimum size required on root partition in MB
debugmode="no"                                      # whether the script should use debug routines
debuguser="none"                                    # optional test git user to use in debug mode
debugpoint="none"                                   # optional git repo branch or tag to checkout
forcesudo="no"                                      # whether the script requires to be ran with root privileges
promptreboot="no"                                   # whether the script should always prompt user to reboot
mininstall="no"                                     # whether the script enforces minimum install routine
customcmd="yes"                                     # whether to execute commands specified before exit
armv6="yes"                                         # whether armv6 processors are supported
armv7="yes"                                         # whether armv7 processors are supported
armv8="yes"                                         # whether armv8 processors are supported
arm64="yes"                                         # whether arm64 processors are supported
raspbianonly="no"                                   # whether the script is allowed to run on other OSes
osreleases=("Raspbian")                             # list os-releases supported
oswarning=("Debian" "Kano" "Mate" "PiTop" "Ubuntu") # list experimental os-releases
osdeny=("Darwin" "Kali")                            # list os-releases specifically disallowed

FORCE=$1
DEVICE_TREE=true
ASK_TO_REBOOT=false
CURRENT_SETTING=false
UPDATE_DB=false

BOOTCMD=/boot/firmware/cmdline.txt
CONFIG=/boot/firmware/config.txt
APTSRC=/etc/apt/sources.list
INITABCONF=/etc/inittab
BLACKLIST=/etc/modprobe.d/raspi-blacklist.conf
LOADMOD=/etc/modules
DTBODIR=/boot/overlays

AUTO_SOUND_CARD=/usr/local/bin/auto_sound_card

# Fall back to old location
if ! test -f $CONFIG; then
    CONFIG=/boot/config.txt
fi

# function define
# =================================================================
confirm() {
    if [ "$FORCE" == '-y' ]; then
        true
    else
        read -r -p "$1 [y/N] " response </dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
    fi
}

prompt() {
    read -r -p "$1 [y/N] " response </dev/tty
    if [[ $response =~ ^(yes|y|Y)$ ]]; then
        true
    else
        false
    fi
}

success() {
    echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

inform() {
    echo -e "$(tput setaf 6)$1$(tput sgr0)"
}

warning() {
    echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

newline() {
    echo ""
}

progress() {
    count=0
    until [ $count -eq $1 ]; do
        echo -n "..." && sleep 1
        ((count++))
    done
    echo
}
sudocheck() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "Install must be run as root. Try 'sudo ./$scriptname'\n"
        exit 1
    fi
}

sysclean() {
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &>/dev/null
}

sysupdate() {
    if ! $UPDATE_DB; then
        echo "Updating apt indexes..." && progress 3 &
        sudo apt-get update 1>/dev/null || { warning "Apt failed to update indexes!" && exit 1; }
        echo "Reading package lists..."
        progress 3 && UPDATE_DB=true
    fi
}

sysupgrade() {
    sudo apt-get upgrade
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &>/dev/null
}

sysreboot() {
    warning "Some changes made to your system require"
    warning "your computer to reboot to take effect."
    newline
    if prompt "Would you like to reboot now?"; then
        sync && sudo reboot
    fi
}

arch_check() {
    IS_ARM64=false
    IS_ARMHF=false
    IS_ARMv6=false

    if uname -m | grep "aarch64" >/dev/null; then
        IS_ARM64=true
    fi
    if uname -m | grep "armv.l" >/dev/null; then
        IS_ARMHF=true
        if uname -m | grep "armv6l" >/dev/null; then
            IS_ARMv6=true
        fi
    fi
}

os_check() {
    IS_RASPBIAN=false
    IS_MACOSX=false
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "Raspbian" >/dev/null; then
            IS_RASPBIAN=true && IS_SUPPORTED=true
        fi
        if command -v apt-get >/dev/null; then
            for os in ${osreleases[@]}; do
                if cat /etc/os-release | grep $os >/dev/null; then
                    IS_SUPPORTED=true && IS_EXPERIMENTAL=false
                fi
            done
            for os in ${oswarning[@]}; do
                if cat /etc/os-release | grep $os >/dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=true
                fi
            done
            for os in ${osdeny[@]}; do
                if cat /etc/os-release | grep $os >/dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=false
                fi
            done
        fi
    fi
    if [ -d ~/.kano-settings ] || [ -d ~/.kanoprofile ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -f ~/.pt-dashboard-config ] || [ -d ~/.pt-dashboard ] || [ -d ~/.pt-os-dashboard ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -d ~/.config/ubuntu-mate ]; then
        for os in ${osdeny[@]}; do
            if [ $os == "Mate" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if uname -s | grep "Darwin" >/dev/null; then
        IS_MACOSX=true
        for os in ${osdeny[@]}; do
            if [ $os == "Darwin" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
}

raspbian_check() {
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "/sid" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bookworm" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bullseye" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "buster" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "stretch" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "jessie" >/dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "wheezy" >/dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        else
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        fi
    fi
}

# main
# =================================================================
: <<'MAINSTART'

Perform all global variables declarations as well as function definition
above this section for clarity, thanks!

MAINSTART

# check platform
#=======================
arch_check
os_check

if [ $debugmode != "no" ]; then
    echo "USER_HOME is $USER_HOME" && newline
    echo "IS_RASPBIAN is $IS_RASPBIAN"
    echo "IS_MACOSX is $IS_MACOSX"
    echo "IS_SUPPORTED is $IS_SUPPORTED"
    echo "IS_EXPERIMENTAL is $IS_EXPERIMENTAL"
    newline
fi

if ! $IS_ARMHF && ! $IS_ARM64; then
    warning "This hardware is not supported, sorry!"
    warning "Config files have been left untouched"
    newline && exit 1
fi

if $IS_ARM64 && [ $arm64 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv8 && [ $armv8 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv7 && [ $armv7 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv6 && [ $armv6 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
fi

if [ $raspbianonly == "yes" ] && ! $IS_RASPBIAN; then
    warning "This script is intended for Raspbian on a Raspberry Pi!"
    newline && exit 1
fi

if $IS_RASPBIAN; then
    raspbian_check
    if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
        newline && warning "--- Warning ---" && newline
        echo "The $productname installer"
        echo "does not work on this version of Raspbian."
        echo "Check https://github.com/$gitusername/$gitreponame"
        echo "for additional information and support"
        newline && exit 1
    fi
fi

if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
    warning "Your operating system is not supported, sorry!"
    newline && exit 1
fi

if $IS_EXPERIMENTAL; then
    warning "Support for your operating system is experimental. Please visit"
    warning "forums.adafruit.com if you experience issues with this product."
    newline
fi

if [ $forcesudo == "yes" ]; then
    sudocheck
fi

newline
echo "This script will install everything needed to use"
echo "$productname"
newline
warning "--- Warning ---"
newline
echo "Always be careful when running scripts and commands"
echo "copied from the internet. Ensure they are from a"
echo "trusted source."
newline
echo "If you want to see what this script does before"
echo "running it, you should run:"
echo "    \curl -sS github.com/adafruit/Raspberry-Pi-Installer-Scripts/$scriptname"
newline

# ask whether to continue
#=======================
if ! confirm "Do you wish to continue?"; then
    newline
    echo "Aborting..."
    newline
    exit 0
fi

# config dtoverlay
#=======================
newline
echo "Checking hardware requirements..."

if [ -e $CONFIG ] && grep -q "^device_tree=$" $CONFIG; then
    DEVICE_TREE=false
fi

if $DEVICE_TREE; then

    newline
    echo "Adding Device Tree Entry to $CONFIG"

    if [ -e $CONFIG ] && grep -q "^dtoverlay=hifiberry-dac$" $CONFIG; then
        echo "dtoverlay already active"
    else
        echo "dtoverlay=hifiberry-dac" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $CONFIG ] && grep -q "^dtoverlay=i2s-mmap$" $CONFIG; then
        echo "i2s mmap dtoverlay already active"
    else
        echo "dtoverlay=i2s-mmap" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $BLACKLIST ]; then
        newline
        echo "Commenting out Blacklist entry in "
        echo "$BLACKLIST"
        sudo sed -i -e "s|^blacklist[[:space:]]*i2c-bcm2708.*|#blacklist i2c-bcm2708|" \
            -e "s|^blacklist[[:space:]]*snd-soc-pcm512x.*|#blacklist snd-soc-pcm512x|" \
            -e "s|^blacklist[[:space:]]*snd-soc-wm8804.*|#blacklist snd-soc-wm8804|" $BLACKLIST &>/dev/null
    fi
else
    newline
    echo "No Device Tree Detected, not supported"
    newline
    exit 1
fi

# install alsa-utils
#=======================
sudo apt install alsa-utils -y

# aplay from /dev/zero at system start
#=======================
newline
echo "Installing aplay systemd unit"
sudo sh -c 'cat > /etc/systemd/system/aplay.service' <<'EOL'
[Unit]
Description=Invoke aplay from /dev/zero at system start.

[Service]
ExecStart=/usr/bin/aplay -D default -t raw -r 44100 -c 2 -f S16_LE /dev/zero

[Install]
WantedBy=multi-user.target
EOL

sudo systemctl daemon-reload
sudo systemctl disable aplay
newline
echo "You can optionally activate '/dev/zero' playback in"
echo "the background at boot. This will remove all"
echo "popping/clicking but does use some processor time."
newline
if confirm "Activate '/dev/zero' playback in background? [RECOMMENDED]"; then
    newline
    sudo systemctl enable aplay
    ASK_TO_REBOOT=true
fi

# config asound
#=======================
newline
echo "Configuring sound output"
# backup file
if [ -e /etc/asound.conf ]; then
    if [ -e /etc/asound.conf.old ]; then
        sudo rm -f /etc/asound.conf.old
    fi
    sudo cp /etc/asound.conf /etc/asound.conf.old
fi

# auto_sound_card scripts

sudo cat >/usr/local/bin/auto_sound_card <<'-EOF'
#!/bin/bash

ASOUND_CONF=/etc/asound.conf
AUDIO_CARD_NAME="sndrpihifiberry"

card_num=$(sudo aplay -l |grep $AUDIO_CARD_NAME |awk '{print $2}'|tr -d ':')
echo "card_num=$card_num"
if [ -n "$card_num" ]; then
    cat > $ASOUND_CONF << EOF
pcm.speakerbonnet {
    type hw card $card_num
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speakerbonnet"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw card $card_num
}

pcm.softvol {
    type softvol
    slave.pcm "dmixer"
    control.name "PCM"
    control.card $card_num
}

ctl.softvol {
    type hw card $card_num
}

pcm.!default {
    type             plug
    slave.pcm       "softvol"
}
EOF
    echo "systemctl restart aplay.service"
    sudo systemctl restart aplay.service

    if [ -n $1 ] && [ $1 -gt 0 ]; then
        echo "set volume to $1"
        amixer -c $card_num sset PCM $1%
    fi

fi

exit 0
-EOF

sudo chmod +x /usr/local/bin/auto_sound_card

# execute the script once
sudo /usr/local/bin/auto_sound_card 100

# add auto_sound_card start on boot
sudo cat >/etc/systemd/system/auto_sound_card.service <<EOF
[Unit]
Description=Auto config als sound card num at system start.
Wants=aplay.service

[Service]
ExecStart=/usr/local/bin/auto_sound_card

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable auto_sound_card

#=======================
newline
echo "We can now test your $productname"
warning "Set your speakers if possible!"
if confirm "Do you wish to test your system now?"; then
    echo "Testing..."
    # enable speaker
    if command -v pinctrl >/dev/null; then
        pinctrl set 20 op dh
    elif command -v raspi-gpio >/dev/null; then
        raspi-gpio set 20 op dh
    else
        warning "Could not find pinctrl or raspi-gpio"
    fi
    # test speaker
    speaker-test -l5 -c2 -t wav
fi
newline
success "All done!"
newline
echo "Enjoy your new $productname!"
newline

if [ $promptreboot == "yes" ] || $ASK_TO_REBOOT; then
    sysreboot
fi

# end
# =======================
exit 0


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/pin.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
import gpiozero  # https://gpiozero.readthedocs.io/en/latest/installing.html
from gpiozero import OutputDevice, InputDevice, Button


class Pin(_Basic_class):
    """Pin manipulation class"""

    OUT = 0x01
    """Pin mode output"""
    IN = 0x02
    """Pin mode input"""

    PULL_UP = 0x11
    """Pin internal pull up"""
    PULL_DOWN = 0x12
    """Pin internal pull down"""
    PULL_NONE = None
    """Pin internal pull none"""

    IRQ_FALLING = 0x21
    """Pin interrupt falling"""
    IRQ_RISING = 0x22
    """Pin interrupt falling"""
    IRQ_RISING_FALLING = 0x23
    """Pin interrupt both rising and falling"""

    _dict = {
        "D0": 17,
        "D1": 4,  # Changed
        "D2": 27,
        "D3": 22,
        "D4": 23,
        "D5": 24,
        "D6": 25,  # Removed
        "D7": 4,  # Removed
        "D8": 5,  # Removed
        "D9": 6,
        "D10": 12,
        "D11": 13,
        "D12": 19,
        "D13": 16,
        "D14": 26,
        "D15": 20,
        "D16": 21,
        "SW": 25,  # Changed
        "USER": 25,
        "LED": 26,
        "BOARD_TYPE": 12,
        "RST": 16,
        "BLEINT": 13,
        "BLERST": 20,
        "MCURST": 5,  # Changed
        "CE": 8,
    }

    def __init__(self, pin, mode=None, pull=None, active_state:bool=None, *args, **kwargs):
        """
        Initialize a pin

        :param pin: pin number of Raspberry Pi
        :type pin: int/str
        :param mode: pin mode(IN/OUT)
        :type mode: int
        :param pull: pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)
        :type pull: int
        :param active_state: active state of pin,  
                            If True, when the hardware pin state is HIGH, the software pin is HIGH. 
                            If False, the input polarity is reversed
        :type active_state: bool or None
        """
        super().__init__(*args, **kwargs)

        # parse pin
        if isinstance(pin, str):
            if pin not in self.dict().keys():
                raise ValueError(
                    f'Pin should be in {self._dict.keys()}, not "{pin}"')
            self._board_name = pin
            self._pin_num = self.dict()[pin]
        elif isinstance(pin, int):
            if pin not in self.dict().values():
                raise ValueError(
                    f'Pin should be in {self._dict.values()}, not "{pin}"')
            self._board_name = {i for i in self._dict if self._dict[i] == pin}
            self._pin_num = pin
        else:
            raise ValueError(
                f'Pin should be in {self._dict.keys()}, not "{pin}"')
        

        # setup
        self._value = 0
        self.gpio = None
        self.setup(mode, pull, active_state)
        self._info("Pin init finished.")

    def close(self):
        self.gpio.close()

    def deinit(self):
        self.gpio.close()
        self.gpio.pin_factory.close()

    def setup(self, mode, pull=None, active_state=None):
        """
        Setup the pin

        :param mode: pin mode(IN/OUT)
        :type mode: int
        :param pull: pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)
        :type pull: int
        """
        # check mode
        if mode in [None, self.OUT, self.IN]:
            self._mode = mode
        else:
            raise ValueError(
                f'mode param error, should be None, Pin.OUT, Pin.IN')
        # check pull
        if pull in [self.PULL_NONE, self.PULL_DOWN, self.PULL_UP]:
            self._pull = pull
        else:
            raise ValueError(
                f'pull param error, should be None, Pin.PULL_NONE, Pin.PULL_DOWN, Pin.PULL_UP'
            )
        #
        if self.gpio != None:
            if self.gpio.pin != None:
                self.gpio.close()
        #
        if mode in [None, self.OUT]:
            self.gpio = OutputDevice(self._pin_num)
        else:
            if pull == self.PULL_UP:
                self.gpio = InputDevice(self._pin_num, pull_up=True, active_state=None)
            elif pull == self.PULL_DOWN:
                self.gpio = InputDevice(self._pin_num, pull_up=False, active_state=None)
            else:
                self.gpio = InputDevice(self._pin_num, pull_up=None, active_state=active_state)

    def dict(self, _dict=None):
        """
        Set/get the pin dictionary

        :param _dict: pin dictionary, leave it empty to get the dictionary
        :type _dict: dict
        :return: pin dictionary
        :rtype: dict
        """
        if _dict == None:
            return self._dict
        else:
            if not isinstance(_dict, dict):
                raise ValueError(
                    f'Argument should be a pin dictionary like {{"my pin": ezblock.Pin.cpu.GPIO17}}, not {_dict}'
                )
            self._dict = _dict

    def __call__(self, value):
        """
        Set/get the pin value

        :param value: pin value, leave it empty to get the value(0/1)
        :type value: int
        :return: pin value(0/1)
        :rtype: int
        """
        return self.value(value)

    def value(self, value: bool = None):
        """
        Set/get the pin value

        :param value: pin value, leave it empty to get the value(0/1)
        :type value: int
        :return: pin value(0/1)
        :rtype: int
        """
        if value == None:
            if self._mode in [None, self.OUT]:
                self.setup(self.IN)
            result = self.gpio.value
            self._debug(f"read pin {self.gpio.pin}: {result}")
            return result
        else:
            if self._mode in [self.IN]:
                self.setup(self.OUT)
            if bool(value):
                value = 1
                self.gpio.on()
            else:
                value = 0
                self.gpio.off()
            return value

    def on(self):
        """
        Set pin on(high)

        :return: pin value(1)
        :rtype: int
        """
        return self.value(1)

    def off(self):
        """
        Set pin off(low)

        :return: pin value(0)
        :rtype: int
        """
        return self.value(0)

    def high(self):
        """
        Set pin high(1)

        :return: pin value(1)
        :rtype: int
        """
        return self.on()

    def low(self):
        """
        Set pin low(0)

        :return: pin value(0)
        :rtype: int
        """
        return self.off()

    def irq(self, handler, trigger, bouncetime=200, pull=None):
        """
        Set the pin interrupt

        :param handler: interrupt handler callback function
        :type handler: function
        :param trigger: interrupt trigger(RISING, FALLING, RISING_FALLING)
        :type trigger: int
        :param bouncetime: interrupt bouncetime in miliseconds
        :type bouncetime: int
        """
        # check trigger
        if trigger not in [
                self.IRQ_FALLING, self.IRQ_RISING, self.IRQ_RISING_FALLING
        ]:
            raise ValueError(
                f'trigger param error, should be None, Pin.IRQ_FALLING, Pin.IRQ_RISING, Pin.IRQ_RISING_FALLING'
            )

        # check pull
        if pull in [self.PULL_NONE, self.PULL_DOWN, self.PULL_UP]:
            self._pull = pull
            if pull == self.PULL_UP:
                _pull_up = True
            else:
                _pull_up = False
        else:
            raise ValueError(
                f'pull param error, should be None, Pin.PULL_NONE, Pin.PULL_DOWN, Pin.PULL_UP'
            )
        #
        pressed_handler = None
        released_handler = None
        #
        if not isinstance(self.gpio, Button):
            if self.gpio != None:
                self.gpio.close()
            self.gpio = Button(pin=self._pin_num,
                               pull_up=_pull_up,
                               bounce_time=float(bouncetime / 1000))
            self._bouncetime = bouncetime
        else:
            if bouncetime != self._bouncetime:
                pressed_handler = self.gpio.when_pressed
                released_handler = self.gpio.when_released
                self.gpio.close()
                self.gpio = Button(pin=self._pin_num,
                                   pull_up=_pull_up,
                                   bounce_time=float(bouncetime / 1000))
                self._bouncetime = bouncetime
        #
        if trigger in [None, self.IRQ_FALLING]:
            pressed_handler = handler
        elif trigger in [self.IRQ_RISING]:
            released_handler = handler
        elif trigger in [self.IRQ_RISING_FALLING]:
            pressed_handler = handler
            released_handler = handler
        #
        if pressed_handler is not None:
            self.gpio.when_pressed = pressed_handler
        if released_handler is not None:
            self.gpio.when_released = released_handler

    def name(self):
        """
        Get the pin name

        :return: pin name
        :rtype: str
        """
        return f"GPIO{self._pin_num}"


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/pwm.py
##################################################

#!/usr/bin/env python3
import math
from .i2c import I2C

timer = [{"arr": 1} for _ in range(7)]


class PWM(I2C):
    """Pulse width modulation (PWM)"""

    REG_CHN = 0x20
    """Channel register prefix"""
    REG_PSC = 0x40
    """Prescaler register prefix"""
    REG_ARR = 0x44
    """Period registor prefix"""
    REG_PSC2 = 0x50
    """Prescaler register prefix"""
    REG_ARR2 = 0x54
    """Period registor prefix"""

    ADDR = [0x14, 0x15, 0x16]

    CLOCK = 72000000.0
    """Clock frequency"""

    def __init__(self, channel, address=None, *args, **kwargs):
        """
        Initialize PWM

        :param channel: PWM channel number(0-19/P0-P19)
        :type channel: int/str
        """
        if address is None:
            super().__init__(self.ADDR, *args, **kwargs)
        else:
            super().__init__(address, *args, **kwargs)

        if isinstance(channel, str):
            if channel.startswith("P"):
                channel = int(channel[1:])
            else:
                raise ValueError(
                    f'PWM channel should be between [P0, P19], not "{channel}"')
        if isinstance(channel, int):
            if channel > 19 or channel < 0:
                raise ValueError(
                    f'channel must be in range of 0-19, not "{channel}"')

        self.channel = channel
        if channel < 16:
            self.timer_index = int(channel/4)
        elif channel == 16 or channel == 17:
            self.timer_index = 4
        elif channel == 18:
            self.timer_index = 5
        elif channel == 19:
            self.timer_index = 6

        self._pulse_width = 0
        self._freq = 50
        self.freq(50)

        # print(f'PWM channel {channel} initialized')
        # print(f'PWM timer_index {self.timer_index}')


    def _i2c_write(self, reg, value):
        value_h = value >> 8
        value_l = value & 0xff
        self.write([reg, value_h, value_l])

    def freq(self, freq=None):
        """
        Set/get frequency, leave blank to get frequency

        :param freq: frequency(0-65535)(Hz)
        :type freq: float
        :return: frequency
        :rtype: float
        """
        if freq == None:
            return self._freq

        self._freq = int(freq)
        # [prescaler,arr] list
        result_ap = []
        # accuracy list
        result_acy = []
        # middle value for equal arr prescaler
        st = int(math.sqrt(self.CLOCK/self._freq))
        # get -5 value as start
        st -= 5
        # prevent negetive value
        if st <= 0:
            st = 1
        for psc in range(st, st+10):
            arr = int(self.CLOCK/self._freq/psc)
            result_ap.append([psc, arr])
            result_acy.append(abs(self._freq-self.CLOCK/psc/arr))
        i = result_acy.index(min(result_acy))
        psc = result_ap[i][0]
        arr = result_ap[i][1]
        self._debug(f"prescaler: {psc}, period: {arr}")
        self.prescaler(psc)
        self.period(arr)

    def prescaler(self, prescaler=None):
        """
        Set/get prescaler, leave blank to get prescaler

        :param prescaler: prescaler(0-65535)
        :type prescaler: int
        :return: prescaler
        :rtype: int
        """
        if prescaler == None:
            return self._prescaler

        self._prescaler = round(prescaler)
        self._freq = self.CLOCK/self._prescaler/timer[self.timer_index]["arr"]
        if self.timer_index < 4:
            reg = self.REG_PSC + self.timer_index
        else:
            reg = self.REG_PSC2 + self.timer_index - 4
        self._debug(f"Set prescaler to: {self._prescaler}")
        self._i2c_write(reg, self._prescaler-1)

    def period(self, arr=None):
        """
        Set/get period, leave blank to get period

        :param arr: period(0-65535)
        :type arr: int
        :return: period
        :rtype: int
        """
        global timer
        if arr == None:
            return timer[self.timer_index]["arr"]

        timer[self.timer_index]["arr"] = round(arr)
        self._freq = self.CLOCK/self._prescaler/timer[self.timer_index]["arr"]

        if self.timer_index < 4:
            reg = self.REG_ARR + self.timer_index
        else:
            reg = self.REG_ARR2 + self.timer_index - 4

        self._debug(f"Set arr to: {timer[self.timer_index]['arr']}")
        self._i2c_write(reg, timer[self.timer_index]["arr"])

    def pulse_width(self, pulse_width=None):
        """
        Set/get pulse width, leave blank to get pulse width

        :param pulse_width: pulse width(0-65535)
        :type pulse_width: float
        :return: pulse width
        :rtype: float
        """
        if pulse_width == None:
            return self._pulse_width

        self._pulse_width = int(pulse_width)
        reg = self.REG_CHN + self.channel
        self._i2c_write(reg, self._pulse_width)

    def pulse_width_percent(self, pulse_width_percent=None):
        """
        Set/get pulse width percentage, leave blank to get pulse width percentage

        :param pulse_width_percent: pulse width percentage(0-100)
        :type pulse_width_percent: float
        :return: pulse width percentage
        :rtype: float
        """
        global timer
        if pulse_width_percent == None:
            return self._pulse_width_percent

        self._pulse_width_percent = pulse_width_percent
        temp = self._pulse_width_percent / 100.0
        pulse_width = temp * timer[self.timer_index]["arr"]
        self.pulse_width(pulse_width)


def test():
    import time
    p = PWM(0, debug_level='debug')
    p.period(1000)
    p.prescaler(10)
    # p.pulse_width(2048)
    while True:
        for i in range(0, 4095, 10):
            p.pulse_width(i)
            print(i)
            time.sleep(1/4095)
        time.sleep(1)
        for i in range(4095, 0, -10):
            p.pulse_width(i)
            print(i)
            time.sleep(1/4095)
        time.sleep(1)


def test2():
    p = PWM("P0", debug_level='debug')
    p.pulse_width_percent(50)
    # while True:
    #     p.pulse_width_percent(50)


if __name__ == '__main__':
    test2()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/config.py
##################################################

import os
from time import sleep

class Config():

    def __init__(self, path:str, mode:str=None, owner:str=None, description=None):
        self.path = path
        # check path
        if self.path != None:
            self.file_check_create(self.path, mode, owner, description)
        #
        self._dict = {}
        self.read()

    def __getitem__(self, key):
        return self._dict[key]
    
    def __setitem__(self, key, value):
        self._dict[key] = value


    def file_check_create(self, path:str, mode:str=None, owner:str=None, description=None):
        dir = path.rsplit('/', 1)[0] # rsplit(), split from right; split(), split from left
        try:
            # check file
            if os.path.exists(path):
                if not os.path.isfile(path):
                    print('Could not create file, there is a folder with the same name')
                    return
                else:
                    # file already exists
                    pass
            else:
                # check directory
                if os.path.exists(dir):
                    if not os.path.isdir(dir):
                        print('Could not create file, there is a file with the same name')
                        return
                    else:
                        # dir already exists
                        pass
                else:
                    # create directory
                    os.makedirs(dir, mode=0o754) # makedirs， make multi-level directories
                    sleep(0.001)

                # create file
                with open(path, 'w') as f:
                    if description != None:
                        lines = description.split('\n')
                        _desc = ''
                        for line in lines:
                            _desc += '# '+line+'\n'
                        _desc += '\n'
                        f.write(_desc)
                    else:
                        f.write('')

                # set mode
                if mode != None:
                    os.popen('sudo chmod %s %s'%(mode, path))
                # set owner
                if owner != None:
                    os.popen('sudo chown -R %s:%s %s'%(owner, owner, dir))
        except Exception as e:
            raise(e)

    @staticmethod
    def _read(path):
        _dict = {}
        with open(path, 'r') as f:
            lines = f.readlines()
            section = ''
            _dict[section] = {}
            for line in lines:
                line = line.strip()
                if len(line) == 0:
                    continue
                if line[0] == '#':
                    continue
                elif line[0] == '[':
                    section = line[1:-1].strip()
                    _dict[section] = {}
                elif '=' in line:
                    option, value = line.split('=', 1)
                    option = option.strip()
                    value = value.strip()
                    # print(section, option, value)
                    _dict[section][option] = value
                else:
                    pass
        return _dict

    @staticmethod
    def _write(path, dict):
        part = {}
        _dict = dict.copy()
        # print(id(_dict), id(dict))
        _sections = list(_dict.keys())
        # print(f'_sections: {_sections}')
        with open(path, 'r') as f:
            lines = f.readlines()
            section = ''
            part[section] = []
            for line in lines:
                line = line.strip()
                if len(line) == 0:
                    part[section].append('\n')
                elif line[0] == '#':
                    part[section].append(line+'\n')
                elif line[0] == '[':
                    # fill items not added in last section
                    if section in _sections:
                        for option, value in _dict[section].items():
                            part[section].append(f'{option} = {value}\n')
                        _dict.pop(section)
                    # next section
                    section = line[1:-1].strip()
                    part[section] = []
                    part[section].append(line+'\n')
                elif '=' in line:
                    option, value = line.split('=', 1)
                    option = option.strip()
                    value = value.strip()
                    if section in _sections and option in _dict[section].keys():
                        value = _dict[section][option]
                        _dict[section].pop(option)
                    part[section].append(f'{option} = {value}\n')
                else:
                    part[section].append(line+'\n')
            # --------------------------------------------------
            # fill items not added in last section
            if section in _sections:
                for option, value in _dict[section].items():
                    part[section].append(f'{option} = {value}\n')
                _dict.pop(section)

            # print(f'new sections: {_dict.keys()}')
            sections = list(_dict.keys())
            for _section in sections:
                part[_section] = []
                part[_section].append(f'[{_section}]\n')
                for option, value in _dict[_section].items():
                    part[_section].append(f'{option} = {value}\n')
                part[_section].append('\n')
                _dict.pop(_section)

        # write new contents to file
        with open(path, 'w') as f:
            for _section in part.keys():
                for line in part[_section]:
                    f.write(line)

        # print new contents
        # for _section in part:
        #     for line in part[_section]:
        #         print(line, end='', flush=True)

    def read(self):
        self._dict = self._read(self.path)
        return self._dict

    def write(self):
        self._write(self.path, self._dict)

    def get(self, section, option, default=None):
        if section not in self._dict.keys():
            self._dict[section] = {}
            self._dict[section][option] = str(default)
        elif option not in self._dict[section].keys():
            self._dict[section][option] = str(default)
        #
        return self._dict[section][option]

    def set(self, section, option, value):
        if section not in self._dict.keys():
            self._dict[section] = {}
        self._dict[section][option] = value


if __name__ == '__main__':
    # description = 'robot-hat config test\nhello'
    description = '''
    robot-hat config test
    hello
    world
'''
    config = Config(path='/opt/robot-hat/test.config',
                    mode='775',
                    owner='xo', 
                    description=description)

    print(config.read()) # read config file to dict

    config['section1'] = {}
    config['section1']['option1'] = '1234'

    config['section2'] = {'option1': '100'}
    print(config.read())
 
    config.write() # write dict to config file

    print(config.get('section2', 'option1'))
    print(config.get('section3', 'option1', default='hello'))

    config.set('section4', 'option1', 'hi')
    config.write()





##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/version.py
##################################################

__version__ = '2.3.5'


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/servo.py
##################################################

#!/usr/bin/env python3
from .pwm import PWM
from .utils import mapping


class Servo(PWM):
    """Servo motor class"""
    MAX_PW = 2500
    MIN_PW = 500
    FREQ = 50
    PERIOD = 4095

    def __init__(self, channel, address=None, *args, **kwargs):
        """
        Initialize the servo motor class

        :param channel: PWM channel number(0-14/P0-P14)
        :type channel: int/str
        """
        super().__init__(channel, address, *args, **kwargs)
        self.period(self.PERIOD)
        prescaler = self.CLOCK / self.FREQ / self.PERIOD
        self.prescaler(prescaler)

    def angle(self, angle):
        """
        Set the angle of the servo motor

        :param angle: angle(-90~90)
        :type angle: float
        """
        if not (isinstance(angle, int) or isinstance(angle, float)):
            raise ValueError(
                "Angle value should be int or float value, not %s" % type(angle))
        if angle < -90:
            angle = -90
        if angle > 90:
            angle = 90
        self._debug(f"Set angle to: {angle}")
        pulse_width_time = mapping(angle, -90, 90, self.MIN_PW, self.MAX_PW)
        self._debug(f"Pulse width: {pulse_width_time}")
        self.pulse_width_time(pulse_width_time)

    def pulse_width_time(self, pulse_width_time):
        """
        Set the pulse width of the servo motor

        :param pulse_width_time: pulse width time(500~2500)
        :type pulse_width_time: float
        """
        if pulse_width_time > self.MAX_PW:
            pulse_width_time = self.MAX_PW
        if pulse_width_time < self.MIN_PW:
            pulse_width_time = self.MIN_PW

        pwr = pulse_width_time / 20000
        self._debug(f"pulse width rate: {pwr}")
        value = int(pwr * self.PERIOD)
        self._debug(f"pulse width value: {value}")
        self.pulse_width(value)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/motor.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .pwm import PWM
from .pin import Pin
from .filedb import fileDB

class Motor():
    """Motor"""
    PERIOD = 4095
    PRESCALER = 10
    DEFAULT_FREQ = 100 # Hz

    '''
    motor mode 1: (TC1508S)
                pin_a: PWM    pin_b: IO
    forward      pwm            1
    backward     pwm            0
    stop         0              x

    motor mode 2: (TC618S)
                pin_a: PWM    pin_b: PWM
    forward      pwm            0
    backward     0             pwm
    stop         0              0
    brake        1              1
    '''

    def __init__(self, pwm, dir, is_reversed=False, mode=None, freq=DEFAULT_FREQ):
        """
        Initialize a motor

        :param pwm: Motor speed control pwm pin
        :type pwm: robot_hat.pwm.PWM
        :param dir: Motor direction control pin
        :type dir: robot_hat.pin.Pin
        """
        if mode == None:
            from . import __device__
            self.mode = __device__.motor_mode
        else:
            self.mode = mode

        # mode 1: (TC1508S)
        if self.mode == 1:
            if not isinstance(pwm, PWM):
                raise TypeError("pin_a must be a class PWM")
            if not isinstance(dir, Pin):
                raise TypeError("pin_b must be a class Pin")

            self.pwm = pwm
            self.dir = dir
            self.freq = freq
            self.pwm.freq(self.freq)
            self.pwm.pulse_width_percent(0)
        # mode 2: (TC618S)
        elif self.mode == 2:
            if not isinstance(pwm, PWM):
                raise TypeError("pin_a must be a class PWM")
            if not isinstance(dir, PWM):
                raise TypeError("pin_b must be a class PWM")

            self.freq = freq
            self.pwm_a = pwm
            self.pwm_a.freq(self.freq)
            self.pwm_a.pulse_width_percent(0)
            self.pwm_b = dir
            self.pwm_b.freq(self.freq)
            self.pwm_b.pulse_width_percent(0)
        # unkowned mode
        else:
            raise ValueError("Unkown motors mode")

        self._speed = 0
        self._is_reverse = is_reversed

    def speed(self, speed=None):
        """
        Get or set motor speed

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        if speed is None:
            return self._speed

        dir = 1 if speed > 0 else 0
        if self._is_reverse:
            # dir = dir + 1 & 1
            dir = dir ^ 1 # XOR
        speed = abs(speed)

        # mode 1: (TC1508S)
        if self.mode == 1:
            self.pwm.pulse_width_percent(speed)
            self.dir.value(dir)
        # mode 2: (TC618S)
        elif self.mode ==2:
            if dir == 1:
                self.pwm_a.pulse_width_percent(speed)
                self.pwm_b.pulse_width_percent(0)
            else:
                self.pwm_a.pulse_width_percent(0)
                self.pwm_b.pulse_width_percent(speed)
        # unkowned mode
        else:
            raise ValueError("Unkown motors mode")
        

    def set_is_reverse(self, is_reverse):
        """
        Set motor is reversed or not

        :param is_reverse: True or False
        :type is_reverse: bool
        """
        self._is_reverse = is_reverse


class Motors(_Basic_class):
    """Motors"""

    DB_FILE = "motors.db"

    MOTOR_1_PWM_PIN = "P13"
    MOTOR_1_DIR_PIN = "D4"
    MOTOR_2_PWM_PIN = "P12"
    MOTOR_2_DIR_PIN = "D5"
    config_file = "/opt/robot_hat/default_motors.config"
    def __init__(self, db=config_file, *args, **kwargs):
        """
        Initialize motors with robot_hat.motor.Motor

        :param db: config file path
        :type db: str
        """
        super().__init__(*args, **kwargs)

        self.db = fileDB(db=db, mode='774', owner=User)
        self.left_id = int(self.db.get("left", default_value=0))
        self.right_id = int(self.db.get("right", default_value=0))
        left_reversed = bool(self.db.get(
            "left_reverse", default_value=False))
        right_reversed = bool(self.db.get(
            "right_reverse", default_value=False))

        self.motors = [
            Motor(PWM(self.MOTOR_1_PWM_PIN), Pin(self.MOTOR_1_DIR_PIN)),
            Motor(PWM(self.MOTOR_2_PWM_PIN), Pin(self.MOTOR_2_DIR_PIN))
        ]
        if self.left_id != 0:
            self.left.set_is_reverse(left_reversed)
        if self.right_id != 0:
            self.right.set_is_reverse(right_reversed)

    def __getitem__(self, key):
        """Get specific motor"""
        return self.motors[key-1]

    def stop(self):
        """Stop all motors"""
        for motor in self.motors:
            motor.speed(0)

    @property
    def left(self):
        """left motor"""
        if self.left_id not in range(1, 3):
            raise ValueError(
                "left motor is not set yet, set it with set_left_id(1/2)")
        return self.motors[self.left_id-1]

    @property
    def right(self):
        """right motor"""
        if self.left_id not in range(1, 3):
            raise ValueError(
                "left motor is not set yet, set it with set_left_id(1/2)")
        return self.motors[self.right_id-1]

    def set_left_id(self, id):
        """
        Set left motor id, this function only need to run once
        It will save the motor id to config file, and load
        the motor id when the class is initialized

        :param id: motor id (1 or 2)
        :type id: int
        """
        if id not in range(1, 3):
            raise ValueError("Motor id must be 1 or 2")
        self.left_id = id
        self.db.set("left", id)

    def set_right_id(self, id):
        """
        Set right motor id, this function only need to run once
        It will save the motor id to config file, and load
        the motor id when the class is initialized

        :param id: motor id (1 or 2)
        :type id: int
        """
        if id not in range(1, 3):
            raise ValueError("Motor id must be 1 or 2")
        self.right_id = id
        self.db.set("right", id)

    def set_left_reverse(self):
        """
        Set left motor reverse, this function only need to run once
        It will save the reversed status to config file, and load
        the reversed status when the class is initialized

        :return: if currently is reversed
        :rtype: bool
        """
        is_reversed = bool(self.db.get("left_reverse", default_value=False))
        is_reversed = not is_reversed
        self.db.set("left_reverse", is_reversed)
        self.left.set_is_reverse(is_reversed)
        return is_reversed

    def set_right_reverse(self):
        """
        Set right motor reverse, this function only need to run once
        It will save the reversed status to config file, and load
        the reversed status when the class is initialized

        :return: if currently is reversed
        :rtype: bool
        """
        is_reversed = bool(self.db.get("right_reverse", default_value=False))
        is_reversed = not is_reversed
        self.db.set("right_reverse", is_reversed)
        self.right.set_is_reverse(is_reversed)
        return is_reversed

    def speed(self, left_speed, right_speed):
        """
        Set motor speed

        :param left_speed: left motor speed(-100.0~100.0)
        :type left_speed: float
        :param right_speed: right motor speed(-100.0~100.0)
        :type right_speed: float
        """
        self.left.speed(left_speed)
        self.right.speed(right_speed)

    def forward(self, speed):
        """
        Forward

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(speed, speed)

    def backward(self, speed):
        """
        Backward

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(-speed, -speed)

    def turn_left(self, speed):
        """
        Left turn

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(-speed, speed)

    def turn_right(self, speed):
        """
        Right turn

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(speed, -speed)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/device.py
##################################################

import os

class Devices():
    HAT_DEVICE_TREE = "/proc/device-tree/"
    HAT_UUIDs = [
        "9daeea78-0000-076e-0032-582369ac3e02", # robothat5 1902v50
        ]

    DEVICES = {
        "robot_hat_v4x": {
            "uuid": None,
            "speaker_enbale_pin": 20,
            "motor_mode": 1,
        }, 
        "robot_hat_v5x": {
            "uuid": HAT_UUIDs[0],
            "speaker_enbale_pin": 12,
            "motor_mode": 2,
        }
    }

    name = ""
    product_id = 0
    product_ver = 0
    uuid = ""
    vendor = ""
    spk_en = 20
    motor_mode = 1

    def __init__(self):
        hat_path = None
        for file in os.listdir('/proc/device-tree/'):
            if 'hat' in file:
                # print("hat detected")
                if os.path.exists(f"/proc/device-tree/{file}/uuid") \
                    and os.path.isfile(f"/proc/device-tree/{file}/uuid"):
                    # print("uuid detected")
                    with open(f"/proc/device-tree/{file}/uuid", "r") as f:
                        uuid = f.read()[:-1] # [:-1] rm \x00
                        if uuid in self.HAT_UUIDs:
                            hat_path = f"/proc/device-tree/{file}"
                            break

        if hat_path is not None:
            with open(f"{hat_path}/product", "r") as f:
                self.name = f.read()
            with open(f"{hat_path}/product_id", "r") as f:
                self.product_id = f.read()[:-1] # [:-1] rm \x00
                self.product_id = int(self.product_id, 16)
            with open(f"{hat_path}/product_ver", "r") as f:
                self.product_ver = f.read()[:-1]
                self.product_ver = int(self.product_ver, 16)
            with open(f"{hat_path}/uuid", "r") as f:
                self.uuid = f.read()[:-1] # [:-1] rm \x00
            with open(f"{hat_path}/vendor", "r") as f:
                self.vendor = f.read()

            for device in self.DEVICES:
                if self.DEVICES[device]['uuid'] == self.uuid:
                    self.spk_en = self.DEVICES[device]["speaker_enbale_pin"]
                    self.motor_mode = self.DEVICES[device]["motor_mode"]
                    break

if __name__ == "__main__":
    device = Devices()
    print(f'name: {device.name}')
    print(f'product_id: {device.product_id}')
    print(f'product_ver: {device.product_ver}')
    print(f'vendor: {device.vendor}')
    print(f'uuid: {device.uuid}')
    print(f'speaker_enbale_pin: {device.spk_en}')
    print(f'motor_mode: {device.motor_mode}')


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/i2c.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .utils import run_command
from smbus2 import SMBus
import multiprocessing


def _retry_wrapper(func):

    def wrapper(self, *arg, **kwargs):
        for _ in range(self.RETRY):
            try:
                return func(self, *arg, **kwargs)
            except OSError:
                self._debug(f"OSError: {func.__name__}")
                continue
        else:
            return False

    return wrapper


class I2C(_Basic_class):
    """
    I2C bus read/write functions
    """
    RETRY = 5

    # i2c_lock = multiprocessing.Value('i', 0)

    def __init__(self, address=None, bus=1, *args, **kwargs):
        """
        Initialize the I2C bus

        :param address: I2C device address
        :type address: int
        :param bus: I2C bus number
        :type bus: int
        """
        super().__init__(*args, **kwargs)
        self._bus = bus
        self._smbus = SMBus(self._bus)
        if isinstance(address, list):
            connected_devices = self.scan()
            for _addr in address:
                if _addr in connected_devices:
                    self.address = _addr
                    break
            else:
                self.address = address[0]
        else:
            self.address = address

        # print(f'address: 0x{self.address:02X}')

    @_retry_wrapper
    def _write_byte(self, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(f"_write_byte: [0x{data:02X}]")
        result = self._smbus.write_byte(self.address, data)
        return result

    @_retry_wrapper
    def _write_byte_data(self, reg, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(f"_write_byte_data: [0x{reg:02X}] [0x{data:02X}]")
        return self._smbus.write_byte_data(self.address, reg, data)

    @_retry_wrapper
    def _write_word_data(self, reg, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(f"_write_word_data: [0x{reg:02X}] [0x{data:04X}]")
        return self._smbus.write_word_data(self.address, reg, data)

    @_retry_wrapper
    def _write_i2c_block_data(self, reg, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(
            f"_write_i2c_block_data: [0x{reg:02X}] {[f'0x{i:02X}' for i in data]}"
        )
        return self._smbus.write_i2c_block_data(self.address, reg, data)

    @_retry_wrapper
    def _read_byte(self):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_byte(self.address)
        self._debug(f"_read_byte: [0x{result:02X}]")
        return result

    @_retry_wrapper
    def _read_byte_data(self, reg):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_byte_data(self.address, reg)
        self._debug(f"_read_byte_data: [0x{reg:02X}] [0x{result:02X}]")
        return result

    @_retry_wrapper
    def _read_word_data(self, reg):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_word_data(self.address, reg)
        result_list = [result & 0xFF, (result >> 8) & 0xFF]
        self._debug(f"_read_word_data: [0x{reg:02X}] [0x{result:04X}]")
        return result_list

    @_retry_wrapper
    def _read_i2c_block_data(self, reg, num):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_i2c_block_data(self.address, reg, num)
        self._debug(
            f"_read_i2c_block_data: [0x{reg:02X}] {[f'0x{i:02X}' for i in result]}"
        )
        return result

    @_retry_wrapper
    def is_ready(self):
        """Check if the I2C device is ready

        :return: True if the I2C device is ready, False otherwise
        :rtype: bool
        """
        addresses = self.scan()
        if self.address in addresses:
            return True
        else:
            return False

    def scan(self):
        """Scan the I2C bus for devices

        :return: List of I2C addresses of devices found
        :rtype: list
        """
        cmd = f"i2cdetect -y {self._bus}"
        # Run the i2cdetect command
        _, output = run_command(cmd)

        # Parse the output
        outputs = output.split('\n')[1:]
        addresses = []
        addresses_str = []
        for tmp_addresses in outputs:
            if tmp_addresses == "":
                continue
            tmp_addresses = tmp_addresses.split(':')[1]
            # Split the addresses into a list
            tmp_addresses = tmp_addresses.strip().split(' ')
            for address in tmp_addresses:
                if address != '--':
                    addresses.append(int(address, 16))
                    addresses_str.append(f'0x{address}')
        self._debug(f"Conneceted i2c device: {addresses_str}")
        return addresses

    def write(self, data):
        """Write data to the I2C device

        :param data: Data to write
        :type data: int/list/bytearray
        :raises: ValueError if write is not an int, list or bytearray
        """
        if isinstance(data, bytearray):
            data_all = list(data)
        elif isinstance(data, int):
            if data == 0:
                data_all = [0]
            else:
                data_all = []
                while data > 0:
                    data_all.append(data & 0xFF)
                    data >>= 8
        elif isinstance(data, list):
            data_all = data
        else:
            raise ValueError(
                f"write data must be int, list, or bytearray, not {type(data)}"
            )

        # Write data
        if len(data_all) == 1:
            data = data_all[0]
            self._write_byte(data)
        elif len(data_all) == 2:
            reg = data_all[0]
            data = data_all[1]
            self._write_byte_data(reg, data)
        elif len(data_all) == 3:
            reg = data_all[0]
            data = (data_all[2] << 8) + data_all[1]
            self._write_word_data(reg, data)
        else:
            reg = data_all[0]
            data = list(data_all[1:])
            self._write_i2c_block_data(reg, data)

    def read(self, length=1):
        """Read data from I2C device

        :param length: Number of bytes to receive
        :type length: int
        :return: Received data
        :rtype: list
        """
        if not isinstance(length, int):
            raise ValueError(f"length must be int, not {type(length)}")

        result = []
        for _ in range(length):
            result.append(self._read_byte())
        return result

    def mem_write(self, data, memaddr):
        """Send data to specific register address

        :param data: Data to send, int, list or bytearray
        :type data: int/list/bytearray
        :param memaddr: Register address
        :type memaddr: int
        :raise ValueError: If data is not int, list, or bytearray
        """
        if isinstance(data, bytearray):
            data_all = list(data)
        elif isinstance(data, list):
            data_all = data
        elif isinstance(data, int):
            data_all = []
            if data == 0:
                data_all = [0]
            else:
                while data > 0:
                    data_all.append(data & 0xFF)
                    data >>= 8
        else:
            raise ValueError(
                "memery write require arguement of bytearray, list, int less than 0xFF"
            )
        self._write_i2c_block_data(memaddr, data_all)

    def mem_read(self, length, memaddr):
        """Read data from specific register address

        :param length: Number of bytes to receive
        :type length: int
        :param memaddr: Register address
        :type memaddr: int
        :return: Received bytearray data or False if error
        :rtype: list/False
        """
        result = self._read_i2c_block_data(memaddr, length)
        return result

    def is_avaliable(self):
        """
        Check if the I2C device is avaliable

        :return: True if the I2C device is avaliable, False otherwise
        :rtype: bool
        """
        return self.address in self.scan()

    def __del__(self):
        self._smbus.close()
        self._smbus = None

if __name__ == "__main__":
    i2c = I2C(address=[0x17, 0x15], debug_level='debug')

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/tts.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .utils import is_installed, run_command
from .music import Music
from distutils.spawn import find_executable


class TTS(_Basic_class):
    """Text to speech class"""
    _class_name = 'TTS'
    SUPPORTED_LANGUAUE = [
        'en-US',
        'en-GB',
        'de-DE',
        'es-ES',
        'fr-FR',
        'it-IT',
    ]
    """Supported TTS language for pico2wave"""

    ESPEAK = 'espeak'
    """espeak TTS engine"""
    ESPEAK_NG = 'espeak-ng'
    """espeak-ng TTS engine"""
    PICO2WAVE = 'pico2wave'
    """pico2wave TTS engine"""

    def __init__(self, engine=PICO2WAVE, lang=None, *args, **kwargs):
        """
        Initialize TTS class.

        :param engine: TTS engine, TTS.PICO2WAVE, TTS.ESPEAK, or TTS.ESPEAK_NG
        :type engine: str
        """
        super().__init__()
        self.engine = engine
        if (engine == self.ESPEAK or engine == self.ESPEAK_NG):
            if not is_installed(engine):
                raise Exception(f"TTS engine: {engine} is not installed.")
            self._amp = 100
            self._speed = 175
            self._gap = 5
            self._pitch = 50
            if lang == None:
                self._lang = "en-us"
            else:
                self._lang = lang
            self._supported_lang = _get_supported_lang_espeak(engine)
        elif (engine == self.PICO2WAVE):
            if not is_installed("pico2wave"):
                raise Exception("TTS engine: pico2wave is not installed.")
            if lang == None:
                self._lang = "en-US"
            else:
                self._lang = lang
            self._supported_lang = self.SUPPORTED_LANGUAUE

    def _check_executable(self, executable):
        executable_path = find_executable(executable)
        found = executable_path is not None
        return found

    def say(self, words):
        """
        Say words.

        :param words: words to say.
        :type words: str
        """
        words = words.replace("'", "\\'")
        eval(f"self.{self.engine.replace('-', '_')}('{words}')")

    def _espeak(self, engine, words):
        """
        Say words with espeak.

        :param words: words to say.
        :type words: str
        """
        self._debug(f'{engine}: [{words}]')
        if not self._check_executable(engine):
            self._debug(f'{engine} is busy. Pass')

        cmd = f'{engine} -v{self._lang} -a{self._amp} -s{self._speed} -g{self._gap} -p{self._pitch} "{words}" --stdout | aplay 2>/dev/null & '
        status, result = run_command(cmd)
        if len(result) != 0:
            raise (f'tts-espeak:\n\t{result}')
        self._debug(f'command: {cmd}')

    def espeak(self, words):
        self._espeak('espeak', words)

    def espeak_ng(self, words):
        self._espeak('espeak-ng', words)

    def pico2wave(self, words):
        """
        Say words with pico2wave.

        :param words: words to say.
        :type words: str
        """
        self._debug(f'pico2wave: [{words}]')
        if not self._check_executable('pico2wave'):
            self._debug('pico2wave is busy. Pass')

        cmd = f'pico2wave -l {self._lang} -w /tmp/tts.wav "{words}" && aplay /tmp/tts.wav 2>/dev/null & '
        status, result = run_command(cmd)
        if len(result) != 0:
            raise (f'tts-pico2wav:\n\t{result}')
        self._debug(f'command: {cmd}')

    def lang(self, *value):
        """
        Set/get language. leave empty to get current language.

        :param value: language.
        :type value: str
        """
        if len(value) == 0:
            return self._lang
        elif len(value) == 1:
            v = value[0]
            if v in self._supported_lang:
                self._lang = v
                return self._lang
        raise ValueError(
            f'Arguement "{value}" is not supported. run tts.supported_lang to get supported language type.'
        )

    def supported_lang(self):
        """
        Get supported language.

        :return: supported language.
        :rtype: list
        """
        return self._supported_lang

    def espeak_params(self, amp=None, speed=None, gap=None, pitch=None):
        """
        Set espeak parameters.

        :param amp: amplitude.
        :type amp: int
        :param speed: speed.
        :type speed: int
        :param gap: gap.
        :type gap: int
        :param pitch: pitch.
        :type pitch: int
        """
        if amp == None:
            amp = self._amp
        if speed == None:
            speed = self._speed
        if gap == None:
            gap = self._gap
        if pitch == None:
            pitch = self._pitch

        if amp not in range(0, 200):
            raise ValueError(f'Amp should be in 0 to 200, not "{amp}"')
        if speed not in range(80, 260):
            raise ValueError(f'speed should be in 80 to 260, not "{speed}"')
        if pitch not in range(0, 99):
            raise ValueError(f'pitch should be in 0 to 99, not "{pitch}"')
        self._amp = amp
        self._speed = speed
        self._gap = gap
        self._pitch = pitch

def _get_supported_lang_espeak(name):
    """
    Get supported language for espeak.

    :param name: espeak command name.
    :return: supported language.
    :rtype: list
    """
    status, result = run_command(f"{name} --voices")
    supported_lang = []
    if not status:
        first = True
        for line in result.split('\n'):
            if first or not line:
                first = False
                continue
            lang = [v for v in line.split() if v][1]
            supported_lang.append(lang)
    return supported_lang


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/__init__.py
##################################################

#!/usr/bin/env python3
"""
Robot Hat Library
"""
from .adc import ADC
from .filedb import fileDB
from .config import Config
from .i2c import I2C
from .modules import *
from .music import Music
from .motor import Motor, Motors
from .pin import Pin
from .pwm import PWM
from .servo import Servo
from .tts import TTS
from .utils import *
from .robot import Robot
from .version import __version__

from .device import Devices
__device__ = Devices()

def __usage__():
    print('''
Usage: robot_hat [option]

reset_mcu               reset mcu on robot-hat
enable_speaker          enable speaker
disable_speaker         disable speaker
version                 get robot-hat libray version
info                    get hat info
    ''')
    quit()

def get_firmware_version():
    ADDR = [0x14, 0x15]
    VERSSION_REG_ADDR = 0x05
    i2c = I2C(ADDR)
    version = i2c.mem_read(3, VERSSION_REG_ADDR)
    return version

def __main__():
    import sys
    import os
    if len(sys.argv) == 2:
        if sys.argv[1] == "reset_mcu":
            reset_mcu()
            info("Onboard MCU reset.")
        elif sys.argv[1] == "enable_speaker":
            info(f"Enable Robot-HAT speaker.")
            utils.enable_speaker()
        elif sys.argv[1] == "disable_speaker":
            info(f"Disable Robot-HAT speaker.")
            utils.disable_speaker()
        elif sys.argv[1] == "version":
            info(f"robot-hat library version: {__version__}")
        elif sys.argv[1] == "info":
            info(f'HAT name: {__device__.name}')
            info(f'PCB ID: O{__device__.product_id}V{__device__.product_ver}')
            info(f'Vendor: {__device__.vendor}')
            firmware_ver = get_firmware_version()
            firmware_ver = f'{firmware_ver[0]}.{firmware_ver[1]}.{firmware_ver[2]}'
            info(f"Firmare version: {firmware_ver}")
        else:
            warn("Unknown option.")
            __usage__()
    else:
        __usage__()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/music.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
import time
import threading
import pyaudio
import os
import struct
import math
from .utils import enable_speaker, disable_speaker

class Music(_Basic_class):
    """Play music, sound affect and note control"""

    FORMAT = pyaudio.paInt16
    CHANNELS = 1
    RATE = 44100

    KEY_G_MAJOR = 1
    KEY_D_MAJOR = 2
    KEY_A_MAJOR = 3
    KEY_E_MAJOR = 4
    KEY_B_MAJOR = 5
    KEY_F_SHARP_MAJOR = 6
    KEY_C_SHARP_MAJOR = 7

    KEY_F_MAJOR = -1
    KEY_B_FLAT_MAJOR = -2
    KEY_E_FLAT_MAJOR = -3
    KEY_A_FLAT_MAJOR = -4
    KEY_D_FLAT_MAJOR = -5
    KEY_G_FLAT_MAJOR = -6
    KEY_C_FLAT_MAJOR = -7

    KEY_SIGNATURE_SHARP = 1
    KEY_SIGNATURE_FLAT = -1

    WHOLE_NOTE = 1
    HALF_NOTE = 1/2
    QUARTER_NOTE = 1/4
    EIGHTH_NOTE = 1/8
    SIXTEENTH_NOTE = 1/16

    NOTE_BASE_FREQ = 440
    """Base note frequency for calculation (A4)"""
    NOTE_BASE_INDEX = 69
    """Base note index for calculation (A4) MIDI compatible"""

    NOTES = [
        None,  None, None,  None, None, None,  None, None,  None, None,  None, None,
        None,  None, None,  None, None, None,  None, None,  None, "A0", "A#0", "B0",
        "C1", "C#1", "D1", "D#1", "E1", "F1", "F#1", "G1", "G#1", "A1", "A#1", "B1",
        "C2", "C#2", "D2", "D#2", "E2", "F2", "F#2", "G2", "G#2", "A2", "A#2", "B2",
        "C3", "C#3", "D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3",
        "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4",
        "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5", "G5", "G#5", "A5", "A#5", "B5",
        "C6", "C#6", "D6", "D#6", "E6", "F6", "F#6", "G6", "G#6", "A6", "A#6", "B6",
        "C7", "C#7", "D7", "D#7", "E7", "F7", "F#7", "G7", "G#7", "A7", "A#7", "B7",
        "C8"]
    """Notes name, MIDI compatible"""

    def __init__(self):
        import warnings
        warnings_bk = warnings.filters
        warnings.filterwarnings("ignore")
        # close welcome message of pygame, and the value must be <str> 
        os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1" 
        import pygame
        warnings.filters = warnings_bk
        """Initialize music"""
        self.pygame = pygame
        self.pygame.mixer.init()
        self.time_signature(4, 4)
        self.tempo(120, 1/4)
        self.key_signature(0)
        #
        enable_speaker()

    def time_signature(self, top: int = None, bottom: int = None):
        """
        Set/get time signature

        :param top: top number of time signature
        :type top: int
        :param bottom: bottom number of time signature
        :type bottom: int
        :return: time signature
        :rtype: tuple
        """
        if top == None and bottom == None:
            return self._time_signature
        if bottom == None:
            bottom = top
        self._time_signature = (top, bottom)
        return self._time_signature

    def key_signature(self, key: int = None):
        """
        Set/get key signature

        :param key: key signature use KEY_XX_MAJOR or String "#", "##", or "bbb", "bbbb"
        :type key: int/str
        :return: key signature
        :rtype: int
        """
        if key == None:
            return self._key_signature
        if isinstance(key, str):
            if "#" in key:
                key = len(key)*self.KEY_SIGNATURE_SHARP
            elif "b" in key:
                key = len(key)*self.KEY_SIGNATURE_FLAT
        self._key_signature = key
        return self._key_signature

    def tempo(self, tempo=None, note_value=QUARTER_NOTE):
        """
        Set/get tempo beat per minute(bpm)

        :param tempo: tempo
        :type tempo: float
        :param note_value: note value(1, 1/2, Music.HALF_NOTE, etc)
        :return: tempo
        :rtype: int
        """
        if tempo == None and note_value == None:
            return self._tempo
        try:
            self._tempo = (tempo, note_value)
            self.beat_unit = 60.0 / tempo
            return self._tempo
        except:
            raise ValueError("tempo must be int not {}".format(tempo))

    def beat(self, beat):
        """
        Calculate beat delay in seconds from tempo

        :param beat: beat index
        :type beat: float
        :return: beat delay
        :rtype: float
        """
        beat = beat / self._tempo[1] * self.beat_unit
        return beat

    def note(self, note, natural=False):
        """
        Get frequency of a note

        :param note_name: note name(See NOTES)
        :type note_name: string
        :param natural: if natural note
        :type natural: bool
        :return: frequency of note
        :rtype: float
        """
        if isinstance(note, str):
            if note in self.NOTES:
                note = self.NOTES.index(note)
            else:
                raise ValueError(
                    f"note {note} not found, note must in Music.NOTES")
        if not natural:
            note += self.key_signature()
            note = min(max(note, 0), len(self.NOTES)-1)
        note_delta = note - self.NOTE_BASE_INDEX
        freq = self.NOTE_BASE_FREQ * (2 ** (note_delta / 12))
        return freq

    def sound_play(self, filename, volume=None):
        """
        Play sound effect file

        :param filename: sound effect file name
        :type filename: str
        """
        sound = self.pygame.mixer.Sound(filename)
        if volume is not None:
            # attention: 
            #   The volume of sound and music is separate, 
            # and the volume of different sound objects is also separate.
            sound.set_volume(round(volume/100.0, 2))
        time_delay = round(sound.get_length(), 2)
        sound.play()
        time.sleep(time_delay)

    def sound_play_threading(self, filename, volume=None):
        """
        Play sound effect in thread(in the background)

        :param filename: sound effect file name
        :type filename: str
        :param volume: volume 0-100, leave empty will not change volume
        :type volume: int
        """
        obj = threading.Thread(target=self.sound_play, kwargs={
                               "filename": filename, "volume": volume})
        obj.start()

    def music_play(self, filename, loops=1, start=0.0, volume=None):
        """
        Play music file

        :param filename: sound file name
        :type filename: str
        :param loops: number of loops, 0:loop forever, 1:play once, 2:play twice, ...
        :type loops: int
        :param start: start time in seconds
        :type start: float
        :param volume: volume 0-100, leave empty will not change volume
        :type volume: int
        """
        if volume is not None:
            self.music_set_volume(volume)
        self.pygame.mixer.music.load(filename)
        self.pygame.mixer.music.play(loops, start)

    def music_set_volume(self, value):
        """
        Set music volume

        :param value: volume 0-100
        :type value: int
        """
        value = round(value/100.0, 2)
        self.pygame.mixer.music.set_volume(value)

    def music_stop(self):
        """Stop music"""
        self.pygame.mixer.music.stop()

    def music_pause(self):
        """Pause music"""
        self.pygame.mixer.music.pause()

    def music_resume(self):
        """Resume music"""
        self.pygame.mixer.music.unpause()

    def music_unpause(self):
        """Unpause music(resume music)"""
        self.pygame.mixer.music.unpause()

    def sound_length(self, filename):
        """
        Get sound effect length in seconds

        :param filename: sound effect file name
        :type filename: str
        :return: length in seconds
        :rtype: float
        """
        music = self.pygame.mixer.Sound(str(filename))
        return round(music.get_length(), 2)

    def get_tone_data(self, freq: float, duration: float):
        """
        Get tone data for playing

        :param freq: frequency
        :type freq: float
        :param duration: duration in seconds
        :type duration: float
        :return: tone data
        :rtype: list
        """
        """
        Credit to: Aditya Shankar & Gringo Suave https://stackoverflow.com/a/53231212/14827323
        """
        duration /= 2.0
        frame_count = int(self.RATE * duration)

        remainder_frames = frame_count % self.RATE
        wavedata = []

        for i in range(frame_count):
            a = self.RATE / freq  # number of frames per wave
            b = i / a
            # explanation for b
            # considering one wave, what part of the wave should this be
            # if we graph the sine wave in a
            # displacement vs i graph for the particle
            # where 0 is the beginning of the sine wave and
            # 1 the end of the sine wave
            # which part is "i" is denoted by b
            # for clarity you might use
            # though this is redundant since math.sin is a looping function
            # b = b - int(b)

            c = b * (2 * math.pi)
            # explanation for c
            # now we map b to between 0 and 2*math.PI
            # since 0 - 2*PI, 2*PI - 4*PI, ...
            # are the repeating domains of the sin wave (so the decimal values will
            # also be mapped accordingly,
            # and the integral values will be multiplied
            # by 2*PI and since sin(n*2*PI) is zero where n is an integer)
            d = math.sin(c) * 32767
            e = int(d)
            wavedata.append(e)

        for i in range(remainder_frames):
            wavedata.append(0)

        number_of_bytes = str(len(wavedata))
        wavedata = struct.pack(number_of_bytes + 'h', *wavedata)

        return wavedata

    def play_tone_for(self, freq, duration):
        """
        Play tone for duration seconds

        :param freq: frequency, you can use NOTES to get frequency
        :type freq: float
        :param duration: duration in seconds
        :type duration: float
        """
        """
        Credit to: Aditya Shankar & Gringo Suave https://stackoverflow.com/a/53231212/14827323
        """
        p = pyaudio.PyAudio()
        frames = self.get_tone_data(freq, duration)
        stream = p.open(format=self.FORMAT, channels=self.CHANNELS,
                        rate=self.RATE, output=True)
        stream.write(frames)
        # stream.stop_stream()
        # stream.close()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/basic.py
##################################################

# -*- coding: utf-8 -*-
#!/usr/bin/env python3
import logging
import time


class _Basic_class(object):
    """
    Basic Class for all classes

    with debug function
    """
    _class_name = '_Basic_class'
    DEBUG_LEVELS = {'debug': logging.DEBUG,
                    'info': logging.INFO,
                    'warning': logging.WARNING,
                    'error': logging.ERROR,
                    'critical': logging.CRITICAL,
                    }
    """Debug level"""
    DEBUG_NAMES = ['critical', 'error', 'warning', 'info', 'debug']
    """Debug level names"""

    def __init__(self, debug_level='warning'):
        """
        Initialize the basic class

        :param debug_level: debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)
        :type debug_level: str/int
        """
        self.logger = logging.getLogger(f"self._class_name-{time.time()}")
        self.ch = logging.StreamHandler()
        form = "%(asctime)s	[%(levelname)s]	%(message)s"
        self.formatter = logging.Formatter(form)
        self.ch.setFormatter(self.formatter)
        self.logger.addHandler(self.ch)
        self._debug = self.logger.debug
        self._info = self.logger.info
        self._warning = self.logger.warning
        self._error = self.logger.error
        self._critical = self.logger.critical
        self.debug_level = debug_level

    @property
    def debug_level(self):
        """Debug level"""
        return self._debug_level

    @debug_level.setter
    def debug_level(self, debug):
        """Debug level"""
        if debug in range(5):
            self._debug_level = self.DEBUG_NAMES[debug]
        elif debug in self.DEBUG_NAMES:
            self._debug_level = debug
        else:
            raise ValueError(
                f'Debug value must be 0(critical), 1(error), 2(warning), 3(info) or 4(debug), not "{debug}".')
        self.logger.setLevel(self.DEBUG_LEVELS[self._debug_level])
        self.ch.setLevel(self.DEBUG_LEVELS[self._debug_level])
        self._debug(f'Set logging level to [{self._debug_level}]')


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/utils.py
##################################################

#!/usr/bin/env python3
import time
import os
import sys
import re
from .pin import Pin


# color:
# https://gist.github.com/rene-d/9e584a7dd2935d0f461904b9f2950007
# 1;30:gray 31:red, 32:green, 33:yellow, 34:blue, 35:purple, 36:dark green, 37:white
GRAY = '1;30'
RED = '0;31'
GREEN = '0;32'
YELLOW = '0;33'
BLUE = '0;34'
PURPLE = '0;35'
DARK_GREEN = '0;36'
WHITE = '0;37'

_adc_obj = None

def print_color(msg, end='\n', file=sys.stdout, flush=False, color=''):
    print('\033[%sm%s\033[0m'%(color, msg), end=end, file=file, flush=flush)

def info(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=WHITE)

def debug(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=GRAY)

def warn(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=YELLOW)

def error(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=RED)

def set_volume(value):
    """
    Set volume

    :param value: volume(0~100)
    :type value: int
    """
    value = min(100, max(0, value))
    cmd = "sudo amixer -M sset 'PCM' %d%%" % value
    os.system(cmd)


def command_exists(cmd):
    import subprocess
    try:
        subprocess.check_output(['which', cmd], stderr=subprocess.STDOUT)
        return True
    except subprocess.CalledProcessError:
        return False


def run_command(cmd):
    """
    Run command and return status and output

    :param cmd: command to run
    :type cmd: str
    :return: status, output
    :rtype: tuple
    """
    import subprocess
    p = subprocess.Popen(
        cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result = p.stdout.read().decode('utf-8')
    status = p.poll()
    return status, result

def command_exists(cmd):
    import subprocess
    try:
        subprocess.check_output(['which', cmd], stderr=subprocess.STDOUT)
        return True
    except subprocess.CalledProcessError:
        return False

def is_installed(cmd):
    """
    Check if command is installed

    :param cmd: command to check
    :type cmd: str
    :return: True if installed
    :rtype: bool
    """
    status, _ = run_command(f"which {cmd}")
    if status in [0, ]:
        return True
    else:
        return False


def mapping(x, in_min, in_max, out_min, out_max):
    """
    Map value from one range to another range

    :param x: value to map
    :type x: float/int
    :param in_min: input minimum
    :type in_min: float/int
    :param in_max: input maximum
    :type in_max: float/int
    :param out_min: output minimum
    :type out_min: float/int
    :param out_max: output maximum
    :type out_max: float/int
    :return: mapped value
    :rtype: float/int
    """
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min


def get_ip(ifaces=['wlan0', 'eth0']):
    """
    Get IP address

    :param ifaces: interfaces to check
    :type ifaces: list
    :return: IP address or False if not found
    :rtype: str/False
    """
    if isinstance(ifaces, str):
        ifaces = [ifaces]
    for iface in list(ifaces):
        search_str = 'ip addr show {}'.format(iface)
        result = os.popen(search_str).read()
        com = re.compile(r'(?<=inet )(.*)(?=\/)', re.M)
        ipv4 = re.search(com, result)
        if ipv4:
            ipv4 = ipv4.groups()[0]
            return ipv4
    return False


def reset_mcu():
    """
    Reset mcu on Robot Hat.

    This is helpful if the mcu somehow stuck in a I2C data
    transfer loop, and Raspberry Pi getting IOError while
    Reading ADC, manipulating PWM, etc.
    """
    mcu_reset = Pin("MCURST")
    mcu_reset.off()
    time.sleep(0.01)
    mcu_reset.on()
    time.sleep(0.01)

    mcu_reset.close()


def get_battery_voltage():
    """
    Get battery voltage

    :return: battery voltage(V)
    :rtype: float
    """
    global _adc_obj
    from .adc import ADC

    if not isinstance(_adc_obj, ADC):
        _adc_obj = ADC("A4")
    raw_voltage = _adc_obj.read_voltage()
    voltage = raw_voltage * 3
    return voltage

def get_username():
    return os.popen('echo ${SUDO_USER:-$LOGNAME}').readline().strip()

def enable_speaker():
    """
    Enable speaker
    """
    from . import __device__
    pincmd = ''
    if command_exists("pinctrl"):
        pincmd = 'pinctrl'
    elif command_exists("raspi-gpio"):
        pincmd = 'raspi-gpio'
    else:
        error("Can't find `pinctrl` or `raspi-gpio` to enable speaker")
        return

    debug(f"{pincmd} set {__device__.spk_en} op dh")
    run_command(f"{pincmd} set {__device__.spk_en} op dh")
    # play a short sound to fill data and avoid the speaker overheating
    run_command(f"play -n trim 0.0 0.5 2>/dev/null")

def disable_speaker():
    """
    Disable speaker
    """
    from . import __device__
    pincmd = ''
    if command_exists("pinctrl"):
        pincmd = 'pinctrl'
    elif command_exists("raspi-gpio"):
        pincmd = 'raspi-gpio'
    else:
        error("Can't find `pinctrl` or `raspi-gpio` to disable speaker")
        return

    debug(f"{pincmd} set {__device__.spk_en} op dl")
    run_command(f"{pincmd} set {__device__.spk_en} op dl")




##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/filedb.py
##################################################

#!/usr/bin/env python3
'''
**********************************************************************
* Filename    : filedb.py
* Description : A simple file based database.
* Author      : Cavon
* Brand       : SunFounder
* E-mail      : service@sunfounder.com
* Website     : www.sunfounder.com
* Update      : Cavon    2016-09-13    New release
**********************************************************************
'''
import os
from time import sleep


class fileDB(object):
	"""A file based database.

    A file based database, read and write arguements in the specific file.
    """
	def __init__(self, db:str, mode:str=None, owner:str=None):  
		'''
		Init the db_file is a file to save the datas.
		
		:param db: the file to save the datas.
		:type db: str
		:param mode: the mode of the file.
		:type mode: str
		:param owner: the owner of the file.
		:type owner: str
		'''

		self.db = db
		# Check if db_file is existed, otherwise create one
		if self.db != None:	
			self.file_check_create(db, mode, owner)
		else:
			raise ValueError('db: Missing file path parameter.')


	def file_check_create(self, file_path:str, mode:str=None, owner:str=None):
		"""
		Check if file is existed, otherwise create one.
		
		:param file_path: the file to check
		:type file_path: str
		:param mode: the mode of the file.
		:type mode: str
		:param owner: the owner of the file.
		:type owner: str
		"""
		dir = file_path.rsplit('/',1)[0]
		try:
			if os.path.exists(file_path):
				if not os.path.isfile(file_path):
					print('Could not create file, there is a folder with the same name')
					return
			else:
				if os.path.exists(dir):
					if not os.path.isdir(dir):
						print('Could not create directory, there is a file with the same name')
						return
				else:
					os.makedirs(dir, mode=0o754)
					sleep(0.001)

				with open(file_path, 'w') as f:
					f.write("# robot-hat config and calibration value of robots\n\n")

			if mode != None:
				os.popen('sudo chmod %s %s'%(mode, file_path))
			if owner != None:
				os.popen('sudo chown -R %s:%s %s'%(owner, owner, dir))		
		except Exception as e:
			raise(e) 
	
	def get(self, name, default_value=None):
		"""
		Get value with data's name
		
		:param name: the name of the arguement
		:type name: str
		:param default_value: the default value of the arguement
		:type default_value: str
		:return: the value of the arguement
		:rtype: str
		"""
		try:
			conf = open(self.db,'r')
			lines=conf.readlines()
			conf.close()
			file_len=len(lines)-1
			flag = False
			# Find the arguement and set the value
			for i in range(file_len):
				if lines[i][0] != '#':
					if lines[i].split('=')[0].strip() == name:
						value = lines[i].split('=')[1].replace(' ', '').strip()
						flag = True
			if flag:
				return value
			else:
				return default_value
		except FileNotFoundError:
			conf = open(self.db,'w')
			conf.write("")
			conf.close()
			return default_value
		except :
			return default_value
	
	def set(self, name, value):
		"""
		Set value by with name. Or create one if the arguement does not exist
		
		:param name: the name of the arguement
		:type name: str
		:param value: the value of the arguement
		:type value: str
		"""
		# Read the file
		conf = open(self.db,'r')
		lines=conf.readlines()
		conf.close()
		file_len=len(lines)-1
		flag = False
		# Find the arguement and set the value
		for i in range(file_len):
			if lines[i][0] != '#':
				if lines[i].split('=')[0].strip() == name:
					lines[i] = '%s = %s\n' % (name, value)
					flag = True
		# If arguement does not exist, create one
		if not flag:
			lines.append('%s = %s\n\n' % (name, value))

		# Save the file
		conf = open(self.db,'w')
		conf.writelines(lines)
		conf.close()

if __name__ == '__main__':
    db = fileDB('/opt/robot-hat/test2.config')

    db.set('a', '1')
    db.set('b', '2')
	
    print(db.get('a'))
    print(db.get('c'))
	


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/robot.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .pwm import PWM
from .servo import Servo
import time
from .filedb import fileDB
import os

# user and User home directory
User = os.popen('echo ${SUDO_USER:-$LOGNAME}').readline().strip()
UserHome = os.popen('getent passwd %s | cut -d: -f 6' %
                    User).readline().strip()
config_file = '%s/.config/robot-hat/robot-hat.conf' % UserHome


class Robot(_Basic_class):
    """
    Robot class

    This class is for makeing a servo robot with Robot HAT

    There are servo initialization, all servo move in specific speed. servo offset and stuff. make it easy to make a robot.
    All Pi-series robot from SunFounder use this class. Check them out for more details.

    PiSloth: https://github.com/sunfounder/pisloth

    PiArm: https://github.com/sunfounder/piarm

    PiCrawler: https://github.com/sunfounder/picrawler
    """

    move_list = {}
    """Preset actions"""

    max_dps = 428  # dps, degrees per second, genally in 4.8V : 60des/0.14s, dps = 428
    # max_dps = 500
    """Servo max Degree Per Second"""

    def __init__(self, pin_list, db=config_file, name=None, init_angles=None, init_order=None, **kwargs):
        """
        Initialize the robot class

        :param pin_list: list of pin number[0-11]
        :type pin_list: list
        :param db: config file path
        :type db: str
        :param name: robot name
        :type name: str
        :param init_angles: list of initial angles
        :type init_angles: list
        :param init_order: list of initialization order(Servos will init one by one in case of sudden huge current, pulling down the power supply voltage. default order is the pin list. in some cases, you need different order, use this parameter to set it.)
        :type init_order: list
        :type init_angles: list
        """
        super().__init__(**kwargs)
        self.servo_list = []
        self.pin_num = len(pin_list)

        if name == None:
            self.name = 'other'
        else:
            self.name = name

        self.offset_value_name = f"{self.name}_servo_offset_list"
        # offset
        self.db = fileDB(db=db, mode='774', owner=User)
        temp = self.db.get(self.offset_value_name,
                           default_value=str(self.new_list(0)))
        temp = [float(i.strip()) for i in temp.strip("[]").split(",")]
        self.offset = temp

        # parameter init
        self.servo_positions = self.new_list(0)
        self.origin_positions = self.new_list(0)
        self.calibrate_position = self.new_list(0)
        self.direction = self.new_list(1)

        # servo init
        if None == init_angles:
            init_angles = [0]*self.pin_num
        elif len(init_angles) != self.pin_num:
            raise ValueError('init angels numbers do not match pin numbers ')

        if init_order == None:
            init_order = range(self.pin_num)

        for i, pin in enumerate(pin_list):
            self.servo_list.append(Servo(pin))
            self.servo_positions[i] = init_angles[i]
        for i in init_order:
            self.servo_list[i].angle(self.offset[i]+self.servo_positions[i])
            time.sleep(0.15)

        self.last_move_time = time.time()

    def new_list(self, default_value):
        """
        Create a list of servo angles with default value

        :param default_value: default value of servo angles
        :type default_value: int or float
        :return: list of servo angles
        :rtype: list
        """
        _ = [default_value] * self.pin_num
        return _

    def servo_write_raw(self, angle_list):
        """
        Set servo angles to specific raw angles

        :param angle_list: list of servo angles
        :type angle_list: list
        """
        for i in range(self.pin_num):
            self.servo_list[i].angle(angle_list[i])

    def servo_write_all(self, angles):
        """
        Set servo angles to specific angles with original angle and offset

        :param angles: list of servo angles
        :type angles: list
        """
        rel_angles = []  # ralative angle to home
        for i in range(self.pin_num):
            rel_angles.append(
                self.direction[i] * (self.origin_positions[i] + angles[i] + self.offset[i]))
        self.servo_write_raw(rel_angles)

    def servo_move(self, targets, speed=50, bpm=None):
        """
        Move servo to specific angles with speed or bpm

        :param targets: list of servo angles
        :type targets: list
        :param speed: speed of servo move
        :type speed: int or float
        :param bpm: beats per minute
        :type bpm: int or float
        """
        '''
            calculate the max delta angle, multiply by 2 to define a max_step
            loop max_step times, every servo add/minus 1 when step reaches its adder_flag
        '''
        speed = max(0, speed)
        speed = min(100, speed)
        step_time = 10  # ms 
        delta = []
        absdelta = []
        max_step = 0
        steps = []
        # print(f"targets: {targets}")
        # print(f"current:{self.servo_positions}")
        # st = time.time()
        # if self.name == "legs":
        #     print(f"move_interval: {time.time() - self.last_move_time}")
        #     self.last_move_time = time.time()

        for i in range(self.pin_num):
            value = targets[i] - self.servo_positions[i]
            delta.append(value)
            absdelta.append(abs(value))

        # Calculate max delta angle
        max_delta = int(max(absdelta))
        if max_delta == 0:
            time.sleep(step_time/1000)
            return

        # Calculate total servo move time
        if bpm: # bpm: beats per minute
            total_time = 60 / bpm * 1000 # time taken per beat, unit: ms
        else:
            total_time = -9.9 * speed + 1000 # time spent in one step, unit: ms
        # print(f"Total time: {total_time} ms")

        # Calculate max dps
        current_max_dps = max_delta / total_time * 1000 # dps, degrees per second

        # If current max dps is larger than max dps, then calculate a new total servo move time
        if current_max_dps > self.max_dps:
            # print(
            #     f"Current Max DPS {current_max_dps} is too high. Max DPS is {self.max_dps}")
            # print(f"Total time: {total_time} ms")
            # print(f"Max Delta: {max_delta}")
            total_time = max_delta / self.max_dps * 1000
            # print(f"New Total time: {total_time} ms")
        # calculate max step
        max_step = int(total_time / step_time)

        # Calculate all step-angles for each servo
        for i in range(self.pin_num):
            step = float(delta[i])/max_step
            steps.append(step)

        # print(f"usage1: {time.time() - st}")
        # st = time.time()

        # print(f"max_delta: {max_delta}, max_step: {max_step}")
        for _ in range(max_step):
            start_timer = time.time()
            delay = step_time/1000

            for j in range(self.pin_num):
                self.servo_positions[j] += steps[j]
            self.servo_write_all(self.servo_positions)

            servo_move_time = time.time() - start_timer
            # print(f"Servo move: {servo_move_time}")
            delay = delay - servo_move_time
            delay = max(0, delay)
            time.sleep(delay)
            # _dealy_start = time.time()
            # if delay > 0:
            #     while (time.time() - _dealy_start < delay):
            #         pass
        # print(f"usage2: {time.time() - st}, max_steps: {max_step}")

    def do_action(self, motion_name, step=1, speed=50):
        """
        Do prefix action with motion_name and step and speed

        :param motion_name: motion
        :type motion_name: str
        :param step: step of motion
        :type step: int
        :param speed: speed of motion
        :type speed: int or float
        """
        for _ in range(step):
            for motion in self.move_list[motion_name]:
                self.servo_move(motion, speed)

    def set_offset(self, offset_list):
        """
        Set offset of servo angles

        :param offset_list: list of servo angles
        :type offset_list: list
        """
        offset_list = [min(max(offset, -20), 20) for offset in offset_list]
        temp = str(offset_list)
        self.db.set(self.offset_value_name, temp)
        self.offset = offset_list

    def calibration(self):
        """Move all servos to home position"""
        self.servo_positions = self.calibrate_position
        self.servo_write_all(self.servo_positions)

    def reset(self, list=None):
        """Reset servo to original position"""
        if list is None:
            self.servo_positions = self.new_list(0)
            self.servo_write_all(self.servo_positions)
        else:
            self.servo_positions = list
            self.servo_write_all(self.servo_positions)

    def soft_reset(self):
        temp_list = self.new_list(0)
        self.servo_write_all(temp_list)


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/modules.py
##################################################

#!/usr/bin/env python3
from .pin import Pin
from .pwm import PWM
from .adc import ADC
from .i2c import I2C
import time
from .basic import _Basic_class
from typing import Union, List, Tuple, Optional

class Ultrasonic():
    SOUND_SPEED = 343.3 # ms

    def __init__(self, trig, echo, timeout=0.02):
        if not isinstance(trig, Pin):
            raise TypeError("trig must be robot_hat.Pin object")
        if not isinstance(echo, Pin):
            raise TypeError("echo must be robot_hat.Pin object")

        self.timeout = timeout

        trig.close()
        echo.close()
        self.trig = Pin(trig._pin_num)
        self.echo = Pin(echo._pin_num, mode=Pin.IN, pull=Pin.PULL_DOWN)

    def _read(self):
        self.trig.off()
        time.sleep(0.001)
        self.trig.on()
        time.sleep(0.00001)
        self.trig.off()

        pulse_end = 0
        pulse_start = 0
        timeout_start = time.time()

        while self.echo.gpio.value == 0:
            pulse_start = time.time()
            if pulse_start - timeout_start > self.timeout:
                return -1
        while self.echo.gpio.value == 1:
            pulse_end = time.time()
            if pulse_end - timeout_start > self.timeout:
                return -1
        if pulse_start == 0 or pulse_end == 0:
            return -2

        during = pulse_end - pulse_start
        cm = round(during * self.SOUND_SPEED / 2 * 100, 2)
        return cm

    def read(self, times=10):
        for i in range(times):
            a = self._read()
            if a != -1:
                return a
        return -1

class ADXL345(I2C):
    """ADXL345 modules"""

    X = 0
    """X"""
    Y = 1
    """Y"""
    Z = 2
    """Z"""
    ADDR =  0x53
    _REG_DATA_X = 0x32  # X-axis data 0 (6 bytes for X/Y/Z)
    _REG_DATA_Y = 0x34  # Y-axis data 0 (6 bytes for X/Y/Z)
    _REG_DATA_Z = 0x36  # Z-axis data 0 (6 bytes for X/Y/Z)
    _REG_POWER_CTL = 0x2D  # Power-saving features control
    _AXISES = [_REG_DATA_X, _REG_DATA_Y, _REG_DATA_Z]

    def __init__(self, *args, address: int = ADDR, bus: int = 1, **kwargs):
        """
        Initialize ADXL345

        :param address: address of the ADXL345
        :type address: int
        """
        super().__init__(address=address, bus=bus, *args, **kwargs)
        self.address = address

    def read(self, axis: int = None) -> Union[float, List[float]]:
        """
        Read an axis from ADXL345

        :param axis: read value(g) of an axis, ADXL345.X, ADXL345.Y or ADXL345.Z, None for all axis
        :type axis: int
        :return: value of the axis, or list of all axis
        :rtype: float/list
        """
        if axis is None:
            return [self._read(i) for i in range(3)]
        else:
            return self._read(axis)

    def _read(self, axis: int) -> float:
        raw_2 = 0
        result = super().read()
        data = (0x08 << 8) + self._REG_POWER_CTL
        if result:
            self.write(data)
        self.mem_write(0, 0x31)
        self.mem_write(8, 0x2D)
        raw = self.mem_read(2, self._AXISES[axis])
        # 第一次读的值总是为0，所以多读取一次
        self.mem_write(0, 0x31)
        self.mem_write(8, 0x2D)
        raw = self.mem_read(2, self._AXISES[axis])
        if raw[1] >> 7 == 1:

            raw_1 = raw[1] ^ 128 ^ 127
            raw_2 = (raw_1 + 1) * -1
        else:
            raw_2 = raw[1]
        g = raw_2 << 8 | raw[0]
        value = g / 256.0
        return value


class RGB_LED():
    """Simple 3 pin RGB LED"""

    ANODE = 1
    """Common anode"""
    CATHODE = 0
    """Common cathode"""

    def __init__(self, r_pin: PWM, g_pin: PWM, b_pin: PWM, common: int = 1):
        """
        Initialize RGB LED

        :param r_pin: PWM object for red
        :type r_pin: robot_hat.PWM
        :param g_pin: PWM object for green
        :type g_pin: robot_hat.PWM
        :param b_pin: PWM object for blue
        :type b_pin: robot_hat.PWM
        :param common: RGB_LED.ANODE or RGB_LED.CATHODE, default is ANODE
        :type common: int
        :raise ValueError: if common is not ANODE or CATHODE
        :raise TypeError: if r_pin, g_pin or b_pin is not PWM object
        """
        if not isinstance(r_pin, PWM):
            raise TypeError("r_pin must be robot_hat.PWM object")
        if not isinstance(g_pin, PWM):
            raise TypeError("g_pin must be robot_hat.PWM object")
        if not isinstance(b_pin, PWM):
            raise TypeError("b_pin must be robot_hat.PWM object")
        if common not in (self.ANODE, self.CATHODE):
            raise ValueError("common must be RGB_LED.ANODE or RGB_LED.CATHODE")
        self.r_pin = r_pin
        self.g_pin = g_pin
        self.b_pin = b_pin
        self.common = common

    def color(self, color: Union[str, Tuple[int, int, int], List[int], int]):
        """
        Write color to RGB LED

        :param color: color to write, hex string starts with "#", 24-bit int or tuple of (red, green, blue)
        :type color: str/int/tuple/list
        """
        if not isinstance(color, (str, int, tuple, list)):
            raise TypeError("color must be str, int, tuple or list")
        if isinstance(color, str):
            color = color.strip("#")
            color = int(color, 16)
        if isinstance(color, (tuple, list)):
            r, g, b = color
        if isinstance(color, int):
            r = (color & 0xff0000) >> 16
            g = (color & 0x00ff00) >> 8
            b = (color & 0x0000ff) >> 0

        if self.common == self.ANODE:
            r = 255-r
            g = 255-g
            b = 255-b

        r = r / 255.0 * 100.0
        g = g / 255.0 * 100.0
        b = b / 255.0 * 100.0

        self.r_pin.pulse_width_percent(r)
        self.g_pin.pulse_width_percent(g)
        self.b_pin.pulse_width_percent(b)


class Buzzer():
    """Buzzer"""

    def __init__(self, buzzer: Union[PWM, Pin]):
        """
        Initialize buzzer

        :param pwm: PWM object for passive buzzer or Pin object for active buzzer
        :type pwm: robot_hat.PWM/robot_hat.Pin
        """
        if not isinstance(buzzer, (PWM, Pin)):
            raise TypeError(
                "buzzer must be robot_hat.PWM or robot_hat.Pin object")
        self.buzzer = buzzer
        self.buzzer.off()

    def on(self):
        """Turn on buzzer"""
        if isinstance(self.buzzer, PWM):
            self.buzzer.pulse_width_percent(50)
        elif isinstance(self.buzzer, Pin):
            self.buzzer.on()

    def off(self):
        """Turn off buzzer"""
        if isinstance(self.buzzer, PWM):
            self.buzzer.pulse_width_percent(0)
        elif isinstance(self.buzzer, Pin):
            self.buzzer.off()

    def freq(self, freq: float):
        """Set frequency of passive buzzer

        :param freq: frequency of buzzer, use Music.NOTES to get frequency of note
        :type freq: int/float
        :raise TypeError: if set to active buzzer
        """
        if isinstance(self.buzzer, Pin):
            raise TypeError("freq is not supported for active buzzer")
        self.buzzer.freq(freq)

    def play(self, freq: float, duration: float = None):
        """
        Play freq

        :param freq: freq to play, you can use Music.note() to get frequency of note
        :type freq: float
        :param duration: duration of each note, in seconds, None means play continuously
        :type duration: float
        :raise TypeError: if set to active buzzer
        """
        if isinstance(self.buzzer, Pin):
            raise TypeError("play is not supported for active buzzer")
        self.freq(freq)
        self.on()
        if duration is not None:
            time.sleep(duration/2)
            self.off()
            time.sleep(duration/2)


class Grayscale_Module(object):
    """3 channel Grayscale Module"""

    LEFT = 0
    """Left Channel"""
    MIDDLE = 1
    """Middle Channel"""
    RIGHT = 2
    """Right Channel"""

    REFERENCE_DEFAULT = [1000]*3

    def __init__(self, pin0: ADC, pin1: ADC, pin2: ADC, reference: int = None):
        """
        Initialize Grayscale Module

        :param pin0: ADC object or int for channel 0
        :type pin0: robot_hat.ADC/int
        :param pin1: ADC object or int for channel 1
        :type pin1: robot_hat.ADC/int
        :param pin2: ADC object or int for channel 2
        :type pin2: robot_hat.ADC/int
        :param reference: reference voltage
        :type reference: 1*3 list, [int, int, int]
        """
        self.pins = (pin0, pin1, pin2)
        for i, pin in enumerate(self.pins):
            if not isinstance(pin, ADC):
                raise TypeError(f"pin{i} must be robot_hat.ADC")
        self._reference = self.REFERENCE_DEFAULT

    def reference(self, ref: list = None) -> list:
        """
        Get Set reference value

        :param ref: reference value, None to get reference value
        :type ref: list
        :return: reference value
        :rtype: list
        """
        if ref is not None:
            if isinstance(ref, list) and len(ref) == 3:
                self._reference = ref
            else:
                raise TypeError("ref parameter must be 1*3 list.")
        return self._reference

    def read_status(self, datas: list = None) -> list:
        """
        Read line status

        :param datas: list of grayscale datas, if None, read from sensor
        :type datas: list
        :return: list of line status, 0 for white, 1 for black
        :rtype: list
        """
        if self._reference == None:
            raise ValueError("Reference value is not set")
        if datas == None:
            datas = self.read()
        return [0 if data > self._reference[i] else 1 for i, data in enumerate(datas)]

    def read(self, channel: int = None) -> list:
        """
        read a channel or all datas

        :param channel: channel to read, leave empty to read all. 0, 1, 2 or Grayscale_Module.LEFT, Grayscale_Module.CENTER, Grayscale_Module.RIGHT 
        :type channel: int/None
        :return: list of grayscale data
        :rtype: list
        """
        if channel == None:
            return [self.pins[i].read() for i in range(3)]
        else:
            return self.pins[channel].read()


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/robot_hat/adc.py
##################################################

#!/usr/bin/env python3
from .i2c import I2C


class ADC(I2C):
    """
    Analog to digital converter
    """
    ADDR = [0x14, 0x15]

    def __init__(self, chn, address=None, *args, **kwargs):
        """
        Analog to digital converter

        :param chn: channel number (0-7/A0-A7)
        :type chn: int/str
        """
        if address is not None:
            super().__init__(address, *args, **kwargs)
        else:
            super().__init__(self.ADDR, *args, **kwargs)
        self._debug(f'ADC device address: 0x{self.address:02X}')

        if isinstance(chn, str):
            # If chn is a string, assume it's a pin name, remove A and convert to int
            if chn.startswith("A"):
                chn = int(chn[1:])
            else:
                raise ValueError(
                    f'ADC channel should be between [A0, A7], not "{chn}"')
        # Make sure channel is between 0 and 7
        if chn < 0 or chn > 7:
            raise ValueError(
                f'ADC channel should be between [0, 7], not "{chn}"')
        chn = 7 - chn
        # Convert to Register value
        self.chn = chn | 0x10

    def read(self):
        """
        Read the ADC value

        :return: ADC value(0-4095)
        :rtype: int
        """
        # Write register address
        self.write([self.chn, 0, 0])
        # Read values
        msb, lsb = super().read(2)

        # Combine MSB and LSB
        value = (msb << 8) + lsb
        self._debug(f"Read value: {value}")
        return value

    def read_voltage(self):
        """
        Read the ADC value and convert to voltage

        :return: Voltage value(0-3.3(V))
        :rtype: float
        """
        # Read ADC value
        value = self.read()
        # Convert to voltage
        voltage = value * 3.3 / 4095
        self._debug(f"Read voltage: {voltage}")
        return voltage


##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/dtoverlays/sunfounder-servohat+.dtbo
##################################################

  2   8     (             v                                   brcm,bcm2835       fragment@0           /chosen    __overlay__    power                       *               fragment@1           2   __overlay__          9okay             fragment@2           2   __overlay__          9okay             fragment@3           2   __overlay__          9okay             fragment@4           /      __overlay__    pcm5102a-codec            ti,pcm5102a          9okay                fragment@5           2   __overlay__           hifiberry,hifiberry-dac          @         9okay             __symbols__          O/fragment@0/__overlay__/power         __fixups__           U/fragment@1:target:0             Z/fragment@2:target:0          >   _/fragment@3:target:0 /fragment@5/__overlay__:i2s-controller:0            p/fragment@5:target:0             	compatible target-path hat_current_supply phandle target status i2s-controller power i2c1 spi0 i2s_clk_producer sound 

##################################################
# FILE: baseline_code_backup_20250606_120552/robot-hat/dtoverlays/sunfounder-robothat5.dtbo
##################################################

     8     (               t                                 brcm,bcm2835       fragment@0           /chosen    __overlay__    power                       *               fragment@1           2   __overlay__          9okay             fragment@2           2   __overlay__          9okay             fragment@3           2   __overlay__          9okay             fragment@4           2   __overlay__    googlevoicehat_pins          @            J            X             *               fragment@5           /      __overlay__    voicehat-codec           b              google,voicehat          sdefault                                      9okay                fragment@6           2   __overlay__       (    googlevoicehat,googlevoicehat-soundcard                   9okay             __symbols__          /fragment@0/__overlay__/power         ,   /fragment@4/__overlay__/googlevoicehat_pins       __fixups__           /fragment@1:target:0             /fragment@2:target:0          >   /fragment@3:target:0 /fragment@6/__overlay__:i2s-controller:0         K   /fragment@4:target:0 /fragment@5/__overlay__/voicehat-codec:sdmode-gpios:0           /fragment@6:target:0          __local_fixups__       fragment@5     __overlay__    voicehat-codec                                 	compatible target-path hat_current_supply phandle target status brcm,pins brcm,function brcm,pull #sound-dai-cells pinctrl-names pinctrl-0 sdmode-gpios i2s-controller power googlevoicehat_pins i2c1 spi0 i2s_clk_producer gpio sound 

##################################################
# FILE: baseline_code/picar-x/picarx/picarx.py
##################################################

from robot_hat import Pin, ADC, PWM, Servo, fileDB
from robot_hat import Grayscale_Module, Ultrasonic, utils
import time
import os


def constrain(x, min_val, max_val):
    '''
    Constrains value to be within a range.
    '''
    return max(min_val, min(max_val, x))

class Picarx(object):
    CONFIG = '/opt/picar-x/picar-x.conf'

    DEFAULT_LINE_REF = [1000, 1000, 1000]
    DEFAULT_CLIFF_REF = [500, 500, 500]

    DIR_MIN = -30
    DIR_MAX = 30
    CAM_PAN_MIN = -90
    CAM_PAN_MAX = 90
    CAM_TILT_MIN = -35
    CAM_TILT_MAX = 65

    PERIOD = 4095
    PRESCALER = 10
    TIMEOUT = 0.02

    # servo_pins: camera_pan_servo, camera_tilt_servo, direction_servo
    # motor_pins: left_swicth, right_swicth, left_pwm, right_pwm
    # grayscale_pins: 3 adc channels
    # ultrasonic_pins: trig, echo2
    # config: path of config file
    def __init__(self, 
                servo_pins:list=['P0', 'P1', 'P2'], 
                motor_pins:list=['D4', 'D5', 'P13', 'P12'],
                grayscale_pins:list=['A0', 'A1', 'A2'],
                ultrasonic_pins:list=['D2','D3'],
                config:str=CONFIG,
                ):

        # reset robot_hat
        utils.reset_mcu()
        time.sleep(0.2)

        # --------- config_flie ---------
        self.config_flie = fileDB(config, 777, os.getlogin())

        # --------- servos init ---------
        self.cam_pan = Servo(servo_pins[0])
        self.cam_tilt = Servo(servo_pins[1])   
        self.dir_servo_pin = Servo(servo_pins[2])
        # get calibration values
        self.dir_cali_val = float(self.config_flie.get("picarx_dir_servo", default_value=0))
        self.cam_pan_cali_val = float(self.config_flie.get("picarx_cam_pan_servo", default_value=0))
        self.cam_tilt_cali_val = float(self.config_flie.get("picarx_cam_tilt_servo", default_value=0))
        # set servos to init angle
        self.dir_servo_pin.angle(self.dir_cali_val)
        self.cam_pan.angle(self.cam_pan_cali_val)
        self.cam_tilt.angle(self.cam_tilt_cali_val)

        # --------- motors init ---------
        self.left_rear_dir_pin = Pin(motor_pins[0])
        self.right_rear_dir_pin = Pin(motor_pins[1])
        self.left_rear_pwm_pin = PWM(motor_pins[2])
        self.right_rear_pwm_pin = PWM(motor_pins[3])
        self.motor_direction_pins = [self.left_rear_dir_pin, self.right_rear_dir_pin]
        self.motor_speed_pins = [self.left_rear_pwm_pin, self.right_rear_pwm_pin]
        # get calibration values
        self.cali_dir_value = self.config_flie.get("picarx_dir_motor", default_value="[1, 1]")
        self.cali_dir_value = [int(i.strip()) for i in self.cali_dir_value.strip().strip("[]").split(",")]
        self.cali_speed_value = [0, 0]
        self.dir_current_angle = 0
        # init pwm
        for pin in self.motor_speed_pins:
            pin.period(self.PERIOD)
            pin.prescaler(self.PRESCALER)

        # --------- grayscale module init ---------
        adc0, adc1, adc2 = [ADC(pin) for pin in grayscale_pins]
        self.grayscale = Grayscale_Module(adc0, adc1, adc2, reference=None)
        # get reference
        self.line_reference = self.config_flie.get("line_reference", default_value=str(self.DEFAULT_LINE_REF))
        self.line_reference = [float(i) for i in self.line_reference.strip().strip('[]').split(',')]
        self.cliff_reference = self.config_flie.get("cliff_reference", default_value=str(self.DEFAULT_CLIFF_REF))
        self.cliff_reference = [float(i) for i in self.cliff_reference.strip().strip('[]').split(',')]
        # transfer reference
        self.grayscale.reference(self.line_reference)

        # --------- ultrasonic init ---------
        trig, echo= ultrasonic_pins
        self.ultrasonic = Ultrasonic(Pin(trig), Pin(echo, mode=Pin.IN, pull=Pin.PULL_DOWN))
        
    def set_motor_speed(self, motor, speed):
        ''' set motor speed
        
        param motor: motor index, 1 means left motor, 2 means right motor
        type motor: int
        param speed: speed
        type speed: int      
        '''
        speed = constrain(speed, -100, 100)
        motor -= 1
        if speed >= 0:
            direction = 1 * self.cali_dir_value[motor]
        elif speed < 0:
            direction = -1 * self.cali_dir_value[motor]
        speed = abs(speed)
        # print(f"direction: {direction}, speed: {speed}")
        if speed != 0:
            speed = int(speed /2 ) + 50
        speed = speed - self.cali_speed_value[motor]
        if direction < 0:
            self.motor_direction_pins[motor].high()
            self.motor_speed_pins[motor].pulse_width_percent(speed)
        else:
            self.motor_direction_pins[motor].low()
            self.motor_speed_pins[motor].pulse_width_percent(speed)

    def motor_speed_calibration(self, value):
        self.cali_speed_value = value
        if value < 0:
            self.cali_speed_value[0] = 0
            self.cali_speed_value[1] = abs(self.cali_speed_value)
        else:
            self.cali_speed_value[0] = abs(self.cali_speed_value)
            self.cali_speed_value[1] = 0

    def motor_direction_calibrate(self, motor, value):
        ''' set motor direction calibration value
        
        param motor: motor index, 1 means left motor, 2 means right motor
        type motor: int
        param value: speed
        type value: int
        '''      
        motor -= 1
        if value == 1:
            self.cali_dir_value[motor] = 1
        elif value == -1:
            self.cali_dir_value[motor] = -1
        self.config_flie.set("picarx_dir_motor", self.cali_dir_value)

    def dir_servo_calibrate(self, value):
        self.dir_cali_val = value
        self.config_flie.set("picarx_dir_servo", "%s"%value)
        self.dir_servo_pin.angle(value)

    def set_dir_servo_angle(self, value):
        self.dir_current_angle = constrain(value, self.DIR_MIN, self.DIR_MAX)
        angle_value  = self.dir_current_angle + self.dir_cali_val
        self.dir_servo_pin.angle(angle_value)

    def cam_pan_servo_calibrate(self, value):
        self.cam_pan_cali_val = value
        self.config_flie.set("picarx_cam_pan_servo", "%s"%value)
        self.cam_pan.angle(value)

    def cam_tilt_servo_calibrate(self, value):
        self.cam_tilt_cali_val = value
        self.config_flie.set("picarx_cam_tilt_servo", "%s"%value)
        self.cam_tilt.angle(value)

    def set_cam_pan_angle(self, value):
        value = constrain(value, self.CAM_PAN_MIN, self.CAM_PAN_MAX)
        self.cam_pan.angle(-1*(value + -1*self.cam_pan_cali_val))

    def set_cam_tilt_angle(self,value):
        value = constrain(value, self.CAM_TILT_MIN, self.CAM_TILT_MAX)
        self.cam_tilt.angle(-1*(value + -1*self.cam_tilt_cali_val))

    def set_power(self, speed):
        self.set_motor_speed(1, speed)
        self.set_motor_speed(2, speed)

    def backward(self, speed):
        current_angle = self.dir_current_angle
        if current_angle != 0:
            abs_current_angle = abs(current_angle)
            if abs_current_angle > self.DIR_MAX:
                abs_current_angle = self.DIR_MAX
            power_scale = (100 - abs_current_angle) / 100.0 
            if (current_angle / abs_current_angle) > 0:
                self.set_motor_speed(1, -1*speed)
                self.set_motor_speed(2, speed * power_scale)
            else:
                self.set_motor_speed(1, -1*speed * power_scale)
                self.set_motor_speed(2, speed )
        else:
            self.set_motor_speed(1, -1*speed)
            self.set_motor_speed(2, speed)  

    def forward(self, speed):
        current_angle = self.dir_current_angle
        if current_angle != 0:
            abs_current_angle = abs(current_angle)
            if abs_current_angle > self.DIR_MAX:
                abs_current_angle = self.DIR_MAX
            power_scale = (100 - abs_current_angle) / 100.0
            if (current_angle / abs_current_angle) > 0:
                self.set_motor_speed(1, 1*speed * power_scale)
                self.set_motor_speed(2, -speed) 
            else:
                self.set_motor_speed(1, speed)
                self.set_motor_speed(2, -1*speed * power_scale)
        else:
            self.set_motor_speed(1, speed)
            self.set_motor_speed(2, -1*speed)                  

    def stop(self):
        '''
        Execute twice to make sure it stops
        '''
        for _ in range(2):
            self.motor_speed_pins[0].pulse_width_percent(0)
            self.motor_speed_pins[1].pulse_width_percent(0)
            time.sleep(0.002)

    def get_distance(self):
        return self.ultrasonic.read()

    def set_grayscale_reference(self, value):
        if isinstance(value, list) and len(value) == 3:
            self.line_reference = value
            self.grayscale.reference(self.line_reference)
            self.config_flie.set("line_reference", self.line_reference)
        else:
            raise ValueError("grayscale reference must be a 1*3 list")

    def get_grayscale_data(self):
        return list.copy(self.grayscale.read())

    def get_line_status(self,gm_val_list):
        return self.grayscale.read_status(gm_val_list)

    def set_line_reference(self, value):
        self.set_grayscale_reference(value)

    def get_cliff_status(self,gm_val_list):
        for i in range(0,3):
            if gm_val_list[i]<=self.cliff_reference[i]:
                return True
        return False

    def set_cliff_reference(self, value):
        if isinstance(value, list) and len(value) == 3:
            self.cliff_reference = value
            self.config_flie.set("cliff_reference", self.cliff_reference)
        else:
            raise ValueError("grayscale reference must be a 1*3 list")

    def reset(self):
        self.stop()
        self.set_dir_servo_angle(0)
        self.set_cam_tilt_angle(0)
        self.set_cam_pan_angle(0)

if __name__ == "__main__":
    px = Picarx()
    px.forward(50)
    time.sleep(1)
    px.stop()


##################################################
# FILE: baseline_code/picar-x/picarx/version.py
##################################################

__version__ = '2.0.5'


##################################################
# FILE: baseline_code/picar-x/picarx/__init__.py
##################################################

#!/usr/bin/env python3
from .picarx import Picarx
from .version import __version__


##################################################
# FILE: baseline_code/picar-x/LICENSE
##################################################

                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS


##################################################
# FILE: baseline_code/picar-x/example/6.cliff_detection.py
##################################################

'''
    Cliff detection program for Picar-X:

    Pay attention to modify the reference value of the grayscale module 
    according to the practical usage scenarios.
    Auto calibrate grayscale values:
        Please run ./calibration/grayscale_calibration.py
    Manual modification:
        Use the following: 
            px.set_cliff_reference([200, 200, 200])
        The reference value be close to the middle of the line gray value
        and the background gray value.

'''
from picarx import Picarx
from time import sleep
from robot_hat import TTS

tts = TTS()
tts.lang("en-US")

px = Picarx()
# px = Picarx(grayscale_pins=['A0', 'A1', 'A2'])
# manual modify reference value
px.set_cliff_reference([200, 200, 200])

current_state = None
px_power = 10
offset = 20
last_state = "safe"



if __name__=='__main__':
    try:
        while True:
            gm_val_list = px.get_grayscale_data()
            gm_state = px.get_cliff_status(gm_val_list)
            # print("cliff status is:  %s"%gm_state)

            if gm_state is False:
                state = "safe"
                px.stop()
            else:
                state = "danger"   
                px.backward(80)
                if last_state == "safe":
                    tts.say("danger")
                    sleep(0.1)
            last_state = state

    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


                

##################################################
# FILE: baseline_code/picar-x/example/9.record_video.py
##################################################

from time import sleep,strftime,localtime
from vilib import Vilib
import readchar
import os

manual = '''
Press keys on keyboard to control recording:
    Q: record/pause/continue
    E: stop
    Ctrl + C: Quit
'''

def print_overwrite(msg,  end='', flush=True):
    print('\r\033[2K', end='',flush=True)
    print(msg, end=end, flush=True)

def main():
    rec_flag = 'stop' # start,pause,stop
    vname = None
    username = os.getlogin()
    
    Vilib.rec_video_set["path"] = f"/home/{username}/Videos/" # set path

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=True,web=True)
    sleep(0.8)  # wait for startup

    print(manual)
    while True:
        # read keyboard
        key = readchar.readkey()
        key = key.lower()
        # start,pause
        if key == 'q':
            key = None
            if rec_flag == 'stop':
                rec_flag = 'start'
                # set name
                vname = strftime("%Y-%m-%d-%H.%M.%S", localtime())
                Vilib.rec_video_set["name"] = vname
                # start record
                Vilib.rec_video_run()
                Vilib.rec_video_start()
                print_overwrite('rec start ...')
            elif rec_flag == 'start':
                rec_flag = 'pause'
                Vilib.rec_video_pause()
                print_overwrite('pause')
            elif rec_flag == 'pause':
                rec_flag = 'start'
                Vilib.rec_video_start()
                print_overwrite('continue')
        # stop
        elif key == 'e' and rec_flag != 'stop':
            key = None
            rec_flag = 'stop'
            Vilib.rec_video_stop()
            print_overwrite("The video saved as %s%s.avi"%(Vilib.rec_video_set["path"],vname),end='\n')
        # quit
        elif key == readchar.key.CTRL_C:
            Vilib.camera_close()
            print('\nquit')
            break

        sleep(0.1)

if __name__ == "__main__":
    main()

##################################################
# FILE: baseline_code/picar-x/example/2.keyboard_control.py
##################################################

from picarx import Picarx
from time import sleep
import readchar

manual = '''
Press keys on keyboard to control PiCar-X!
    w: Forward
    a: Turn left
    s: Backward
    d: Turn right
    i: Head up
    k: Head down
    j: Turn head left
    l: Turn head right
    ctrl+c: Press twice to exit the program
'''

def show_info():
    print("\033[H\033[J",end='')  # clear terminal windows
    print(manual)


if __name__ == "__main__":
    try:
        pan_angle = 0
        tilt_angle = 0
        px = Picarx()
        show_info()
        while True:
            key = readchar.readkey()
            key = key.lower()
            if key in('wsadikjl'): 
                if 'w' == key:
                    px.set_dir_servo_angle(0)
                    px.forward(80)
                elif 's' == key:
                    px.set_dir_servo_angle(0)
                    px.backward(80)
                elif 'a' == key:
                    px.set_dir_servo_angle(-30)
                    px.forward(80)
                elif 'd' == key:
                    px.set_dir_servo_angle(30)
                    px.forward(80)
                elif 'i' == key:
                    tilt_angle+=5
                    if tilt_angle>30:
                        tilt_angle=30
                elif 'k' == key:
                    tilt_angle-=5
                    if tilt_angle<-30:
                        tilt_angle=-30
                elif 'l' == key:
                    pan_angle+=5
                    if pan_angle>30:
                        pan_angle=30
                elif 'j' == key:
                    pan_angle-=5
                    if pan_angle<-30:
                        pan_angle=-30                 

                px.set_cam_tilt_angle(tilt_angle)
                px.set_cam_pan_angle(pan_angle)      
                show_info()                     
                sleep(0.5)
                px.forward(0)
          
            elif key == readchar.key.CTRL_C:
                print("\n Quit")
                break

    finally:
        px.set_cam_tilt_angle(0)
        px.set_cam_pan_angle(0)  
        px.set_dir_servo_angle(0)  
        px.stop()
        sleep(.2)




##################################################
# FILE: baseline_code/picar-x/example/calibration/grayscale_calibration.py
##################################################

from picarx import Picarx
import time
import threading
import readchar 
import os

px = Picarx()
config_path = px.CONFIG

manual = f'''\
        ┌────────────────────────────────────┐
        │ Picar-X Grayscale Module Reference │
        │       Calibration Helper           │
        └────────────────────────────────────┘
 config_file: {config_path}

 press [Q] to start line reference calibration,
 press [E] to start cliff reference calibration

 [SPACE]: confirm calibration           [Crtl+C]: quit
'''

current_grayscale_value = [0, 0, 0]
line_reference = px.line_reference
cliff_reference = px.cliff_reference
current_mode = None
thresholds = [
    [4096, 0], # min, max
    [4096, 0],
    [4096, 0],
]
line_min = [
    4096,
    4096,
    4096,
]

run_flag = False
cali_status = 'none' # none, work, done
_lock = threading.Lock()
key = ''

# print control
# ==========================================
def clear_line_and_print(msg, color=''):
    print(f'\033[K\033[{color}m{msg}\033[m')

def noecho():
    os.system("stty -echo")

def echo():
    os.system("stty echo")

def disable_cursor():
    print("\033[?25l", end='', flush=True)

def enable_cursor():
    print("\033[?25h", end='', flush=True)

# test direc servo
# ==========================================
px.set_dir_servo_angle(-30)
time.sleep(0.5)
px.set_dir_servo_angle(30)
time.sleep(0.5)
px.set_dir_servo_angle(0)
time.sleep(0.5)

# read grayscale value thread
# ==========================================
def read_data_loop():
    global current_grayscale_value, thresholds, run_flag, cali_status

    while run_flag:
        try:
            current_grayscale_value = px.get_grayscale_data()

            # calculate the reference
            if cali_status == 'work':
                for i in range(3):
                    if current_grayscale_value[i] < thresholds[i][0]:
                        thresholds[i][0] = current_grayscale_value[i]
                    if current_grayscale_value[i] > thresholds[i][1]:
                        thresholds[i][1] = current_grayscale_value[i]
                    line_reference[i] = int((thresholds[i][0] + thresholds[i][1])/2)
            if cali_status == 'done':
                if (cliff_reference[0] < line_reference[0]) and (cliff_reference[1] < line_reference[1]) and (cliff_reference[2] < line_reference[2]):
                    cliff_reference[0] = int((cliff_reference[0] + line_reference[0]) / 2)
                    cliff_reference[1] = int((cliff_reference[1] + line_reference[1]) / 2)
                    cliff_reference[2] = int((cliff_reference[2] + line_reference[2]) / 2)
                cali_status = 'none'

        except Exception as e:
            run_flag = False
            print(f'\033[31mread_data_loop error: {e}\033[m')
        time.sleep(0.2)

# read key thread
# ==========================================
def read_key_loop():
    global key, run_flag
    while run_flag:
        try:
            key = readchar.readkey()
            time.sleep(0.25)
        except KeyboardInterrupt:
            run_flag = False
            print('quit')
#
def update_info(isback=True):
    if isback:
        print("\033[6A", end='\r') # moves cursor up 6 lines

    if current_mode == None:
        clear_line_and_print(' ---------- ', color='32' )
    elif current_mode == 'line_cali':
        clear_line_and_print("Line reference auto calibrating ...", color='33')
    elif current_mode == 'line_cali_done':
        clear_line_and_print("Line reference auto calibration done.", color='32')
    elif current_mode == 'cliff_cali':
        clear_line_and_print("Cliff reference auto calibrating ...", color='33')
    elif current_mode == 'cliff_cali_done':
        clear_line_and_print("Cliff reference auto calibration done.", color='32')
    elif current_mode == 'saved':
        clear_line_and_print("The reference values has been saved.", color='32')

    _is_val_error = False
    if cali_status == 'none':
        for i in range(3):
            if line_reference[i] < cliff_reference[i]:
                _is_val_error = True
                break
    if _is_val_error:
        clear_line_and_print("Note that cliff reference values shou be less than line reference values.", color='31')
    else:
        clear_line_and_print("")

    clear_line_and_print(f'current value: {current_grayscale_value}')
    clear_line_and_print(f'thresholds: {thresholds}')
    clear_line_and_print(f'line reference: {line_reference}')
    clear_line_and_print(f'cliff reference: {cliff_reference}')


# line reference calibration
# =================================================================
def start_line_calibrate():
    def line_calibrate_work():
        global current_mode, cali_status, thresholds
        current_mode = 'line_cali'
        cali_status = 'work'
        # reset thresholds
        thresholds = [
            [4096, 0], # min, max
            [4096, 0],
            [4096, 0],
        ]
        _angle = 35
        _delay = 0.8
        # front left
        px.set_dir_servo_angle(-_angle)
        px.forward(10)
        time.sleep(_delay)
        # back left
        px.backward(10)
        time.sleep(_delay)
        # stop
        px.set_dir_servo_angle(0)
        px.stop()
        time.sleep(0.2)
        # front right
        px.set_dir_servo_angle(_angle)
        px.forward(10)
        time.sleep(_delay)
        # back right
        px.backward(10)
        time.sleep(_delay)
        # stop
        px.set_dir_servo_angle(0)
        px.stop()
        time.sleep(0.2)
        current_mode = 'line_cali_done'
        cali_status = 'done'
    line_calibrate_thread = threading.Thread(target=line_calibrate_work)
    line_calibrate_thread.daemon = True
    line_calibrate_thread.start()

# cliff reference calibration
def start_cliff_calibrate():
    def cliff_calibrate_work():
        global current_mode, cliff_reference, thresholds
        current_mode = 'cliff_cali'
        count = 0
        _left_val = 0
        _mid_val = 0
        _right_val = 0

        while True:
            _left_val += current_grayscale_value[0]
            _mid_val += current_grayscale_value[1]
            _right_val += current_grayscale_value[2]
            if count >= 10:
                break
            else:
                count += 1
            time.sleep(0.2)

        _left_val /= 10
        _mid_val /= 10
        _right_val /= 10

        if _left_val < thresholds[0][0] and _mid_val < thresholds[1][0] and _right_val < thresholds[2][0]:
            _left_val = int((_left_val + thresholds[0][0]) / 2)
            _mid_val = int((_mid_val + thresholds[1][0]) / 2)
            _right_val = int((_right_val + thresholds[2][0]) / 2)
        cliff_reference = [int(_left_val), int(_mid_val), int(_right_val)]
        current_mode = 'cliff_cali_done'

    cliff_calibrate_thread = threading.Thread(target=cliff_calibrate_work)
    cliff_calibrate_thread.daemon = True
    cliff_calibrate_thread.start()


def main():
    global key, current_mode, run_flag
    # start read data thread
    run_flag = True
    _read_data_thead = threading.Thread(target=read_data_loop)
    _read_data_thead.daemon = True
    _read_data_thead.start()
    # start read key thread
    _read_key_thead = threading.Thread(target=read_key_loop)
    _read_key_thead.daemon = True
    _read_key_thead.start()
    #
    noecho()
    disable_cursor()
    print(manual)
    update_info(False)
    while run_flag:
        key = key.lower()
        if key == 'q':
            current_mode = 'line_cali'
            start_line_calibrate()
        elif key == 'e':
            current_mode = 'cliff_cali'
            start_cliff_calibrate()
        elif key == readchar.key.SPACE:
            print('\033[32mConfirm save ?(y/n)\033[m')
            while True:
                key = key.lower()
                if key == 'y':
                    px.set_line_reference(line_reference)
                    px.set_cliff_reference(cliff_reference)
                    current_mode = 'saved'
                    print("\033[1A\033[J", end='\r')
                    break
                elif key == 'n':
                    current_mode = None
                    print("\033[1A\033[J", end='\r')
                    break
                time.sleep(0.05)
        # update print
        update_info()
        # reset key
        key = ''

        time.sleep(0.2)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print('quit')
    except Exception as e:
        print(e)
    finally:
        # enable echo
        echo()
        # enable cursor
        enable_cursor()
        # stop
        px.stop()
        time.sleep(0.1)


##################################################
# FILE: baseline_code/picar-x/example/calibration/calibration.py
##################################################

#!/usr/bin/env python3
from picarx import Picarx
from time import sleep
import readchar 

manual = '''
--------------- Picar-X Calibration Helper -----------------

    [1]: direction servo            [W/D]: increase servo angle
    [2]: camera pan servo           [S/A]: decrease servo angle
    [3]: camera tilt servo          [R]: servos test

    [4]: left motor                 [Q]: change motor direction
    [5]: right motor                [E]: motors run/stop

    [SPACE]: confirm calibration                [Crtl+C]: quit
                                      
'''    

px = Picarx()
px_power = 30

servo_num = 0
motor_num = 0
servo_names = ['direction servo', 'camera pan servo', 'camera tilt servo']
motor_names = ['left motor', 'right motor']
servos_cali = [px.dir_cali_val, px.cam_pan_cali_val, px.cam_tilt_cali_val]
motors_cali = px.cali_dir_value
servos_offset = list.copy(servos_cali)
motors_offset = list.copy(motors_cali)

def servos_test():
    px.set_dir_servo_angle(-30)
    sleep(0.5)
    px.set_dir_servo_angle(30)
    sleep(0.5)
    px.set_dir_servo_angle(0)
    sleep(0.5)
    px.set_cam_pan_angle(-30)
    sleep(0.5)
    px.set_cam_pan_angle(30)
    sleep(0.5)
    px.set_cam_pan_angle(0)
    sleep(0.5)
    px.set_cam_tilt_angle(-30)
    sleep(0.5)
    px.set_cam_tilt_angle(30)
    sleep(0.5)
    px.set_cam_tilt_angle(0)
    sleep(0.5)

def servos_move(servo_num, value):
    if servo_num == 0:
        px.set_dir_servo_angle(value)
    elif servo_num == 1:
        px.set_cam_pan_angle(value)
    elif servo_num == 2:
        px.set_cam_tilt_angle(value)
    sleep(0.2)

def set_servos_offset(servo_num, value):
    if servo_num == 0:
        px.dir_cali_val = value
    elif servo_num == 1:
        px.cam_pan_cali_val = value
    elif servo_num == 2:
        px.cam_tilt_cali_val  = value  

def servos_reset():
    for i in range(3):
        servos_move(i,0)

def show_info():
    print("\033[H\033[J", end='')  # clear terminal windows
    print(manual)
    print('[ %s ] [ %s ]'%(servo_names[servo_num], motor_names[motor_num])) 
    print('offset: %s, %s'%(servos_offset, motors_offset))


def cali_helper(): 
    global servo_num, motor_num
    global servos_cali, motors_cali, servos_offset, motors_offset
    motor_run = False
    step = 0.4
    # step = (180 / 2000) * (20000 / 4095)  # actual precision of steering gear

    # reset
    servos_reset()
    # show_info 
    show_info()

    # key control
    while True:
        # readkey
        key = readchar.readkey()
        key = key.lower()
        # select the servo 
        if key in ('123'):
            servo_num = int(key)-1
            show_info()
        if key in ('45'):
            motor_num = int(key)-4
            show_info()
        # servos move
        elif key == 'r':
            servos_test()
        elif key == 'w' or key == 'd':
            servos_offset[servo_num] += step
            if servos_offset[servo_num] > 20:
                servos_offset[servo_num] =20
            servos_offset[servo_num] = round(servos_offset[servo_num], 2) 
            show_info()
            set_servos_offset(servo_num, servos_offset[servo_num])
            servos_move(servo_num, 0)
        elif key == 's' or key == 'a':
            servos_offset[servo_num] -= step
            if servos_offset[servo_num] < -20:
                servos_offset[servo_num] = -20
            servos_offset[servo_num] = round(servos_offset[servo_num], 2) 
            show_info()
            set_servos_offset(servo_num, servos_offset[servo_num])
            servos_move(servo_num, 0)
        # motors move
        elif key == 'q': 
            motors_offset[motor_num] = -1 * motors_offset[motor_num]
            px.cali_dir_value = list.copy(motors_offset)
            motor_run = True
            px.forward(px_power)
            show_info()
        elif key == 'e':
            if motor_run == False:
                motor_run = True
                px.forward(px_power)
            else:
                motor_run = False
                px.stop()
        # save
        elif key == readchar.key.SPACE:
            print('Confirm save ?(y/n)')
            while True:
                key = readchar.readkey()
                key = key.lower()
                if key == 'y':
                    px.dir_servo_calibrate(servos_offset[0])
                    px.cam_pan_servo_calibrate(servos_offset[1])
                    px.cam_tilt_servo_calibrate(servos_offset[2])
                    px.motor_direction_calibrate(motor_num +1 , motors_offset[motor_num])
                    sleep(0.2)
                    servos_offset = [px.dir_cali_val, px.cam_pan_cali_val, px.cam_tilt_cali_val]
                    show_info()
                    print('The calibration value has been saved.')
                    break
                elif key == 'n':
                    show_info()
                    break   
                sleep(0.01) 

        # quit
        elif key == readchar.key.CTRL_C or key in readchar.key.ESC:
            print('quit')
            break 

        sleep(0.01)


if __name__ == "__main__":
    try:
        cali_helper()
    except KeyboardInterrupt:
        print('quit')
    except Exception as e:
        print(e)
    finally:
        px.stop()
        sleep(0.1)


##################################################
# FILE: baseline_code/picar-x/example/10.bull_fight.py
##################################################

from picarx import Picarx
from time import sleep
from vilib import Vilib


px = Picarx()

def clamp_number(num,a,b):
  return max(min(num, max(a, b)), min(a, b))

def main():
    Vilib.camera_start()
    Vilib.display()
    Vilib.color_detect("red")
    speed = 50
    dir_angle=0
    x_angle =0
    y_angle =0
    while True:
        if Vilib.detect_obj_parameter['color_n']!=0:
            coordinate_x = Vilib.detect_obj_parameter['color_x']
            coordinate_y = Vilib.detect_obj_parameter['color_y']
            
            # change the pan-tilt angle for track the object
            x_angle +=(coordinate_x*10/640)-5
            x_angle = clamp_number(x_angle,-35,35)
            px.set_cam_pan_angle(x_angle)

            y_angle -=(coordinate_y*10/480)-5
            y_angle = clamp_number(y_angle,-35,35)
            px.set_cam_tilt_angle(y_angle)

            # move
            # The movement direction will change slower than the pan/tilt direction 
            # change to avoid confusion when the picture changes at high speed.
            if dir_angle > x_angle:
                dir_angle -= 1
            elif dir_angle < x_angle:
                dir_angle += 1
            px.set_dir_servo_angle(x_angle)
            px.forward(speed)
            sleep(0.05)

        else :
            px.forward(0)
            sleep(0.05)


if __name__ == "__main__":
    try:
       main()
    
    
    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


##################################################
# FILE: baseline_code/picar-x/example/4.avoiding_obstacles.py
##################################################

from picarx import Picarx
import time

POWER = 50
SafeDistance = 40   # > 40 safe
DangerDistance = 20 # > 20 && < 40 turn around, 
                    # < 20 backward

def main():
    try:
        px = Picarx()
        # px = Picarx(ultrasonic_pins=['D2','D3']) # tring, echo
       
        while True:
            distance = round(px.ultrasonic.read(), 2)
            print("distance: ",distance)
            if distance >= SafeDistance:
                px.set_dir_servo_angle(0)
                px.forward(POWER)
            elif distance >= DangerDistance:
                px.set_dir_servo_angle(30)
                px.forward(POWER)
                time.sleep(0.1)
            else:
                px.set_dir_servo_angle(-30)
                px.backward(POWER)
                time.sleep(0.5)

    finally:
        px.forward(0)


if __name__ == "__main__":
    main()



##################################################
# FILE: baseline_code/picar-x/example/1.move.py
##################################################

from picarx import Picarx
import time


if __name__ == "__main__":
    try:
        # init picarx
        px = Picarx()

        # test motor
        px.forward(30)
        time.sleep(0.5)
        # test direction servo
        for angle in range(0, 35):
            px.set_dir_servo_angle(angle)
            time.sleep(0.01)
        for angle in range(35, -35, -1):
            px.set_dir_servo_angle(angle)
            time.sleep(0.01)
        for angle in range(-35, 0):
            px.set_dir_servo_angle(angle)
            time.sleep(0.01)
        px.stop()
        time.sleep(1)
        # test cam servos
        for angle in range(0, 35):
            px.set_cam_pan_angle(angle)
            time.sleep(0.01)
        for angle in range(35, -35, -1):
            px.set_cam_pan_angle(angle)
            time.sleep(0.01)        
        for angle in range(-35, 0):
            px.set_cam_pan_angle(angle)
            time.sleep(0.01)
        for angle in range(0, 35):
            px.set_cam_tilt_angle(angle)
            time.sleep(0.01)
        for angle in range(35, -35,-1):
            px.set_cam_tilt_angle(angle)
            time.sleep(0.01)        
        for angle in range(-35, 0):
            px.set_cam_tilt_angle(angle)
            time.sleep(0.01)
    finally:
        px.stop()
        time.sleep(0.2)




##################################################
# FILE: baseline_code/picar-x/example/5.minecart_plus.py
##################################################

'''
    Line Following program for Picar-X:

    Pay attention to modify the reference value of the grayscale module 
    according to the practical usage scenarios.
    Auto calibrate grayscale values:
        Please run ./calibration/grayscale_calibration.py
    Manual modification:
        Use the following: 
            px.set_line_reference([1400, 1400, 1400])
        The reference value be close to the middle of the line gray value
        and the background gray value.

'''
from picarx import Picarx
from time import sleep

px = Picarx()
# px = Picarx(grayscale_pins=['A0', 'A1', 'A2'])

# Please run ./calibration/grayscale_calibration.py to Auto calibrate grayscale values
# or manual modify reference value by follow code
# px.set_line_reference([1400, 1400, 1400])

current_state = None
px_power = 10
offset = 20
last_state = "stop"

def outHandle():
    global last_state, current_state
    if last_state == 'left':
        px.set_dir_servo_angle(-30)
        px.backward(10)
    elif last_state == 'right':
        px.set_dir_servo_angle(30)
        px.backward(10)
    while True:
        gm_val_list = px.get_grayscale_data()
        gm_state = get_status(gm_val_list)
        print("outHandle gm_val_list: %s, %s"%(gm_val_list, gm_state))
        currentSta = gm_state
        if currentSta != last_state:
            break
    sleep(0.001)

def get_status(val_list):
    _state = px.get_line_status(val_list)  # [bool, bool, bool], 0 means line, 1 means background
    if _state == [0, 0, 0]:
        return 'stop'
    elif _state[1] == 1:
        return 'forward'
    elif _state[0] == 1:
        return 'right'
    elif _state[2] == 1:
        return 'left'

if __name__=='__main__':
    try:
        while True:
            gm_val_list = px.get_grayscale_data()
            gm_state = get_status(gm_val_list)
            print("gm_val_list: %s, %s"%(gm_val_list, gm_state))

            if gm_state != "stop":
                last_state = gm_state

            if gm_state == 'forward':
                px.set_dir_servo_angle(0)
                px.forward(px_power) 
            elif gm_state == 'left':
                px.set_dir_servo_angle(offset)
                px.forward(px_power) 
            elif gm_state == 'right':
                px.set_dir_servo_angle(-offset)
                px.forward(px_power) 
            else:
                outHandle()
    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


##################################################
# FILE: baseline_code/picar-x/example/servo_zeroing.py
##################################################


from robot_hat import Servo
from robot_hat.utils import reset_mcu
from time import sleep

reset_mcu()
sleep(0.2)

if __name__ == '__main__':
    print(f"Set servo to zero")
    for i in range(12):
        # print(f"Servo {i} set to zero")
        Servo(i).angle(10)
        sleep(0.1)
        Servo(i).angle(0)
        sleep(0.1)
    while True:
        sleep(1)

##################################################
# FILE: baseline_code/picar-x/example/11.video_car.py
##################################################

# #!/usr/bin/env python3

from robot_hat.utils import reset_mcu
from picarx import Picarx
from vilib import Vilib
from time import sleep, time, strftime, localtime
import readchar

import os
user = os.getlogin()
user_home = os.path.expanduser(f'~{user}')

reset_mcu()
sleep(0.2)

manual = '''
Press key to call the function(non-case sensitive):

    O: speed up
    P: speed down
    W: forward  
    S: backward
    A: turn left
    D: turn right
    F: stop
    T: take photo

    Ctrl+C: quit
'''


px = Picarx()

def take_photo():
    _time = strftime('%Y-%m-%d-%H-%M-%S',localtime(time()))
    name = 'photo_%s'%_time
    path = f"{user_home}/Pictures/picar-x/"
    Vilib.take_photo(name, path)
    print('\nphoto save as %s%s.jpg'%(path,name))


def move(operate:str, speed):

    if operate == 'stop':
        px.stop()  
    else:
        if operate == 'forward':
            px.set_dir_servo_angle(0)
            px.forward(speed)
        elif operate == 'backward':
            px.set_dir_servo_angle(0)
            px.backward(speed)
        elif operate == 'turn left':
            px.set_dir_servo_angle(-30)
            px.forward(speed)
        elif operate == 'turn right':
            px.set_dir_servo_angle(30)
            px.forward(speed)
        


def main():
    speed = 0
    status = 'stop'

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=True,web=True)
    sleep(2)  # wait for startup
    print(manual)
    
    while True:
        print("\rstatus: %s , speed: %s    "%(status, speed), end='', flush=True)
        # readkey
        key = readchar.readkey().lower()
        # operation 
        if key in ('wsadfop'):
            # throttle
            if key == 'o':
                if speed <=90:
                    speed += 10           
            elif key == 'p':
                if speed >=10:
                    speed -= 10
                if speed == 0:
                    status = 'stop'
            # direction
            elif key in ('wsad'):
                if speed == 0:
                    speed = 10
                if key == 'w':
                    # Speed limit when reversing,avoid instantaneous current too large
                    if status != 'forward' and speed > 60:  
                        speed = 60
                    status = 'forward'
                elif key == 'a':
                    status = 'turn left'
                elif key == 's':
                    if status != 'backward' and speed > 60: # Speed limit when reversing
                        speed = 60
                    status = 'backward'
                elif key == 'd':
                    status = 'turn right' 
            # stop
            elif key == 'f':
                status = 'stop'
            # move 
            move(status, speed)  
        # take photo
        elif key == 't':
            take_photo()
        # quit
        elif key == readchar.key.CTRL_C:
            print('\nquit ...')
            px.stop()
            Vilib.camera_close()
            break 

        sleep(0.1)


if __name__ == "__main__":
    try:
        main()
    except Exception as e:    
        print("error:%s"%e)
    finally:
        px.stop()
        Vilib.camera_close()


        

##################################################
# FILE: baseline_code/picar-x/example/12.treasure_hunt.py
##################################################

from picarx import Picarx
from time import sleep
from robot_hat import Music,TTS
from vilib import Vilib
import readchar
import random
import threading

px = Picarx()

music = Music()
tts = TTS()

manual = '''
Press keys on keyboard to control Picar-X!
    w: Forward
    a: Turn left
    s: Backward
    d: Turn right
    space: Say the target again
    ctrl+c: Quit
'''

color = "red"
color_list=["red","orange","yellow","green","blue","purple"]

def renew_color_detect():
    global color
    color = random.choice(color_list)
    Vilib.color_detect(color)
    tts.say("Look for " + color)

key = None
lock = threading.Lock()
def key_scan_thread():
    global key
    while True:
        key_temp = readchar.readkey()
        print('\r',end='')
        with lock:
            key = key_temp.lower()
            if key == readchar.key.SPACE:
                key = 'space'
            elif key == readchar.key.CTRL_C:
                key = 'quit'
                break
        sleep(0.01)

def car_move(key):
    if 'w' == key:
        px.set_dir_servo_angle(0)
        px.forward(80)
    elif 's' == key:
        px.set_dir_servo_angle(0)
        px.backward(80)
    elif 'a' == key:
        px.set_dir_servo_angle(-30)
        px.forward(80)
    elif 'd' == key:
        px.set_dir_servo_angle(30)
        px.forward(80)


def main():
    global key
    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=False,web=True)
    sleep(0.8)
    print(manual)

    sleep(1)
    _key_t = threading.Thread(target=key_scan_thread)
    _key_t.setDaemon(True)
    _key_t.start()

    tts.say("game start")
    sleep(0.05)
    renew_color_detect()
    while True:

        if Vilib.detect_obj_parameter['color_n']!=0 and Vilib.detect_obj_parameter['color_w']>100:
            tts.say("will done")
            sleep(0.05)
            renew_color_detect()

        with lock:
            if key != None and key in ('wsad'):
                car_move(key)
                sleep(0.5)
                px.stop()
                key =  None
            elif key == 'space':
                tts.say("Look for " + color)
                key =  None
            elif key == 'quit':
                _key_t.join()
                print("\n\rQuit")
                break

        sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"ERROR: {e}")
    finally:
        Vilib.camera_close()
        px.stop()
        sleep(.2)

##################################################
# FILE: baseline_code/picar-x/example/8.stare_at_you.py
##################################################

from picarx import Picarx
from time import sleep
from vilib import Vilib

px = Picarx()

def clamp_number(num,a,b):
  return max(min(num, max(a, b)), min(a, b))

def main():
    Vilib.camera_start()
    Vilib.display()
    Vilib.face_detect_switch(True)
    x_angle =0
    y_angle =0
    while True:
        if Vilib.detect_obj_parameter['human_n']!=0:
            coordinate_x = Vilib.detect_obj_parameter['human_x']
            coordinate_y = Vilib.detect_obj_parameter['human_y']
            
            # change the pan-tilt angle for track the object
            x_angle +=(coordinate_x*10/640)-5
            x_angle = clamp_number(x_angle,-35,35)
            px.set_cam_pan_angle(x_angle)

            y_angle -=(coordinate_y*10/480)-5
            y_angle = clamp_number(y_angle,-35,35)
            px.set_cam_tilt_angle(y_angle)

            sleep(0.05)

        else :
            pass
            sleep(0.05)


if __name__ == "__main__":
    try:
       main()
    
    
    finally:
        px.stop()
        print("stop and exit")
        sleep(0.1)


##################################################
# FILE: baseline_code/picar-x/example/7.display.py
##################################################

from pydoc import text
from vilib import Vilib
from time import sleep, time, strftime, localtime
import threading
import readchar
import os

flag_face = False
flag_color = False
qr_code_flag = False

manual = '''
Input key to call the function!
    q: Take photo
    1: Color detect : red
    2: Color detect : orange
    3: Color detect : yellow
    4: Color detect : green
    5: Color detect : blue
    6: Color detect : purple
    0: Switch off Color detect
    r: Scan the QR code
    f: Switch ON/OFF face detect
    s: Display detected object information
'''

color_list = ['close', 'red', 'orange', 'yellow',
        'green', 'blue', 'purple',
]

def face_detect(flag):
    print("Face Detect:" + str(flag))
    Vilib.face_detect_switch(flag)


def qrcode_detect():
    global qr_code_flag
    if qr_code_flag == True:
        Vilib.qrcode_detect_switch(True)
        print("Waitting for QR code")

    text = None
    while True:
        temp = Vilib.detect_obj_parameter['qr_data']
        if temp != "None" and temp != text:
            text = temp
            print('QR code:%s'%text)
        if qr_code_flag == False:
            break
        sleep(0.5)
    Vilib.qrcode_detect_switch(False)


def take_photo():
    _time = strftime('%Y-%m-%d-%H-%M-%S',localtime(time()))
    name = 'photo_%s'%_time
    username = os.getlogin()

    path = f"/home/{username}/Pictures/"
    Vilib.take_photo(name, path)
    print('photo save as %s%s.jpg'%(path,name))


def object_show():
    global flag_color, flag_face

    if flag_color is True:
        if Vilib.detect_obj_parameter['color_n'] == 0:
            print('Color Detect: None')
        else:
            color_coodinate = (Vilib.detect_obj_parameter['color_x'],Vilib.detect_obj_parameter['color_y'])
            color_size = (Vilib.detect_obj_parameter['color_w'],Vilib.detect_obj_parameter['color_h'])
            print("[Color Detect] ","Coordinate:",color_coodinate,"Size",color_size)

    if flag_face is True:
        if Vilib.detect_obj_parameter['human_n'] == 0:
            print('Face Detect: None')
        else:
            human_coodinate = (Vilib.detect_obj_parameter['human_x'],Vilib.detect_obj_parameter['human_y'])
            human_size = (Vilib.detect_obj_parameter['human_w'],Vilib.detect_obj_parameter['human_h'])
            print("[Face Detect] ","Coordinate:",human_coodinate,"Size",human_size)


def main():
    global flag_face, flag_color, qr_code_flag
    qrcode_thread = None

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=True,web=True)
    print(manual)

    while True:
        # readkey
        key = readchar.readkey()
        key = key.lower()
        # take photo
        if key == 'q':
            take_photo()
        # color detect
        elif key != '' and key in ('0123456'):  # '' in ('0123') -> True
            index = int(key)
            if index == 0:
                flag_color = False
                Vilib.color_detect('close')
            else:
                flag_color = True
                Vilib.color_detect(color_list[index]) # color_detect(color:str -> color_name/close)
            print('Color detect : %s'%color_list[index])
        # face detection
        elif key =="f":
            flag_face = not flag_face
            face_detect(flag_face)
        # qrcode detection
        elif key =="r":
            qr_code_flag = not qr_code_flag
            if qr_code_flag == True:
                if qrcode_thread == None or not qrcode_thread.is_alive():
                    qrcode_thread = threading.Thread(target=qrcode_detect)
                    qrcode_thread.daemon = True
                    qrcode_thread.start()
            else:
                if qrcode_thread != None and qrcode_thread.is_alive():
                # wait for thread to end
                    qrcode_thread.join()
                    print('QRcode Detect: close')
        # show detected object information
        elif key == "s":
            object_show()

        sleep(0.5)


if __name__ == "__main__":
    main()

##################################################
# FILE: baseline_code/picar-x/example/3.tts_example.py
##################################################

from time import sleep
from robot_hat import Music,TTS
import readchar
from os import geteuid

if geteuid() != 0:
    print(f"\033[0;33m{'The program needs to be run using sudo, otherwise there may be no sound.'}\033[0m")

music = Music()
tts = TTS()

manual = '''
Input key to call the function!
    space: Play sound effect (Car horn)
    c: Play sound effect with threads
    t: Text to speak
    q: Play/Stop Music
'''

def main():
    print(manual)

    flag_bgm = False
    music.music_set_volume(20)
    tts.lang("en-US")

    while True:
        key = readchar.readkey()
        key = key.lower()
        if key == "q":
            flag_bgm = not flag_bgm
            if flag_bgm is True:
                print('Play Music')
                music.music_play('../musics/slow-trail-Ahjay_Stelino.mp3')
            else:
                print('Stop Music')
                music.music_stop()

        elif key == readchar.key.SPACE:
            print('Beep beep beep !')
            music.sound_play('../sounds/car-double-horn.wav')
            sleep(0.05)

        elif key == "c":
            print('Beep beep beep !')
            music.sound_play_threading('../sounds/car-double-horn.wav')
            sleep(0.05)

        elif key == "t":
            words = "Hello"
            print(f'{words}')
            tts.say(words)

if __name__ == "__main__":
    main()

##################################################
# FILE: baseline_code/picar-x/example/13.app_control.py
##################################################

from sunfounder_controller import SunFounderController
from picarx import Picarx
from robot_hat import utils, Music
from vilib import Vilib
import os
from time import sleep

# reset robot_hat
utils.reset_mcu()
sleep(0.2)

# init SunFounder Controller class
sc = SunFounderController()
sc.set_name('Picarx-001')
sc.set_type('Picarx')
sc.start()

# init picarx
px = Picarx()
speed = 0

current_line_state = None
last_line_state = "stop"
LINE_TRACK_SPEED = 10
LINE_TRACK_ANGLE_OFFSET = 20

AVOID_OBSTACLES_SPEED = 40
SafeDistance = 40   # > 40 safe
DangerDistance = 20 # > 20 && < 40 turn around, < 20 backward

DETECT_COLOR = 'red' # red, green, blue, yellow , orange, purple

# init music player
User = os.popen('echo ${SUDO_USER:-$LOGNAME}').readline().strip()
UserHome = os.popen('getent passwd %s | cut -d: -f 6' %User).readline().strip()

music = Music()
if os.geteuid() != 0:
    print('\033[33mPlay sound needs to be run with sudo.\033[m')

def horn(): 
    _status, _result = utils.run_command('sudo killall pulseaudio')
    music.sound_play_threading(f'{UserHome}/picar-x/sounds/car-double-horn.wav')

def avoid_obstacles():
    distance = px.get_distance()
    if distance >= SafeDistance:
        px.set_dir_servo_angle(0)
        px.forward(AVOID_OBSTACLES_SPEED)
    elif distance >= DangerDistance:
        px.set_dir_servo_angle(30)
        px.forward(AVOID_OBSTACLES_SPEED)
        sleep(0.1)
    else:
        px.set_dir_servo_angle(-30)
        px.backward(AVOID_OBSTACLES_SPEED)
        sleep(0.5) 

def get_status(val_list):
    _state = px.get_line_status(val_list)  # [bool, bool, bool], 0 means line, 1 means background
    if _state == [0, 0, 0]:
        return 'stop'
    elif _state[1] == 1:
        return 'forward'
    elif _state[0] == 1:
        return 'right'
    elif _state[2] == 1:
        return 'left'

def outHandle():
    global last_line_state, current_line_state
    if last_line_state == 'left':
        px.set_dir_servo_angle(-30)
        px.backward(10)
    elif last_line_state == 'right':
        px.set_dir_servo_angle(30)
        px.backward(10)
    while True:
        gm_val_list = px.get_grayscale_data()
        gm_state = get_status(gm_val_list)
        currentSta = gm_state
        if currentSta != last_line_state:
            break
    sleep(0.001)

def line_track():
    global last_line_state
    gm_val_list = px.get_grayscale_data()
    gm_state = get_status(gm_val_list)

    if gm_state != "stop":
        last_line_state = gm_state

    if gm_state == 'forward':
        px.set_dir_servo_angle(0)
        px.forward(LINE_TRACK_SPEED) 
    elif gm_state == 'left':
        px.set_dir_servo_angle(LINE_TRACK_ANGLE_OFFSET)
        px.forward(LINE_TRACK_SPEED) 
    elif gm_state == 'right':
        px.set_dir_servo_angle(-LINE_TRACK_ANGLE_OFFSET)
        px.forward(LINE_TRACK_SPEED) 
    else:
        outHandle()

def main():
    global speed

    ip = utils.get_ip()
    print('ip : %s'%ip)
    sc.set('video','http://'+ip+':9000/mjpg')

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.display(local=False, web=True)
    speak = None
    while True:
        # --- send data ---
        sc.set("A", speed)

        grayscale_data = px.get_grayscale_data()
        sc.set("D", grayscale_data )

        distance = px.get_distance()
        sc.set("F", distance)

        # --- control ---

        # # horn
        if sc.get('M') == True:
            horn()

        # speaker
        if sc.get('J') != None:
            speak=sc.get('J')
            print(f'speaker: {speak}')
        if speak in ["forward"]:
            px.forward(speed)
        elif speak in ["backward"]:
            px.backward(speed)
        elif speak in ["left"]:
            px.set_dir_servo_angle(-30)
            px.forward(60)
            sleep(1.2)
            px.set_dir_servo_angle(0)
            px.forward(speed)
        elif speak in ["right", "white", "rice"]:
            px.set_dir_servo_angle(30)
            px.forward(60)
            sleep(1.2)
            px.set_dir_servo_angle(0)
            px.forward(speed)
        elif speak in ["stop"]:
            px.stop()

        # line_track and avoid_obstacles
        line_track_switch = sc.get('I')
        avoid_obstacles_switch = sc.get('E')
        if line_track_switch == True:
            speed = LINE_TRACK_SPEED
            line_track()
        elif avoid_obstacles_switch == True:
            speed = AVOID_OBSTACLES_SPEED
            avoid_obstacles()
    
        # joystick moving
        if line_track_switch != True and avoid_obstacles_switch != True:
            Joystick_K_Val = sc.get('K')
            if Joystick_K_Val != None:
                dir_angle = utils.mapping(Joystick_K_Val[0], -100, 100, -30, 30)
                speed = Joystick_K_Val[1]
                px.set_dir_servo_angle(dir_angle)
                if speed > 0:
                    px.forward(speed)
                elif speed < 0:
                    speed = -speed
                    px.backward(speed)
                else:
                    px.stop()

        # camera servos control
        Joystick_Q_Val = sc.get('Q')
        if Joystick_Q_Val != None:
            pan = min(90, max(-90, Joystick_Q_Val[0]))
            tilt = min(65, max(-35, Joystick_Q_Val[1]))
            px.set_cam_pan_angle(pan)
            px.set_cam_tilt_angle(tilt)

        # image recognition
        if sc.get('N') == True:
            Vilib.color_detect(DETECT_COLOR)
        else:
            Vilib.color_detect("close")

        if sc.get('O') == True:
            Vilib.face_detect_switch(True)  
        else:
            Vilib.face_detect_switch(False)  

        if sc.get('P') == True:
            Vilib.object_detect_switch(True) 
        else:
            Vilib.object_detect_switch(False)


if __name__ == "__main__":
    try:
        main()
    finally:
        print("stop and exit")
        px.stop()
        Vilib.camera_close()






##################################################
# FILE: baseline_code/picar-x/i2samp.sh
##################################################

#!/bin/bash

: <<'DISCLAIMER'

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

This script is licensed under the terms of the MIT license.
Unless otherwise noted, code reproduced herein
was written for this script.

- The Pimoroni Crew - (modified by Adafruit!)

DISCLAIMER

# script control variables
# =================================================================
productname="i2s amplifier" # the name of the product to install
scriptname="i2samp" # the name of this script
spacereq=1 # minimum size required on root partition in MB
debugmode="no" # whether the script should use debug routines
debuguser="none" # optional test git user to use in debug mode
debugpoint="none" # optional git repo branch or tag to checkout
forcesudo="no" # whether the script requires to be ran with root privileges
promptreboot="no" # whether the script should always prompt user to reboot
mininstall="no" # whether the script enforces minimum install routine
customcmd="yes" # whether to execute commands specified before exit
armv6="yes" # whether armv6 processors are supported
armv7="yes" # whether armv7 processors are supported
armv8="yes" # whether armv8 processors are supported
arm64="yes" # whether arm64 processors are supported
raspbianonly="no" # whether the script is allowed to run on other OSes
osreleases=( "Raspbian" ) # list os-releases supported
oswarning=( "Debian" "Kano" "Mate" "PiTop" "Ubuntu" ) # list experimental os-releases
osdeny=( "Darwin" "Kali" ) # list os-releases specifically disallowed

FORCE=$1
DEVICE_TREE=true
ASK_TO_REBOOT=false
CURRENT_SETTING=false
UPDATE_DB=false

BOOTCMD=/boot/firmware/cmdline.txt
CONFIG=/boot/firmware/config.txt
APTSRC=/etc/apt/sources.list
INITABCONF=/etc/inittab
BLACKLIST=/etc/modprobe.d/raspi-blacklist.conf
LOADMOD=/etc/modules
DTBODIR=/boot/overlays

AUTO_SOUND_CARD=/usr/local/bin/auto_sound_card

# Fall back to old location
if ! test -f $CONFIG; then
    CONFIG=/boot/config.txt
fi

# function define
# =================================================================
confirm() {
    if [ "$FORCE" == '-y' ]; then
        true
    else
        read -r -p "$1 [y/N] " response < /dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
    fi
}

prompt() {
        read -r -p "$1 [y/N] " response < /dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
}

success() {
    echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

inform() {
    echo -e "$(tput setaf 6)$1$(tput sgr0)"
}

warning() {
    echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

newline() {
    echo ""
}

progress() {
    count=0
    until [ $count -eq $1 ]; do
        echo -n "..." && sleep 1
        ((count++))
    done
    echo
}
sudocheck() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "Install must be run as root. Try 'sudo ./$scriptname'\n"
        exit 1
    fi
}

sysclean() {
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &> /dev/null
}

sysupdate() {
    if ! $UPDATE_DB; then
        echo "Updating apt indexes..." && progress 3 &
        sudo apt-get update 1> /dev/null || { warning "Apt failed to update indexes!" && exit 1; }
        echo "Reading package lists..."
        progress 3 && UPDATE_DB=true
    fi
}

sysupgrade() {
    sudo apt-get upgrade
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &> /dev/null
}

sysreboot() {
    warning "Some changes made to your system require"
    warning "your computer to reboot to take effect."
    newline
    if prompt "Would you like to reboot now?"; then
        sync && sudo reboot
    fi
}

arch_check() {
    IS_ARM64=false
    IS_ARMHF=false
    IS_ARMv6=false

    if uname -m | grep "aarch64" > /dev/null; then
        IS_ARM64=true
    fi
    if uname -m | grep "armv.l" > /dev/null; then
        IS_ARMHF=true
        if uname -m | grep "armv6l" > /dev/null; then
            IS_ARMv6=true
        fi
    fi
}

os_check() {
    IS_RASPBIAN=false
    IS_MACOSX=false
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "Raspbian" > /dev/null; then
            IS_RASPBIAN=true && IS_SUPPORTED=true
        fi
        if command -v apt-get > /dev/null; then
            for os in ${osreleases[@]}; do
                if cat /etc/os-release | grep $os > /dev/null; then
                    IS_SUPPORTED=true && IS_EXPERIMENTAL=false
                fi
            done
            for os in ${oswarning[@]}; do
                if cat /etc/os-release | grep $os > /dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=true
                fi
            done
            for os in ${osdeny[@]}; do
                if cat /etc/os-release | grep $os > /dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=false
                fi
            done
        fi
    fi
    if [ -d ~/.kano-settings ] || [ -d ~/.kanoprofile ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -f ~/.pt-dashboard-config ] || [ -d ~/.pt-dashboard ] || [ -d ~/.pt-os-dashboard ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -d ~/.config/ubuntu-mate ]; then
        for os in ${osdeny[@]}; do
            if [ $os == "Mate" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if uname -s | grep "Darwin" > /dev/null; then
        IS_MACOSX=true
        for os in ${osdeny[@]}; do
            if [ $os == "Darwin" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
}

raspbian_check() {
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "/sid" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bookworm" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bullseye" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "buster" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "stretch" > /dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "jessie" > /dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "wheezy" > /dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        else
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        fi
    fi
}

# main
# =================================================================
: <<'MAINSTART'

Perform all global variables declarations as well as function definition
above this section for clarity, thanks!

MAINSTART

# check platform
#=======================
arch_check
os_check

if [ $debugmode != "no" ]; then
    echo "USER_HOME is $USER_HOME" && newline
    echo "IS_RASPBIAN is $IS_RASPBIAN"
    echo "IS_MACOSX is $IS_MACOSX"
    echo "IS_SUPPORTED is $IS_SUPPORTED"
    echo "IS_EXPERIMENTAL is $IS_EXPERIMENTAL"
    newline
fi

if ! $IS_ARMHF && ! $IS_ARM64; then
    warning "This hardware is not supported, sorry!"
    warning "Config files have been left untouched"
    newline && exit 1
fi

if $IS_ARM64 && [ $arm64 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv8 && [ $armv8 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv7 && [ $armv7 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv6 && [ $armv6 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
fi

if [ $raspbianonly == "yes" ] && ! $IS_RASPBIAN;then
        warning "This script is intended for Raspbian on a Raspberry Pi!"
        newline && exit 1
fi

if $IS_RASPBIAN; then
    raspbian_check
    if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
        newline && warning "--- Warning ---" && newline
        echo "The $productname installer"
        echo "does not work on this version of Raspbian."
        echo "Check https://github.com/$gitusername/$gitreponame"
        echo "for additional information and support"
        newline && exit 1
    fi
fi

if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
        warning "Your operating system is not supported, sorry!"
        newline && exit 1
fi

if $IS_EXPERIMENTAL; then
    warning "Support for your operating system is experimental. Please visit"
    warning "forums.adafruit.com if you experience issues with this product."
    newline
fi

if [ $forcesudo == "yes" ]; then
    sudocheck
fi

newline
echo "This script will install everything needed to use"
echo "$productname"
newline
warning "--- Warning ---"
newline
echo "Always be careful when running scripts and commands"
echo "copied from the internet. Ensure they are from a"
echo "trusted source."
newline
echo "If you want to see what this script does before"
echo "running it, you should run:"
echo "    \curl -sS github.com/adafruit/Raspberry-Pi-Installer-Scripts/$scriptname"
newline

# ask whether to continue
#=======================
if ! confirm "Do you wish to continue?"; then
    newline
    echo "Aborting..."
    newline
    exit 0
fi

# config dtoverlay
#=======================
newline
echo "Checking hardware requirements..."

if [ -e $CONFIG ] && grep -q "^device_tree=$" $CONFIG; then
    DEVICE_TREE=false
fi

if $DEVICE_TREE; then

    newline
    echo "Adding Device Tree Entry to $CONFIG"

    if [ -e $CONFIG ] && grep -q "^dtoverlay=hifiberry-dac$" $CONFIG; then
        echo "dtoverlay already active"
    else
        echo "dtoverlay=hifiberry-dac" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $CONFIG ] && grep -q "^dtoverlay=i2s-mmap$" $CONFIG; then
        echo "i2s mmap dtoverlay already active"
    else
        echo "dtoverlay=i2s-mmap" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $BLACKLIST ]; then
        newline
        echo "Commenting out Blacklist entry in "
        echo "$BLACKLIST"
        sudo sed -i -e "s|^blacklist[[:space:]]*i2c-bcm2708.*|#blacklist i2c-bcm2708|" \
                    -e "s|^blacklist[[:space:]]*snd-soc-pcm512x.*|#blacklist snd-soc-pcm512x|" \
                    -e "s|^blacklist[[:space:]]*snd-soc-wm8804.*|#blacklist snd-soc-wm8804|" $BLACKLIST &> /dev/null
    fi
else
    newline
    echo "No Device Tree Detected, not supported"
    newline
    exit 1
fi

# install alsa-utils 
#=======================
sudo apt install alsa-utils -y

# aplay from /dev/zero at system start
#=======================
newline
echo "Installing aplay systemd unit"
sudo sh -c 'cat > /etc/systemd/system/aplay.service' << 'EOL'
[Unit]
Description=Invoke aplay from /dev/zero at system start.

[Service]
ExecStart=/usr/bin/aplay -D default -t raw -r 44100 -c 2 -f S16_LE /dev/zero

[Install]
WantedBy=multi-user.target
EOL

sudo systemctl daemon-reload
sudo systemctl disable aplay
newline
echo "You can optionally activate '/dev/zero' playback in"
echo "the background at boot. This will remove all"
echo "popping/clicking but does use some processor time."
newline
if confirm "Activate '/dev/zero' playback in background? [RECOMMENDED]"; then
newline
sudo systemctl enable aplay
ASK_TO_REBOOT=true
fi

# config asound
#=======================
newline
echo "Configuring sound output"
# backup file
if [ -e /etc/asound.conf ]; then
    if [ -e /etc/asound.conf.old ]; then
        sudo rm -f /etc/asound.conf.old
    fi
    sudo cp /etc/asound.conf /etc/asound.conf.old
fi

# auto_sound_card scripts

sudo cat > /usr/local/bin/auto_sound_card << '-EOF'
#!/bin/bash

ASOUND_CONF=/etc/asound.conf
AUDIO_CARD_NAME="sndrpihifiberry"

card_num=$(sudo aplay -l |grep $AUDIO_CARD_NAME |awk '{print $2}'|tr -d ':')
echo "card_num=$card_num"
if [ -n "$card_num" ]; then
    cat > $ASOUND_CONF << EOF
pcm.speakerbonnet {
    type hw card $card_num
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speakerbonnet"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw card $card_num
}

pcm.softvol {
    type softvol
    slave.pcm "dmixer"
    control.name "PCM"
    control.card $card_num
}

ctl.softvol {
    type hw card $card_num
}

pcm.!default {
    type             plug
    slave.pcm       "softvol"
}
EOF
    echo "systemctl restart aplay.service"
    sudo systemctl restart aplay.service

    if [ -n $1 ] && [ $1 -gt 0 ]; then
        echo "set volume to $1"
        amixer -c $card_num sset PCM $1%
    fi

fi

exit 0
-EOF

sudo chmod +x /usr/local/bin/auto_sound_card

# execute the script once
sudo /usr/local/bin/auto_sound_card 100

# add auto_sound_card start on boot
sudo cat > /etc/systemd/system/auto_sound_card.service << EOF
[Unit]
Description=Auto config als sound card num at system start.
Wants=aplay.service

[Service]
ExecStart=/usr/local/bin/auto_sound_card

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable auto_sound_card

#=======================
newline
echo "We can now test your $productname"
warning "Set your speakers if possible!"
if confirm "Do you wish to test your system now?"; then
    echo "Testing..."
    pinctrl set 20 op dh
    speaker-test -l5 -c2 -t wav
fi
newline
success "All done!"
newline
echo "Enjoy your new $productname!"
newline

if [ $promptreboot == "yes" ] || $ASK_TO_REBOOT; then
    sysreboot
fi

# end
# =======================
exit 0


##################################################
# FILE: baseline_code/picar-x/MANIFEST.in
##################################################

include DESCRIPTION.rst

# Include the test suite (FIXME: does not work yet)
# recursive-include tests *

# If using Python 3.5 or less, then have to include package data, even though
# it's already declared in setup.py


##################################################
# FILE: baseline_code/picar-x/README.md
##################################################

# Picar-X

Picar-X Python library for Raspberry Pi.

## Links

- Docs: <https://docs.sunfounder.com/projects/picar-x-v20/en/latest/>
- Robot Hat: <https://docs.sunfounder.com/projects/robot-hat-v4/en/latest/>
- Forum: <https://forum.sunfounder.com/>
- Sunfounder: <https://www.sunfounder.com/>

## Installation

 > **Note**
  You also need to install robot_hat, vilib, sunfounder_controller and other dependent libraries.\
  <https://docs.sunfounder.com/projects/picar-x-v20/en/latest/python/python_start/install_all_modules.html>

```bash
git clone -b v2.0 https://github.com/sunfounder/picar-x.git
cd picar-x
sudo python3 setup.py install

```

## Trouble Shooting

----------------------------------------------

## About SunFounder

SunFounder is a technology company focused on Raspberry Pi and Arduino open source community development. Committed to the promotion of open source culture, we strives to bring the fun of electronics making to people all around the world and enable everyone to be a maker. Our products include learning kits, development boards, robots, sensor modules and development tools. In addition to high quality products, SunFounder also offers video tutorials to help you make your own project. If you have interest in open source or making something cool, welcome to join us!

----------------------------------------------

## License

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied wa rranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

{Repository Name} comes with ABSOLUTELY NO WARRANTY; for details run ./show w. This is free software, and you are welcome to redistribute it under certain conditions; run ./show c for details.

SunFounder, Inc., hereby disclaims all copyright interest in the program '{Repository Name}' (which makes passes at compilers).

Mike Huang, 21 August 2015

Mike Huang, Chief Executive Officer

Email: service@sunfounder.com, support@sunfounder.com

----------------------------------------------

## Contact us

website:
    www.sunfounder.com

E-mail:
    service@sunfounder.com, support@sunfounder.com


##################################################
# FILE: baseline_code/picar-x/DESCRIPTION.rst
##################################################

picarx
=======================
Library for picarx


##################################################
# FILE: baseline_code/picar-x/gpt_examples/openai_helper.py
##################################################

from openai import OpenAI
import time
import shutil
import os

# utils
# =================================================================
def chat_print(label, message):
    width = shutil.get_terminal_size().columns
    msg_len = len(message)
    line_len = width - 27

    # --- normal print ---
    print(f'{time.time():.3f} {label:>6} >>> {message}')
    return

    # --- table mode ---
    if width < 38 or msg_len <= line_len:
        print(f'{time.time():.3f} {label:>6} >>> {message}')
    else:
        texts = []

        # words = message.split()
        # print(words)
        # current_line = ""
        # for word in words:
        #     if len(current_line) + len(word) + 1 <= line_len:
        #         current_line += word + " "
        #     else:
        #         texts.append(current_line)
        #         current_line = ""

        # if current_line:
        #     texts.append(current_line)

        for i in range(0, len(message), line_len):
            texts.append(message[i:i+line_len])

        for i, text in enumerate(texts):
            if i == 0:
                print(f'{time.time():.3f} {label:>6} >>> {text}')
            else:
                print(f'{"":>26} {text}')

# OpenAiHelper
# =================================================================
class OpenAiHelper():
    STT_OUT = "stt_output.wav"
    TTS_OUTPUT_FILE = 'tts_output.mp3'
    TIMEOUT = 30 # seconds

    def __init__(self, api_key, assistant_id, assistant_name, timeout=TIMEOUT) -> None:
        
        self.api_key = api_key
        self.assistant_id = assistant_id
        self.assistant_name = assistant_name

        self.client = OpenAI(api_key=api_key, timeout=timeout)
        self.thread = self.client.beta.threads.create()
        self.run = self.client.beta.threads.runs.create_and_poll(
            thread_id=self.thread.id,
            assistant_id=assistant_id,
        )

    def stt(self, audio, language='en'):
        try:
            import wave
            from io import BytesIO

            wav_data = BytesIO(audio.get_wav_data())
            wav_data.name = self.STT_OUT

            transcript = self.client.audio.transcriptions.create(
                model="whisper-1", 
                file=wav_data,
                language=language,
                prompt="this is the conversation between me and a robot"
            )

            # file = "./stt_output.wav"
            # with wave.open(file, "wb") as wf:
            #     wf.write(audio.get_wav_data())

            # with open(file, 'rb') as f:
            #     transcript = client.audio.transcriptions.create(
            #         model="whisper-1", 
            #         file=f
            #     )
            return transcript.text
        except Exception as e:
            print(f"stt err:{e}")
            return False

    def speech_recognition_stt(self, recognizer, audio):
        import speech_recognition as sr

        # # recognize speech using Sphinx
        # try:
        #     print("Sphinx thinks you said: " + r.recognize_sphinx(audio, language="en-US"))
        # except sr.UnknownValueError:
        #     print("Sphinx could not understand audio")
        # except sr.RequestError as e:
        #     print("Sphinx error; {0}".format(e))

        # recognize speech using whisper
        # try:
        #     print("Whisper thinks you said: " + r.recognize_whisper(audio, language="english"))
        # except sr.UnknownValueError:
        #     print("Whisper could not understand audio")
        # except sr.RequestError as e:
        #     print(f"Could not request results from Whisper; {e}")

        # recognize speech using Whisper API
        try:
            return recognizer.recognize_whisper_api(audio, api_key=self.api_key)
        except sr.RequestError as e:
            print(f"Could not request results from Whisper API; {e}")
            return False

    def dialogue(self, msg):
        chat_print("user", msg)
        message = self.client.beta.threads.messages.create(
            thread_id=self.thread.id,
            role="user",
            content=msg
            )
        run = self.client.beta.threads.runs.create_and_poll(
            thread_id=self.thread.id,
            assistant_id=self.assistant_id,
        )
        if run.status == 'completed': 
            messages = self.client.beta.threads.messages.list(
                thread_id=self.thread.id
            )

            for message in messages.data:
                if message.role == 'assistant':
                    for block in message.content:
                        if block.type == 'text':
                            value = block.text.value
                            chat_print(self.assistant_name, value)
                            try:
                                value = eval(value) # convert to dict
                                return value
                            except Exception as e:
                                return str(value)
                break # only last reply
        else:
            print(run.status)


    def dialogue_with_img(self, msg, img_path):
        chat_print(f"user", msg)

        img_file = self.client.files.create(
                    file=open(img_path, "rb"),
                    purpose="vision"
                )

        message =  self.client.beta.threads.messages.create(
            thread_id= self.thread.id,
            role="user",
            content= [
                {
                    "type": "text",
                    "text": msg
                },
                # {
                # "type": "image_url",
                # "image_url": {"url": "https://example.com/image.png"}
                # },
                {
                    "type": "image_file",
                    "image_file": {"file_id": img_file.id}
                }
            ],
            )
        run = self.client.beta.threads.runs.create_and_poll(
            thread_id=self.thread.id,
            assistant_id=self.assistant_id,
        )
        if run.status == 'completed': 
            messages = self.client.beta.threads.messages.list(
                thread_id=self.thread.id
            )

            for message in messages.data:
                if message.role == 'assistant':
                    for block in message.content:
                        if block.type == 'text':
                            value = block.text.value
                            chat_print(self.assistant_name, value)
                            try:
                                value = eval(value) # convert to dict
                                return value
                            except Exception as e:
                                return str(value)
                break # only last reply
        else:
            print(run.status)


    def text_to_speech(self, text, output_file, voice='alloy', response_format="mp3", speed=1):
        '''
        voice: alloy, echo, fable, onyx, nova, and shimmer
        '''
        try:
            # check dir
            dir = os.path.dirname(output_file)
            if not os.path.exists(dir):
                os.mkdir(dir)
            elif not os.path.isdir(dir):
                raise FileExistsError(f"\'{dir}\' is not a directory")

            # tts
            with self.client.audio.speech.with_streaming_response.create(
                model="tts-1",
                voice=voice,
                input=text,
                response_format=response_format,
                speed=speed,
            ) as response:
                response.stream_to_file(output_file)

            return True
        except Exception as e:
            print(f'tts err: {e}')
            return False



##################################################
# FILE: baseline_code/picar-x/gpt_examples/keys.py
##################################################

OPENAI_API_KEY = ""
OPENAI_ASSISTANT_ID = ""


##################################################
# FILE: baseline_code/picar-x/gpt_examples/README.md
##################################################

## Picar-X GPT examples usage

----------------------------------------------------------------

## Install dependencies

- Make sure you have installed Pidog and related dependencies first

    <https://docs.sunfounder.com/projects/picar-x-v20/en/latest/python/python_start/install_all_modules.html>

- Install openai and speech processing libraries

> [!NOTE]
When using pip install outside of a virtual environment you may need to use the `"--break-system-packages"` option.

    ```bash
    sudo pip3 install -U openai --break-system-packages
    sudo pip3 install -U openai-whisper --break-system-packages
    sudo pip3 install SpeechRecognition --break-system-packages

    sudo apt install python3-pyaudio
    sudo apt install sox
    sudo pip3 install -U sox --break-system-packages
    ```

----------------------------------------------------------------

## Create your own GPT assistant

### GET API KEY

<https://platform.openai.com/api-keys>

Fill your OPENAI_API_KEY into the `keys.py` file.

![tutorial_1](./tutorial_1.png)

### Create assistant and set Assistant ID

<https://platform.openai.com/assistants>

Fill your ASSISTANT_ID into the `keys.py` file.

![tutorial_2](./tutorial_2.png)

- Set Assistant Name

- Describe your Assistant

```markdown
    You are a small car with AI capabilities named PaiCar-X. You can engage in conversations with people and react accordingly to different situations with actions or sounds. You are driven by two rear wheels, with two front wheels that can turn left and right, and equipped with a camera mounted on a 2-axis gimbal.

    ## Response with Json Format, eg:
    {"actions": ["start engine", "honking", "wave hands"], "answer": "Hello, I am PaiCar-X, your good friend."}

    ## Response Style
    Tone: Cheerful, optimistic, humorous, childlike
    Preferred Style: Enjoys incorporating jokes, metaphors, and playful banter; prefers responding from a robotic perspective
    Answer Elaboration: Moderately detailed

    ## Actions you can do:
    ["shake head", "nod", "wave hands", "resist", "act cute", "rub hands", "think", "twist body", "celebrate, "depressed"]
    ## Sound effects:
    ["honking", "start engine"]
```

- Select gpt model

    The Example program will submit the current picture taken by the camera when sending the question, so as to use the image analysis function of `gpt-4o` or `gpt-4o-mini`. Of course, you can also choose `gpt3.5-turbo` or other models

----------------------------------------------------------------

## Set Key for example

Confirm that `keys.py` is configured correctly

## Run

- Run with vioce

```bash
sudo python3 gpt_car.py
```

- Run with keyboard

```bash
sudo python3 gpt_car.py --keyboard
```

- Run without image analysis

```bash
sudo python3 gpt_car.py --keyboard --no-img
```

> [!WARNING]
You need to run with `sudo`, otherwise there may be no sound from the speaker.
For certain Robot HATs, you might need to turn on the speaker switch with the command `"pinctrl set 20 op dh"` or `"robot-hat enable_speaker"`

## Modify parameters [optional]

- Set language of STT

    Config `LANGUAGE` variable in the file `gpt_car.py` to improve STT accuracy and latency, `"LANGUAGE = []"`means supporting all languages, but it may affect the accuracy and latency of the speech-to-text (STT) system.
    <https://platform.openai.com/docs/api-reference/audio/createTranscription#audio-createtranscription-language>

- Set TTS volume gain

    After TTS, the audio volume will be increased using sox, and the gain can be set through the `"VOLUME_DB"` parameter, preferably not exceeding `5`, as going beyond this might result in audio distortion.

- Select TTS voice role

    Config `TTS_VOICE` variable in the file `gpt_car.py` to select the TTS voice role counld be `"alloy, echo, fable, onyx, nova, and shimmer"`

```python
# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

```


##################################################
# FILE: baseline_code/picar-x/gpt_examples/utils.py
##################################################

import os
import sys

GRAY = '1;30'
RED = '0;31'
GREEN = '0;32'
YELLOW = '0;33'
BLUE = '0;34'
PURPLE = '0;35'
DARK_GREEN = '0;36'
WHITE = '0;37'

def print_color(msg, end='\n', file=sys.stdout, flush=False, color=''):
    print('\033[%sm%s\033[0m'%(color, msg), end=end, file=file, flush=flush)

def gray_print(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=GRAY)

def warn(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=YELLOW)

def error(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=RED)

def redirect_error_2_null():
    # https://github.com/spatialaudio/python-sounddevice/issues/11

    devnull = os.open(os.devnull, os.O_WRONLY)
    old_stderr = os.dup(2)
    sys.stderr.flush()
    os.dup2(devnull, 2)
    os.close(devnull)
    return old_stderr

def cancel_redirect_error(old_stderr):
    os.dup2(old_stderr, 2)
    os.close(old_stderr)

def run_command(cmd):
    """
    Run command and return status and output

    :param cmd: command to run
    :type cmd: str
    :return: status, output
    :rtype: tuple
    """
    import subprocess
    p = subprocess.Popen(
        cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result = p.stdout.read().decode('utf-8')
    status = p.poll()
    return status, result

def sox_volume(input_file, output_file, volume):
    import sox

    try:
        transform = sox.Transformer()
        transform.vol(volume)

        transform.build(input_file, output_file)

        return True
    except Exception as e:
        print(f"sox_volume err: {e}")
        return False


speak_first = False

def speak_block(music, name, volume=100):
    """
    speak, play audio with block

    :param name: the file name int the folder(SOUND_DIR)
    :type name: str
    :param volume: volume, 0-100
    :type volume: int
    """
    global speak_first
    is_run_with_root = (os.geteuid() == 0)
    if not is_run_with_root and not speak_first:
        speak_first = True
        warn("Play sound needs to be run with sudo.")
    _status, _ = run_command('sudo killall pulseaudio') # Solve the problem that there is no sound when running in the vnc environment
    
    if os.path.isfile(name):
        music.sound_play(name, volume)
    else:
        warn(f'No sound found for {name}')
        return False


##################################################
# FILE: baseline_code/picar-x/gpt_examples/gpt_car.py
##################################################

from openai_helper import OpenAiHelper
from keys import OPENAI_API_KEY, OPENAI_ASSISTANT_ID
from preset_actions import *
from utils import *

import readline # optimize keyboard input, only need to import

import speech_recognition as sr

from picarx import Picarx
from robot_hat import Music, Pin

import time
import threading
import random

import os
import sys

os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
current_path = os.path.dirname(os.path.abspath(__file__))
os.chdir(current_path) # change working directory

input_mode = None
with_img = True
args = sys.argv[1:]
if '--keyboard' in args:
    input_mode = 'keyboard'
else:
    input_mode = 'voice'

if '--no-img' in args:
    with_img = False
else:
    with_img = True

# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

SOUND_EFFECT_ACTIONS = ["honking", "start engine"]

# car init 
# =================================================================
try:
    my_car = Picarx()
    time.sleep(1)
except Exception as e:
    raise RuntimeError(e)

music = Music()

led = Pin('LED')

DEFAULT_HEAD_TILT = 20

# Vilib start
# =================================================================
if with_img:
    from vilib import Vilib
    import cv2

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.show_fps()
    Vilib.display(local=False,web=True)

    while True:
        if Vilib.flask_start:
            break
        time.sleep(0.01)

    time.sleep(.5)
    print('\n')

# speech_recognition init
# =================================================================
'''
self.energy_threshold = 300  # minimum audio energy to consider for recording
self.dynamic_energy_threshold = True
self.dynamic_energy_adjustment_damping = 0.15
self.dynamic_energy_ratio = 1.5
self.pause_threshold = 0.8  # seconds of non-speaking audio before a phrase is considered complete
self.operation_timeout = None  # seconds after an internal operation (e.g., an API request) starts before it times out, or ``None`` for no timeout

self.phrase_threshold = 0.3  # minimum seconds of speaking audio before we consider the speaking audio a phrase - values below this are ignored (for filtering out clicks and pops)
self.non_speaking_duration = 0.5  # seconds of non-speaking audio to keep on both sides of the recording

'''
recognizer = sr.Recognizer()
recognizer.dynamic_energy_adjustment_damping = 0.16
recognizer.dynamic_energy_ratio = 1.6

# speak_hanlder
# =================================================================
speech_loaded = False
speech_lock = threading.Lock()
tts_file = None

def speak_hanlder():
    global speech_loaded, tts_file
    while True:
        with speech_lock:
            _isloaded = speech_loaded
        if _isloaded:
            # gray_print('speak start')
            speak_block(music, tts_file)
            # gray_print('speak done')
            with speech_lock:
                speech_loaded = False
        time.sleep(0.05)

speak_thread = threading.Thread(target=speak_hanlder)
speak_thread.daemon = True


# actions thread
# =================================================================
action_status = 'standby' # 'standby', 'think', 'actions', 'actions_done'
led_status = 'standby' # 'standby', 'think' or 'actions', 'actions_done'
last_action_status = 'standby'
last_led_status = 'standby'

LED_DOUBLE_BLINK_INTERVAL = 0.8 # seconds
LED_BLINK_INTERVAL = 0.1 # seconds

actions_to_be_done = []
action_lock = threading.Lock()

def action_handler():
    global action_status, actions_to_be_done, led_status, last_action_status, last_led_status

    # standby_actions = ['waiting', 'feet_left_right']
    # standby_weights = [1, 0.3]

    action_interval = 5 # seconds
    last_action_time = time.time()
    last_led_time = time.time()

    while True:
        with action_lock:
            _state = action_status

        # led
        # ------------------------------
        led_status = _state

        if led_status != last_led_status:
            last_led_time = 0
            last_led_status = led_status

        if led_status == 'standby':
            if time.time() - last_led_time > LED_DOUBLE_BLINK_INTERVAL:
                led.off()
                led.on()
                sleep(.1)
                led.off()
                sleep(.1)
                led.on()
                sleep(.1)
                led.off()
                last_led_time = time.time()
        elif led_status == 'think':
            if time.time() - last_led_time > LED_BLINK_INTERVAL:
                led.off()
                sleep(LED_BLINK_INTERVAL)
                led.on()
                sleep(LED_BLINK_INTERVAL)
                last_led_time = time.time()
        elif led_status == 'actions':
                led.on() 

        # actions
        # ------------------------------
        if _state == 'standby':
            last_action_status = 'standby'
            if time.time() - last_action_time > action_interval:
                # TODO: standby actions
                last_action_time = time.time()
                action_interval = random.randint(2, 6)
        elif _state == 'think':
            if last_action_status != 'think':
                last_action_status = 'think'
                # think(my_car)
                keep_think(my_car)
        elif _state == 'actions':
            last_action_status = 'actions'
            with action_lock:
                _actions = actions_to_be_done
            for _action in _actions:
                try:
                    actions_dict[_action](my_car)
                except Exception as e:
                    print(f'action error: {e}')
                time.sleep(0.5)

            with action_lock:
                action_status = 'actions_done'
            last_action_time = time.time()

        time.sleep(0.01)

action_thread = threading.Thread(target=action_handler)
action_thread.daemon = True


# main
# =================================================================
def main():
    global current_feeling, last_feeling
    global speech_loaded
    global action_status, actions_to_be_done
    global tts_file

    my_car.reset()
    my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

    speak_thread.start()
    action_thread.start()

    while True:
        if input_mode == 'voice':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            # listen
            # ----------------------------------------------------------------
            gray_print("listening ...")

            with action_lock:
                action_status = 'standby'

            _stderr_back = redirect_error_2_null() # ignore error print to ignore ALSA errors
            # If the chunk_size is set too small (default_size=1024), it may cause the program to freeze
            with sr.Microphone(chunk_size=8192) as source:
                cancel_redirect_error(_stderr_back) # restore error print
                recognizer.adjust_for_ambient_noise(source)
                audio = recognizer.listen(source)

            # stt
            # ----------------------------------------------------------------
            st = time.time()
            _result = openai_helper.stt(audio, language=LANGUAGE)
            gray_print(f"stt takes: {time.time() - st:.3f} s")

            if _result == False or _result == "":
                print() # new line
                continue

        elif input_mode == 'keyboard':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            with action_lock:
                action_status = 'standby'

            _result = input(f'\033[1;30m{"intput: "}\033[0m').encode(sys.stdin.encoding).decode('utf-8')

            if _result == False or _result == "":
                print() # new line
                continue

        else:
            raise ValueError("Invalid input mode")

        # chat-gpt
        # ---------------------------------------------------------------- 
        response = {}
        st = time.time()

        with action_lock:
            action_status = 'think'

        if with_img:
            img_path = './img_imput.jpg'
            cv2.imwrite(img_path, Vilib.img)
            response = openai_helper.dialogue_with_img(_result, img_path)
        else:
            response = openai_helper.dialogue(_result)

        gray_print(f'chat takes: {time.time() - st:.3f} s')

        # actions & TTS
        # ----------------------------------------------------------------
        _sound_actions = [] 
        try:
            if isinstance(response, dict):
                if 'actions' in response:
                    actions = list(response['actions'])
                else:
                    actions = ['stop']

                if 'answer' in response:
                    answer = response['answer']
                else:
                    answer = ''

                if len(answer) > 0:
                    _actions = list.copy(actions)
                    for _action in _actions:
                        if _action in SOUND_EFFECT_ACTIONS:
                            _sound_actions.append(_action)
                            actions.remove(_action)

            else:
                response = str(response)
                if len(response) > 0:
                    actions = []
                    answer = response

        except:
            actions = []
            answer = ''
    
        try:
            # ---- tts ----
            _tts_status = False
            if answer != '':
                st = time.time()
                _time = time.strftime("%y-%m-%d_%H-%M-%S", time.localtime())
                _tts_f = f"./tts/{_time}_raw.wav"
                _tts_status = openai_helper.text_to_speech(answer, _tts_f, TTS_VOICE, response_format='wav') # alloy, echo, fable, onyx, nova, and shimmer
                if _tts_status:
                    tts_file = f"./tts/{_time}_{VOLUME_DB}dB.wav"
                    _tts_status = sox_volume(_tts_f, tts_file, VOLUME_DB)
                gray_print(f'tts takes: {time.time() - st:.3f} s')

            # ---- actions ----
            with action_lock:
                actions_to_be_done = actions
                gray_print(f'actions: {actions_to_be_done}')
                action_status = 'actions'

            # --- sound effects and voice ---
            for _sound in _sound_actions:
                try:
                    sounds_dict[_sound](music)
                except Exception as e:
                    print(f'action error: {e}')

            if _tts_status:
                with speech_lock:
                    speech_loaded = True

            # ---- wait speak done ----
            if _tts_status:
                while True:
                    with speech_lock:
                        if not speech_loaded:
                            break
                    time.sleep(.01)

            # ---- wait actions done ----
            while True:
                with action_lock:
                    if action_status != 'actions':
                        break
                time.sleep(.01)

            ##
            print() # new line

        except Exception as e:
            print(f'actions or TTS error: {e}')


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\033[31mERROR: {e}\033[m")
    finally:
        if with_img:
            Vilib.camera_close()
        my_car.reset()



##################################################
# FILE: baseline_code/picar-x/gpt_examples/preset_actions.py
##################################################


from time import sleep
import random
from math import sin, cos, pi

def wave_hands(car):
    car.reset()
    car.set_cam_tilt_angle(20)
    for _ in range(2):
        car.set_dir_servo_angle(-25)
        sleep(.1)
        # car.set_dir_servo_angle(0)
        # sleep(.1)
        car.set_dir_servo_angle(25)
        sleep(.1)
    car.set_dir_servo_angle(0)

def resist(car):
    car.reset()
    car.set_cam_tilt_angle(10)
    for _ in range(3):
        car.set_dir_servo_angle(-15)
        car.set_cam_pan_angle(15)
        sleep(.1)
        car.set_dir_servo_angle(15)
        car.set_cam_pan_angle(-15)
        sleep(.1)
    car.stop()
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)

def act_cute(car):
    car.reset()
    car.set_cam_tilt_angle(-20)
    for i in range(15):
        car.forward(5)
        sleep(0.02)
        car.backward(5)
        sleep(0.02)
    car.set_cam_tilt_angle(0)
    car.stop()

def rub_hands(car):
    car.reset()
    for i in range(5):
        car.set_dir_servo_angle(-6)
        sleep(.5)
        car.set_dir_servo_angle(6)
        sleep(.5)
    car.reset()

def think(car):
    car.reset()

    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)
    sleep(1)
    car.set_cam_pan_angle(15)
    car.set_cam_tilt_angle(-10)
    car.set_dir_servo_angle(10)
    sleep(.1)
    car.reset()

def keep_think(car):
    car.reset()
    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)

def shake_head(car):
    car.stop()
    car.set_cam_pan_angle(0)
    car.set_cam_pan_angle(60)
    sleep(.2)
    car.set_cam_pan_angle(-50)
    sleep(.1)
    car.set_cam_pan_angle(40)
    sleep(.1)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_cam_pan_angle(20)
    sleep(.1)
    car.set_cam_pan_angle(-10)
    sleep(.1)
    car.set_cam_pan_angle(10)
    sleep(.1)
    car.set_cam_pan_angle(-5)
    sleep(.1)
    car.set_cam_pan_angle(0)

def nod(car):
    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(0)


def depressed(car):
    # car.reset()
    # car.set_cam_tilt_angle(0)
    # car.set_cam_tilt_angle(20)
    # sleep(.22)
    # car.set_cam_tilt_angle(-30)
    # sleep(.1)
    # car.set_cam_tilt_angle(15)
    # sleep(.1)
    # car.set_cam_tilt_angle(-20)
    # sleep(.1)
    # car.set_cam_tilt_angle(10)
    # sleep(.1)
    # car.set_cam_tilt_angle(-10)
    # sleep(.1)
    # car.set_cam_tilt_angle(5)
    # sleep(.1)
    # car.set_cam_tilt_angle(-5)
    # sleep(.1)
    # car.set_cam_tilt_angle(2)
    # sleep(.1)
    # car.set_cam_tilt_angle(0)

    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(20)
    sleep(.22)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(0)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-15)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-19)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)

    sleep(1.5)
    car.reset()

def twist_body(car):
    car.reset()
    for i in range(3):
        car.set_motor_speed(1, 20)
        car.set_motor_speed(2, 20)
        car.set_cam_pan_angle(-20)
        car.set_dir_servo_angle(-10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)
        sleep(.1)
        car.set_motor_speed(1, -20)
        car.set_motor_speed(2, -20)
        car.set_cam_pan_angle(20)
        car.set_dir_servo_angle(10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)

        sleep(.1)


def celebrate(car):
    car.reset()
    car.set_cam_tilt_angle(20)

    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(10)
    car.set_cam_pan_angle(30)
    sleep(.1)
    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(-10)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

def honking(music):
    import utils
    # utils.speak_block(music, "../sounds/car-double-horn.wav", 100)
    music.sound_play_threading("../sounds/car-double-horn.wav", 100)

def start_engine(music):
    import utils
    # utils.speak_block(music, "../sounds/car-start-engine.wav", 100)
    music.sound_play_threading("../sounds/car-start-engine.wav", 50)


actions_dict = {
    "shake head":shake_head, 
    "nod": nod,
    "wave hands": wave_hands,
    "resist": resist,
    "act cute": act_cute,
    "rub hands": rub_hands,
    "think": think,
    "twist body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
}

sounds_dict = {
    "honking": honking,
    "start engine": start_engine,
}


if __name__ == "__main__":
    from picarx import Picarx
    from robot_hat import Music
    import os

    os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
    current_path = os.path.dirname(os.path.abspath(__file__))
    os.chdir(current_path) # change working directory

    my_car = Picarx()
    my_car.reset()

    music = Music()

    sleep(.5)

    _actions_num = len(actions_dict)
    actions = list(actions_dict.keys())
    for i, key in enumerate(actions_dict):
        print(f'{i} {key}')
    
    _sounds_num = len(sounds_dict)
    sounds = list(sounds_dict.keys())
    for i, key in enumerate(sounds_dict):
        print(f'{_actions_num+i} {key}')

    last_key = None

    try:
        while True:
            key = input()

            if key == '':
                if last_key > _actions_num - 1:
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    print(actions[last_key])
                    actions_dict[actions[last_key]](my_car)
            else:
                key = int(key)
                if key > (_actions_num + _sounds_num - 1):
                    print("Invalid key")
                elif key > (_actions_num - 1):
                    last_key = key
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    last_key = key
                    print(actions[key])
                    actions_dict[actions[key]](my_car)

            # sleep(2)
            # shake_head(my_car)
            # nod(my_car)
            # wave_hands(my_car)
            # resist(my_car)
            # act_cute(my_car)
            # rub_hands(my_car)
            # think(my_car)
            # twist(my_car)
            # celebrate(my_car)
            # depressed(my_car)

    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f'Error:\n {e}')
    finally:
        my_car.reset()
        sleep(.1)






##################################################
# FILE: baseline_code/picar-x/setup.py
##################################################

# Always prefer setuptools over distutils
from setuptools import setup, find_packages
# To use a consistent encoding
from codecs import open
from os import path
import sys

sys.path.append('./picarx')
from version import __version__

here = path.abspath(path.dirname(__file__))

# Get the long description from the relevant file
with open(path.join(here, 'DESCRIPTION.rst'), encoding='utf-8') as f:
    long_description = f.read()

setup(
    name='picarx',

    # Versions should comply with PEP440.  For a discussion on single-sourcing
    # the version across setup.py and the project code, see
    # https://packaging.python.org/en/latest/single_source_version.html
    version=__version__,

    description='Picarx gait Library for Raspberry Pi',
    long_description=long_description,

    # The project's main homepage.
    url='https://github.com/sunfounder/piarm',

    # Author details
    author='SunFounder',
    author_email='service@sunfounder.com',

    # Choose your license
    license='GNU',
    zip_safe=False,
    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers
    classifiers=[
        # How mature is this project? Common values are
        #   3 - Alpha
        #   4 - Beta
        #   5 - Production/Stable
        'Development Status :: 3 - Alpha',

        # Indicate who your project is intended for
        'Intended Audience :: Developers',
        'Topic :: Software Development :: Build Tools',

        # Pick your license as you wish (should match "license" above)
        'License :: OSI Approved :: GNU License',

        # Specify the Python versions you support here. In particular, ensure
        # that you indicate whether you support Python 2, Python 3 or both.
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.2',
        'Programming Language :: Python :: 3.3',
        'Programming Language :: Python :: 3.4',
    ],

    # What does your project relate to?
    keywords='python raspberry pi GPIO sunfounder',

    # You can just specify the packages manually here if your project is
    # simple. Or you can use find_packages().
    packages=find_packages(exclude=[ 'doc', 'tests*' ,'examples']),

    # List run-time dependencies here.  These will be installed by pip when
    # your project is installed. For an analysis of "install_requires" vs pip's
    # requirements files see:
    # https://packaging.python.org/en/latest/requirements.html
    install_requires=['readchar'],
 
    # To provide executable scripts, use entry points in preference to the
    # "scripts" keyword. Entry points provide cross-platform support and allow
    # pip to create the appropriate form of executable for the target platform.
    entry_points={
        'console_scripts': [
        ],
    },
)


##################################################
# FILE: baseline_code/picar-x/autostart.service
##################################################

# https://www.freedesktop.org/software/systemd/man/systemd.service.html
[Unit]
Description=picarx service
After=multi-user.target

[Service]
Type=forking
WorkingDirectory=/home/pi/picar-x/
ExecStart=python3 /home/pi/picar-x/examples/minecart_plus.py &&

[Install]
WantedBy=multi-user.target

##################################################
# FILE: baseline_code/robot-hat/LICENSE
##################################################

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


##################################################
# FILE: baseline_code/robot-hat/i2samp.sh
##################################################

#!/bin/bash

# global variables
# =================================================================
VERSION="0.0.4"
USERNAME=${SUDO_USER:-$LOGNAME}
USER_RUN="sudo -u ${USERNAME} env XDG_RUNTIME_DIR=/run/user/$(id -u ${USERNAME})"

CONFIG="/boot/firmware/config.txt"
# Fall back to the old config.txt path
if ! test -f $CONFIG; then
    CONFIG="/boot/config.txt"
fi

ASOUND_CONF="/etc/asound.conf"

# ----- robot hat without onboard mic -----
DTOVERLAY_WITHOUT_MIC="hifiberry-dac"
AUDIO_CARD_NAME_WITHOUT_MIC="sndrpihifiberry"
ALSA_CARD_NAME_WITHOUT_MIC="snd_rpi_hifiberry_dac"

# ----- robot hat with onboard mic -----
DTOVERLAY_WITH_MIC="googlevoicehat-soundcard"
AUDIO_CARD_NAME_WITH_MIC="sndrpigooglevoi"
ALSA_CARD_NAME_WITH_MIC="snd_rpi_googlevoicehat_soundcar"

SOFTVOL_SPEAKER_NAME="robot-hat speaker"
SOFTVOL_MIC_NAME="robot-hat mic"

# ----- robot hat 5 -----
HAT_DEVICE_TREE="/proc/decvice-tree/"
HAT_UUIDs=(
    "9daeea78-0000-076e-0032-582369ac3e02",
)
ROBOTHAT5_PRODUCT_VER=50
robothat_product=""
robothat_product_id=0
robothat_product_ver=0
robothat_uuid=""
robothat_vendor=""

# ---------------------------
robothat_spk_en=20 # robothat4 GPIO20, robothat5 GPIO12
_is_install_deps=true
_is_with_mic=true
dtoverlay_name=""
audio_card_name=""
alsa_card_name=""

# function define
# =================================================================
# black     0
# red       1
# green     2
# yellow    3
# blue      4
# magenta   5
# cyan      6
# white     7
success() {
    echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

info() {
    echo -e "$(tput setaf 6)$1$(tput sgr0)"
}

warning() {
    echo -e "$(tput setaf 3)$1$(tput sgr0)"
}

error() {
    echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

newline() {
    echo ""
}

confirm() {
    if [ "$FORCE" == '-y' ]; then
        true
    else
        read -r -p "$1 [y/N] " response </dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
    fi
}

sudocheck() {
    if [ $(id -u) -ne 0 ]; then
        warning "Install must be run as root. Try 'sudo bash ./i2samp.sh'"
        exit 1
    fi
}

ask_reboot() {
    read -e -p "$(tput setaf 5)$1 (Y/N): $(tput sgr0)" choice
    if [ "$choice" == "Y" ] || [ "$choice" == "y" ]; then
        info "Rebooting now ..."
        sudo sync && sudo reboot
    fi
}

get_soundcard_index() {
    card_name=$1
    if [[ -z "${card_name}" ]]; then
        error "card_name is null"
        return
    fi
    card_index=$(sudo aplay -l | grep $card_name | awk '{print $2}' | tr -d ':')
    echo $card_index
}

config_asound_without_mic() {
    # backup file
    if [ -e "${ASOUND_CONF}" ]; then
        if [ -e "${ASOUND_CONF}.old" ]; then
            sudo rm -f "${ASOUND_CONF}.old"
        fi
        sudo cp "${ASOUND_CONF}" "${ASOUND_CONF}.old"
    fi

    cat >"${ASOUND_CONF}" <<EOF

pcm.speaker {
    type hw
    card ${AUDIO_CARD_NAME_WITHOUT_MIC}
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speaker"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw
    card ${AUDIO_CARD_NAME_WITHOUT_MIC}
}

pcm.softvol {
    type softvol
    slave.pcm "dmixer"
    control {
        name "${SOFTVOL_SPEAKER_NAME} Playback Volume"
        card ${AUDIO_CARD_NAME_WITHOUT_MIC}
    }
    min_dB -51.0
    max_dB 0.0
}

pcm.robothat {
    type plug
    slave.pcm "softvol"
}

ctl.robothat {
    type hw
    card ${AUDIO_CARD_NAME_WITHOUT_MIC}
}

pcm.!default robothat
ctl.!default robothat

EOF
}

config_asound_with_mic() {
    # backup file
    if [ -e "${ASOUND_CONF}" ]; then
        if [ -e "${ASOUND_CONF}.old" ]; then
            sudo rm -f "${ASOUND_CONF}.old"
        fi
        sudo cp "${ASOUND_CONF}" "${ASOUND_CONF}.old"
    fi

    if [ $robothat_product_ver -ge ${ROBOTHAT5_PRODUCT_VER} ]; then

        #
        sudo cat >"${ASOUND_CONF}" <<EOF

pcm.robothat {
    type asym
    playback.pcm {
        type plug
        slave.pcm "speaker"
    }
    capture.pcm {
        type plug
        slave.pcm "mic"
    }
}

pcm.speaker_hw {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
    device 0
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speaker_hw"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
}

pcm.speaker {
    type softvol
    slave {
        pcm "dmixer"
    }
    control {
        name "${SOFTVOL_SPEAKER_NAME} Playback Volume"
        card ${AUDIO_CARD_NAME_WITH_MIC}
    }
    min_dB -51.0
    max_dB 0.0
}

pcm.mic_hw {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
    device 0
}

pcm.mic {
    type softvol
    slave {
        pcm "mic_hw"
    }
    control {
        name "${SOFTVOL_MIC_NAME} Capture Volume"
        card ${AUDIO_CARD_NAME_WITH_MIC}
    }
    min_dB -26.0
    max_dB 25.0
}

ctl.robothat {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
}

pcm.!default robothat
ctl.!default robothat

EOF

    else
        sudo cat >"${ASOUND_CONF}" <<EOF

pcm.robothat {
    type asym
    playback.pcm {
        type plug
        slave.pcm "speaker"
    }
}

pcm.speaker_hw {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
    device 0
}

pcm.speaker {
    type softvol
    slave {
        pcm "speaker_hw"
    }
    control {
        name "${SOFTVOL_SPEAKER_NAME} Playback Volume"
        card ${AUDIO_CARD_NAME_WITH_MIC}
    }
    min_dB -51.0
    max_dB 0.0
}

ctl.robothat {
    type hw
    card ${AUDIO_CARD_NAME_WITH_MIC}
}

pcm.!default robothat
ctl.!default robothat

EOF
    fi

}

get_sink_index() {
    card_name=$1
    if [[ -z "${card_name}" ]]; then
        error "card name is null"
        return
    fi
    index=$($USER_RUN \
        pactl -f json list sinks | jq -r \
        '.[] | select(.["properties"]["alsa.card_name"] == "'${card_name}'"
        and .["properties"]["device.class"] == "sound"
        ).index')
    echo $index
}

get_source_index() {
    card_name=$1
    if [[ -z "${card_name}" ]]; then
        error "card name is null"
        return
    fi
    index=$($USER_RUN \
        pactl -f json list sources | jq -r \
        '.[] | select(.["properties"]["alsa.card_name"] == "'${card_name}'"
        and .["properties"]["device.class"] == "sound"
        ).index')
    echo $index
}

set_default_sink() {
    sink_index=$1
    if [[ -z "${sink_index}" ]]; then
        error "sink index is null"
        return
    fi
    $USER_RUN \
        pactl set-default-sink ${sink_index}
}

set_default_source() {
    source_index=$1
    if [[ -z "${source_index}" ]]; then
        error "source index is null"
        return
    fi
    $USER_RUN \
        pactl set-default-source ${source_index}
}

set_default_sink_volume() {
    volume=$1
    if [[ -z "${volume}" ]]; then
        error "volume is null"
        return
    fi
    $USER_RUN \
        pactl set-sink-volume @DEFAULT_SINK@ ${volume}%
}

set_default_source_volume() {
    volume=$1
    if [[ -z "${volume}" ]]; then
        error "volume is null"
        return
    fi
    $USER_RUN \
        pactl set-source-volume @DEFAULT_SOURCE@ ${volume}%
}

check_robothat() {
    # find robothat device-tree directory
    hat_dirs=$(find /proc/device-tree/*hat* -type d)
    # echo $hat_dirs
    hat_dir=""

    for dir in $hat_dirs; do
        if [ ! -e "$dir"/uuid ]; then
            continue
        fi
        uuid=$(tr -d '\0' <"$dir"/uuid)
        # echo uuid:$uuid

        # ----- whether uuid in HAT_UUIDs -----
        # echo HAT_UUIDs:${HAT_UUIDs[@]}
        if [[ -n "${uuid}" && "${HAT_UUIDs[@]}" =~ "${uuid}" ]]; then
            hat_dir=$dir
            break
        fi
    done

    echo hat_dir:$hat_dir
    if [[ -z "${hat_dir}" ]]; then
        echo "No robothat 5 found"
        return
    fi

    # read robothat info
    robothat_product=$(tr -d '\0' <"$hat_dir"/product)
    robothat_product_id_hex=$(tr -d '\0' <"$hat_dir"/product_id)
    robothat_product_ver_hex=$(tr -d '\0' <"$hat_dir"/product_ver)
    let robothat_product_id=$(printf "%d" $robothat_product_id_hex)
    let robothat_product_ver=$(printf "%d" $robothat_product_ver_hex)

    robothat_uuid=$(tr -d '\0' <"$hat_dir"/uuid)
    robothat_vendor=$(tr -d '\0' <"$hat_dir"/vendor)

    success "Found:"
    success "  Product: $robothat_product"
    success "  Product ID: $robothat_product_id ($robothat_product_id_hex)"
    success "  Version: $robothat_product_ver ($robothat_product_ver_hex)"
    success "  Vendor: $robothat_vendor"
    success "  UUID: $robothat_uuid"
}

# main_fuction
# ================================================================================
install_soundcard_driver() {
    info "install robot-hat soundcard driver >>>"
    info "script version: $VERSION"
    info "user: $USERNAME"

    # check root
    # =====================================
    sudocheck

    # apt install packages
    # =====================================
    if $_is_install_deps; then
        newline
        info "apt update..."
        apt update

        info "install alsa-utils ..."
        # alsa-utils includes:
        #  alsamixer, aplay, arecord, amixer, speaker-test
        apt install alsa-utils -y

        info "install pulseaudio ..."
        apt install pulseaudio -y

        info "install pulseaudio-utils ..."
        apt install pulseaudio-utils -y

        info "install jq ..."
        apt install jq -y

        info "install sox ..."
        apt install sox -y
    else
        info "skip install deps ..."
    fi

    # detect robothat 5
    # =====================================
    newline
    info "check robothat 5 ..."
    check_robothat

    if [ $robothat_product_ver -ge ${ROBOTHAT5_PRODUCT_VER} ]; then
        robothat_spk_en=12
        _is_with_mic=true
    else
        robothat_spk_en=20
        _is_with_mic=false
    fi
    success "robothat_spk_en: ${robothat_spk_en}"
    success "is_with_mic: ${_is_with_mic}"

    # config soundcard
    # =====================================
    newline
    if $_is_with_mic; then
        info "config soundcard with mic ..."
        dtoverlay_name=${DTOVERLAY_WITH_MIC}
        audio_card_name=${AUDIO_CARD_NAME_WITH_MIC}
        alsa_card_name=${ALSA_CARD_NAME_WITH_MIC}
    else
        info "config soundcard without mic ..."
        dtoverlay_name=${DTOVERLAY_WITHOUT_MIC}
        audio_card_name=${AUDIO_CARD_NAME_WITHOUT_MIC}
        alsa_card_name=${ALSA_CARD_NAME_WITHOUT_MIC}
    fi

    # --- add dtoverlay to config.txt ---
    newline
    if $_is_with_mic; then
        info "add dtoverlay ${DTOVERLAY_WITH_MIC} in ${CONFIG} ..."
        if [ -e "${CONFIG}" ]; then
            # dtoverlay=googlevoicehat-soundcard
            # #dtoverlay=hifiberry-dac
            if grep -q -e ".*dtoverlay=${DTOVERLAY_WITH_MIC}.*" "${CONFIG}"; then
                echo "activated dtoverlay ${DTOVERLAY_WITH_MIC} ..."
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITH_MIC}.*:dtoverlay=${DTOVERLAY_WITH_MIC}:g" "${CONFIG}"
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*:#dtoverlay=${DTOVERLAY_WITHOUT_MIC}:g" "${CONFIG}"
            else
                echo "add dtoverlay ${DTOVERLAY_WITH_MIC} ..."
                echo "dtoverlay=${DTOVERLAY_WITH_MIC}" | sudo tee -a $CONFIG
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*:#dtoverlay=${DTOVERLAY_WITHOUT_MIC}:g" "${CONFIG}"
            fi
        else
            error "${CONFIG} not found"
        fi
    else
        info "add dtoverlay ${DTOVERLAY_WITHOUT_MIC} in ${CONFIG} ..."
        if [ -e "${CONFIG}" ]; then
            # dtoverlay=googlevoicehat-soundcard
            # #dtoverlay=hifiberry-dac
            if grep -q -e ".*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*" "${CONFIG}"; then
                echo "activated dtoverlay ${DTOVERLAY_WITHOUT_MIC} ..."
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITHOUT_MIC}.*:dtoverlay=${DTOVERLAY_WITHOUT_MIC}:g" "${CONFIG}"
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITH_MIC}.*:#dtoverlay=${DTOVERLAY_WITH_MIC}:g" "${CONFIG}"
            else
                echo "add dtoverlay ${DTOVERLAY_WITHOUT_MIC} ..."
                echo "dtoverlay=${DTOVERLAY_WITHOUT_MIC}" | sudo tee -a $CONFIG
                sudo sed -i -e "s:.*dtoverlay=${DTOVERLAY_WITH_MIC}.*:#dtoverlay=${DTOVERLAY_WITH_MIC}:g" "${CONFIG}"
            fi
        else
            error "${CONFIG} not found"
        fi
    fi

    # --- load dtoverlay ---
    newline
    info "Trying to load dtoverlay ${dtoverlay_name} ..."
    dtoverlay ${dtoverlay_name}
    sleep 1

    # --- get sound card ---
    info "get_soundcard_index ..."
    card_index=$(get_soundcard_index $audio_card_name)
    if [[ -z "${card_index}" ]]; then
        error "soundcard index not found. Sometimes you need to reboot to activate the soundcard."
        ask_reboot "Would you like to reboot and retry now?"
        warning "Unfinished"
        exit 1
    else
        success "soundcard ${audio_card_name} index: ${card_index}"
    fi

    # --- config /etc/asound.conf ---
    newline
    if $_is_with_mic; then
        info "config /etc/asound.conf with mic ..."
        # write asound.conf
        config_asound_with_mic
    else
        info "config /etc/asound.conf without mic ..."
        # write asound.conf
        config_asound_without_mic
    fi
    # restart alsa-utils
    sudo systemctl restart alsa-utils 2>/dev/null
    # set volume 100%
    info "set ALSA speker volume to 100% ..."
    play -n trim 0.0 0.5 2>/dev/null # play a short sound to to activate alsamixer speaker vol control
    amixer -c ${audio_card_name} sset "${SOFTVOL_SPEAKER_NAME}" 100%
    if $_is_with_mic; then
        info "set ALSA mic volume to 100% ..."
        rec /tmp/rec_test.wav trim 0 0.5 2>/dev/null # record a short sound to activate alsamixer mic vol control
        amixer -c ${audio_card_name} sset "${SOFTVOL_MIC_NAME}" 100%
    fi

    # --- config pulseaudio ---
    newline
    info "config pulseaudio ..."

    # enable pulseaudio
    # https://www.raspberrypi.com/documentation/computers/configuration.html#audio-config-2
    info "raspi-config enable pulseaudio ..."
    raspi-config nonint do_audioconf 1 2>/dev/null

    # run pulseaudio
    info "run pulseaudio ..."
    # # stop pulseaudio
    # $USER_RUN \
    #     pulseaudio -k 2>/dev/null
    # start pulseaudio
    $USER_RUN \
        pulseaudio -D 2>/dev/null

    # get sink index
    newline
    info "get_sink_index ..."
    sink_index=$(get_sink_index $alsa_card_name)
    if [[ -z "${sink_index}" ]]; then
        error "sink index not found."
        error "Sometimes you need to reboot to activate the soundcard."
    else
        success "sink index: ${sink_index}"
    fi

    # set default sink
    info "set default sink ..."
    set_default_sink "${sink_index}"

    if $_is_with_mic; then
        # get source index
        info "get_source_index ..."
        source_index=$(get_source_index $alsa_card_name)
        if [[ -z "${source_index}" ]]; then
            error "source index not found."
            error "Sometimes you need to reboot to activate the soundcard."
        else
            success "source index: ${source_index}"
        fi
        # set default source
        info "set default source ..."
        set_default_source "${source_index}"
    fi

    # set default volume
    info "set default Pulseaudio volume to 100% ..."
    set_default_sink_volume 100
    if $_is_with_mic; then
        set_default_source_volume 100
    fi

    # --- test speaker ---
    newline
    if confirm "Do you wish to test speaker now?"; then
        info "testing speaker ..."
        # enable speaker
        if command -v pinctrl >/dev/null; then
            pinctrl set $robothat_spk_en op dh
            # play a short sound to fill data and avoid the speaker overheating
            play -n trim 0.0 0.5 2>/dev/null
        elif command -v raspi-gpio >/dev/null; then
            raspi-gpio set $robothat_spk_en op dh
            # play a short sound to fill data and avoid the speaker overheating
            play -n trim 0.0 0.5 2>/dev/null
        else
            warning "Could not find pinctrl or raspi-gpio command."
        fi
        # test speaker
        speaker-test -l3 -c2 -t wav
    fi

    # --- Done ---
    newline
    success "All done!"
    newline
}

# main
# =================================================================
for arg in "$@"; do
    case $arg in
    --no-deps)
        _is_install_deps=false
        ;;
    esac
done

# echo sink_index=$(get_sink_index)
# echo source_index=$(get_source_index)

install_soundcard_driver

exit 0


##################################################
# FILE: baseline_code/robot-hat/pyproject.toml
##################################################


[build-system]
requires = ["setuptools >= 61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "robot_hat"
authors = [
  { name="sunfounder", email="service@sunfounder.com" },
]
description = "Robot Hat Python library for Raspberry Pi"
readme = "README.md"
requires-python = ">=3.7"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
    "Operating System :: POSIX :: Linux",
]
keywords = ["robot_hat", "sunfounder"]
dynamic = ["version"]

dependencies = [

]

[project.scripts]
robot_hat = "robot_hat:__main__"

[project.urls]
Homepage = "https://www.sunfounder.com/products/sunfounder-robot-hat-expansion-board-designed-for-raspberry-pi"
Documentation = "https://docs.sunfounder.com/projects/robot-hat-v4/en/latest/"
Repository = "https://github.com/sunfounder/robot-hat/tree/dev"
Issues = "https://github.com/sunfounder/robot-hat/issues"
Changelog = "https://github.com/sunfounder/robot-hat/commits/dev/"

[tool.setuptools.packages.find]
include = ["robot_hat"]
exclude = ["setup.py", "docs", 'tests*', 'examples', 'workspace']

[tool.setuptools.dynamic]
version = {attr = "robot_hat.version.__version__"}




##################################################
# FILE: baseline_code/robot-hat/tests/servo_test.py
##################################################

from robot_hat import Servo
from time import sleep

servos = [Servo(i) for i in range(12)]

while True:
    for servo in servos:
        servo.angle(-20)
        sleep(0.1)
    for servo in servos:
        servo.angle(20)
        sleep(0.1)



##################################################
# FILE: baseline_code/robot-hat/tests/init_angles_test.py
##################################################

from robot_hat import Robot,PWM,Servo,Music
from robot_hat.utils import reset_mcu
from time import sleep

reset_mcu()
sleep(0.01)


def fuc():
    rubo = Robot([10,11,12],3,init_angles=[10,45,-45])


if __name__ == "__main__":
    fuc()


##################################################
# FILE: baseline_code/robot-hat/tests/motor_robothat5_test.py
##################################################

from robot_hat import Motor, PWM, Pin
from time import sleep

m0 = Motor(PWM('P12'), PWM('P13'), mode=2)
m1 = Motor(PWM('P14'), PWM('P15'), mode=2)
m2 = Motor(PWM('P16'), PWM('P17'), mode=2)
m3 = Motor(PWM('P18'), PWM('P19'), mode=2)


try:
    while True:
        m0.speed(-50)
        m1.speed(-50)
        m2.speed(-50)
        m3.speed(-50)
        sleep(1)
        m0.speed(50)
        m1.speed(50)
        m2.speed(50)
        m3.speed(50)
        sleep(1)
        m0.speed(0)
        m1.speed(0)
        m2.speed(0)
        m3.speed(0)
finally:
    m0.speed(0)
    m1.speed(0)
    m2.speed(0)
    m3.speed(0)
    sleep(.1)



##################################################
# FILE: baseline_code/robot-hat/tests/button_event_test.py
##################################################

from robot_hat import Pin
import time

btn = Pin("D0") # IO17

def pressed_handler():
    print(f"Pressed - {time.time()}")

def released_handler():
    print(f"Released - {time.time()}")

def both_handler():
    print(f"xxx - {time.time()}")

btn.irq(handler=pressed_handler, trigger=Pin.IRQ_FALLING, bouncetime=20)
print(btn)
btn.irq(handler=released_handler, trigger=Pin.IRQ_RISING, bouncetime=10)
print(btn)
# btn.irq(handler=both_handler, trigger=Pin.IRQ_RISING_FALLING, bouncetime=10)
# print(btn)



while True:
    time.sleep(1)


##################################################
# FILE: baseline_code/robot-hat/tests/tone_test.py
##################################################

from robot_hat import Music, set_volume
import time

# Create a new Music object
music = Music()

set_volume(80)
music.tempo(60, 1/4)

print("Measure 1")
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 2")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("C5"), music.beat(1/8))
music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("D#5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 3")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 4")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 5")
music.play_tone_for(music.note("A4"), music.beat(1/4))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
music.play_tone_for(music.note("D4"), music.beat(1/4))
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 6")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("C5"), music.beat(1/8))
music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("D#5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 7")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 8")
music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("A4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("E4"), music.beat(1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
print("Measure 9")
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
print("Measure 10")
music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("F5"), music.beat(1/8))
music.play_tone_for(music.note("E5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 11")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 12")
music.play_tone_for(music.note("A#4"), music.beat(1/4))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
print("Measure 13")
music.play_tone_for(music.note("A4"), music.beat(1/4))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
music.play_tone_for(music.note("D4"), music.beat(1/4 + 1/8))
print("Measure 14")
music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("F5"), music.beat(1/8))
music.play_tone_for(music.note("E5"), music.beat(1/16))
music.play_tone_for(music.note("D5"), music.beat(1/8))
print("Measure 15")
music.play_tone_for(music.note("C5"), music.beat(1/4))
music.play_tone_for(music.note("A4"), music.beat(1/8))
music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("G4"), music.beat(1/16))
music.play_tone_for(music.note("A4"), music.beat(1/8))
print("Measure 16")
music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("A4"), music.beat(1/16))
music.play_tone_for(music.note("G4"), music.beat(1/8))
music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
music.play_tone_for(music.note("E4"), music.beat(1/16))
music.play_tone_for(music.note("F#4"), music.beat(1/8))
print("Measure 17")
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))


# Baby shark

# music.tempo(180)
# music.key_signature("#")
# music.time_signature(4, 4)

# print("Measure 0")
# music.play_tone_for(music.note("D4"), music.beat(1/2))
# music.play_tone_for(music.note("E4"), music.beat(1/2))
# print("Measure 1")
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# print("Measure 2")
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("D4"), music.beat(1/4))
# music.play_tone_for(music.note("E4"), music.beat(1/4))
# print("Measure 3")
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# print("Measure 4")
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("D4"), music.beat(1/4))
# music.play_tone_for(music.note("E4"), music.beat(1/4))
# print("Measure 5")
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# print("Measure 6")
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/8))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# music.play_tone_for(music.note("G4"), music.beat(1/4))
# print("Measure 7")
# music.play_tone_for(music.note("F#4"), music.beat(1))


##################################################
# FILE: baseline_code/robot-hat/tests/motor_test.py
##################################################

from robot_hat import Motor, PWM, Pin
from time import sleep

m0 = Motor(PWM('P13'), Pin('D4'))
m1= Motor(PWM('P12'), Pin('D5'))

try:
    while True:
        m0.speed(-50)
        m1.speed(-50)
        sleep(1)
        m0.speed(50)
        m1.speed(50)
        sleep(1)
        m0.speed(0)
        m1.speed(0)
finally:
    m0.speed(0)
    m1.speed(0)
    sleep(.1)



##################################################
# FILE: baseline_code/robot-hat/tests/servo_hat_test.py
##################################################

#!/usr/bin/env python3
from robot_hat import Servo, ADC
from robot_hat.utils import reset_mcu
from time import sleep

reset_mcu()
sleep(1)

adc0 = ADC(0)
adc1 = ADC(1)
adc2 = ADC(2)
adc3 = ADC(3)
adc4 = ADC(4)


if __name__ == '__main__':
    for i in range(16):
        print(f"Servo {i} set to zero")
        Servo(i).angle(10)
        sleep(0.1)
        Servo(i).angle(0)
        sleep(0.1)
    while True:
        v0 = adc0.read()
        v1 = adc1.read()
        v2 = adc2.read()
        v3 = adc3.read()
        v4 = adc4.read()
        print(v0, v1, v2, v3, v4)
        sleep(1)


##################################################
# FILE: baseline_code/robot-hat/docs/requirements.txt
##################################################

# Defining the exact version will make sure things don't break
sphinx==7.3.7
sphinx_rtd_theme==3.0.1
sphinx_copybutton
sphinx_toolbox


##################################################
# FILE: baseline_code/robot-hat/docs/Makefile
##################################################

# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = source
BUILDDIR      = build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)


##################################################
# FILE: baseline_code/robot-hat/docs/source/api_robot.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_robot:

class ``Robot``
========================================

**Example**

.. code-block:: python

    # Import Robot class
    from robot import Robot

    # Create a robot(PiSloth)
    robot = Robot(pin_list=[0, 1, 2, 3], name="pisloth")

    robot.move_list["forward"] = [
        [0, 40, 0, 15],
        [-30, 40, -30, 15],
        [-30, 0, -30, 0],

        [0, -15, 0, -40],
        [30, -15, 30, -40],
        [30, 0, 30, 0],
        ]
    
    robot.do_action("forward", step=3, speed=90)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Robot
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/api_servo.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_servo:

class ``Servo``
=============================

**Example**

.. code-block:: python
    
    # Import Servo class
    from robot_hat import Servo

    # Create Servo object with PWM object
    servo0 = Servo("P0")

    # Set servo to position 0, here 0 is the center position,
    # angle ranges from -90 to 90
    servo0.angle(0)

    # Sweep servo from 0 to 90 degrees, then 90 to -90 degrees, finally back to 0
    import time
    for i in range(0, 91):
        servo0.angle(i)
        time.sleep(0.05)
    for i in range(90, -91, -1):
        servo0.angle(i)
        time.sleep(0.05)
    for i in range(-90, 1):
        servo0.angle(i)
        time.sleep(0.05)


    # Servos are all controls with pulse width, some
    # from 500 ~ 2500 like most from SunFounder.
    # You can directly set the pulse width

    # Set servo to 1500 pulse width (-90 degree)
    servo0.pulse_width_time(500)
    # Set servo to 1500 pulse width (0 degree)
    servo0.pulse_width_time(1500)
    # Set servo to 1500 pulse width (90 degree)
    servo0.pulse_width_time(2500)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Servo
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/projects.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Some Projects
=================

Here, you'll find a collection of fascinating projects, all implemented using the Robot HAT. 
We provide you with detailed code, giving you the opportunity to try these projects out for yourself.

.. toctree::
    :maxdepth: 1

    project_control_motor_servo
    project_diy_car
    project_photoresistor
    project_ultrasonic
    project_plant_monitor
    project_say_something
    project_security
    community_tutorials



##################################################
# FILE: baseline_code/robot-hat/docs/source/index.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

SunFounder |link_Robot_HAT_kit|
=====================================

* |link_Robot_HAT|

Thanks for choosing our |link_Robot_HAT_kit|.

.. note::
    This document is available in the following languages.

        * |link_german_tutorials|
        * |link_jp_tutorials|
        * |link_en_tutorials|
    
    Please click on the respective links to access the document in your preferred language.

.. image:: img/robot_hat_pic.png
    :width: 500
    :align: center
   

Robot HAT is a multifunctional expansion board that allows Raspberry Pi to be quickly turned into a robot. An MCU is on board to extend the PWM output and ADC input for the Raspberry Pi, as well as a motor driver chip, Bluetooth module, I2S audio module and mono speaker. As well as the GPIOs that lead out of the Raspberry Pi itself.

It also comes with a Speaker, which can be used to play background music, sound effects and implement TTS functions to make your project more interesting.

Accepts 6.0V-8.4V XH2.54 3pin power input with 2 power indicators. The board also has a user available LED and a button for you to quickly test some effects.

In this document, you will get a full understanding of the interface functions of the Robot HAT and the usage of these interfaces through the Python ``robot-hat`` library provided by SunFounder.


.. toctree::
    :maxdepth: 3

    About this HAT<self>
    features
    hardware_introduction
    battery
    installation
    install_i2s_for_speaker
    onboard_mcu
    api
    projects
    faq


##################################################
# FILE: baseline_code/robot-hat/docs/source/project_photoresistor.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Read from Photoresistor Module
================================

In this project, we detect the light intensity and display on the I2C LCD1602.

.. image:: img/photoresistor.jpg

**Steps**

#. In this project, an I2C LCD1602 is used, so it's necessary to download the relevant libraries to make it work.

    .. code-block:: shell

        cd ~/
        wget https://github.com/sunfounder/raphael-kit/blob/master/python/LCD1602.py

#. Install ``smbus2`` for I2C.

    .. code-block:: shell

        sudo pip3 install smbus2

#. Save the following code to your Raspberry Pi and give it a name, for example, ``photoresistor.ty``.

    .. code-block:: python

        from robot_hat import ADC
        import LCD1602
        import time

        # Create an ADC object to read the value from the photoresistor
        a0 = ADC(0)

        def setup():
            # Initialize the LCD1602
            LCD1602.init(0x27, 1)
            time.sleep(2)

        def destroy():
            # Clear the LCD display
            LCD1602.clear()

        def loop():
            while True:
                # Read the value from the photoresistor
                value0 = a0.read()
                # Display the read value on the LCD
                LCD1602.write(0, 0, 'Value: %d  ' % value0)
                # Reduce the refresh rate to update once per second
                time.sleep(0.2)

        if __name__ == '__main__':
            setup()
            try:
                loop()
            except KeyboardInterrupt:
                destroy()
            except Exception as e:
                # Clear the LCD and print error message in case of an exception
                destroy()
                print("Error:", e)


#. Use the command ``sudo python3 photoresistor.ty`` to run this code.



##################################################
# FILE: baseline_code/robot-hat/docs/source/project_control_motor_servo.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Control Servos and Motors
============================

In this project, we have 12 servos and two motors working simultaneously.

.. image:: img/servo_motor.jpg
    :width: 500
    :align: center

However, it's important to note that if your servos and motors have a high starting current, it's recommended to start them separately to avoid insufficient power supply current, which could lead to the Raspberry Pi restarting.

**Code**

.. code-block:: python

    from robot_hat import Servo, Motors
    import time

    # Create objects for 12 servos
    servos = [Servo(f"P{i}") for i in range(12)]

    # Create motor object
    motors = Motors()

    def initialize_servos():
        """Set initial angle of all servos to 0."""
        for servo in servos:
            servo.angle(-90)
            time.sleep(0.1)  # Wait for servos to reach the initial position
        time.sleep(1)


    def sweep_servos(angle_from, angle_to, step):
        """Control all servos to sweep from a start angle to an end angle."""
        if angle_from < angle_to:
            range_func = range(angle_from, angle_to + 1, step)
        else:
            range_func = range(angle_from, angle_to - 1, -step)

        for angle in range_func:
            for servo in servos:
                servo.angle(angle)
            time.sleep(0.05)

    def control_motors_and_servos():
        """Control motors and servos in synchronization."""
        try:
            while True:
                # Motors rotate forward and servos sweep from -90 to 90 degrees
                motors[1].speed(80)
                time.sleep(0.01)
                motors[2].speed(80)
                time.sleep(0.01)
                sweep_servos(-90, 90, 5)
                time.sleep(1)

                # Motors rotate backward and servos sweep from 90 to -90 degrees
                motors[1].speed(-80)
                time.sleep(0.01)
                motors[2].speed(-80)
                time.sleep(0.01)
                sweep_servos(90, -90, 5)
                time.sleep(1)
        except KeyboardInterrupt:
            # Stop motors when Ctrl+C is pressed
            motors.stop()
            print("Motors stopped.")

    # Initialize servos to their initial position
    initialize_servos()

    # Control motors and servos
    control_motors_and_servos()




##################################################
# FILE: baseline_code/robot-hat/docs/source/api_basic_class.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

class ``_Basic_class``
=========================================

``_Basic_class`` is a logger class for all class to log, so if you want to see
logs of a class, just add a debug argument to it.

**Example**

.. code-block:: python

    # See PWM log
    from robot_hat import PWM

    # init the class with a debug argument
    pwm = PWM(0, debug_level="debug")

    # run some functions and see logs
    pwm.freq(1000)
    pwm.pulse_width_percent(100)


**API**

.. currentmodule:: robot_hat.basic

.. autoclass:: _Basic_class
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../api.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api.rst:16
msgid "Reference"
msgstr "参照"

#: of robot_hat:1
msgid "Robot Hat Library"
msgstr "Robot Hatライブラリ"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_photoresistor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_photoresistor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_photoresistor.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_photoresistor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_photoresistor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_photoresistor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_photoresistor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_photoresistor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_photoresistor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_photoresistor.rst:16
msgid "Read from Photoresistor Module"
msgstr "フォトレジスタモジュールから読み取る"

#: ../project_photoresistor.rst:18
msgid ""
"In this project, we detect the light intensity and display on the I2C "
"LCD1602."
msgstr "このプロジェクトでは、光の強度を検出し、I2C LCD1602に表示します。"

#: ../project_photoresistor.rst:22
msgid "**Steps**"
msgstr "**手順**"

#: ../project_photoresistor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr "このプロジェクトではI2C LCD1602を使用しているため、関連するライブラリをダウンロードして機能させる必要があります。"

#: ../project_photoresistor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "I2C用に ``smbus2`` をインストールします。"

#: ../project_photoresistor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``photoresistor.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``photoresistor.ty`` のような名前を付けます。"

#: ../project_photoresistor.rst:78
msgid "Use the command ``sudo python3 photoresistor.ty`` to run this code."
msgstr "このコードを実行するには、コマンド ``sudo python3 photoresistor.ty`` を使用します。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_i2c.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_i2c.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_i2c.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_i2c.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_i2c.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_i2c.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_i2c.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_i2c.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_i2c.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_i2c.rst:18
msgid "class ``I2C``"
msgstr "クラス ``I2C``"

#: ../api_i2c.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_i2c.rst:44
msgid "For more information on the I2C protocol, see checkout adc.py and pwm.py"
msgstr "I2Cプロトコルの詳細については、adc.pyとpwm.pyをご覧ください"

#: ../api_i2c.rst:46
msgid "**API**"
msgstr "**API**"

#: of robot_hat.i2c.I2C:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.i2c.I2C:1
msgid "I2C bus read/write functions"
msgstr "I2Cバスの読み書き機能"

#: of robot_hat.i2c.I2C.__init__:1
msgid "Initialize the I2C bus"
msgstr "I2Cバスを初期化する"

#: of robot_hat.i2c.I2C.__init__ robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.mem_write robot_hat.i2c.I2C.read robot_hat.i2c.I2C.write
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.i2c.I2C.__init__:3
msgid "I2C device address"
msgstr "I2Cデバイスアドレス"

#: of robot_hat.i2c.I2C.__init__:5
msgid "I2C bus number"
msgstr "I2Cバス番号"

#: of robot_hat.i2c.I2C.scan:1
msgid "Scan the I2C bus for devices"
msgstr "I2Cバスをスキャンしてデバイスを検出する"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.i2c.I2C.scan:3
msgid "List of I2C addresses of devices found"
msgstr "見つかったデバイスのI2Cアドレスのリスト"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.i2c.I2C.write:1
msgid "Write data to the I2C device"
msgstr "I2Cデバイスにデータを書き込む"

#: of robot_hat.i2c.I2C.write:3
msgid "Data to write"
msgstr "書き込むデータ"

#: of robot_hat.i2c.I2C.write
msgid "raises"
msgstr "例外"

#: of robot_hat.i2c.I2C.write:5
msgid "ValueError if write is not an int, list or bytearray"
msgstr "書き込みがint、リスト、またはバイト配列でない場合はValueError"

#: of robot_hat.i2c.I2C.read:1
msgid "Read data from I2C device"
msgstr "I2Cデバイスからデータを読み取る"

#: of robot_hat.i2c.I2C.mem_read:3 robot_hat.i2c.I2C.read:3
msgid "Number of bytes to receive"
msgstr "受信するバイト数"

#: of robot_hat.i2c.I2C.read:5
msgid "Received data"
msgstr "受信したデータ"

#: of robot_hat.i2c.I2C.mem_write:1
msgid "Send data to specific register address"
msgstr "特定のレジスタアドレスにデータを送信する"

#: of robot_hat.i2c.I2C.mem_write:3
msgid "Data to send, int, list or bytearray"
msgstr "送信するデータ、int、リスト、またはバイト配列"

#: of robot_hat.i2c.I2C.mem_read:5 robot_hat.i2c.I2C.mem_write:5
msgid "Register address"
msgstr "レジスタアドレス"

#: of robot_hat.i2c.I2C.mem_write
msgid "Raises"
msgstr "例外"

#: of robot_hat.i2c.I2C.mem_write:7
msgid "If data is not int, list, or bytearray"
msgstr "データがint、リスト、またはバイト配列でない場合"

#: of robot_hat.i2c.I2C.mem_read:1
msgid "Read data from specific register address"
msgstr "特定のレジスタアドレスからデータを読み取る"

#: of robot_hat.i2c.I2C.mem_read:7
msgid "Received bytearray data or False if error"
msgstr "エラーがない場合は受信したバイト配列データ、エラーがある場合はFalse"

#: of robot_hat.i2c.I2C.is_avaliable:1
msgid "Check if the I2C device is avaliable"
msgstr "I2Cデバイスが利用可能かどうかを確認する"

#: of robot_hat.i2c.I2C.is_avaliable:3
msgid "True if the I2C device is avaliable, False otherwise"
msgstr "I2Cデバイスが利用可能な場合はTrue、そうでない場合はFalse"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_tts.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_tts.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_tts.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_tts.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_tts.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_tts.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_tts.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_tts.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_tts.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_tts.rst:18
msgid "class ``TTS``"
msgstr "クラス ``TTS``"

#: ../api_tts.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr "スピーカーが動作しない場合、このスクリプトを実行する際には ``sudo`` を追加する必要があります。"

#: ../api_tts.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_tts.rst:24
msgid "**Example**"
msgstr "**例**"

#: ../api_tts.rst:39
msgid "**API**"
msgstr "**API**"

#: of robot_hat.tts.TTS:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.tts.TTS:1
msgid "Text to speech class"
msgstr "テキストから音声への変換クラス"

#: ../docstring of robot_hat.TTS.SUPPORTED_LANGUAUE:1
msgid "Supported TTS language for pico2wave"
msgstr "pico2waveのためのサポートされているTTS言語"

#: ../docstring of robot_hat.TTS.ESPEAK:1
msgid "espeak TTS engine"
msgstr "espeak TTSエンジン"

#: ../docstring of robot_hat.TTS.PICO2WAVE:1
msgid "pico2wave TTS engine"
msgstr "pico2wave TTSエンジン"

#: of robot_hat.tts.TTS.__init__:1
msgid "Initialize TTS class."
msgstr "TTSクラスを初期化する。"

#: of robot_hat.tts.TTS.__init__ robot_hat.tts.TTS.espeak
#: robot_hat.tts.TTS.espeak_params robot_hat.tts.TTS.lang
#: robot_hat.tts.TTS.pico2wave robot_hat.tts.TTS.say
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.tts.TTS.__init__:3
msgid "TTS engine, TTS.PICO2WAVE or TTS.ESPEAK"
msgstr "TTSエンジン、TTS.PICO2WAVEまたはTTS.ESPEAK"

#: of robot_hat.tts.TTS.say:1
msgid "Say words."
msgstr "言葉を話す。"

#: of robot_hat.tts.TTS.espeak:3 robot_hat.tts.TTS.pico2wave:3
#: robot_hat.tts.TTS.say:3
msgid "words to say."
msgstr "話す言葉。"

#: of robot_hat.tts.TTS.espeak:1
msgid "Say words with espeak."
msgstr "espeakで言葉を話す。"

#: of robot_hat.tts.TTS.pico2wave:1
msgid "Say words with pico2wave."
msgstr "pico2waveで言葉を話す。"

#: of robot_hat.tts.TTS.lang:1
msgid "Set/get language. leave empty to get current language."
msgstr "言語を設定/取得する。現在の言語を取得するために空のままにする。"

#: of robot_hat.tts.TTS.lang:3
msgid "language."
msgstr "言語。"

#: of robot_hat.tts.TTS.supported_lang:1
msgid "Get supported language."
msgstr "サポートされている言語を取得する。"

#: of robot_hat.tts.TTS.supported_lang
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.tts.TTS.supported_lang:3
msgid "supported language."
msgstr "サポートされている言語。"

#: of robot_hat.tts.TTS.supported_lang
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.tts.TTS.espeak_params:1
msgid "Set espeak parameters."
msgstr "espeakのパラメータを設定する。"

#: of robot_hat.tts.TTS.espeak_params:3
msgid "amplitude."
msgstr "振幅。"

#: of robot_hat.tts.TTS.espeak_params:5
msgid "speed."
msgstr "速度。"

#: of robot_hat.tts.TTS.espeak_params:7
msgid "gap."
msgstr "ギャップ。"

#: of robot_hat.tts.TTS.espeak_params:9
msgid "pitch."
msgstr "ピッチ。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/hardware_introduction.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../hardware_introduction.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../hardware_introduction.rst:5
msgid "**Why Join?**"
msgstr "**Warum beitreten?**"

#: ../hardware_introduction.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../hardware_introduction.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../hardware_introduction.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../hardware_introduction.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../hardware_introduction.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../hardware_introduction.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../hardware_introduction.rst:16
msgid "Hardware Introduction"
msgstr "ハードウェア紹介"

#: ../hardware_introduction.rst:19
msgid "Pinout"
msgstr "ピン配置"

#: ../hardware_introduction.rst:27
msgid "**Power Port**"
msgstr "**Power Port**"

#: ../hardware_introduction.rst:26
msgid "6.0V-8.4V XH2.54 3pin power input."
msgstr "6.0V-8.4V XH2.54 3ピン電源入力。"

#: ../hardware_introduction.rst:27
msgid "Powering the Raspberry Pi and Robot HAT at the same time."
msgstr "Raspberry PiとRobot HATを同時に給電します。"

#: ../hardware_introduction.rst:30
msgid "**Power Switch**"
msgstr "**Power Switch**"

#: ../hardware_introduction.rst:30
msgid "Turn on/off the power of the robot HAT."
msgstr "Robot HATの電源をオン/オフします。"

#: ../hardware_introduction.rst:36
msgid "**Type-C USB Port**"
msgstr "**Type-C USB Port**"

#: ../hardware_introduction.rst:33
msgid "Insert the Type-C cable to charge the battery."
msgstr "Type-Cケーブルを挿入してバッテリーを充電します。"

#: ../hardware_introduction.rst:34
msgid "At the same time, the charging indicator lights up in red color."
msgstr "同時に、充電インジケータが赤色で点灯します。"

#: ../hardware_introduction.rst:35
msgid "When the battery is fully charged, the charging indicator turns off."
msgstr "バッテリーが完全に充電されると、充電インジケータが消灯します。"

#: ../hardware_introduction.rst:36
msgid ""
"If the USB cable is still plugged in about 4 hours after it is fully "
"charged, the charging indicator will blink to prompt."
msgstr "バッテリーが完全に充電された後、約4時間USBケーブルがまだ接続されている場合、充電インジケータが点滅してプロンプト表示されます。"

#: ../hardware_introduction.rst:41
msgid "**Digital Pin**"
msgstr "**Digital Pin**"

#: ../hardware_introduction.rst:39
msgid "4-channel digital pins, D0-D3."
msgstr "4チャンネルのデジタルピン、D0-D3。"

#: ../hardware_introduction.rst:40
msgid "Pin: :ref:`pin_digital`."
msgstr "ピン： :ref:`pin_digital`。"

#: ../hardware_introduction.rst:41
msgid "API: :ref:`class_pin`."
msgstr "API： :ref:`class_pin`。"

#: ../hardware_introduction.rst:46
msgid "**ADC Pin**"
msgstr "**ADC Pin**"

#: ../hardware_introduction.rst:44
msgid "4-channel ADC pins, A0-A3."
msgstr "4チャンネルADCピン、A0-A3。"

#: ../hardware_introduction.rst:45
msgid "Pin: :ref:`pin_adc`."
msgstr "ピン： :ref:`pin_adc`。"

#: ../hardware_introduction.rst:46
msgid "API: :ref:`class_adc`."
msgstr "API： :ref:`class_adc`。"

#: ../hardware_introduction.rst:51
msgid "**PWM Pin**"
msgstr "**PWM Pin**"

#: ../hardware_introduction.rst:49
msgid "12-channel PWM pins, P0-P11."
msgstr "12チャンネルPWMピン、P0-P11。"

#: ../hardware_introduction.rst:50
msgid "Pin: :ref:`pin_pwm`."
msgstr "ピン： :ref:`pin_pwm`。"

#: ../hardware_introduction.rst:51
msgid "API: :ref:`class_pwm`."
msgstr "API： :ref:`class_pwm`。"

#: ../hardware_introduction.rst:56
msgid "**Left/Right Motor Port**"
msgstr "**Left/Right Motor Port**"

#: ../hardware_introduction.rst:54
msgid "2-channel XH2.54 motor ports."
msgstr "2チャンネルXH2.54モーターポート。"

#: ../hardware_introduction.rst:55
msgid "Pin: :ref:`pin_motor`."
msgstr "ピン： :ref:`pin_motor`。"

#: ../hardware_introduction.rst:56
msgid ""
"API: :ref:`class_motor`, ``1`` for left motor port, ``2`` for right motor"
" port."
msgstr "API： :ref:`class_motor`、 ``1`` は左モーターポート用、 ``2`` は右モーターポート用。"

#: ../hardware_introduction.rst:63
msgid "**I2C Pin and I2C Port**"
msgstr "**I2C Pin and I2C Port**"

#: ../hardware_introduction.rst:59
msgid "**I2C Pin**: P2.54 4-pin interface."
msgstr "**I2C Pin**：P2.54 4ピンインターフェース。"

#: ../hardware_introduction.rst:60
msgid ""
"**I2C Port**: SH1.0 4-pin interface, which is compatible with QWIIC and "
"STEMMA QT."
msgstr "**I2C Port**：SH1.0 4ピンインターフェース、QWIICおよびSTEMMA QTと互換性があります。"

#: ../hardware_introduction.rst:61
msgid ""
"These I2C interfaces are connected to the Raspberry Pi's I2C interface "
"via GPIO2 (SDA) and GPIO3 (SCL)."
msgstr ""
"これらのI2Cインターフェースは、GPIO2 (SDA) および GPIO3 (SCL) を介してRaspberry "
"PiのI2Cインターフェースに接続されています。"

#: ../hardware_introduction.rst:62
msgid "Pin: :ref:`pin_i2c`."
msgstr "ピン： :ref:`pin_i2c`。"

#: ../hardware_introduction.rst:63
msgid "API: :ref:`class_i2c`."
msgstr "API： :ref:`class_i2c`。"

#: ../hardware_introduction.rst:67
msgid "**SPI Pin**"
msgstr "**SPI Pin**"

#: ../hardware_introduction.rst:66
msgid "P2.54 7-pin SPI interface."
msgstr "P2.54 7ピンSPIインターフェース。"

#: ../hardware_introduction.rst:67
msgid "Pin: :ref:`pin_spi`."
msgstr "ピン： :ref:`pin_spi`。"

#: ../hardware_introduction.rst:71
msgid "**UART Pin**"
msgstr "**UART Pin**"

#: ../hardware_introduction.rst:70
msgid "P2.54 4-pin interface."
msgstr "P2.54 4ピンインターフェース。"

#: ../hardware_introduction.rst:71
msgid "Pin: :ref:`pin_uart`."
msgstr "ピン： :ref:`pin_uart`。"

#: ../hardware_introduction.rst:77
msgid "**RST Button**"
msgstr "**RST Button**"

#: ../hardware_introduction.rst:74
msgid ""
"The RST button, when using Ezblock, serves as a button to restart the "
"Ezblock program."
msgstr "Ezblockを使用しているとき、RSTボタンはEzblockプログラムを再起動するためのボタンとして機能します。"

#: ../hardware_introduction.rst:75
msgid ""
"If not using Ezblock, the RST button does not have a predefined function "
"and can be fully customized according to your needs."
msgstr "Ezblockを使用していない場合、RSTボタンにはあらかじめ定義された機能はなく、あなたのニーズに合わせて完全にカスタマイズすることができます。"

#: ../hardware_introduction.rst:76 ../hardware_introduction.rst:82
msgid "Pin: :ref:`pin_button`."
msgstr "ピン： :ref:`pin_button`。"

#: ../hardware_introduction.rst:77
msgid "API: :ref:`class_pin`"
msgstr "API： :ref:`class_pin`"

#: ../hardware_introduction.rst:82
msgid "**USR Button**"
msgstr "**USR Button**"

#: ../hardware_introduction.rst:80
msgid ""
"The functions of USR Button can be set by your programming. (Pressing "
"down leads to a input “0”; releasing produces a input “1”. )"
msgstr "USRボタンの機能はプログラミングによって設定することができます。(押すと入力「0」になり、放すと入力「1」になります。)"

#: ../hardware_introduction.rst:81
msgid "API: :ref:`class_pin`, you can use ``Pin(\"SW\")`` to define it."
msgstr "API： :ref:`class_pin` 、 ``Pin(\"SW\")`` を使用して定義することができます。"

#: ../hardware_introduction.rst:88
msgid "**Battery Indicator**"
msgstr "**Battery Indicator**"

#: ../hardware_introduction.rst:85
msgid "Two LEDs light up when the voltage is higher than 7.6V."
msgstr "電圧が7.6Vを超えると2つのLEDが点灯します。"

#: ../hardware_introduction.rst:86
msgid "One LED lights up in the 7.15V to 7.6V range."
msgstr "7.15Vから7.6Vの範囲では1つのLEDが点灯します。"

#: ../hardware_introduction.rst:87
msgid "Below 7.15V, both LEDs turn off."
msgstr "7.15V以下では両方のLEDが消灯します。"

#: ../hardware_introduction.rst:88
msgid ":ref:`battery_indicator`."
msgstr ":ref:`battery_indicator`。"

#: ../hardware_introduction.rst:96
msgid "**Speaker and Speaker Port**"
msgstr "**Speaker and Speaker Port**"

#: ../hardware_introduction.rst:91
msgid "**Speaker**: This is a 2030 audio chamber speaker."
msgstr "**Speaker**：これは2030オーディオチャンバースピーカーです。"

#: ../hardware_introduction.rst:92
msgid ""
"**Speaker Port**: The Robot HAT is equipped with onboard I2S audio "
"output, along with a 2030 audio chamber speaker, providing a mono sound "
"output."
msgstr ""
"**Speaker Port**：Robot "
"HATは、2030オーディオチャンバースピーカーと共に、オンボードI2Sオーディオ出力を備え、モノサウンド出力を提供します。"

#: ../hardware_introduction.rst:93
msgid "Pin: :ref:`pin_speaker`."
msgstr "ピン： :ref:`pin_speaker`。"

#: ../hardware_introduction.rst:94
msgid "API: :ref:`class_music`"
msgstr "API： :ref:`class_music`"

#: ../hardware_introduction.rst:99
msgid "Pin Mapping"
msgstr "ピンマッピング"

#: ../hardware_introduction.rst:101
msgid "Raspberry Pi IO"
msgstr "Raspberry Pi IO"

#: ../hardware_introduction.rst:105 ../hardware_introduction.rst:108
#: ../hardware_introduction.rst:203 ../hardware_introduction.rst:276
#: ../hardware_introduction.rst:315
msgid "Robot Hat V4"
msgstr "Robot Hat V4"

#: ../hardware_introduction.rst:106 ../hardware_introduction.rst:107
#: ../hardware_introduction.rst:204 ../hardware_introduction.rst:277
#: ../hardware_introduction.rst:316 ../hardware_introduction.rst:337
msgid "Raspberry Pi"
msgstr "Raspberry Pi"

#: ../hardware_introduction.rst:109 ../hardware_introduction.rst:141
#: ../hardware_introduction.rst:160 ../hardware_introduction.rst:161
#: ../hardware_introduction.rst:164 ../hardware_introduction.rst:184
msgid "NC"
msgstr "NC"

#: ../hardware_introduction.rst:110 ../hardware_introduction.rst:142
#: ../hardware_introduction.rst:288
msgid "3V3"
msgstr "3V3"

#: ../hardware_introduction.rst:111 ../hardware_introduction.rst:112
#: ../hardware_introduction.rst:115 ../hardware_introduction.rst:116
msgid "5V"
msgstr "5V"

#: ../hardware_introduction.rst:113 ../hardware_introduction.rst:114
msgid "SDA"
msgstr "SDA"

#: ../hardware_introduction.rst:117 ../hardware_introduction.rst:118
msgid "SCL"
msgstr "SCL"

#: ../hardware_introduction.rst:119 ../hardware_introduction.rst:120
#: ../hardware_introduction.rst:125 ../hardware_introduction.rst:126
#: ../hardware_introduction.rst:135 ../hardware_introduction.rst:136
#: ../hardware_introduction.rst:147 ../hardware_introduction.rst:148
#: ../hardware_introduction.rst:157 ../hardware_introduction.rst:158
#: ../hardware_introduction.rst:167 ../hardware_introduction.rst:168
#: ../hardware_introduction.rst:175 ../hardware_introduction.rst:176
#: ../hardware_introduction.rst:185 ../hardware_introduction.rst:186
#: ../hardware_introduction.rst:290
msgid "GND"
msgstr "GND"

#: ../hardware_introduction.rst:121 ../hardware_introduction.rst:209
msgid "D1"
msgstr "D1"

#: ../hardware_introduction.rst:122 ../hardware_introduction.rst:210
msgid "GPIO4"
msgstr "GPIO4"

#: ../hardware_introduction.rst:123 ../hardware_introduction.rst:124
msgid "TXD"
msgstr "TXD"

#: ../hardware_introduction.rst:127 ../hardware_introduction.rst:128
msgid "RXD"
msgstr "RXD"

#: ../hardware_introduction.rst:129 ../hardware_introduction.rst:206
msgid "D0"
msgstr "D0"

#: ../hardware_introduction.rst:130 ../hardware_introduction.rst:207
msgid "GPIO17"
msgstr "GPIO17"

#: ../hardware_introduction.rst:131 ../hardware_introduction.rst:341
msgid "GPIO18"
msgstr "GPIO18"

#: ../hardware_introduction.rst:132
msgid "I2S BCLK"
msgstr "I2S BCLK"

#: ../hardware_introduction.rst:133 ../hardware_introduction.rst:212
msgid "D2"
msgstr "D2"

#: ../hardware_introduction.rst:134 ../hardware_introduction.rst:213
msgid "GPIO27"
msgstr "GPIO27"

#: ../hardware_introduction.rst:137 ../hardware_introduction.rst:215
msgid "D3"
msgstr "D3"

#: ../hardware_introduction.rst:138 ../hardware_introduction.rst:216
msgid "GPIO22"
msgstr "GPIO22"

#: ../hardware_introduction.rst:139 ../hardware_introduction.rst:360
msgid "GPIO23"
msgstr "GPIO23"

#: ../hardware_introduction.rst:140
msgid "MOTOR 1 DIR"
msgstr "モーター1 DIR"

#: ../hardware_introduction.rst:143 ../hardware_introduction.rst:364
msgid "GPIO24"
msgstr "GPIO24"

#: ../hardware_introduction.rst:144
msgid "MOTOR 2 DIR"
msgstr "モーター2 DIR"

#: ../hardware_introduction.rst:145
msgid "SPI MOSI"
msgstr "SPI MOSI"

#: ../hardware_introduction.rst:146
msgid "MOSI"
msgstr "MOSI"

#: ../hardware_introduction.rst:149
msgid "SPI MISO"
msgstr "SPI MISO"

#: ../hardware_introduction.rst:150
msgid "MISO"
msgstr "MISO"

#: ../hardware_introduction.rst:151 ../hardware_introduction.rst:320
msgid "GPIO25"
msgstr "GPIO25"

#: ../hardware_introduction.rst:152
msgid "USR BUTTON"
msgstr "USRボタン"

#: ../hardware_introduction.rst:153
msgid "SPI SCLK"
msgstr "SPI SCLK"

#: ../hardware_introduction.rst:154
msgid "SCLK"
msgstr "SCLK"

#: ../hardware_introduction.rst:155
msgid "CE0"
msgstr "CE0"

#: ../hardware_introduction.rst:156
msgid "SPI CE0"
msgstr "SPI CE0"

#: ../hardware_introduction.rst:159
msgid "CE1"
msgstr "CE1"

#: ../hardware_introduction.rst:162
msgid "ID_SD"
msgstr "ID_SD"

#: ../hardware_introduction.rst:163
msgid "ID_SC"
msgstr "ID_SC"

#: ../hardware_introduction.rst:165
msgid "MCU Reset"
msgstr "MCUリセット"

#: ../hardware_introduction.rst:166
msgid "GPIO5"
msgstr "GPIO5"

#: ../hardware_introduction.rst:169
msgid "(SPI)BSY"
msgstr "(SPI)BSY"

#: ../hardware_introduction.rst:170 ../hardware_introduction.rst:279
msgid "GPIO6"
msgstr "GPIO6"

#: ../hardware_introduction.rst:171
msgid "GPIO12"
msgstr "GPIO12"

#: ../hardware_introduction.rst:172
msgid "Board Identifier 2"
msgstr "ボード識別子 2"

#: ../hardware_introduction.rst:173
msgid "Board Identifier 1"
msgstr "ボード識別子 1"

#: ../hardware_introduction.rst:174
msgid "GPIO13"
msgstr "GPIO13"

#: ../hardware_introduction.rst:177
msgid "I2S LRCLK"
msgstr "I2S LRCLK"

#: ../hardware_introduction.rst:178 ../hardware_introduction.rst:339
msgid "GPIO19"
msgstr "GPIO19"

#: ../hardware_introduction.rst:179 ../hardware_introduction.rst:322
msgid "GPIO16"
msgstr "GPIO16"

#: ../hardware_introduction.rst:180
msgid "RST BUTTON"
msgstr "RSTボタン"

#: ../hardware_introduction.rst:181
msgid "USER LED"
msgstr "ユーザー LED"

#: ../hardware_introduction.rst:182 ../hardware_introduction.rst:318
msgid "GPIO26"
msgstr "GPIO26"

#: ../hardware_introduction.rst:183
msgid "GPIO20"
msgstr "GPIO20"

#: ../hardware_introduction.rst:187 ../hardware_introduction.rst:343
msgid "GPIO21"
msgstr "GPIO21"

#: ../hardware_introduction.rst:188
msgid "I2S SDATA"
msgstr "I2S SDATA"

#: ../hardware_introduction.rst:193 ../hardware_introduction.rst:199
msgid "Digital IO"
msgstr "Digital IO"

#: ../hardware_introduction.rst:195
msgid "Robot HAT has 4 sets of P2.54 3Pin digital pins."
msgstr "Robot HATには4セットのP2.543ピンデジタルピンがあります。"

#: ../hardware_introduction.rst:221
msgid "ADC"
msgstr "ADC"

#: ../hardware_introduction.rst:225
msgid ""
"The Robot HAT features four sets of 3Pin ADC (Analog to Digital "
"Converter) pins, each spaced 2.54mm apart. These pins operate at a 3.3V "
"power supply. The ADC function, offering 12-bit precision, is facilitated"
" by an onboard microcontroller. Detailed instructions for reading ADC "
"values are provided in the :ref:`on_board_mcu` section."
msgstr ""
"Robot "
"HATは、4セットの3ピンADC（アナログ・デジタルコンバータ）ピンを特長としており、それぞれが2.54mm間隔で配置されています。これらのピンは3.3Vの電源で動作します。12ビットの精度を提供するADC機能は、オンボードのマイクロコントローラによって容易になっています。ADC値の読み取り方法の詳細は、"
" :ref:`on_board_mcu` セクションで提供されています。"

#: ../hardware_introduction.rst:229
msgid ""
"Also, ADC channel A4 is connected to the battery through a voltage "
"divider using resistors, which will be used to measure the battery "
"voltage to estimate the approximate battery charge."
msgstr "また、ADCチャネルA4は抵抗を使用した電圧分割器を介してバッテリーに接続されており、バッテリー電圧を測定しておおよそのバッテリー残量を推定するために使用されます。"

#: ../hardware_introduction.rst:232
msgid "The voltage divider ratio is 20K/10K, so:"
msgstr "電圧分割比は20K/10Kなので："

#: ../hardware_introduction.rst:234
msgid "A4 voltage (Va4) = value_A4 / 4095.0 * 3.3"
msgstr "A4電圧 (Va4) = value_A4 / 4095.0 * 3.3"

#: ../hardware_introduction.rst:235
msgid "Battery voltage (Vbat) = Va4*3"
msgstr "バッテリー電圧 (Vbat) = Va4*3"

#: ../hardware_introduction.rst:236
msgid "Battery voltage (Vbat) = value_A4 / 4095.0 * 3.3 * 3"
msgstr "バッテリー電圧 (Vbat) = value_A4 / 4095.0 * 3.3 * 3"

#: ../hardware_introduction.rst:241
msgid "PWM"
msgstr "PWM"

#: ../hardware_introduction.rst:245
msgid ""
"Robot HAT has 4 sets of 3Pin PWM pins, each spaced 2.54mm apart, and the "
"power supply is 5V. The method of using the PWM is described in detail in"
" :ref:`on_board_mcu`."
msgstr ""
"Robot HATには、2.54mm間隔で配置された4セットの3ピンPWMピンがあり、電源は5Vです。PWMの使用方法は、 "
":ref:`on_board_mcu` で詳しく説明されています。"

#: ../hardware_introduction.rst:248
msgid "PWM13 & 14 channels are used for motor drive."
msgstr "PWM13および14チャンネルはモータードライブ用に使用されます。"

#: ../hardware_introduction.rst:253
msgid "I2C"
msgstr "I2C"

#: ../hardware_introduction.rst:257
msgid ""
"The Robot HAT has two I2C interfaces. One is the P2.54 4-pin interface, "
"and the other is the SH1.0 4-pin interface, which is compatible with "
"QWIIC and STEMMA QT. These I2C interfaces are connected to the Raspberry "
"Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL). The board also "
"features an :ref:`on_board_mcu`, and the two signal lines have 10K pull-"
"up resistors."
msgstr ""
"Robot HATには2つのI2Cインターフェイスがあります。一つはP2.54 4ピンインターフェイス、もう一つはQWIICおよびSTEMMA "
"QTと互換性のあるSH1.0 4ピンインターフェイスです。これらのI2CインターフェイスはGPIO2 (SDA)およびGPIO3 "
"(SCL)を介してRaspberry PiのI2Cインターフェイスに接続されています。ボードには :ref:`on_board_mcu` "
"も搭載されており、2つの信号線には10Kのプルアップ抵抗があります。"

#: ../hardware_introduction.rst:264 ../hardware_introduction.rst:272
msgid "SPI"
msgstr "SPI"

#: ../hardware_introduction.rst:268
msgid ""
"The SPI interface of the Robot HAT is a 7-pin P2.54 interface. It "
"connects to the SPI interface of the Raspberry Pi and includes an "
"additional I/O pin that can be used for purposes such as interrupts or "
"resets."
msgstr ""
"Robot HATのSPIインターフェイスは7ピンのP2.54インターフェイスです。これはRaspberry "
"PiのSPIインターフェイスに接続され、割り込みやリセットなどの目的に使用できる追加のI/Oピンを含んでいます。"

#: ../hardware_introduction.rst:278
msgid "BSY"
msgstr "BSY"

#: ../hardware_introduction.rst:280
msgid "CS"
msgstr "CS"

#: ../hardware_introduction.rst:281
msgid "CE0(GPIO8)"
msgstr "CE0(GPIO8)"

#: ../hardware_introduction.rst:282
msgid "SCK"
msgstr "SCK"

#: ../hardware_introduction.rst:283
msgid "SCLK(GPIO11)"
msgstr "SCLK(GPIO11)"

#: ../hardware_introduction.rst:284
msgid "MI"
msgstr "MI"

#: ../hardware_introduction.rst:285
msgid "MISO(GPIO9)"
msgstr "MISO(GPIO9)"

#: ../hardware_introduction.rst:286
msgid "MO"
msgstr "MO"

#: ../hardware_introduction.rst:287
msgid "MOSI(GPIO10)"
msgstr "MOSI(GPIO10)"

#: ../hardware_introduction.rst:289
msgid "3.3V Power"
msgstr "3.3V 電源"

#: ../hardware_introduction.rst:291
msgid "Ground"
msgstr "グラウンド"

#: ../hardware_introduction.rst:296
msgid "UART"
msgstr "UART"

#: ../hardware_introduction.rst:300
msgid ""
"The UART interface of the Robot HAT is a 4-pin P2.54 interface. It "
"connects to the Raspberry Pi's GPIO14 (TXD) and GPIO15 (RXD) pins."
msgstr ""
"Robot HATのUARTインターフェイスは4ピンのP2.54インターフェイスです。これはRaspberry PiのGPIO14 "
"(TXD)とGPIO15 (RXD)ピンに接続されます。"

#: ../hardware_introduction.rst:305
msgid "Buttons"
msgstr "ボタン"

#: ../hardware_introduction.rst:307
msgid ""
"The Robot HAT comes with 1 LED and 2 buttons, all directly connected to "
"the Raspberry Pi's GPIO pins. The RST button, when using Ezblock, serves "
"as a button to restart the Ezblock program. If not using Ezblock, the RST"
" button does not have a predefined function and can be fully customized "
"according to your needs."
msgstr ""
"Robot HATには1つのLEDと2つのボタンがあり、すべてRaspberry "
"PiのGPIOピンに直接接続されています。Ezblockを使用している場合、RSTボタンはEzblockプログラムを再起動するためのボタンとして機能します。Ezblockを使用していない場合、RSTボタンには事前に定義された機能はなく、必要に応じて完全にカスタマイズすることができます。"

#: ../hardware_introduction.rst:311
msgid "LED & Button"
msgstr "LED＆ボタン"

#: ../hardware_introduction.rst:317
msgid "LED"
msgstr "LED"

#: ../hardware_introduction.rst:319
msgid "USR"
msgstr "USR"

#: ../hardware_introduction.rst:321
msgid "RST"
msgstr "RST"

#: ../hardware_introduction.rst:327
msgid "Speaker and Speaker Port"
msgstr "スピーカーとスピーカーポート"

#: ../hardware_introduction.rst:329
msgid ""
"The Robot HAT is equipped with onboard I2S audio output, along with a "
"2030 audio chamber speaker, providing a mono sound output."
msgstr ""
"Robot "
"HATにはオンボードのI2Sオーディオ出力が搭載されており、2030オーディオチャンバースピーカーと共にモノラルサウンド出力を提供します。"

#: ../hardware_introduction.rst:332 ../hardware_introduction.rst:336
msgid "I2S"
msgstr "I2S"

#: ../hardware_introduction.rst:338
msgid "LRCLK"
msgstr "LRCLK"

#: ../hardware_introduction.rst:340
msgid "BCLK"
msgstr "BCLK"

#: ../hardware_introduction.rst:342
msgid "SDATA"
msgstr "SDATA"

#: ../hardware_introduction.rst:348
msgid "Motor Port"
msgstr "モーターポート"

#: ../hardware_introduction.rst:350
msgid ""
"The motor driver of the Robot HAT supports 2 channels and can be "
"controlled using 2 digital signals for direction and 2 PWM signals for "
"speed control."
msgstr ""
"Robot "
"HATのモータードライバーは2チャンネルをサポートしており、2つのデジタル信号を使用して方向を制御し、2つのPWM信号を使用して速度を制御することができます。"

#: ../hardware_introduction.rst:353
msgid "Motor Driver"
msgstr "モータードライバー"

#: ../hardware_introduction.rst:357
msgid "Motor"
msgstr "モーター"

#: ../hardware_introduction.rst:358
msgid "IO"
msgstr "IO"

#: ../hardware_introduction.rst:359
msgid "Motor1 Dir"
msgstr "モーター1方向"

#: ../hardware_introduction.rst:361
msgid "Motor1 Power"
msgstr "モーター1電源"

#: ../hardware_introduction.rst:362
msgid "PWM13"
msgstr "PWM13"

#: ../hardware_introduction.rst:363
msgid "Motor2 Dir"
msgstr "モーター2方向"

#: ../hardware_introduction.rst:365
msgid "Motor2 Power"
msgstr "モーター2電源"

#: ../hardware_introduction.rst:366
msgid "PWM12"
msgstr "PWM12"

#: ../hardware_introduction.rst:371
msgid "Battery Level Indicator"
msgstr "バッテリーレベルインジケーター"

#: ../hardware_introduction.rst:373
msgid ""
"The battery level indicator on the Robot HAT monitors the battery voltage"
" using a voltage divider method and serves as a reference for estimating "
"the battery level. The relationship between the LED and voltage is as "
"follows:"
msgstr ""
"Robot "
"HATのバッテリーレベルインジケーターは、電圧分割器法を使用してバッテリー電圧を監視し、バッテリーレベルの推定のための参考として機能します。LEDと電圧の関係は以下の通りです："

#: ../hardware_introduction.rst:376
msgid "Battery Level"
msgstr "バッテリーレベル"

#: ../hardware_introduction.rst:380
msgid "LED Battery"
msgstr "LEDバッテリー"

#: ../hardware_introduction.rst:381
msgid "Total Voltage"
msgstr "合計電圧"

#: ../hardware_introduction.rst:382
msgid "2 LEDs on"
msgstr "2つのLED点灯"

#: ../hardware_introduction.rst:383
msgid "Greater than 7.6V"
msgstr "7.6V以上"

#: ../hardware_introduction.rst:384
msgid "1 LED on"
msgstr "1つのLED点灯"

#: ../hardware_introduction.rst:385
msgid "Greater than 7.15V"
msgstr "7.15V以上"

#: ../hardware_introduction.rst:386
msgid "Both LEDs off"
msgstr "両方のLED消灯"

#: ../hardware_introduction.rst:387
msgid "Less than 7.15V"
msgstr "7.15V未満"

#: ../hardware_introduction.rst:389
msgid ""
"When any one of the batteries reaches or exceeds 4.1V while the others "
"are below that threshold, the charging current of that specific battery "
"will be reduced."
msgstr "バッテリーのうちの1つが4.1Vに達するかそれを超えると、他のバッテリーがその閾値以下の場合、その特定のバッテリーの充電電流が減少します。"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/community_tutorials.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../community_tutorials.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../community_tutorials.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../community_tutorials.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../community_tutorials.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../community_tutorials.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../community_tutorials.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../community_tutorials.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../community_tutorials.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../community_tutorials.rst:16
msgid "Community Tutorials"
msgstr "コミュニティチュートリアル"

#: ../community_tutorials.rst:18
msgid "|link_peppe8o|"
msgstr "|link_peppe8o|"

#: ../community_tutorials.rst:20
msgid ""
"This document summarizes the SunFounder Raspberry Pi Robot HAT, covering "
"its purpose, compatibility, specifications, and testing:"
msgstr ""
"この文書は、SunFounder Raspberry Pi Robot "
"HATに関する概要を説明し、その目的、互換性、仕様、テストについて述べています:"

#: ../community_tutorials.rst:22
msgid ""
"**Introduction**: Explains the Robot HAT's role in simplifying control "
"for Raspberry Pi-based DIY robot projects."
msgstr "**はじめに**: Raspberry PiベースのDIYロボットプロジェクトの制御を簡素化するRobot HATの役割について説明します。"

#: ../community_tutorials.rst:23
msgid ""
"**Specifications**: Details the technical specs, including power input, "
"battery details, ports, and motor driver features."
msgstr "**仕様**: 電源入力、バッテリーの詳細、ポート、モータードライバーの機能など、技術的な仕様について詳述します。"

#: ../community_tutorials.rst:24
msgid ""
"**Ports Overview**: Describes various ports like Power, Digital, Analog, "
"PWM, I2C, SPI, UART, and Motor Ports."
msgstr "**ポートの概要**: 電源、デジタル、アナログ、PWM、I2C、SPI、UART、モーターポートなど、各種ポートについて説明します。"

#: ../community_tutorials.rst:25
msgid ""
"**Additional Components**: Highlights extra components like buttons, LED,"
" and speaker, with Raspberry Pi PIN mappings."
msgstr "**追加コンポーネント**: ボタン、LED、スピーカーなどの追加コンポーネントと、Raspberry PiのPIN配置を強調します。"

#: ../community_tutorials.rst:26
msgid ""
"**Setup and Testing**: Guides on mounting the Robot HAT, necessary "
"components, and testing procedures for features like LED and servo "
"motors."
msgstr "**セットアップとテスト**: Robot HATの取り付け、必要なコンポーネント、LEDやサーボモーターなどの機能のテスト手順について案内します。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_robot.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_robot.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_robot.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_robot.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_robot.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_robot.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_robot.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_robot.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_robot.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_robot.rst:18
msgid "class ``Robot``"
msgstr "クラス ``Robot``"

#: ../api_robot.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_robot.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.robot.Robot:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.robot.Robot:1
msgid "Robot class"
msgstr "ロボットクラス"

#: of robot_hat.robot.Robot:3
msgid "This class is for makeing a servo robot with Robot HAT"
msgstr "このクラスはRobot HATを使ってサーボロボットを作るためのものです"

#: of robot_hat.robot.Robot:5
msgid ""
"There are servo initialization, all servo move in specific speed. servo "
"offset and stuff. make it easy to make a robot. All Pi-series robot from "
"SunFounder use this class. Check them out for more details."
msgstr "サーボの初期化、全サーボが特定の速度で動くこと、サーボのオフセットなどがあり、ロボットを作りやすくなっています。SunFounderのPiシリーズロボットはすべてこのクラスを使用しています。詳細はそれらをチェックしてください。"

#: of robot_hat.robot.Robot:8
msgid "PiSloth: https://github.com/sunfounder/pisloth"
msgstr "PiSloth: https://github.com/sunfounder/pisloth"

#: of robot_hat.robot.Robot:10
msgid "PiArm: https://github.com/sunfounder/piarm"
msgstr "PiArm: https://github.com/sunfounder/piarm"

#: of robot_hat.robot.Robot:12
msgid "PiCrawler: https://github.com/sunfounder/picrawler"
msgstr "PiCrawler: https://github.com/sunfounder/picrawler"

#: ../docstring of robot_hat.Robot.move_list:1
msgid "Preset actions"
msgstr "プリセットアクション"

#: ../docstring of robot_hat.Robot.max_dps:1
msgid "Servo max Degree Per Second"
msgstr "サーボの最大度/秒"

#: of robot_hat.robot.Robot.__init__:1
msgid "Initialize the robot class"
msgstr "ロボットクラスを初期化する"

#: of robot_hat.robot.Robot.__init__ robot_hat.robot.Robot.do_action
#: robot_hat.robot.Robot.new_list robot_hat.robot.Robot.servo_move
#: robot_hat.robot.Robot.servo_write_all robot_hat.robot.Robot.servo_write_raw
#: robot_hat.robot.Robot.set_offset
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.robot.Robot.__init__:3
msgid "list of pin number[0-11]"
msgstr "ピン番号のリスト[0-11]"

#: of robot_hat.robot.Robot.__init__:5
msgid "config file path"
msgstr "設定ファイルのパス"

#: of robot_hat.robot.Robot.__init__:7
msgid "robot name"
msgstr "ロボットの名前"

#: of robot_hat.robot.Robot.__init__:9
msgid "list of initial angles"
msgstr "初期角度のリスト"

#: of robot_hat.robot.Robot.__init__:11
msgid ""
"list of initialization order(Servos will init one by one in case of "
"sudden huge current, pulling down the power supply voltage. default order"
" is the pin list. in some cases, you need different order, use this "
"parameter to set it.)"
msgstr "初期化の順序のリスト（突然の大電流の場合、サーボは1つずつ初期化され、電源電圧が下がることがあります。デフォルトの順序はピンリストです。場合によっては異なる順序が必要です。このパラメータを使用して設定してください。）"

#: of robot_hat.robot.Robot.new_list:1
msgid "Create a list of servo angles with default value"
msgstr "デフォルト値でサーボ角度のリストを作成する"

#: of robot_hat.robot.Robot.new_list:3
msgid "default value of servo angles"
msgstr "サーボ角度のデフォルト値"

#: of robot_hat.robot.Robot.new_list
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.robot.Robot.new_list:5 robot_hat.robot.Robot.servo_move:3
#: robot_hat.robot.Robot.servo_write_all:3
#: robot_hat.robot.Robot.servo_write_raw:3 robot_hat.robot.Robot.set_offset:3
msgid "list of servo angles"
msgstr "サーボ角度のリスト"

#: of robot_hat.robot.Robot.new_list
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.robot.Robot.servo_write_raw:1
msgid "Set servo angles to specific raw angles"
msgstr "サーボ角度を特定の生の角度に設定する"

#: of robot_hat.robot.Robot.servo_write_all:1
msgid "Set servo angles to specific angles with original angle and offset"
msgstr "元の角度とオフセットを使ってサーボ角度を特定の角度に設定する"

#: of robot_hat.robot.Robot.servo_move:1
msgid "Move servo to specific angles with speed or bpm"
msgstr "速度またはBPMでサーボを特定の角度に動かす"

#: of robot_hat.robot.Robot.servo_move:5
msgid "speed of servo move"
msgstr "サーボ移動の速度"

#: of robot_hat.robot.Robot.servo_move:7
msgid "beats per minute"
msgstr "分あたりの拍数"

#: of robot_hat.robot.Robot.do_action:1
msgid "Do prefix action with motion_name and step and speed"
msgstr "動作名とステップと速度を使ってプレフィックスアクションを実行する"

#: of robot_hat.robot.Robot.do_action:3
msgid "motion"
msgstr "動作"

#: of robot_hat.robot.Robot.do_action:5
msgid "step of motion"
msgstr "動作のステップ"

#: of robot_hat.robot.Robot.do_action:7
msgid "speed of motion"
msgstr "動作の速度"

#: of robot_hat.robot.Robot.set_offset:1
msgid "Set offset of servo angles"
msgstr "サーボ角度のオフセットを設定する"

#: of robot_hat.robot.Robot.calibration:1
msgid "Move all servos to home position"
msgstr "全てのサーボをホームポジションに動かす"

#: of robot_hat.robot.Robot.reset:1
msgid "Reset servo to original position"
msgstr "サーボを元の位置にリセットする"





##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_control_motor_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_control_motor_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_control_motor_servo.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_control_motor_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_control_motor_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_control_motor_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_control_motor_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_control_motor_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_control_motor_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_control_motor_servo.rst:16
msgid "Control Servos and Motors"
msgstr "サーボとモーターの制御"

#: ../project_control_motor_servo.rst:18
msgid "In this project, we have 12 servos and two motors working simultaneously."
msgstr "このプロジェクトでは、12個のサーボと2つのモーターが同時に動作します。"

#: ../project_control_motor_servo.rst:24
msgid ""
"However, it's important to note that if your servos and motors have a "
"high starting current, it's recommended to start them separately to avoid"
" insufficient power supply current, which could lead to the Raspberry Pi "
"restarting."
msgstr ""
"ただし、サーボやモーターの始動電流が高い場合は、それらを個別に起動して、電源電流不足を避けることをお勧めします。電流不足はRaspberry "
"Piの再起動につながる可能性があります。"

#: ../project_control_motor_servo.rst:26
msgid "**Code**"
msgstr "**コード**"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_say_something.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_say_something.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_say_something.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_say_something.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_say_something.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_say_something.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_say_something.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_say_something.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_say_something.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_say_something.rst:16
msgid "Say Something"
msgstr "何かを話す"

#: ../project_say_something.rst:19
msgid ""
"In this section, you'll learn how to convert text into speech and have "
"Robot HAT speak it aloud."
msgstr "このセクションでは、テキストを音声に変換して、Robot HATに大声で話させる方法を学びます。"

#: ../project_say_something.rst:21
msgid "**Steps**"
msgstr "**手順**"

#: ../project_say_something.rst:23
msgid ""
"We retrieve text from the command line to enable Robot HAT to articulate "
"it. To achieve this, save the following code as a ``.py`` file, such as "
"``tts.py``."
msgstr ""
"コマンドラインからテキストを取得してRobot HATがそれを話すようにします。これを実現するために、以下のコードを ``.py`` "
"ファイルとして保存します。例えば ``tts.py`` などです。"

#: ../project_say_something.rst:46
msgid ""
"To make Robot HAT vocalize a specific sentence, you can use the following"
" command: ``sudo python3 tts.py \"any text\"`` - simply replace ``\"any "
"text\"`` with the desired phrase."
msgstr ""
"Robot HATに特定の文章を発声させるには、次のコマンドを使用します： ``sudo python3 tts.py \"任意のテキスト\"``"
" - 単に ``\"任意のテキスト\"`` を希望のフレーズに置き換えてください。"

#: ../project_say_something.rst:50
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/install_i2s_for_speaker.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../install_i2s_for_speaker.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../install_i2s_for_speaker.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../install_i2s_for_speaker.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../install_i2s_for_speaker.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../install_i2s_for_speaker.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../install_i2s_for_speaker.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../install_i2s_for_speaker.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../install_i2s_for_speaker.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../install_i2s_for_speaker.rst:18
msgid "Install ``i2samp.sh`` for the Speaker"
msgstr "スピーカー用の ``i2samp.sh`` をインストールする"

#: ../install_i2s_for_speaker.rst:20
msgid ""
"The ``i2samp.sh`` is a sophisticated Bash script specifically designed "
"for setting up and configuring an I2S (Inter-IC Sound) amplifier on "
"Raspberry Pi and similar devices. Licensed under the MIT license, it "
"ensures compatibility with a range of hardware and operating systems, "
"conducting thorough checks before proceeding with any installation or "
"configuration."
msgstr ""
"``i2samp.sh`` は、Raspberry Piや類似のデバイスでI2S（Inter-IC "
"Sound）アンプを設定し、構成するために特別に設計された高度なBashスクリプトです。MITライセンスのもとで、さまざまなハードウェアとオペレーティングシステムとの互換性を保証し、インストールや構成を進める前に徹底的なチェックを行います。"

#: ../install_i2s_for_speaker.rst:22
msgid ""
"If you want your speaker to work properly, you definitely need to install"
" this script."
msgstr "スピーカーを適切に動作させたい場合は、このスクリプトのインストールが絶対に必要です。"

#: ../install_i2s_for_speaker.rst:24
msgid "The steps are as follows:"
msgstr "手順は以下の通りです："

#: ../install_i2s_for_speaker.rst:31
msgid "Type ``y`` and press ``enter`` to continue running the script."
msgstr "``y`` と入力し ``enter`` を押して、スクリプトの実行を続けます。"

#: ../install_i2s_for_speaker.rst:35
msgid "Type ``y`` and press ``enter`` to run ``/dev/zero`` in the background."
msgstr "``y`` と入力し ``enter`` を押して、バックグラウンドで ``/dev/zero`` を実行します。"

#: ../install_i2s_for_speaker.rst:39
msgid "Type ``y`` and press ``enter`` to restart the Raspberry pi."
msgstr "``y`` と入力し ``enter`` を押して、Raspberry Piを再起動します。"

#: ../install_i2s_for_speaker.rst:45
msgid ""
"If there is no sound after restarting, you may need to run the "
"``i2samp.sh`` script several times."
msgstr "再起動後に音が出ない場合は、 ``i2samp.sh`` スクリプトを数回実行する必要があるかもしれません。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_plant_monitor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_plant_monitor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_plant_monitor.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_plant_monitor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_plant_monitor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_plant_monitor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_plant_monitor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_plant_monitor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_plant_monitor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_plant_monitor.rst:16
msgid "Plant Monitor"
msgstr "プラントモニター"

#: ../project_plant_monitor.rst:18
msgid ""
"In this project, we detect both light intensity and soil moisture levels,"
" and display them on the I2C LCD1602 . When you feel that the soil "
"moisture is insufficient, you can press the button module to water the "
"potted plant."
msgstr ""
"このプロジェクトでは、光の強度と土壌の水分レベルの両方を検出し、I2C "
"LCD1602に表示します。土壌の水分が不足していると感じたら、ボタンモジュールを押して鉢植えに水をやることができます。"

#: ../project_plant_monitor.rst:22
msgid "**Steps**"
msgstr "**手順**"

#: ../project_plant_monitor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr "このプロジェクトではI2C LCD1602を使用しているため、関連するライブラリをダウンロードして機能させる必要があります。"

#: ../project_plant_monitor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "I2C用に ``smbus2`` をインストールします。"

#: ../project_plant_monitor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``plant_monitor.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``plant_monitor.ty`` という名前を付けます。"

#: ../project_plant_monitor.rst:120
msgid "Use the command ``sudo python3 plant_monitor.ty`` to run this code."
msgstr "このコードを実行するには、 ``sudo python3 plant_monitor.ty`` コマンドを使用します。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_modules.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_modules.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_modules.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_modules.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_modules.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_modules.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_modules.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_modules.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_modules.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_modules.rst:16
msgid "module ``modules``"
msgstr "モジュール ``modules``"

#: ../api_modules.rst:21
msgid "class ``Ultrasonic``"
msgstr "クラス ``Ultrasonic``"

#: ../api_modules.rst:23 ../api_modules.rst:46 ../api_modules.rst:80
#: ../api_modules.rst:110 ../api_modules.rst:220
msgid "**Example**"
msgstr "**例**"

#: ../api_modules.rst:37 ../api_modules.rst:70 ../api_modules.rst:101
#: ../api_modules.rst:210 ../api_modules.rst:246
msgid "**API**"
msgstr "**API**"

#: ../api_modules.rst:44
msgid "class ``ADXL345``"
msgstr "クラス ``ADXL345``"

#: of robot_hat.modules.ADXL345:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "基底: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.modules.ADXL345:1
msgid "ADXL345 modules"
msgstr "ADXL345モジュール"

#: ../docstring of robot_hat.ADXL345.X:1
msgid "X"
msgstr "X"

#: ../docstring of robot_hat.ADXL345.Y:1
msgid "Y"
msgstr "Y"

#: ../docstring of robot_hat.ADXL345.Z:1
msgid "Z"
msgstr "Z"

#: of robot_hat.modules.ADXL345.__init__:1
msgid "Initialize ADXL345"
msgstr "ADXL345を初期化する"

#: of robot_hat.modules.ADXL345.__init__ robot_hat.modules.ADXL345.read
#: robot_hat.modules.Buzzer.__init__ robot_hat.modules.Buzzer.freq
#: robot_hat.modules.Buzzer.play robot_hat.modules.Grayscale_Module.__init__
#: robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
#: robot_hat.modules.RGB_LED.__init__ robot_hat.modules.RGB_LED.color
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.modules.ADXL345.__init__:3
msgid "address of the ADXL345"
msgstr "ADXL345のアドレス"

#: of robot_hat.modules.ADXL345.read:1
msgid "Read an axis from ADXL345"
msgstr "ADXL345から軸を読み取る"

#: of robot_hat.modules.ADXL345.read:3
msgid ""
"read value(g) of an axis, ADXL345.X, ADXL345.Y or ADXL345.Z, None for all"
" axis"
msgstr "軸の値(g)を読み取る、ADXL345.X、ADXL345.YまたはADXL345.Z、すべての軸の場合はNone"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.modules.ADXL345.read:5
msgid "value of the axis, or list of all axis"
msgstr "軸の値、またはすべての軸のリスト"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Return type"
msgstr "戻り値の型"

#: ../api_modules.rst:78
msgid "class ``RGB_LED``"
msgstr "クラス ``RGB_LED``"

#: of robot_hat.modules.RGB_LED:1
msgid "Simple 3 pin RGB LED"
msgstr "シンプルな3ピンRGB LED"

#: ../docstring of robot_hat.RGB_LED.ANODE:1
msgid "Common anode"
msgstr "共通アノード"

#: ../docstring of robot_hat.RGB_LED.CATHODE:1
msgid "Common cathode"
msgstr "共通カソード"

#: of robot_hat.modules.RGB_LED.__init__:1
msgid "Initialize RGB LED"
msgstr "RGB LEDを初期化する"

#: of robot_hat.modules.RGB_LED.__init__:3
msgid "PWM object for red"
msgstr "赤用のPWMオブジェクト"

#: of robot_hat.modules.RGB_LED.__init__:5
msgid "PWM object for green"
msgstr "緑用のPWMオブジェクト"

#: of robot_hat.modules.RGB_LED.__init__:7
msgid "PWM object for blue"
msgstr "青用のPWMオブジェクト"

#: of robot_hat.modules.RGB_LED.__init__:9
msgid "RGB_LED.ANODE or RGB_LED.CATHODE, default is ANODE"
msgstr "RGB_LED.ANODEまたはRGB_LED.CATHODE、デフォルトはANODE"

#: of robot_hat.modules.Buzzer.freq robot_hat.modules.Buzzer.play
#: robot_hat.modules.RGB_LED.__init__
msgid "Raises"
msgstr ""

#: of robot_hat.modules.RGB_LED.__init__:11
msgid "if common is not ANODE or CATHODE"
msgstr "共通がANODEまたはCATHODEでない場合"

#: of robot_hat.modules.RGB_LED.__init__:12
msgid "if r_pin, g_pin or b_pin is not PWM object"
msgstr "r_pin、g_pin、またはb_pinがPWMオブジェクトでない場合"

#: of robot_hat.modules.RGB_LED.color:1
msgid "Write color to RGB LED"
msgstr "RGB LEDに色を書き込む"

#: of robot_hat.modules.RGB_LED.color:3
msgid ""
"color to write, hex string starts with \"#\", 24-bit int or tuple of "
"(red, green, blue)"
msgstr "書き込む色、\"#\"で始まる16進数文字列、24ビット整数、または(red, green, blue)のタプル"

#: ../api_modules.rst:108
msgid "class ``Buzzer``"
msgstr "クラス ``Buzzer``"

#: ../api_modules.rst:112
msgid "Imports and initialize"
msgstr "インポートと初期化"

#: ../api_modules.rst:133
msgid "Active buzzer beeping"
msgstr "アクティブブザーのビープ音"

#: ../api_modules.rst:143
msgid "Passive buzzer Simple usage"
msgstr "パッシブブザーの簡単な使用方法"

#: ../api_modules.rst:155
msgid "Passive buzzer Manual control"
msgstr "パッシブブザーの手動制御"

#: ../api_modules.rst:171
msgid "Play a song! Baby shark!"
msgstr "曲を演奏する！ベイビーシャーク！"

#: of robot_hat.modules.Buzzer.__init__:1
msgid "Initialize buzzer"
msgstr "ブザーを初期化する"

#: of robot_hat.modules.Buzzer.__init__:3
msgid "PWM object for passive buzzer or Pin object for active buzzer"
msgstr "パッシブブザー用のPWMオブジェクトまたはアクティブブザー用のピンオブジェクト"

#: of robot_hat.modules.Buzzer.on:1
msgid "Turn on buzzer"
msgstr "ブザーをオンにする"

#: of robot_hat.modules.Buzzer.off:1
msgid "Turn off buzzer"
msgstr "ブザーをオフにする"

#: of robot_hat.modules.Buzzer.freq:1
msgid "Set frequency of passive buzzer"
msgstr "パッシブブザーの周波数を設定する"

#: of robot_hat.modules.Buzzer.freq:3
msgid "frequency of buzzer, use Music.NOTES to get frequency of note"
msgstr "ブザーの周波数、Music.NOTESを使用して音符の周波数を取得する"

#: of robot_hat.modules.Buzzer.freq:5 robot_hat.modules.Buzzer.play:7
msgid "if set to active buzzer"
msgstr "アクティブブザーに設定した場合"

#: of robot_hat.modules.Buzzer.play:1
msgid "Play freq"
msgstr "周波数を演奏する"

#: of robot_hat.modules.Buzzer.play:3
msgid "freq to play, you can use Music.note() to get frequency of note"
msgstr "演奏する周波数、Music.note()を使用して音符の周波数を取得できる"

#: of robot_hat.modules.Buzzer.play:5
msgid "duration of each note, in seconds, None means play continuously"
msgstr "各音符の持続時間（秒）、Noneは連続して演奏することを意味する"

#: ../api_modules.rst:218
msgid "class ``Grayscale_Module``"
msgstr "クラス ``Grayscale_Module``"

#: of robot_hat.modules.Grayscale_Module:1
msgid "3 channel Grayscale Module"
msgstr "3チャンネルグレースケールモジュール"

#: ../docstring of robot_hat.Grayscale_Module.LEFT:1
msgid "Left Channel"
msgstr "左チャンネル"

#: ../docstring of robot_hat.Grayscale_Module.MIDDLE:1
msgid "Middle Channel"
msgstr "中央チャンネル"

#: ../docstring of robot_hat.Grayscale_Module.RIGHT:1
msgid "Right Channel"
msgstr "右チャンネル"

#: of robot_hat.modules.Grayscale_Module.__init__:1
msgid "Initialize Grayscale Module"
msgstr "グレースケールモジュールを初期化する"

#: of robot_hat.modules.Grayscale_Module.__init__:3
msgid "ADC object or int for channel 0"
msgstr "チャンネル0用のADCオブジェクトまたは整数"

#: of robot_hat.modules.Grayscale_Module.__init__:5
msgid "ADC object or int for channel 1"
msgstr "チャンネル1用のADCオブジェクトまたは整数"

#: of robot_hat.modules.Grayscale_Module.__init__:7
msgid "ADC object or int for channel 2"
msgstr "チャンネル2用のADCオブジェクトまたは整数"

#: of robot_hat.modules.Grayscale_Module.__init__:9
msgid "reference voltage"
msgstr "基準電圧"

#: of robot_hat.modules.Grayscale_Module.reference:1
msgid "Get Set reference value"
msgstr "基準値の取得と設定"

#: of robot_hat.modules.Grayscale_Module.reference:3
msgid "reference value, None to get reference value"
msgstr "基準値、基準値を取得する場合はNone"

#: of robot_hat.modules.Grayscale_Module.reference:5
msgid "reference value"
msgstr "基準値"

#: of robot_hat.modules.Grayscale_Module.read_status:1
msgid "Read line status"
msgstr "ライン状態の読み取り"

#: of robot_hat.modules.Grayscale_Module.read_status:3
msgid "list of grayscale datas, if None, read from sensor"
msgstr "グレースケールデータのリスト、Noneの場合はセンサーから読み取り"

#: of robot_hat.modules.Grayscale_Module.read_status:5
msgid "list of line status, 0 for white, 1 for black"
msgstr "ライン状態のリスト、0は白、1は黒"

#: of robot_hat.modules.Grayscale_Module.read:1
msgid "read a channel or all datas"
msgstr "チャンネルまたはすべてのデータを読み取る"

#: of robot_hat.modules.Grayscale_Module.read:3
msgid ""
"channel to read, leave empty to read all. 0, 1, 2 or "
"Grayscale_Module.LEFT, Grayscale_Module.CENTER, Grayscale_Module.RIGHT"
msgstr "読み取るチャンネル、すべてを読み取るには空のままにする。0、1、2またはGrayscale_Module.LEFT、Grayscale_Module.CENTER、Grayscale_Module.RIGHT"

#: of robot_hat.modules.Grayscale_Module.read:5
msgid "list of grayscale data"
msgstr "グレースケールデータのリスト"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_pin.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pin.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_pin.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_pin.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_pin.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_pin.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_pin.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_pin.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_pin.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_pin.rst:18
msgid "class ``Pin``"
msgstr "クラス ``Pin``"

#: ../api_pin.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_pin.rst:52
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pin.Pin:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.pin.Pin:1
msgid "Pin manipulation class"
msgstr "ピン操作クラス"

#: ../docstring of robot_hat.Pin.OUT:1
msgid "Pin mode output"
msgstr "ピンモード出力"

#: ../docstring of robot_hat.Pin.IN:1
msgid "Pin mode input"
msgstr "ピンモード入力"

#: ../docstring of robot_hat.Pin.PULL_UP:1
msgid "Pin internal pull up"
msgstr "ピン内部プルアップ"

#: ../docstring of robot_hat.Pin.PULL_DOWN:1
msgid "Pin internal pull down"
msgstr "ピン内部プルダウン"

#: ../docstring of robot_hat.Pin.PULL_NONE:1
msgid "Pin internal pull none"
msgstr "ピン内部プルなし"

#: ../docstring of robot_hat.Pin.IRQ_FALLING:1 robot_hat.Pin.IRQ_RISING:1
msgid "Pin interrupt falling"
msgstr "ピン割り込みフォーリング"

#: ../docstring of robot_hat.Pin.IRQ_RISING_FALLING:1
msgid "Pin interrupt both rising and falling"
msgstr "ピン割り込みライジングとフォーリングの両方"

#: of robot_hat.pin.Pin.__init__:1
msgid "Initialize a pin"
msgstr "ピンの初期化"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.__init__
#: robot_hat.pin.Pin.dict robot_hat.pin.Pin.irq robot_hat.pin.Pin.setup
#: robot_hat.pin.Pin.value
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.pin.Pin.__init__:3
msgid "pin number of Raspberry Pi"
msgstr "Raspberry Piのピン番号"

#: of robot_hat.pin.Pin.__init__:5 robot_hat.pin.Pin.setup:3
msgid "pin mode(IN/OUT)"
msgstr "ピンモード(IN/OUT)"

#: of robot_hat.pin.Pin.__init__:7 robot_hat.pin.Pin.setup:5
msgid "pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)"
msgstr "ピンプルアップ/ダウン(PUD_UP/PUD_DOWN/PUD_NONE)"

#: of robot_hat.pin.Pin.setup:1
msgid "Setup the pin"
msgstr "ピンのセットアップ"

#: of robot_hat.pin.Pin.dict:1
msgid "Set/get the pin dictionary"
msgstr "ピン辞書の設定/取得"

#: of robot_hat.pin.Pin.dict:3
msgid "pin dictionary, leave it empty to get the dictionary"
msgstr "ピン辞書、辞書を取得するには空のままにしてください"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.pin.Pin.dict:5
msgid "pin dictionary"
msgstr "ピン辞書"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.pin.Pin.__call__:1 robot_hat.pin.Pin.value:1
msgid "Set/get the pin value"
msgstr "ピン値の設定/取得"

#: of robot_hat.pin.Pin.__call__:3 robot_hat.pin.Pin.value:3
msgid "pin value, leave it empty to get the value(0/1)"
msgstr "ピン値、値を取得する場合は空にしておく(0/1)"

#: of robot_hat.pin.Pin.__call__:5 robot_hat.pin.Pin.value:5
msgid "pin value(0/1)"
msgstr "ピン値(0/1)"

#: of robot_hat.pin.Pin.on:1
msgid "Set pin on(high)"
msgstr "ピンをオン(ハイ)に設定"

#: of robot_hat.pin.Pin.high:3 robot_hat.pin.Pin.on:3
msgid "pin value(1)"
msgstr "ピン値(1)"

#: of robot_hat.pin.Pin.off:1
msgid "Set pin off(low)"
msgstr "ピンをオフ(ロー)に設定"

#: of robot_hat.pin.Pin.low:3 robot_hat.pin.Pin.off:3
msgid "pin value(0)"
msgstr "ピン値(0)"

#: of robot_hat.pin.Pin.high:1
msgid "Set pin high(1)"
msgstr "ピンをハイ(1)に設定"

#: of robot_hat.pin.Pin.low:1
msgid "Set pin low(0)"
msgstr "ピンをロー(0)に設定"

#: of robot_hat.pin.Pin.irq:1
msgid "Set the pin interrupt"
msgstr "ピン割り込みを設定"

#: of robot_hat.pin.Pin.irq:3
msgid "interrupt handler callback function"
msgstr "割り込みハンドラコールバック関数"

#: of robot_hat.pin.Pin.irq:5
msgid "interrupt trigger(RISING, FALLING, RISING_FALLING)"
msgstr "割り込みトリガー(RISING, FALLING, RISING_FALLING)"

#: of robot_hat.pin.Pin.irq:7
msgid "interrupt bouncetime in miliseconds"
msgstr "割り込みバウンスタイム（ミリ秒）"

#: of robot_hat.pin.Pin.name:1
msgid "Get the pin name"
msgstr "ピン名を取得"

#: of robot_hat.pin.Pin.name:3
msgid "pin name"
msgstr "ピン名"





##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/faq.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../faq.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../faq.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../faq.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../faq.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../faq.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../faq.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../faq.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../faq.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../faq.rst:16
msgid "FAQ"
msgstr "よくある質問"

#: ../faq.rst:19
msgid ""
"Q1: Can the battery be connected while providing power to the Raspberry "
"Pi at the same time?"
msgstr "Q1: バッテリーを接続しながら、同時にRaspberry Piに電力を供給することは可能ですか？"

#: ../faq.rst:20
msgid ""
"A: Yes, the Robot HAT has a built-in anti-backflow diode that prevents "
"the Raspberry Pi's power from flowing back into the Robot HAT."
msgstr "A: はい、Robot HATには逆流防止ダイオードが内蔵されており、Raspberry Piの電力がRobot HATに逆流するのを防ぎます。"

#: ../faq.rst:23
msgid "Q2: Can the Robot HAT be used while charging?"
msgstr "Q2: 充電中にRobot HATを使用することは可能ですか？"

#: ../faq.rst:24
msgid ""
"A: Yes, the Robot HAT can be used while charging. When charging, the "
"input power is boosted by the charging chip to charge the batteries, "
"while also providing power to the DC-DC step-down for external use. The "
"charging power is approximately 10W. If the external power consumption is"
" too high for an extended period, the batteries may supplement the power,"
" similar to how a mobile phone charges while in use. However, it is "
"important to be mindful of the battery's capacity to avoid draining it "
"completely during simultaneous charging and usage."
msgstr ""
"A: はい、充電中でもRobot HATを使用できます。充電中、入力電力は充電チップによって増幅され"
"、バッテリーを充電しながら外部使用のためのDC-"
"DC降圧にも電力を供給します。充電電力は約10Wです。外部電力消費が長期間にわたって高すぎる場合、バッテリーが電力を補うことがあります。これは、使用中の携帯電話が充電されるのと同様です。ただし、同時に充電と使用を行う際には、バッテリーの容量に注意し、完全に消耗させないようにすることが重要です。"

#: ../faq.rst:29
msgid "Q3: Why is there no sound from the speaker?"
msgstr "Q3: スピーカーから音が出ないのはなぜですか？"

#: ../faq.rst:31
msgid ""
"When your script is running but the speaker is not producing sound, there"
" could be several reasons:"
msgstr "スクリプトが実行されているにもかかわらずスピーカーから音が出ない場合、いくつかの理由が考えられます："

#: ../faq.rst:33
msgid ""
"Check if the ``i2samp.sh`` script has been installed. For detailed "
"instructions, please refer to: :ref:`install_i2s`."
msgstr ""
"``i2samp.sh`` スクリプトがインストールされているか確認してください。詳細な指示については、 :ref:`install_i2s` "
"を参照してください。"

#: ../faq.rst:34
msgid ""
"When running scripts related to speakers, it's necessary to add ``sudo`` "
"to obtain administrative privileges. For example, ``sudo python3 "
"tts.py``."
msgstr ""
"スピーカー関連のスクリプトを実行する際には、管理者権限を得るために ``sudo`` を追加する必要があります。例えば、 ``sudo "
"python3 tts.py`` とします。"

#: ../faq.rst:35
msgid ""
"Don't using Raspberry Pi's built-in programming tools, like Geany to run "
"Speaker-related scripts. These tools run with standard user privileges, "
"while hardware control, such as managing speakers, often requires higher "
"permissions."
msgstr ""
"スピーカー関連のスクリプトを実行する際に、Raspberry "
"Piの組み込みプログラミングツール（例えばGeany）を使用しないでください。これらのツールは標準ユーザー権限で実行されますが、スピーカーの管理などのハードウェア制御にはより高い権限がしばしば必要です。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/projects.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../projects.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../projects.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../projects.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../projects.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../projects.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../projects.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../projects.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../projects.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../projects.rst:16
msgid "Some Projects"
msgstr "いくつかのプロジェクト"

#: ../projects.rst:18
msgid ""
"Here, you'll find a collection of fascinating projects, all implemented "
"using the Robot HAT. We provide you with detailed code, giving you the "
"opportunity to try these projects out for yourself."
msgstr ""
"ここでは、Robot "
"HATを使用して実装された魅力的なプロジェクトのコレクションを紹介します。詳細なコードを提供し、これらのプロジェクトを自分で試す機会を提供します。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_utils.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_utils.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_utils.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_utils.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_utils.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_utils.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_utils.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_utils.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_utils.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_utils.rst:16
msgid "module ``utils``"
msgstr "モジュール ``utils``"

#: of robot_hat.utils.set_volume:1
msgid "Set volume"
msgstr "音量を設定する"

#: of robot_hat.utils.get_ip robot_hat.utils.is_installed
#: robot_hat.utils.mapping robot_hat.utils.run_command
#: robot_hat.utils.set_volume
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.utils.set_volume:3
msgid "volume(0~100)"
msgstr "音量（0〜100）"

#: of robot_hat.utils.run_command:1
msgid "Run command and return status and output"
msgstr "コマンドを実行し、状態と出力を返す"

#: of robot_hat.utils.run_command:3
msgid "command to run"
msgstr "実行するコマンド"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.utils.run_command:5
msgid "status, output"
msgstr "状態、出力"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.utils.is_installed:1
msgid "Check if command is installed"
msgstr "コマンドがインストールされているかどうかを確認する"

#: of robot_hat.utils.is_installed:3
msgid "command to check"
msgstr "確認するコマンド"

#: of robot_hat.utils.is_installed:5
msgid "True if installed"
msgstr "インストールされている場合はTrue"

#: of robot_hat.utils.mapping:1
msgid "Map value from one range to another range"
msgstr "ある範囲の値を別の範囲にマップする"

#: of robot_hat.utils.mapping:3
msgid "value to map"
msgstr "マップする値"

#: of robot_hat.utils.mapping:5
msgid "input minimum"
msgstr "入力最小値"

#: of robot_hat.utils.mapping:7
msgid "input maximum"
msgstr "入力最大値"

#: of robot_hat.utils.mapping:9
msgid "output minimum"
msgstr "出力最小値"

#: of robot_hat.utils.mapping:11
msgid "output maximum"
msgstr "出力最大値"

#: of robot_hat.utils.mapping:13
msgid "mapped value"
msgstr "マップされた値"

#: of robot_hat.utils.get_ip:1
msgid "Get IP address"
msgstr "IPアドレスを取得する"

#: of robot_hat.utils.get_ip:3
msgid "interfaces to check"
msgstr "チェックするインターフェース"

#: of robot_hat.utils.get_ip:5
msgid "IP address or False if not found"
msgstr "見つかった場合はIPアドレス、見つからない場合はFalse"

#: of robot_hat.utils.reset_mcu:1
msgid "Reset mcu on Robot Hat."
msgstr "Robot Hat上のMCUをリセットする。"

#: of robot_hat.utils.reset_mcu:3
msgid ""
"This is helpful if the mcu somehow stuck in a I2C data transfer loop, and"
" Raspberry Pi getting IOError while Reading ADC, manipulating PWM, etc."
msgstr ""
"これは、MCUが何らかの理由でI2Cデータ転送ループに固まり、Raspberry "
"PiがADCの読み取り、PWMの操作などでIOErrorを取得している場合に役立ちます。"

#: of robot_hat.utils.get_battery_voltage:1
msgid "Get battery voltage"
msgstr "バッテリー電圧を取得する"

#: of robot_hat.utils.get_battery_voltage:3
msgid "battery voltage(V)"
msgstr "バッテリー電圧（V）"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_pwm.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pwm.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_pwm.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_pwm.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_pwm.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_pwm.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_pwm.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_pwm.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_pwm.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_pwm.rst:18
msgid "class ``PWM``"
msgstr "クラス ``PWM``"

#: ../api_pwm.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_pwm.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pwm.PWM:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "基底: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.pwm.PWM:1
msgid "Pulse width modulation (PWM)"
msgstr "パルス幅変調（PWM）"

#: ../docstring of robot_hat.PWM.REG_CHN:1
msgid "Channel register prefix"
msgstr "チャンネルレジスタの接頭辞"

#: ../docstring of robot_hat.PWM.REG_PSC:1
msgid "Prescaler register prefix"
msgstr "プリスケーラーレジスタの接頭辞"

#: ../docstring of robot_hat.PWM.REG_ARR:1
msgid "Period registor prefix"
msgstr "周期レジスタの接頭辞"

#: ../docstring of robot_hat.PWM.CLOCK:1
msgid "Clock frequency"
msgstr "クロック周波数"

#: of robot_hat.pwm.PWM.__init__:1
msgid "Initialize PWM"
msgstr "PWMの初期化"

#: of robot_hat.pwm.PWM.__init__ robot_hat.pwm.PWM.freq
#: robot_hat.pwm.PWM.period robot_hat.pwm.PWM.prescaler
#: robot_hat.pwm.PWM.pulse_width robot_hat.pwm.PWM.pulse_width_percent
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.pwm.PWM.__init__:3
msgid "PWM channel number(0-13/P0-P13)"
msgstr "PWMチャンネル番号(0-13/P0-P13)"

#: of robot_hat.pwm.PWM.freq:1
msgid "Set/get frequency, leave blank to get frequency"
msgstr "周波数の設定/取得、周波数を取得するには空白にしておく"

#: of robot_hat.pwm.PWM.freq:3
msgid "frequency(0-65535)(Hz)"
msgstr "周波数(0-65535)(Hz)"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.pwm.PWM.freq:5
msgid "frequency"
msgstr "周波数"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.pwm.PWM.prescaler:1
msgid "Set/get prescaler, leave blank to get prescaler"
msgstr "プリスケーラーを設定/取得、プリスケーラーを取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.prescaler:3
msgid "prescaler(0-65535)"
msgstr "プリスケーラー(0-65535)"

#: of robot_hat.pwm.PWM.prescaler:5
msgid "prescaler"
msgstr "プリスケーラー"

#: of robot_hat.pwm.PWM.period:1
msgid "Set/get period, leave blank to get period"
msgstr "周期を設定/取得、周期を取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.period:3
msgid "period(0-65535)"
msgstr "周期(0-65535)"

#: of robot_hat.pwm.PWM.period:5
msgid "period"
msgstr "周期"

#: of robot_hat.pwm.PWM.pulse_width:1
msgid "Set/get pulse width, leave blank to get pulse width"
msgstr "パルス幅を設定/取得、パルス幅を取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.pulse_width:3
msgid "pulse width(0-65535)"
msgstr "パルス幅(0-65535)"

#: of robot_hat.pwm.PWM.pulse_width:5
msgid "pulse width"
msgstr "パルス幅"

#: of robot_hat.pwm.PWM.pulse_width_percent:1
msgid "Set/get pulse width percentage, leave blank to get pulse width percentage"
msgstr "パルス幅のパーセンテージを設定/取得、パルス幅のパーセンテージを取得するには空欄にしておく"

#: of robot_hat.pwm.PWM.pulse_width_percent:3
msgid "pulse width percentage(0-100)"
msgstr "パルス幅のパーセンテージ(0-100)"

#: of robot_hat.pwm.PWM.pulse_width_percent:5
msgid "pulse width percentage"
msgstr "パルス幅のパーセンテージ"





##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_music.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_music.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_music.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_music.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_music.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_music.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_music.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_music.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_music.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_music.rst:18
msgid "class ``Music``"
msgstr "クラス ``Music``"

#: ../api_music.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr "スピーカーが動作しない場合、このスクリプトを実行する際には ``sudo`` を追加する必要があります。"

#: ../api_music.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_music.rst:24
msgid "**Example**"
msgstr "**例**"

#: ../api_music.rst:26
msgid "Initialize"
msgstr "初期化"

#: ../api_music.rst:36
msgid "Play tones"
msgstr "トーンを演奏する"

#: ../api_music.rst:144
msgid "Play sound"
msgstr "サウンドを演奏する"

#: ../api_music.rst:155
msgid "Play Music"
msgstr "音楽を演奏する"

#: ../api_music.rst:176
msgid "**API**"
msgstr "**API**"

#: of robot_hat.music.Music:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.music.Music:1
msgid "Play music, sound affect and note control"
msgstr "音楽、サウンドエフェクト、音符の制御を演奏する"

#: ../docstring of robot_hat.Music.NOTE_BASE_FREQ:1
msgid "Base note frequency for calculation (A4)"
msgstr "計算用の基準音の周波数（A4）"

#: ../docstring of robot_hat.Music.NOTE_BASE_INDEX:1
msgid "Base note index for calculation (A4) MIDI compatible"
msgstr "計算用の基準音のインデックス（A4）MIDI互換"

#: ../docstring of robot_hat.Music.NOTES:1
msgid "Notes name, MIDI compatible"
msgstr "音符の名前、MIDI互換"

#: of robot_hat.music.Music.__init__:1
msgid "Initialize the basic class"
msgstr "基本クラスを初期化する"

#: of robot_hat.music.Music.__init__ robot_hat.music.Music.beat
#: robot_hat.music.Music.get_tone_data robot_hat.music.Music.key_signature
#: robot_hat.music.Music.music_play robot_hat.music.Music.music_set_volume
#: robot_hat.music.Music.note robot_hat.music.Music.play_tone_for
#: robot_hat.music.Music.sound_length robot_hat.music.Music.sound_play
#: robot_hat.music.Music.sound_play_threading robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.music.Music.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "デバッグレベル、0（クリティカル）、1（エラー）、2（警告）、3（情報）または4（デバッグ）"

#: of robot_hat.music.Music.time_signature:1
msgid "Set/get time signature"
msgstr "拍子記号の設定/取得"

#: of robot_hat.music.Music.time_signature:3
msgid "top number of time signature"
msgstr "拍子記号の上部の数字"

#: of robot_hat.music.Music.time_signature:5
msgid "bottom number of time signature"
msgstr "拍子記号の下部の数字"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.music.Music.time_signature:7
msgid "time signature"
msgstr "拍子記号"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.music.Music.key_signature:1
msgid "Set/get key signature"
msgstr "キー記号の設定/取得"

#: of robot_hat.music.Music.key_signature:3
msgid ""
"key signature use KEY_XX_MAJOR or String \"#\", \"##\", or \"bbb\", "
"\"bbbb\""
msgstr "キー記号はKEY_XX_MAJORまたは\\「#\\」、\\「##\\」、\\「bbb\\」、\\「bbbb\\」の文字列を使用"

#: of robot_hat.music.Music.key_signature:5
msgid "key signature"
msgstr "キー記号"

#: of robot_hat.music.Music.tempo:1
msgid "Set/get tempo beat per minute(bpm)"
msgstr "テンポ（分あたりの拍数）の設定/取得"

#: of robot_hat.music.Music.tempo:3 robot_hat.music.Music.tempo:6
msgid "tempo"
msgstr "テンポ"

#: of robot_hat.music.Music.tempo:5
msgid "note value(1, 1/2, Music.HALF_NOTE, etc)"
msgstr "音価（1、1/2、Music.HALF_NOTEなど）"

#: of robot_hat.music.Music.beat:1
msgid "Calculate beat delay in seconds from tempo"
msgstr "テンポから拍子の遅延を秒単位で計算する"

#: of robot_hat.music.Music.beat:3
msgid "beat index"
msgstr "拍子インデックス"

#: of robot_hat.music.Music.beat:5
msgid "beat delay"
msgstr "拍子の遅延"

#: of robot_hat.music.Music.note:1
msgid "Get frequency of a note"
msgstr "音符の周波数を取得する"

#: of robot_hat.music.Music.note:3
msgid "note name(See NOTES)"
msgstr "音符の名前（NOTES参照）"

#: of robot_hat.music.Music.note:5
msgid "if natural note"
msgstr "ナチュラルノートの場合"

#: of robot_hat.music.Music.note:7
msgid "frequency of note"
msgstr "音符の周波数"

#: of robot_hat.music.Music.sound_play:1
msgid "Play sound effect file"
msgstr "サウンドエフェクトファイルを再生する"

#: of robot_hat.music.Music.sound_length:3 robot_hat.music.Music.sound_play:3
#: robot_hat.music.Music.sound_play_threading:3
msgid "sound effect file name"
msgstr "サウンドエフェクトファイル名"

#: of robot_hat.music.Music.sound_play_threading:1
msgid "Play sound effect in thread(in the background)"
msgstr "サウンドエフェクトをスレッドで再生する（バックグラウンドで）"

#: of robot_hat.music.Music.music_play:9
#: robot_hat.music.Music.sound_play_threading:5
msgid "volume 0-100, leave empty will not change volume"
msgstr "音量0-100、空欄にすると音量は変わらない"

#: of robot_hat.music.Music.music_play:1
msgid "Play music file"
msgstr "音楽ファイルを再生する"

#: of robot_hat.music.Music.music_play:3
msgid "sound file name"
msgstr "サウンドファイル名"

#: of robot_hat.music.Music.music_play:5
msgid "number of loops, 0:loop forever, 1:play once, 2:play twice, ..."
msgstr "ループ回数、0:無限ループ、1:1回再生、2:2回再生、..."

#: of robot_hat.music.Music.music_play:7
msgid "start time in seconds"
msgstr "開始時間（秒）"

#: of robot_hat.music.Music.music_set_volume:1
msgid "Set music volume"
msgstr "音楽の音量を設定する"

#: of robot_hat.music.Music.music_set_volume:3
msgid "volume 0-100"
msgstr "音量 0-100"

#: of robot_hat.music.Music.music_stop:1
msgid "Stop music"
msgstr "音楽を停止する"

#: of robot_hat.music.Music.music_pause:1
msgid "Pause music"
msgstr "音楽を一時停止する"

#: of robot_hat.music.Music.music_resume:1
msgid "Resume music"
msgstr "音楽を再開する"

#: of robot_hat.music.Music.music_unpause:1
msgid "Unpause music(resume music)"
msgstr "音楽の一時停止を解除する（音楽を再開する）"

#: of robot_hat.music.Music.sound_length:1
msgid "Get sound effect length in seconds"
msgstr "サウンドエフェクトの長さを秒で取得する"

#: of robot_hat.music.Music.sound_length:5
msgid "length in seconds"
msgstr "長さ（秒）"

#: of robot_hat.music.Music.get_tone_data:1
msgid "Get tone data for playing"
msgstr "演奏用のトーンデータを取得する"

#: of robot_hat.music.Music.get_tone_data:3
msgid "frequency"
msgstr "周波数"

#: of robot_hat.music.Music.get_tone_data:5
#: robot_hat.music.Music.play_tone_for:5
msgid "duration in seconds"
msgstr "持続時間（秒）"

#: of robot_hat.music.Music.get_tone_data:7
msgid "tone data"
msgstr "トーンデータ"

#: of robot_hat.music.Music.play_tone_for:1
msgid "Play tone for duration seconds"
msgstr "指定された持続時間のトーンを演奏する"

#: of robot_hat.music.Music.play_tone_for:3
msgid "frequency, you can use NOTES to get frequency"
msgstr "周波数、NOTESを使用して周波数を取得できる"





##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_adc.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_adc.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_adc.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_adc.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_adc.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_adc.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_adc.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_adc.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_adc.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_adc.rst:18
msgid "class ``ADC``"
msgstr "クラス ``ADC``"

#: ../api_adc.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_adc.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.adc.ADC:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "基底: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.adc.ADC:1 robot_hat.adc.ADC.__init__:1
msgid "Analog to digital converter"
msgstr "アナログからデジタルへの変換器"

#: of robot_hat.adc.ADC.__init__
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.adc.ADC.__init__:3
msgid "channel number (0-7/A0-A7)"
msgstr "チャンネル番号 (0-7/A0-A7)"

#: of robot_hat.adc.ADC.read:1
msgid "Read the ADC value"
msgstr "ADC値を読む"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.adc.ADC.read:3
msgid "ADC value(0-4095)"
msgstr "ADC値(0-4095)"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.adc.ADC.read_voltage:1
msgid "Read the ADC value and convert to voltage"
msgstr "ADC値を読み取り電圧に変換する"

#: of robot_hat.adc.ADC.read_voltage:3
msgid "Voltage value(0-3.3(V))"
msgstr "電圧値(0-3.3(V))"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_basic_class.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_basic_class.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_basic_class.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_basic_class.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_basic_class.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_basic_class.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_basic_class.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_basic_class.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_basic_class.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_basic_class.rst:16
msgid "class ``_Basic_class``"
msgstr "クラス ``_Basic_class``"

#: ../api_basic_class.rst:18
msgid ""
"``_Basic_class`` is a logger class for all class to log, so if you want "
"to see logs of a class, just add a debug argument to it."
msgstr "``_Basic_class`` はすべてのクラスのロガークラスで、特定のクラスのログを見たい場合は、デバッグ引数を追加するだけです。"

#: ../api_basic_class.rst:21
msgid "**Example**"
msgstr "**例**"

#: ../api_basic_class.rst:36
msgid "**API**"
msgstr "**API**"

#: of robot_hat.basic._Basic_class:1
msgid "Basic Class for all classes"
msgstr "すべてのクラスの基本クラス"

#: of robot_hat.basic._Basic_class:3
msgid "with debug function"
msgstr "デバッグ機能付き"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_LEVELS:1
#: robot_hat.basic._Basic_class.debug_level:1
msgid "Debug level"
msgstr "デバッグレベル"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_NAMES:1
msgid "Debug level names"
msgstr "デバッグレベルの名称"

#: of robot_hat.basic._Basic_class.__init__:1
msgid "Initialize the basic class"
msgstr "基本クラスを初期化する"

#: of robot_hat.basic._Basic_class.__init__
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.basic._Basic_class.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "デバッグレベル、0（重大）、1（エラー）、2（警告）、3（情報）または4（デバッグ）"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_diy_car.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_diy_car.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_diy_car.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_diy_car.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_diy_car.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_diy_car.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_diy_car.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_diy_car.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_diy_car.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_diy_car.rst:16
msgid "DIY Car"
msgstr "DIYカー"

#: ../project_diy_car.rst:18
msgid ""
"In addition to being suitable for simple experiments, the Robot HAT is "
"ideal for use as a central controller in robotics, such as for smart "
"cars."
msgstr "シンプルな実験に適しているだけでなく、スマートカーなどのロボティクスにおける中央コントローラとしても、Robot HATは理想的です。"

#: ../project_diy_car.rst:20
msgid "In this project, we built a simple line-following car."
msgstr "このプロジェクトでは、シンプルなラインフォローイングカーを作りました。"

#: ../project_diy_car.rst:24
msgid "**Code**"
msgstr "**コード**"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/index.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../index.rst:43
msgid "About this HAT"
msgstr "このHATについて"

#: ../index.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../index.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../index.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../index.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../index.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../index.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../index.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../index.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../index.rst:16
msgid "SunFounder Robot HAT"
msgstr "SunFounder Robot HAT"

#: ../index.rst:18
msgid "Thanks for choosing our Robot HAT."
msgstr "SunFounder Robot HATをお選びいただき、ありがとうございます。"

#: ../index.rst:21
msgid "This document is available in the following languages."
msgstr "このドキュメントは以下の言語で利用可能です。"

#: ../index.rst:23
msgid "|link_german_tutorials|"
msgstr "|link_german_tutorials|"

#: ../index.rst:24
msgid "|link_jp_tutorials|"
msgstr "|link_jp_tutorials|"

#: ../index.rst:25
msgid "|link_en_tutorials|"
msgstr "|link_en_tutorials|"

#: ../index.rst:27
msgid ""
"Please click on the respective links to access the document in your "
"preferred language."
msgstr "ご希望の言語でドキュメントにアクセスするために、それぞれのリンクをクリックしてください。"

#: ../index.rst:34
msgid ""
"Robot HAT is a multifunctional expansion board that allows Raspberry Pi "
"to be quickly turned into a robot. An MCU is on board to extend the PWM "
"output and ADC input for the Raspberry Pi, as well as a motor driver "
"chip, Bluetooth module, I2S audio module and mono speaker. As well as the"
" GPIOs that lead out of the Raspberry Pi itself."
msgstr ""
"Robot HATは、Raspberry Piを迅速にロボットに変換できる多機能拡張ボードです。MCUが搭載されており、Raspberry "
"PiのPWM出力とADC入力を拡張するとともに、モータードライバーチップ、Bluetoothモジュール、I2Sオーディオモジュール、モノラルスピーカー、そしてRaspberry"
" Pi自体から出るGPIOも搭載しています。"

#: ../index.rst:36
msgid ""
"It also comes with a Speaker, which can be used to play background music,"
" sound effects and implement TTS functions to make your project more "
"interesting."
msgstr "また、背景音楽や効果音を再生し、TTS機能を実装してプロジェクトをより魅力的にするためのスピーカーも付属しています。"

#: ../index.rst:38
msgid ""
"Accepts 6.0V-8.4V XH2.54 3pin power input with 2 power indicators. The "
"board also has a user available LED and a button for you to quickly test "
"some effects."
msgstr ""
"6.0V-8.4V XH2.54 "
"3ピン電源入力と2つの電源インジケータを受け入れます。このボードには、ユーザーが使用可能なLEDと、いくつかの効果を迅速にテストするためのボタンも備えています。"

#: ../index.rst:40
msgid ""
"In this document, you will get a full understanding of the interface "
"functions of the Robot HAT and the usage of these interfaces through the "
"Python ``robot-hat`` library provided by SunFounder."
msgstr ""
"この文書では、SunFounderが提供するPython ``robot-hat`` ライブラリを通じて、Robot "
"HATのインターフェイス機能とこれらのインターフェイスの使用方法を完全に理解できます。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_filedb.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_filedb.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_filedb.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_filedb.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_filedb.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_filedb.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_filedb.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_filedb.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_filedb.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_filedb.rst:16
msgid "class ``FileDB``"
msgstr "クラス ``FileDB``"

#: ../api_filedb.rst:18
msgid "**Example**"
msgstr "**例**"

#: ../api_filedb.rst:41
msgid "Now you can checkout the config file ``config`` in bash."
msgstr "これでbashで設定ファイル ``config`` を確認できます。"

#: ../api_filedb.rst:47
msgid "**API**"
msgstr "**API**"

#: of robot_hat.filedb.fileDB:1
msgid "Bases: :py:class:`object`"
msgstr "基底: :py:class:`object`"

#: of robot_hat.filedb.fileDB:1
msgid "A file based database."
msgstr "ファイルベースのデータベース。"

#: of robot_hat.filedb.fileDB:3
msgid "A file based database, read and write arguements in the specific file."
msgstr "特定のファイルで引数を読み書きするファイルベースのデータベースです。"

#: of robot_hat.filedb.fileDB.__init__:1
msgid "Init the db_file is a file to save the datas."
msgstr "db_fileを初期化すると、データを保存するファイルになります。"

#: of robot_hat.filedb.fileDB.__init__
#: robot_hat.filedb.fileDB.file_check_create robot_hat.filedb.fileDB.get
#: robot_hat.filedb.fileDB.set
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.filedb.fileDB.__init__:3
msgid "the file to save the datas."
msgstr "データを保存するファイル。"

#: of robot_hat.filedb.fileDB.__init__:5
#: robot_hat.filedb.fileDB.file_check_create:5
msgid "the mode of the file."
msgstr "ファイルのモード。"

#: of robot_hat.filedb.fileDB.__init__:7
#: robot_hat.filedb.fileDB.file_check_create:7
msgid "the owner of the file."
msgstr "ファイルの所有者。"

#: of robot_hat.filedb.fileDB.file_check_create:1
msgid "Check if file is existed, otherwise create one."
msgstr "ファイルが存在するかチェックし、存在しない場合は作成する。"

#: of robot_hat.filedb.fileDB.file_check_create:3
msgid "the file to check"
msgstr "チェックするファイル"

#: of robot_hat.filedb.fileDB.get:1
msgid "Get value with data's name"
msgstr "データの名前で値を取得する"

#: of robot_hat.filedb.fileDB.get:3 robot_hat.filedb.fileDB.set:3
msgid "the name of the arguement"
msgstr "引数の名前"

#: of robot_hat.filedb.fileDB.get:5
msgid "the default value of the arguement"
msgstr "引数のデフォルト値"

#: of robot_hat.filedb.fileDB.get
msgid "Returns"
msgstr "戻り値"

#: of robot_hat.filedb.fileDB.get:7 robot_hat.filedb.fileDB.set:5
msgid "the value of the arguement"
msgstr "引数の値"

#: of robot_hat.filedb.fileDB.get
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.filedb.fileDB.set:1
msgid "Set value by with name. Or create one if the arguement does not exist"
msgstr "名前で値を設定する。または、引数が存在しない場合は作成する"





##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_security.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_security.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_security.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_security.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_security.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_security.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_security.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_security.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_security.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_security.rst:16
msgid "Security System"
msgstr "セキュリティシステム"

#: ../project_security.rst:18
msgid ""
"In this project, we've created a simple security system. The PIR sensor "
"detects if someone passes by, and then the camera activates. If a face is"
" detected, it takes a picture and simultaneously delivers a warning "
"message."
msgstr "このプロジェクトでは、シンプルなセキュリティシステムを作成しました。PIRセンサーが人の動きを検出すると、カメラが起動します。顔が検出されると、写真を撮り、同時に警告メッセージを発信します。"

#: ../project_security.rst:22
msgid "**Steps**"
msgstr "**手順**"

#: ../project_security.rst:24
msgid "Install the ``vilib`` library for face detection."
msgstr "顔検出のための ``vilib`` ライブラリをインストールします。"

#: ../project_security.rst:33
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``security.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``security.ty`` という名前を付けます。"

#: ../project_security.rst:106
msgid "Use the command ``sudo python3 security.py`` to run this code."
msgstr "このコードを実行するには、 ``sudo python3 security.py`` コマンドを使用します。"

#: ../project_security.rst:106
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"

#: ../project_security.rst:108
msgid ""
"Open a web browser and enter ``http://rpi_ip:9000/mjpg`` to view the "
"captured footage. Additionally, you can find the captured face images in "
"``/home/{username}/Pictures/``."
msgstr ""
"ウェブブラウザを開いて ``http://rpi_ip:9000/mjpg`` "
"にアクセスし、キャプチャされた映像を視聴できます。さらに、キャプチャされた顔の画像は ``/home/{username}/Pictures/``"
" で見つけることができます。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/installation.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../installation.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../installation.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../installation.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../installation.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../installation.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../installation.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../installation.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../installation.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../installation.rst:16
msgid "Install the ``robot-hat`` Module"
msgstr "``robot-hat`` モジュールのインストール"

#: ../installation.rst:18
msgid "``robot-hat`` is the supported library for the Robot HAT."
msgstr "``robot-hat`` はRobot HATに対応したライブラリです。"

#: ../installation.rst:20
msgid "Update your system."
msgstr "システムをアップデートしてください。"

#: ../installation.rst:22
msgid "Make sure you are connected to the Internet and update your system:"
msgstr "インターネットに接続していることを確認し、システムをアップデートしてください:"

#: ../installation.rst:35
msgid ""
"Python3 related packages must be installed if you are installing the "
"**Lite** version OS."
msgstr "OSの **Lite** バージョンをインストールする場合、Python3関連のパッケージをインストールする必要があります。"

#: ../installation.rst:45
msgid "Type this command into the terminal to install the ``robot-hat`` package."
msgstr "このコマンドをターミナルに入力して、``robot-hat`` パッケージをインストールします。"

#: ../installation.rst:59
msgid ""
"Run ``setup.py`` to download some necessary components. You may have a "
"network problem and the download may fail. At this point you may need to "
"download again. In the following cases, type ``Y`` and press ``Enter`` to"
" continue the process."
msgstr ""
"``setup.py`` "
"を実行して必要なコンポーネントをダウンロードします。ネットワークの問題でダウンロードが失敗することがあります。その場合は、再度ダウンロードが必要になるかもしれません。次のような場合には、"
" ``Y`` と入力し ``Enter`` を押してプロセスを続行してください。"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/battery.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../battery.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../battery.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../battery.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../battery.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../battery.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../battery.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../battery.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../battery.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../battery.rst:16
msgid "About the Battery"
msgstr "バッテリーについて"

#: ../battery.rst:17
msgid "**Battery**"
msgstr "**バッテリー**"

#: ../battery.rst:23
msgid ""
"**VCC**: Battery positive terminal, here there are two sets of VCC and "
"GND is to increase the current and reduce the resistance."
msgstr "**VCC**: バッテリーの正極端子。ここにはVCCとGNDの2組があり、電流を増やし抵抗を減らすためです。"

#: ../battery.rst:24
msgid ""
"**Middle**: To balance the voltage between the two cells and thus protect"
" the battery."
msgstr "**Middle**: 二つのセル間の電圧をバランスさせ、バッテリーを保護します。"

#: ../battery.rst:25
msgid "**GND**: Negative battery terminal."
msgstr "**GND**: バッテリーの負極端子。"

#: ../battery.rst:28
msgid ""
"This is a custom battery pack made by SunFounder consisting of two 18650 "
"batteries with a capacity of 2000mAh. The connector is XH2.54 3pin, which"
" can be charged directly after being inserted into the shield."
msgstr ""
"これはSunFounderによって製造されたカスタムバッテリーパックで、2000mAhの容量を持つ18650バッテリー2個で構成されています。コネクターは"
" XH2.54-3Pで、シールドに挿入後、直接充電が可能です。"

#: ../battery.rst:32
msgid "**Features**"
msgstr "**特徴**"

#: ../battery.rst:34
msgid "Composition: Li-ion"
msgstr "構成: Li Battery (リチウムイオン二次電池)"

#: ../battery.rst:35
msgid "Battery Capacity: 2000mAh, 14.8Wh"
msgstr "バッテリー容量: 2000mAh, 14.8Wh"

#: ../battery.rst:36
msgid "Battery Weight: 90.8g"
msgstr "バッテリー重量：90.8g"

#: ../battery.rst:37
msgid "Number of Cells: 2"
msgstr "セル数：2"

#: ../battery.rst:38
msgid "Connector: XH2.54 3pin"
msgstr "コネクター: XH2.54 3pin"

#: ../battery.rst:39
msgid "Over-discharge protection: 6.0V"
msgstr "過放電保護 6.0V"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_motor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_motor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_motor.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_motor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_motor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_motor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_motor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_motor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_motor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_motor.rst:18
msgid "module ``motor``"
msgstr "モジュール ``motor``"

#: ../api_motor.rst:21
msgid "class ``Motors``"
msgstr "クラス ``Motors``"

#: ../api_motor.rst:23 ../api_motor.rst:95
msgid "**Example**"
msgstr "**例**"

#: ../api_motor.rst:25
msgid "Initilize"
msgstr "初期化"

#: ../api_motor.rst:35
msgid "Directly control a motor. Motor 1/2 is according to PCB mark"
msgstr "モーターを直接制御します。モーター1/2はPCBのマークに従います"

#: ../api_motor.rst:46
msgid ""
"Setup for high level control, high level control provides functions from "
"simple forword, backward, left, right, stop to more complex like joystick"
" control, motor directions calibration, etc."
msgstr "ハイレベル制御の設定を行います。ハイレベル制御は、単純な前進、後退、左、右、停止から、ジョイスティック制御、モーター方向のキャリブレーションなどの複雑な機能を提供します。"

#: ../api_motor.rst:51
msgid ""
"All these setup only need to run once, and will save in a config file. "
"Next time you load Motors class, it will load from config file."
msgstr "これらの設定は一度だけ実行する必要があり、設定ファイルに保存されます。次にMotorsクラスをロードするときは、設定ファイルからロードされます。"

#: ../api_motor.rst:67
msgid "Now control the robot"
msgstr "これでロボットを制御できます"

#: ../api_motor.rst:83 ../api_motor.rst:113
msgid "**API**"
msgstr "**API**"

#: of robot_hat.motor.Motors:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "基底: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.motor.Motors.__init__:1
msgid "Initialize motors with robot_hat.motor.Motor"
msgstr "robot_hat.motor.Motorでモーターを初期化"

#: of robot_hat.motor.Motor.__init__ robot_hat.motor.Motor.set_is_reverse
#: robot_hat.motor.Motor.speed robot_hat.motor.Motors.__init__
#: robot_hat.motor.Motors.backward robot_hat.motor.Motors.forward
#: robot_hat.motor.Motors.set_left_id robot_hat.motor.Motors.set_right_id
#: robot_hat.motor.Motors.speed robot_hat.motor.Motors.turn_left
#: robot_hat.motor.Motors.turn_right
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.motor.Motors.__init__:3
msgid "config file path"
msgstr "設定ファイルのパス"

#: of robot_hat.motor.Motors.__getitem__:1
msgid "Get specific motor"
msgstr "特定のモーターを取得する"

#: of robot_hat.motor.Motors.stop:1
msgid "Stop all motors"
msgstr "すべてのモーターを停止する"

#: of robot_hat.Motors.left:1
msgid "left motor"
msgstr "左のモーター"

#: of robot_hat.Motors.right:1
msgid "right motor"
msgstr "右のモーター"

#: of robot_hat.motor.Motors.set_left_id:1
msgid ""
"Set left motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr "左のモーターIDを設定します。この機能は一度だけ実行する必要があり、モーターIDを設定ファイルに保存し、クラスが初期化されるときにモーターIDをロードします。"

#: of robot_hat.motor.Motors.set_left_id:5
#: robot_hat.motor.Motors.set_right_id:5
msgid "motor id (1 or 2)"
msgstr "モーターID（1または2）"

#: of robot_hat.motor.Motors.set_right_id:1
msgid ""
"Set right motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr "右のモーターIDを設定します。この機能は一度だけ実行する必要があり、モーターIDを設定ファイルに保存し、クラスが初期化されるときにモーターIDをロードします。"

#: of robot_hat.motor.Motors.set_left_reverse:1
msgid ""
"Set left motor reverse, this function only need to run once It will save "
"the reversed status to config file, and load the reversed status when the"
" class is initialized"
msgstr "左のモーターを逆回転に設定します。この機能は一度だけ実行する必要があり、逆回転の状態を設定ファイルに保存し、クラスが初期化されるときに逆回転の状態をロードします。"

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Returns"
msgstr ""

#: of robot_hat.motor.Motors.set_left_reverse:5
#: robot_hat.motor.Motors.set_right_reverse:5
msgid "if currently is reversed"
msgstr "現在逆回転しているかどうか"

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Return type"
msgstr "戻り値の型"

#: of robot_hat.motor.Motors.set_right_reverse:1
msgid ""
"Set right motor reverse, this function only need to run once It will save"
" the reversed status to config file, and load the reversed status when "
"the class is initialized"
msgstr "右のモーターを逆回転に設定します。この機能は一度だけ実行する必要があり、逆回転の状態を設定ファイルに保存し、クラスが初期化されるときに逆回転の状態をロードします。"

#: of robot_hat.motor.Motors.speed:1
msgid "Set motor speed"
msgstr "モーター速度を設定する"

#: of robot_hat.motor.Motors.speed:3
msgid "left motor speed(-100.0~100.0)"
msgstr "左モーターの速度(-100.0~100.0)"

#: of robot_hat.motor.Motors.speed:5
msgid "right motor speed(-100.0~100.0)"
msgstr "右モーターの速度(-100.0~100.0)"

#: of robot_hat.motor.Motors.forward:1
msgid "Forward"
msgstr "前進"

#: of robot_hat.motor.Motor.speed:3 robot_hat.motor.Motors.backward:3
#: robot_hat.motor.Motors.forward:3 robot_hat.motor.Motors.turn_left:3
#: robot_hat.motor.Motors.turn_right:3
msgid "Motor speed(-100.0~100.0)"
msgstr "モーター速度(-100.0~100.0)"

#: of robot_hat.motor.Motors.backward:1
msgid "Backward"
msgstr "後退"

#: of robot_hat.motor.Motors.turn_left:1
msgid "Left turn"
msgstr "左折"

#: of robot_hat.motor.Motors.turn_right:1
msgid "Right turn"
msgstr "右折"

#: ../api_motor.rst:93
msgid "class ``Motor``"
msgstr "クラス ``Motor``"

#: of robot_hat.motor.Motor:1
msgid "Bases: :py:class:`object`"
msgstr "基底: :py:class:`object`"

#: of robot_hat.motor.Motor.__init__:1
msgid "Initialize a motor"
msgstr "モーターを初期化する"

#: of robot_hat.motor.Motor.__init__:3
msgid "Motor speed control pwm pin"
msgstr "モーター速度制御用PWMピン"

#: of robot_hat.motor.Motor.__init__:5
msgid "Motor direction control pin"
msgstr "モーター方向制御ピン"

#: of robot_hat.motor.Motor.speed:1
msgid "Get or set motor speed"
msgstr "モーター速度の取得または設定"

#: of robot_hat.motor.Motor.set_is_reverse:1
msgid "Set motor is reversed or not"
msgstr "モーターの逆転を設定するかどうか"

#: of robot_hat.motor.Motor.set_is_reverse:3
msgid "True or False"
msgstr "True または False"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/api_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"こんにちは、SunFounderのRaspberry Pi & Arduino & "
"ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry "
"Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../api_servo.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../api_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../api_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../api_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../api_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../api_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../api_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../api_servo.rst:18
msgid "class ``Servo``"
msgstr "クラス ``Servo``"

#: ../api_servo.rst:20
msgid "**Example**"
msgstr "**例**"

#: ../api_servo.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.servo.Servo:1
msgid "Bases: :py:class:`~robot_hat.pwm.PWM`"
msgstr "基底: :py:class:`~robot_hat.pwm.PWM`"

#: of robot_hat.servo.Servo:1
msgid "Servo motor class"
msgstr "サーボモータークラス"

#: of robot_hat.servo.Servo.__init__:1
msgid "Initialize the servo motor class"
msgstr "サーボモータークラスを初期化する"

#: of robot_hat.servo.Servo.__init__ robot_hat.servo.Servo.angle
#: robot_hat.servo.Servo.pulse_width_time
msgid "Parameters"
msgstr "パラメータ"

#: of robot_hat.servo.Servo.__init__:3
msgid "PWM channel number(0-14/P0-P14)"
msgstr "PWMチャンネル番号(0-14/P0-P14)"

#: of robot_hat.servo.Servo.angle:1
msgid "Set the angle of the servo motor"
msgstr "サーボモーターの角度を設定する"

#: of robot_hat.servo.Servo.angle:3
msgid "angle(-90~90)"
msgstr "角度(-90~90)"

#: of robot_hat.servo.Servo.pulse_width_time:1
msgid "Set the pulse width of the servo motor"
msgstr "サーボモーターのパルス幅を設定する"

#: of robot_hat.servo.Servo.pulse_width_time:3
msgid "pulse width time(500~2500)"
msgstr "パルス幅時間(500~2500)"




##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/project_ultrasonic.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_ultrasonic.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../project_ultrasonic.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../project_ultrasonic.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../project_ultrasonic.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../project_ultrasonic.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../project_ultrasonic.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../project_ultrasonic.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../project_ultrasonic.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../project_ultrasonic.rst:16
msgid "Read from Ultrasonic Module"
msgstr "超音波モジュールからの読み取り"

#: ../project_ultrasonic.rst:19
msgid ""
"In this project, we use ultrasonic sensors to measure distance and "
"display the readings on the I2C LCD1602."
msgstr "このプロジェクトでは、超音波センサーを使用して距離を測定し、その読み取り値をI2C LCD1602に表示します。"

#: ../project_ultrasonic.rst:23
msgid "**Steps**"
msgstr "**手順**"

#: ../project_ultrasonic.rst:25
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr "このプロジェクトではI2C LCD1602を使用しているため、関連するライブラリをダウンロードして機能させる必要があります。"

#: ../project_ultrasonic.rst:32
msgid "Install ``smbus2`` for I2C."
msgstr "I2C用に ``smbus2`` をインストールします。"

#: ../project_ultrasonic.rst:38
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``ultrasonic.ty``."
msgstr "以下のコードをRaspberry Piに保存し、例えば ``ultrasonic.ty`` という名前を付けます。"

#: ../project_ultrasonic.rst:88
msgid "Use the command ``sudo python3 ultrasonic.ty`` to run this code."
msgstr "このコードを実行するには、 ``sudo python3 ultrasonic.ty`` コマンドを使用します。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/features.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../features.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../features.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../features.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../features.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../features.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../features.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../features.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../features.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../features.rst:16
msgid "Features"
msgstr "特徴"

#: ../features.rst:18
msgid "Shutdown Current: < 0.5mA"
msgstr "シャットダウン電流：<0.5mA"

#: ../features.rst:19
msgid "Power Input: USB Type-C, 5V/2A"
msgstr "電源入力：USB Type-C、5V/2A"

#: ../features.rst:20
msgid "Charging Power: 5V/2A 10W"
msgstr "充電電力：5V/2A 10W"

#: ../features.rst:21
msgid "Output Power: 5V/3A"
msgstr "出力電力：5V/3A"

#: ../features.rst:22
msgid ""
"Included Batteries: 2 x 3.7V 18650 Lithium-ion Batteries, XH2.54 3P "
"Interface"
msgstr "付属のバッテリー：2 x 3.7V 18650リチウムイオンバッテリー、XH2.54 3Pインターフェース"

#: ../features.rst:23
msgid "Battery Protection: Reverse polarity protection"
msgstr "バッテリー保護：逆極性保護"

#: ../features.rst:24
msgid ""
"Charging Protection: Input undervoltage protection, input overvoltage "
"protection, charging balance, overheat protection"
msgstr "充電保護：入力低電圧保護、入力過電圧保護、充電バランス、過熱保護"

#: ../features.rst:25
msgid "Onboard Charging Indicator Light: CHG"
msgstr "オンボード充電指示灯：CHG"

#: ../features.rst:26
msgid "Onboard Power Indicator Light: PWR"
msgstr "オンボード電源指示灯：PWR"

#: ../features.rst:27
msgid "Onboard 2 Battery Level Indicator LEDs"
msgstr "オンボード2つのバッテリーレベル指示LED"

#: ../features.rst:28
msgid "Onboard User LED, 2 tactile switches"
msgstr "オンボードユーザーLED、2つの触覚スイッチ"

#: ../features.rst:29
msgid "Motor Driver: 5V/1.8A x 2"
msgstr "モータードライバー：5V/1.8A x 2"

#: ../features.rst:30
msgid "4-channel 12-bit ADC"
msgstr "4チャンネル12ビットADC"

#: ../features.rst:31
msgid "12-channel PWM"
msgstr "12チャンネルPWM"

#: ../features.rst:32
msgid "4-channel digital signals"
msgstr "4チャンネルデジタル信号"

#: ../features.rst:33
msgid "Onboard SPI interface, UART interface, I2C interface"
msgstr "オンボードSPIインターフェース、UARTインターフェース、I2Cインターフェース"

#: ../features.rst:34
msgid "Mono Speaker: 8Ω1W"
msgstr "モノスピーカー：8Ω1W"

#: ../features.rst:36
msgid "Electrical Characteristics"
msgstr "電気特性"

#: ../features.rst:40
msgid "Parameters:"
msgstr "パラメータ："

#: ../features.rst:41
msgid "Minimum Value:"
msgstr "最小値："

#: ../features.rst:42
msgid "Typical Value:"
msgstr "典型値："

#: ../features.rst:43
msgid "Maximum Value:"
msgstr "最大値："

#: ../features.rst:44
msgid "Unit:"
msgstr "単位："

#: ../features.rst:45
msgid "Input Voltage:"
msgstr "入力電圧："

#: ../features.rst:46 ../features.rst:62
msgid "4.25"
msgstr "4.25"

#: ../features.rst:47
msgid "5"
msgstr "5"

#: ../features.rst:48 ../features.rst:53 ../features.rst:67
msgid "8.4"
msgstr "8.4"

#: ../features.rst:49 ../features.rst:54 ../features.rst:59 ../features.rst:64
#: ../features.rst:69 ../features.rst:84
msgid "V"
msgstr "V"

#: ../features.rst:50
msgid "Battery Input Voltage:"
msgstr "バッテリー入力電圧："

#: ../features.rst:51
msgid "6.0"
msgstr "6.0"

#: ../features.rst:52
msgid "7.4"
msgstr "7.4"

#: ../features.rst:55
msgid "Overcharge Protection (Battery):"
msgstr "過充電保護（バッテリー）："

#: ../features.rst:57 ../features.rst:66
msgid "8.3"
msgstr "8.3"

#: ../features.rst:60
msgid "Input Undervoltage Protection:"
msgstr "入力低電圧保護："

#: ../features.rst:61
msgid "4.15"
msgstr "4.15"

#: ../features.rst:63
msgid "4.35"
msgstr "4.35"

#: ../features.rst:65
msgid "Input Overvoltage Protection:"
msgstr "入力過電圧保護："

#: ../features.rst:68
msgid "8.5"
msgstr "8.5"

#: ../features.rst:70
msgid "Charging Current (5V):"
msgstr "充電電流（5V）："

#: ../features.rst:73
msgid "2.0"
msgstr "2.0"

#: ../features.rst:74 ../features.rst:79 ../features.rst:99
msgid "A"
msgstr "A"

#: ../features.rst:75
msgid "Output Current (5V):"
msgstr "出力電流（5V）："

#: ../features.rst:78
msgid "3.0"
msgstr "3.0"

#: ../features.rst:80
msgid "Output Voltage:"
msgstr "出力電圧："

#: ../features.rst:81
msgid "5.166"
msgstr "5.166"

#: ../features.rst:82
msgid "5.246"
msgstr "5.246"

#: ../features.rst:83
msgid "5.327"
msgstr "5.327"

#: ../features.rst:85
msgid "Charging Overheat Protection:"
msgstr "充電過熱保護："

#: ../features.rst:86
msgid "125"
msgstr "125"

#: ../features.rst:87
msgid "135"
msgstr "135"

#: ../features.rst:88
msgid "145"
msgstr "145"

#: ../features.rst:89 ../features.rst:94
msgid "°C"
msgstr "°C"

#: ../features.rst:90
msgid "DC-DC Overheat Protection:"
msgstr "DC-DC過熱保護："

#: ../features.rst:91
msgid "70"
msgstr "70"

#: ../features.rst:92
msgid "75"
msgstr "75"

#: ../features.rst:93
msgid "80"
msgstr "80"

#: ../features.rst:95
msgid "Motor Output Current:"
msgstr "モーター出力電流："

#: ../features.rst:98
msgid "1.8"
msgstr "1.8"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/ja/LC_MESSAGES/onboard_mcu.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../onboard_mcu.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "こんにちは、SunFounderのRaspberry Pi & Arduino & ESP32愛好家コミュニティへようこそ！Facebook上でRaspberry Pi、Arduino、ESP32についてもっと深く掘り下げ、他の愛好家と交流しましょう。"

#: ../onboard_mcu.rst:5
msgid "**Why Join?**"
msgstr " **参加する理由は？**"

#: ../onboard_mcu.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**エキスパートサポート**：コミュニティやチームの助けを借りて、販売後の問題や技術的な課題を解決します。"

#: ../onboard_mcu.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**学び＆共有**：ヒントやチュートリアルを交換してスキルを向上させましょう。"

#: ../onboard_mcu.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**独占的なプレビュー**：新製品の発表や先行プレビューに早期アクセスしましょう。"

#: ../onboard_mcu.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**特別割引**：最新製品の独占割引をお楽しみください。"

#: ../onboard_mcu.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**祭りのプロモーションとギフト**：ギフトや祝日のプロモーションに参加しましょう。"

#: ../onboard_mcu.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 私たちと一緒に探索し、創造する準備はできていますか？[|link_sf_facebook|]をクリックして今すぐ参加しましょう！"

#: ../onboard_mcu.rst:18
msgid "On-Board MCU"
msgstr "オンボードMCU"

#: ../onboard_mcu.rst:20
msgid ""
"The Robot HAT comes with an AT32F413CBT7 microcontroller from Artery. It "
"is an ARM Cortex-M4 processor with a maximum clock frequency of 200MHz. "
"The microcontroller has 128KB of Flash memory and 32KB of SRAM."
msgstr ""
"Robot "
"HATは、ArteryのAT32F415CBT7マイクロコントローラーを搭載しています。これは、最大クロック周波数が150MHzのARM "
"Cortex-M4プロセッサーです。マイクロコントローラーには、256KBのフラッシュメモリと32KBのSRAMがあります。"

#: ../onboard_mcu.rst:22
msgid ""
"The onboard PWM and ADC are driven by the microcontroller. Communication "
"between the Raspberry Pi and the microcontroller is established via the "
"I2C interface. The I2C address used for communication is 0x14 (7-bit "
"address format)."
msgstr ""
"オンボードのPWMとADCは、マイクロコントローラによって駆動されます。Raspberry "
"Piとマイクロコントローラ間の通信は、I2Cインターフェイスを通じて確立されます。通信に使用されるI2Cアドレスは0x14（7ビットアドレス形式）です。"

#: ../onboard_mcu.rst:28
msgid "Introduce"
msgstr "紹介"

#: ../onboard_mcu.rst:30
msgid ""
"The on board MCU RESET pin is connected to Raspberry Pi GPIO 5, or "
"``MCURST`` for :py:class:`robot_hat.Pin`. The MCU using 7-bit address "
"``0x14``."
msgstr ""
"オンボードMCUのRESETピンは、Raspberry PiのGPIO 5、または :py:class:`robot_hat.Pin` の "
"``MCURST`` に接続されています。MCUは7ビットアドレスの ``0x14`` を使用しています。"

#: ../onboard_mcu.rst:33
msgid "ADC"
msgstr "ADC"

#: ../onboard_mcu.rst:35
msgid ""
"Register addresses is 3 byte, 0x170000 to 0x140000 are ADC channels 0 to "
"3. The ADC precision is 12 bit, and the value is 0 to 4095. See more "
"details in :py:class:`robot_hat.ADC`."
msgstr ""
"レジスタアドレスは3バイトで、0x170000から0x140000までがADCチャンネル0から3です。ADCの精度は12ビットで、値は0から4095までです。:py:class:`robot_hat.ADC`"
" で詳細を確認してください。"

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Address"
msgstr "アドレス"

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Description"
msgstr "説明"

#: ../onboard_mcu.rst:44
msgid "``0x170000``"
msgstr "``0x170000``"

#: ../onboard_mcu.rst:44
msgid "ADC channel 0"
msgstr "ADCチャンネル0"

#: ../onboard_mcu.rst:46
msgid "``0x160000``"
msgstr "``0x160000``"

#: ../onboard_mcu.rst:46
msgid "ADC channel 1"
msgstr "ADCチャンネル1"

#: ../onboard_mcu.rst:48
msgid "``0x150000``"
msgstr "``0x150000``"

#: ../onboard_mcu.rst:48
msgid "ADC channel 2"
msgstr "ADCチャンネル2"

#: ../onboard_mcu.rst:50
msgid "``0x140000``"
msgstr "``0x140000``"

#: ../onboard_mcu.rst:50
msgid "ADC channel 3"
msgstr "ADCチャンネル3"

#: ../onboard_mcu.rst:52
msgid "``0x130000``"
msgstr "``0x130000``"

#: ../onboard_mcu.rst:52
msgid "ADC channel 4 (Battery Level)"
msgstr "ADCチャンネル4（バッテリーレベル）"

#: ../onboard_mcu.rst:55
msgid "**Example:**"
msgstr "**例:**"

#: ../onboard_mcu.rst:57
msgid "Read Channel 0 ADC value:"
msgstr "チャンネル0のADC値を読む:"

#: ../onboard_mcu.rst:72
msgid "PWM"
msgstr "PWM"

#: ../onboard_mcu.rst:74
msgid "PWM have 1 byte register with 2 byte values."
msgstr "PWMは1バイトのレジスタと2バイトの値を持っています。"

#: ../onboard_mcu.rst:77
msgid "Changing PWM Frequency"
msgstr "PWM周波数の変更"

#: ../onboard_mcu.rst:79
msgid "Frequency is defined with prescaler and period."
msgstr "周波数はプリスケーラと周期で定義されます。"

#: ../onboard_mcu.rst:81
msgid ""
"To set frequency first you need to define the period you want. Like on "
"Arduino, normaly is 255, or like PCA9685 is 4095."
msgstr "周波数を設定するには、まず設定したい周期を定義する必要があります。Arduinoでは通常255、PCA9685では4095です。"

#: ../onboard_mcu.rst:84
msgid ""
"CPU clock is 72MHz, Then you can calculate the prescaler from your desire"
" frequency"
msgstr "CPUクロックは72MHzです。そこから、希望の周波数に応じたプリスケーラを計算できます"

#: ../onboard_mcu.rst:87
msgid "prescaler = 72MHz / (Period + 1) / Frequency - 1"
msgstr "プリスケーラ = 72MHz / (周期 + 1) / 周波数 - 1"

#: ../onboard_mcu.rst:89
msgid ""
"Or if you don't care about the period, there's a way to calculate both "
"period and prescaler from frequency. See :py:func:`robot_hat.PWM.freq`."
msgstr ""
"周期にこだわらない場合は、周波数から周期とプリスケーラの両方を計算する方法があります。 :py:func:`robot_hat.PWM.freq`"
" を参照してください。"

#: ../onboard_mcu.rst:93
msgid "Pulse width"
msgstr "パルス幅"

#: ../onboard_mcu.rst:95
msgid ""
"To control the channel pulse width is rather simple, just write the value"
" to the register."
msgstr "チャンネルのパルス幅を制御するのは簡単で、値をレジスタに書き込むだけです。"

#: ../onboard_mcu.rst:97
msgid ""
"**But** what is the value? If you want to set the PWM to 50% pulse width,"
" you need to know exactly what the period is. Base on the above "
"calculation, if you set the period to 4095, then set pulse value to 2048 "
"is about 50% pulse width."
msgstr ""
"**しかし** "
"値とは何か？PWMを50%のパルス幅に設定したい場合、周期が正確に何であるかを知る必要があります。上記の計算に基づき、周期を4095に設定した場合、パルス値を2048に設定すると、約50%のパルス幅になります。"

#: ../onboard_mcu.rst:106
msgid "``0x20``"
msgstr "``0x20``"

#: ../onboard_mcu.rst:106
msgid "Set PWM channel 0 **On Value**"
msgstr "PWMチャンネル0 **オン値** を設定"

#: ../onboard_mcu.rst:108
msgid "``0x21``"
msgstr "``0x21``"

#: ../onboard_mcu.rst:108
msgid "Set PWM channel 1 **On Value**"
msgstr "PWMチャンネル1 **オン値** を設定"

#: ../onboard_mcu.rst:110
msgid "``0x22``"
msgstr "``0x22``"

#: ../onboard_mcu.rst:110
msgid "Set PWM channel 2 **On Value**"
msgstr "PWMチャンネル2の **オン値** を設定"

#: ../onboard_mcu.rst:112
msgid "``0x23``"
msgstr "``0x23``"

#: ../onboard_mcu.rst:112
msgid "Set PWM channel 3 **On Value**"
msgstr "PWMチャンネル3の **オン値** を設定"

#: ../onboard_mcu.rst:114
msgid "``0x24``"
msgstr "``0x24``"

#: ../onboard_mcu.rst:114
msgid "Set PWM channel 4 **On Value**"
msgstr "PWMチャンネル4の **オン値** を設定"

#: ../onboard_mcu.rst:116
msgid "``0x25``"
msgstr "``0x25``"

#: ../onboard_mcu.rst:116
msgid "Set PWM channel 5 **On Value**"
msgstr "PWMチャンネル5の **オン値** を設定"

#: ../onboard_mcu.rst:118
msgid "``0x26``"
msgstr "``0x26``"

#: ../onboard_mcu.rst:118
msgid "Set PWM channel 6 **On Value**"
msgstr "PWMチャンネル6の **オン値** を設定"

#: ../onboard_mcu.rst:120
msgid "``0x27``"
msgstr "``0x27``"

#: ../onboard_mcu.rst:120
msgid "Set PWM channel 7 **On Value**"
msgstr "PWMチャンネル7の **オン値** を設定"

#: ../onboard_mcu.rst:122
msgid "``0x28``"
msgstr "``0x28``"

#: ../onboard_mcu.rst:122
msgid "Set PWM channel 8 **On Value**"
msgstr "PWMチャンネル8の **オン値** を設定"

#: ../onboard_mcu.rst:124
msgid "``0x29``"
msgstr "``0x29``"

#: ../onboard_mcu.rst:124
msgid "Set PWM channel 9 **On Value**"
msgstr "PWMチャンネル9の **オン値** を設定"

#: ../onboard_mcu.rst:126
msgid "``0x2A``"
msgstr "``0x2A``"

#: ../onboard_mcu.rst:126
msgid "Set PWM channel 10 **On Value**"
msgstr "PWMチャンネル10の **オン値** を設定"

#: ../onboard_mcu.rst:128
msgid "``0x2B``"
msgstr "``0x2B``"

#: ../onboard_mcu.rst:128
msgid "Set PWM channel 11 **On Value**"
msgstr "PWMチャンネル11の **オン値** を設定"

#: ../onboard_mcu.rst:130
msgid "``0x2C``"
msgstr "``0x2C``"

#: ../onboard_mcu.rst:130
msgid "Set Motor 2 speed **On Value**"
msgstr "モーター2の速度 **オン値** を設定"

#: ../onboard_mcu.rst:132
msgid "``0x2D``"
msgstr "``0x2D``"

#: ../onboard_mcu.rst:132
msgid "Set Motor 1 speed **On Value**"
msgstr "モーター1の速度 **オン値** を設定"

#: ../onboard_mcu.rst:136
msgid "Prescaler"
msgstr "プリスケーラー"

#: ../onboard_mcu.rst:138
msgid ""
"Register from 0x40 is to set the PWM prescaler. ranges from 0~65535. "
"There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"0x40から始まるレジスタはPWMプリスケーラーを設定するためのもので、範囲は0〜65535です。全14チャンネルに対してタイマーは4つのみです。"
" `PWMタイマー(重要)`_ を参照してください。"

#: ../onboard_mcu.rst:146
msgid "``0x40``"
msgstr "``0x40``"

#: ../onboard_mcu.rst:146
msgid "Set timer 0 **Prescaler**"
msgstr "タイマー0の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:148
msgid "``0x41``"
msgstr "``0x41``"

#: ../onboard_mcu.rst:148
msgid "Set timer 1 **Prescaler**"
msgstr "タイマー1の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:150
msgid "``0x42``"
msgstr "``0x42``"

#: ../onboard_mcu.rst:150
msgid "Set timer 2 **Prescaler**"
msgstr "タイマー2の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:152
msgid "``0x43``"
msgstr "``0x43``"

#: ../onboard_mcu.rst:152
msgid "Set timer 3 **Prescaler**"
msgstr "タイマー3の **プリスケーラー** を設定"

#: ../onboard_mcu.rst:156
msgid "Period"
msgstr "周期"

#: ../onboard_mcu.rst:158
msgid ""
"Register from 0x44 is to set the PWM period. ranges from 0~65535. There "
"are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"0x44から始まるレジスタはPWM周期を設定するためのもので、範囲は0〜65535です。全14チャンネルに対してタイマーは4つのみです。 "
"`PWMタイマー(重要)`_ を参照してください。"

#: ../onboard_mcu.rst:166
msgid "``0x44``"
msgstr "``0x44``"

#: ../onboard_mcu.rst:166
msgid "Set timer 0 **Period**"
msgstr "タイマー0の **周期** を設定"

#: ../onboard_mcu.rst:168
msgid "``0x45``"
msgstr "``0x45``"

#: ../onboard_mcu.rst:168
msgid "Set timer 1 **Period**"
msgstr "タイマー1の **周期** を設定"

#: ../onboard_mcu.rst:170
msgid "``0x46``"
msgstr "``0x46``"

#: ../onboard_mcu.rst:170
msgid "Set timer 2 **Period**"
msgstr "タイマー2の **周期** を設定"

#: ../onboard_mcu.rst:172
msgid "``0x47``"
msgstr "``0x47``"

#: ../onboard_mcu.rst:172
msgid "Set timer 3 **Period**"
msgstr "タイマー3の **周期** を設定"

#: ../onboard_mcu.rst:176
msgid "PWM Timer(IMPORTANT)"
msgstr "PWMタイマー（重要）"

#: ../onboard_mcu.rst:178
msgid ""
"What is PWM Timer? PWM Timer is a tool to turn on and off the PWM channel"
" for you."
msgstr "PWMタイマーとは何ですか？PWMタイマーは、PWMチャンネルをオン・オフするためのツールです。"

#: ../onboard_mcu.rst:180
msgid ""
"The MCU only have 4 timers for PWM: which means you cannot set frequency "
"on different channels at with the same timer."
msgstr "MCUにはPWM用のタイマーが4つしかありません：つまり、同じタイマーで異なるチャンネルの周波数を設定することはできません。"

#: ../onboard_mcu.rst:183
msgid ""
"Example: if you set frequency on channel 0, channel 1, 2, 3 will be "
"affected. If you change channel 2 frequency, channel 0, 1, 3 will be "
"override."
msgstr "例：チャンネル0に周波数を設定すると、チャンネル1、2、3に影響が及びます。チャンネル2の周波数を変更すると、チャンネル0、1、3が上書きされます。"

#: ../onboard_mcu.rst:186
msgid ""
"This happens like if you want to control both a passive buzzer (who "
"changes frequency all the time) and servo (who needs a fix frequency of "
"50Hz). Then you should seperate them into two different timer."
msgstr "これは、常に周波数を変更するパッシブブザーと固定周波数50Hzが必要なサーボを同時に制御したい場合のような状況です。この場合、それらを2つの異なるタイマーに分けるべきです。"

#: ../onboard_mcu.rst:192
msgid "Timer"
msgstr "タイマー"

#: ../onboard_mcu.rst:192
msgid "PWM Channel"
msgstr "PWMチャンネル"

#: ../onboard_mcu.rst:194
msgid "Timer 0"
msgstr "タイマー0"

#: ../onboard_mcu.rst:194
msgid "0, 1, 2, 3"
msgstr "0, 1, 2, 3"

#: ../onboard_mcu.rst:196
msgid "Timer 1"
msgstr "タイマー1"

#: ../onboard_mcu.rst:196
msgid "4, 5, 6, 7"
msgstr "4, 5, 6, 7"

#: ../onboard_mcu.rst:198
msgid "Timer 2"
msgstr "タイマー2"

#: ../onboard_mcu.rst:198
msgid "8, 9, 10, 11"
msgstr "8, 9, 10, 11"

#: ../onboard_mcu.rst:200
msgid "Timer 3"
msgstr "タイマー3"

#: ../onboard_mcu.rst:200
msgid "12, 13(for motors)"
msgstr "12, 13（モーター用）"

#: ../onboard_mcu.rst:204
msgid "Example"
msgstr "例"

#: ../onboard_mcu.rst:224
msgid "Reset MCU"
msgstr "MCUをリセット"

#: ../onboard_mcu.rst:226
msgid ""
"Currently the firmware reads a fix 3 byte value, then it can return ADC "
"values or control PWM. Thats why ADC register need 3byte with the latter "
"2 byte is 0."
msgstr "現在のファームウェアは固定3バイトの値を読み取り、その後ADC値を返すかPWMを制御できます。そのためADCレジスタは最後の2バイトが0の3バイトが必要です。"

#: ../onboard_mcu.rst:229
msgid ""
"And if your program is interrupted in the middle of the communication, "
"the firmware may stuck and offset the data. Even we have timeout on "
"waiting on 3 byte datas."
msgstr "そして、通信の途中でプログラムが中断されると、ファームウェアが固まってデータがずれる可能性があります。3バイトのデータ待ちにはタイムアウトも設定しています。"

#: ../onboard_mcu.rst:231
msgid ""
"If so, you need to reset the MCU. To reset it. You can use the robot_hat "
"command:"
msgstr "そのような場合は、MCUをリセットする必要があります。リセットするには、robot_hatコマンドを使用できます："

#: ../onboard_mcu.rst:237
msgid "Or you can do it in your python code:"
msgstr "または、Pythonコードで行うこともできます："

#: ../onboard_mcu.rst:244
msgid ""
"Or you can just pull down the reset pin (GPIO 5) for 10 ms, then pull it "
"back up for another 10ms, as that's what ``reset_mcu`` dose."
msgstr "あるいは、リセットピン（GPIO 5）を10ms引き下げてから、さらに10ms引き上げるだけで、それが ``reset_mcu`` が行うことです。"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../api.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../api.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../api.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../api.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../api.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api.rst:16
msgid "Reference"
msgstr "Referenz"

#: of robot_hat:1
msgid "Robot Hat Library"
msgstr "Robot Hat Bibliothek"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_photoresistor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_photoresistor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_photoresistor.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_photoresistor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_photoresistor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_photoresistor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_photoresistor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_photoresistor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_photoresistor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_photoresistor.rst:16
msgid "Read from Photoresistor Module"
msgstr "Lesen vom Fotowiderstandsmodul"

#: ../project_photoresistor.rst:18
msgid ""
"In this project, we detect the light intensity and display on the I2C "
"LCD1602."
msgstr ""
"In diesem Projekt erfassen wir die Lichtintensität und zeigen sie auf dem"
" I2C LCD1602 an."

#: ../project_photoresistor.rst:22
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_photoresistor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr ""
"In diesem Projekt wird ein I2C LCD1602 verwendet, daher ist es notwendig,"
" die relevanten Bibliotheken herunterzuladen, damit es funktioniert."

#: ../project_photoresistor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "Installieren Sie ``smbus2`` für I2C."

#: ../project_photoresistor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``photoresistor.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``photoresistor.ty``."

#: ../project_photoresistor.rst:78
msgid "Use the command ``sudo python3 photoresistor.ty`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 photoresistor.ty``, um diesen "
"Code auszuführen."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_i2c.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_i2c.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_i2c.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_i2c.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_i2c.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_i2c.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_i2c.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_i2c.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_i2c.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_i2c.rst:18
msgid "class ``I2C``"
msgstr "Klasse ``I2C``"

#: ../api_i2c.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_i2c.rst:44
msgid "For more information on the I2C protocol, see checkout adc.py and pwm.py"
msgstr "Für weitere Informationen zum I2C-Protokoll siehe adc.py und pwm.py"

#: ../api_i2c.rst:46
msgid "**API**"
msgstr "**API**"

#: of robot_hat.i2c.I2C:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.i2c.I2C:1
msgid "I2C bus read/write functions"
msgstr "I2C-Bus Lese-/Schreibfunktionen"

#: of robot_hat.i2c.I2C.__init__:1
msgid "Initialize the I2C bus"
msgstr "Initialisierung des I2C-Busses"

#: of robot_hat.i2c.I2C.__init__ robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.mem_write robot_hat.i2c.I2C.read robot_hat.i2c.I2C.write
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.i2c.I2C.__init__:3
msgid "I2C device address"
msgstr "I2C-Geräteadresse"

#: of robot_hat.i2c.I2C.__init__:5
msgid "I2C bus number"
msgstr "I2C-Busnummer"

#: of robot_hat.i2c.I2C.scan:1
msgid "Scan the I2C bus for devices"
msgstr "I2C-Bus nach Geräten scannen"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.i2c.I2C.scan:3
msgid "List of I2C addresses of devices found"
msgstr "Liste der gefundenen I2C-Adressen von Geräten"

#: of robot_hat.i2c.I2C.is_avaliable robot_hat.i2c.I2C.mem_read
#: robot_hat.i2c.I2C.read robot_hat.i2c.I2C.scan
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.i2c.I2C.write:1
msgid "Write data to the I2C device"
msgstr "Daten an das I2C-Gerät schreiben"

#: of robot_hat.i2c.I2C.write:3
msgid "Data to write"
msgstr "Zu schreibende Daten"

#: of robot_hat.i2c.I2C.write
msgid "raises"
msgstr "Wirft"

#: of robot_hat.i2c.I2C.write:5
msgid "ValueError if write is not an int, list or bytearray"
msgstr ""
"ValueError, falls die Schreiboperation kein int, keine Liste oder kein "
"Bytearray ist"

#: of robot_hat.i2c.I2C.read:1
msgid "Read data from I2C device"
msgstr "Daten vom I2C-Gerät lesen"

#: of robot_hat.i2c.I2C.mem_read:3 robot_hat.i2c.I2C.read:3
msgid "Number of bytes to receive"
msgstr "Anzahl der zu empfangenden Bytes"

#: of robot_hat.i2c.I2C.read:5
msgid "Received data"
msgstr "Empfangene Daten"

#: of robot_hat.i2c.I2C.mem_write:1
msgid "Send data to specific register address"
msgstr "Daten an eine spezifische Registeradresse senden"

#: of robot_hat.i2c.I2C.mem_write:3
msgid "Data to send, int, list or bytearray"
msgstr "Zu sendende Daten, int, Liste oder Bytearray"

#: of robot_hat.i2c.I2C.mem_read:5 robot_hat.i2c.I2C.mem_write:5
msgid "Register address"
msgstr "Registeradresse"

#: of robot_hat.i2c.I2C.mem_write
msgid "Raises"
msgstr "Wirft"

#: of robot_hat.i2c.I2C.mem_write:7
msgid "If data is not int, list, or bytearray"
msgstr "Falls die Daten kein int, keine Liste oder kein Bytearray sind"

#: of robot_hat.i2c.I2C.mem_read:1
msgid "Read data from specific register address"
msgstr "Daten von einer spezifischen Registeradresse lesen"

#: of robot_hat.i2c.I2C.mem_read:7
msgid "Received bytearray data or False if error"
msgstr "Empfangene Bytearray-Daten oder False bei einem Fehler"

#: of robot_hat.i2c.I2C.is_avaliable:1
msgid "Check if the I2C device is avaliable"
msgstr "Überprüfen, ob das I2C-Gerät verfügbar ist"

#: of robot_hat.i2c.I2C.is_avaliable:3
msgid "True if the I2C device is avaliable, False otherwise"
msgstr "True, wenn das I2C-Gerät verfügbar ist, andernfalls False"




##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_tts.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_tts.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_tts.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_tts.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_tts.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_tts.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_tts.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_tts.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_tts.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_tts.rst:18
msgid "class ``TTS``"
msgstr "Klasse ``TTS``"

#: ../api_tts.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr ""
"Sie müssen ``sudo`` hinzufügen, wenn Sie dieses Skript ausführen, falls "
"der Lautsprecher nicht funktioniert."

#: ../api_tts.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_tts.rst:24
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_tts.rst:39
msgid "**API**"
msgstr "**API**"

#: of robot_hat.tts.TTS:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.tts.TTS:1
msgid "Text to speech class"
msgstr "Text-zu-Sprache-Klasse"

#: ../docstring of robot_hat.TTS.SUPPORTED_LANGUAUE:1
msgid "Supported TTS language for pico2wave"
msgstr "Unterstützte TTS-Sprache für pico2wave"

#: ../docstring of robot_hat.TTS.ESPEAK:1
msgid "espeak TTS engine"
msgstr "espeak TTS-Engine"

#: ../docstring of robot_hat.TTS.PICO2WAVE:1
msgid "pico2wave TTS engine"
msgstr "pico2wave TTS-Engine"

#: of robot_hat.tts.TTS.__init__:1
msgid "Initialize TTS class."
msgstr "TTS-Klasse initialisieren."

#: of robot_hat.tts.TTS.__init__ robot_hat.tts.TTS.espeak
#: robot_hat.tts.TTS.espeak_params robot_hat.tts.TTS.lang
#: robot_hat.tts.TTS.pico2wave robot_hat.tts.TTS.say
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.tts.TTS.__init__:3
msgid "TTS engine, TTS.PICO2WAVE or TTS.ESPEAK"
msgstr "TTS-Engine, TTS.PICO2WAVE oder TTS.ESPEAK"

#: of robot_hat.tts.TTS.say:1
msgid "Say words."
msgstr "Worte aussprechen."

#: of robot_hat.tts.TTS.espeak:3 robot_hat.tts.TTS.pico2wave:3
#: robot_hat.tts.TTS.say:3
msgid "words to say."
msgstr "Zu sprechende Worte."

#: of robot_hat.tts.TTS.espeak:1
msgid "Say words with espeak."
msgstr "Worte mit espeak sprechen."

#: of robot_hat.tts.TTS.pico2wave:1
msgid "Say words with pico2wave."
msgstr "Worte mit pico2wave sprechen."

#: of robot_hat.tts.TTS.lang:1
msgid "Set/get language. leave empty to get current language."
msgstr ""
"Sprache einstellen/abfragen. Leer lassen, um die aktuelle Sprache zu "
"erhalten."

#: of robot_hat.tts.TTS.lang:3
msgid "language."
msgstr "Sprache."

#: of robot_hat.tts.TTS.supported_lang:1
msgid "Get supported language."
msgstr "Unterstützte Sprache abrufen."

#: of robot_hat.tts.TTS.supported_lang
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.tts.TTS.supported_lang:3
msgid "supported language."
msgstr "Unterstützte Sprache."

#: of robot_hat.tts.TTS.supported_lang
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.tts.TTS.espeak_params:1
msgid "Set espeak parameters."
msgstr "Espeak-Parameter einstellen."

#: of robot_hat.tts.TTS.espeak_params:3
msgid "amplitude."
msgstr "Amplitude."

#: of robot_hat.tts.TTS.espeak_params:5
msgid "speed."
msgstr "Geschwindigkeit."

#: of robot_hat.tts.TTS.espeak_params:7
msgid "gap."
msgstr "Lücke."

#: of robot_hat.tts.TTS.espeak_params:9
msgid "pitch."
msgstr "Tonhöhe."


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/hardware_introduction.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../hardware_introduction.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../hardware_introduction.rst:5
msgid "**Why Join?**"
msgstr "**Warum beitreten?**"

#: ../hardware_introduction.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../hardware_introduction.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../hardware_introduction.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../hardware_introduction.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../hardware_introduction.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../hardware_introduction.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../hardware_introduction.rst:16
msgid "Hardware Introduction"
msgstr "Hardware-Einführung"

#: ../hardware_introduction.rst:19
msgid "Pinout"
msgstr "Pinbelegung"

#: ../hardware_introduction.rst:27
msgid "**Power Port**"
msgstr "**Power Port**"

#: ../hardware_introduction.rst:26
msgid "6.0V-8.4V XH2.54 3pin power input."
msgstr "6.0V-8.4V XH2.54 3-Pin-Stromeingang."

#: ../hardware_introduction.rst:27
msgid "Powering the Raspberry Pi and Robot HAT at the same time."
msgstr "Gleichzeitige Stromversorgung des Raspberry Pi und des Robot HAT."

#: ../hardware_introduction.rst:30
msgid "**Power Switch**"
msgstr "**Power Switch**"

#: ../hardware_introduction.rst:30
msgid "Turn on/off the power of the robot HAT."
msgstr "Den Strom des Robot HAT ein-/ausschalten."

#: ../hardware_introduction.rst:36
msgid "**Type-C USB Port**"
msgstr "**Type-C USB Port**"

#: ../hardware_introduction.rst:33
msgid "Insert the Type-C cable to charge the battery."
msgstr "Stecken Sie das Type-C-Kabel ein, um die Batterie zu laden."

#: ../hardware_introduction.rst:34
msgid "At the same time, the charging indicator lights up in red color."
msgstr "Gleichzeitig leuchtet die Ladeanzeige in roter Farbe."

#: ../hardware_introduction.rst:35
msgid "When the battery is fully charged, the charging indicator turns off."
msgstr "Wenn die Batterie vollständig geladen ist, erlischt die Ladeanzeige."

#: ../hardware_introduction.rst:36
msgid ""
"If the USB cable is still plugged in about 4 hours after it is fully "
"charged, the charging indicator will blink to prompt."
msgstr ""
"Wenn das USB-Kabel etwa 4 Stunden nach vollständiger Aufladung noch "
"eingesteckt ist, blinkt die Ladeanzeige zur Erinnerung."

#: ../hardware_introduction.rst:41
msgid "**Digital Pin**"
msgstr "**Digital Pin**"

#: ../hardware_introduction.rst:39
msgid "4-channel digital pins, D0-D3."
msgstr "4-Kanal digitale Pins, D0-D3."

#: ../hardware_introduction.rst:40
msgid "Pin: :ref:`pin_digital`."
msgstr "Pin: :ref:`pin_digital`."

#: ../hardware_introduction.rst:41
msgid "API: :ref:`class_pin`."
msgstr "API: :ref:`class_pin`."

#: ../hardware_introduction.rst:46
msgid "**ADC Pin**"
msgstr "**ADC Pin**"

#: ../hardware_introduction.rst:44
msgid "4-channel ADC pins, A0-A3."
msgstr "4-Kanal ADC-Pins, A0-A3."

#: ../hardware_introduction.rst:45
msgid "Pin: :ref:`pin_adc`."
msgstr "Pin: :ref:`pin_adc`."

#: ../hardware_introduction.rst:46
msgid "API: :ref:`class_adc`."
msgstr "API: :ref:`class_adc`."

#: ../hardware_introduction.rst:51
msgid "**PWM Pin**"
msgstr "**PWM Pin**"

#: ../hardware_introduction.rst:49
msgid "12-channel PWM pins, P0-P11."
msgstr "12-Kanal PWM-Pins, P0-P11."

#: ../hardware_introduction.rst:50
msgid "Pin: :ref:`pin_pwm`."
msgstr "Pin: :ref:`pin_pwm`."

#: ../hardware_introduction.rst:51
msgid "API: :ref:`class_pwm`."
msgstr "API: :ref:`class_pwm`."

#: ../hardware_introduction.rst:56
msgid "**Left/Right Motor Port**"
msgstr "**Left/Right Motor Port**"

#: ../hardware_introduction.rst:54
msgid "2-channel XH2.54 motor ports."
msgstr "2-Kanal XH2.54 Motoranschlüsse."

#: ../hardware_introduction.rst:55
msgid "Pin: :ref:`pin_motor`."
msgstr "Pin: :ref:`pin_motor`."

#: ../hardware_introduction.rst:56
msgid ""
"API: :ref:`class_motor`, ``1`` for left motor port, ``2`` for right motor"
" port."
msgstr ""
"API: :ref:`class_motor`, ``1`` für den linken Motoranschluss, ``2`` für "
"den rechten Motoranschluss."

#: ../hardware_introduction.rst:63
msgid "**I2C Pin and I2C Port**"
msgstr "**I2C Pin und I2C Port**"

#: ../hardware_introduction.rst:59
msgid "**I2C Pin**: P2.54 4-pin interface."
msgstr "**I2C Pin**: P2.54 4-Pin-Schnittstelle."

#: ../hardware_introduction.rst:60
msgid ""
"**I2C Port**: SH1.0 4-pin interface, which is compatible with QWIIC and "
"STEMMA QT."
msgstr ""
"**I2C Port**: SH1.0 4-Pin-Schnittstelle, kompatibel mit QWIIC und STEMMA "
"QT."

#: ../hardware_introduction.rst:61
msgid ""
"These I2C interfaces are connected to the Raspberry Pi's I2C interface "
"via GPIO2 (SDA) and GPIO3 (SCL)."
msgstr ""
"Diese I2C-Schnittstellen sind über GPIO2 (SDA) und GPIO3 (SCL) mit der "
"I2C-Schnittstelle des Raspberry Pi verbunden."

#: ../hardware_introduction.rst:62
msgid "Pin: :ref:`pin_i2c`."
msgstr "Pin: :ref:`pin_i2c`."

#: ../hardware_introduction.rst:63
msgid "API: :ref:`class_i2c`."
msgstr "API: :ref:`class_i2c`."

#: ../hardware_introduction.rst:67
msgid "**SPI Pin**"
msgstr "**SPI Pin**"

#: ../hardware_introduction.rst:66
msgid "P2.54 7-pin SPI interface."
msgstr "P2.54 7-Pin SPI-Schnittstelle."

#: ../hardware_introduction.rst:67
msgid "Pin: :ref:`pin_spi`."
msgstr "Pin: :ref:`pin_spi`."

#: ../hardware_introduction.rst:71
msgid "**UART Pin**"
msgstr "**UART Pin**"

#: ../hardware_introduction.rst:70
msgid "P2.54 4-pin interface."
msgstr "P2.54 4-Pin-Schnittstelle."

#: ../hardware_introduction.rst:71
msgid "Pin: :ref:`pin_uart`."
msgstr "Pin: :ref:`pin_uart`."

#: ../hardware_introduction.rst:77
msgid "**RST Button**"
msgstr "**RST Button**"

#: ../hardware_introduction.rst:74
msgid ""
"The RST button, when using Ezblock, serves as a button to restart the "
"Ezblock program."
msgstr ""
"Der RST-Knopf dient bei Verwendung von Ezblock als Knopf zum Neustarten "
"des Ezblock-Programms."

#: ../hardware_introduction.rst:75
msgid ""
"If not using Ezblock, the RST button does not have a predefined function "
"and can be fully customized according to your needs."
msgstr ""
"Wenn Ezblock nicht verwendet wird, hat der RST-Knopf keine vordefinierte "
"Funktion und kann ganz nach Ihren Bedürfnissen angepasst werden."

#: ../hardware_introduction.rst:76 ../hardware_introduction.rst:82
msgid "Pin: :ref:`pin_button`."
msgstr "Pin: :ref:`pin_button`."

#: ../hardware_introduction.rst:77
msgid "API: :ref:`class_pin`"
msgstr "API: :ref:`class_pin`"

#: ../hardware_introduction.rst:82
msgid "**USR Button**"
msgstr "**USR Button**"

#: ../hardware_introduction.rst:80
msgid ""
"The functions of USR Button can be set by your programming. (Pressing "
"down leads to a input “0”; releasing produces a input “1”. )"
msgstr ""
"Die Funktionen des USR-Knopfs können durch Ihre Programmierung festgelegt"
" werden. (Herunterdrücken führt zu einem Eingang „0“; Loslassen erzeugt "
"einen Eingang „1“.)"

#: ../hardware_introduction.rst:81
msgid "API: :ref:`class_pin`, you can use ``Pin(\"SW\")`` to define it."
msgstr ""
"API: :ref:`class_pin`, Sie können ``Pin(\"SW\")`` verwenden, um ihn zu "
"definieren."

#: ../hardware_introduction.rst:88
msgid "**Battery Indicator**"
msgstr "**Battery Indicator**"

#: ../hardware_introduction.rst:85
msgid "Two LEDs light up when the voltage is higher than 7.6V."
msgstr "Zwei LEDs leuchten auf, wenn die Spannung höher als 7,6V ist."

#: ../hardware_introduction.rst:86
msgid "One LED lights up in the 7.15V to 7.6V range."
msgstr "Eine LED leuchtet im Bereich von 7,15V bis 7,6V."

#: ../hardware_introduction.rst:87
msgid "Below 7.15V, both LEDs turn off."
msgstr "Unter 7,15V schalten sich beide LEDs aus."

#: ../hardware_introduction.rst:88
msgid ":ref:`battery_indicator`."
msgstr ":ref:`battery_indicator`."

#: ../hardware_introduction.rst:96
msgid "**Speaker and Speaker Port**"
msgstr "**Speaker and Speaker Port**"

#: ../hardware_introduction.rst:91
msgid "**Speaker**: This is a 2030 audio chamber speaker."
msgstr "**Speaker**: Dies ist ein 2030 Audio-Kammerlautsprecher."

#: ../hardware_introduction.rst:92
msgid ""
"**Speaker Port**: The Robot HAT is equipped with onboard I2S audio "
"output, along with a 2030 audio chamber speaker, providing a mono sound "
"output."
msgstr ""
"**Speaker Port**: Der Robot HAT ist mit einem Onboard-I2S-Audioausgang "
"ausgestattet, zusammen mit einem 2030 Audio-Kammerlautsprecher, der einen"
" Mono-Soundausgang bietet."

#: ../hardware_introduction.rst:93
msgid "Pin: :ref:`pin_speaker`."
msgstr "Pin: :ref:`pin_speaker`."

#: ../hardware_introduction.rst:94
msgid "API: :ref:`class_music`"
msgstr "API: :ref:`class_music`"

#: ../hardware_introduction.rst:99
msgid "Pin Mapping"
msgstr "Pin-Belegung"

#: ../hardware_introduction.rst:101
msgid "Raspberry Pi IO"
msgstr "Raspberry Pi IO"

#: ../hardware_introduction.rst:105 ../hardware_introduction.rst:108
#: ../hardware_introduction.rst:203 ../hardware_introduction.rst:276
#: ../hardware_introduction.rst:315
msgid "Robot Hat V4"
msgstr "Robot Hat V4"

#: ../hardware_introduction.rst:106 ../hardware_introduction.rst:107
#: ../hardware_introduction.rst:204 ../hardware_introduction.rst:277
#: ../hardware_introduction.rst:316 ../hardware_introduction.rst:337
msgid "Raspberry Pi"
msgstr "Raspberry Pi"

#: ../hardware_introduction.rst:109 ../hardware_introduction.rst:141
#: ../hardware_introduction.rst:160 ../hardware_introduction.rst:161
#: ../hardware_introduction.rst:164 ../hardware_introduction.rst:184
msgid "NC"
msgstr "NC"

#: ../hardware_introduction.rst:110 ../hardware_introduction.rst:142
#: ../hardware_introduction.rst:288
msgid "3V3"
msgstr "3V3"

#: ../hardware_introduction.rst:111 ../hardware_introduction.rst:112
#: ../hardware_introduction.rst:115 ../hardware_introduction.rst:116
msgid "5V"
msgstr "5V"

#: ../hardware_introduction.rst:113 ../hardware_introduction.rst:114
msgid "SDA"
msgstr "SDA"

#: ../hardware_introduction.rst:117 ../hardware_introduction.rst:118
msgid "SCL"
msgstr "SCL"

#: ../hardware_introduction.rst:119 ../hardware_introduction.rst:120
#: ../hardware_introduction.rst:125 ../hardware_introduction.rst:126
#: ../hardware_introduction.rst:135 ../hardware_introduction.rst:136
#: ../hardware_introduction.rst:147 ../hardware_introduction.rst:148
#: ../hardware_introduction.rst:157 ../hardware_introduction.rst:158
#: ../hardware_introduction.rst:167 ../hardware_introduction.rst:168
#: ../hardware_introduction.rst:175 ../hardware_introduction.rst:176
#: ../hardware_introduction.rst:185 ../hardware_introduction.rst:186
#: ../hardware_introduction.rst:290
msgid "GND"
msgstr "GND"

#: ../hardware_introduction.rst:121 ../hardware_introduction.rst:209
msgid "D1"
msgstr "D1"

#: ../hardware_introduction.rst:122 ../hardware_introduction.rst:210
msgid "GPIO4"
msgstr "GPIO4"

#: ../hardware_introduction.rst:123 ../hardware_introduction.rst:124
msgid "TXD"
msgstr "TXD"

#: ../hardware_introduction.rst:127 ../hardware_introduction.rst:128
msgid "RXD"
msgstr "RXD"

#: ../hardware_introduction.rst:129 ../hardware_introduction.rst:206
msgid "D0"
msgstr "D0"

#: ../hardware_introduction.rst:130 ../hardware_introduction.rst:207
msgid "GPIO17"
msgstr "GPIO17"

#: ../hardware_introduction.rst:131 ../hardware_introduction.rst:341
msgid "GPIO18"
msgstr "GPIO18"

#: ../hardware_introduction.rst:132
msgid "I2S BCLK"
msgstr "I2S BCLK"

#: ../hardware_introduction.rst:133 ../hardware_introduction.rst:212
msgid "D2"
msgstr "D2"

#: ../hardware_introduction.rst:134 ../hardware_introduction.rst:213
msgid "GPIO27"
msgstr "GPIO27"

#: ../hardware_introduction.rst:137 ../hardware_introduction.rst:215
msgid "D3"
msgstr "D3"

#: ../hardware_introduction.rst:138 ../hardware_introduction.rst:216
msgid "GPIO22"
msgstr "GPIO22"

#: ../hardware_introduction.rst:139 ../hardware_introduction.rst:360
msgid "GPIO23"
msgstr "GPIO23"

#: ../hardware_introduction.rst:140
msgid "MOTOR 1 DIR"
msgstr "MOTOR 1 DIR"

#: ../hardware_introduction.rst:143 ../hardware_introduction.rst:364
msgid "GPIO24"
msgstr "GPIO24"

#: ../hardware_introduction.rst:144
msgid "MOTOR 2 DIR"
msgstr "MOTOR 2 RICHTUNG"

#: ../hardware_introduction.rst:145
msgid "SPI MOSI"
msgstr "SPI MOSI"

#: ../hardware_introduction.rst:146
msgid "MOSI"
msgstr "MOSI"

#: ../hardware_introduction.rst:149
msgid "SPI MISO"
msgstr "SPI MISO"

#: ../hardware_introduction.rst:150
msgid "MISO"
msgstr "MISO"

#: ../hardware_introduction.rst:151 ../hardware_introduction.rst:320
msgid "GPIO25"
msgstr "GPIO25"

#: ../hardware_introduction.rst:152
msgid "USR BUTTON"
msgstr "USR-TASTE"

#: ../hardware_introduction.rst:153
msgid "SPI SCLK"
msgstr "SPI SCLK"

#: ../hardware_introduction.rst:154
msgid "SCLK"
msgstr "SCLK"

#: ../hardware_introduction.rst:155
msgid "CE0"
msgstr "CE0"

#: ../hardware_introduction.rst:156
msgid "SPI CE0"
msgstr "SPI CE0"

#: ../hardware_introduction.rst:159
msgid "CE1"
msgstr "CE1"

#: ../hardware_introduction.rst:162
msgid "ID_SD"
msgstr "ID_SD"

#: ../hardware_introduction.rst:163
msgid "ID_SC"
msgstr "ID_SC"

#: ../hardware_introduction.rst:165
msgid "MCU Reset"
msgstr "MCU-Reset"

#: ../hardware_introduction.rst:166
msgid "GPIO5"
msgstr "GPIO5"

#: ../hardware_introduction.rst:169
msgid "(SPI)BSY"
msgstr "(SPI)BSY"

#: ../hardware_introduction.rst:170 ../hardware_introduction.rst:279
msgid "GPIO6"
msgstr "GPIO6"

#: ../hardware_introduction.rst:171
msgid "GPIO12"
msgstr "GPIO12"

#: ../hardware_introduction.rst:172
msgid "Board Identifier 2"
msgstr "Platinen-Identifikator 2"

#: ../hardware_introduction.rst:173
msgid "Board Identifier 1"
msgstr "Platinen-Identifikator 1"

#: ../hardware_introduction.rst:174
msgid "GPIO13"
msgstr "GPIO13"

#: ../hardware_introduction.rst:177
msgid "I2S LRCLK"
msgstr "I2S LRCLK"

#: ../hardware_introduction.rst:178 ../hardware_introduction.rst:339
msgid "GPIO19"
msgstr "GPIO19"

#: ../hardware_introduction.rst:179 ../hardware_introduction.rst:322
msgid "GPIO16"
msgstr "GPIO16"

#: ../hardware_introduction.rst:180
msgid "RST BUTTON"
msgstr "RST-TASTE"

#: ../hardware_introduction.rst:181
msgid "USER LED"
msgstr "BENUTZER-LED"

#: ../hardware_introduction.rst:182 ../hardware_introduction.rst:318
msgid "GPIO26"
msgstr "GPIO26"

#: ../hardware_introduction.rst:183
msgid "GPIO20"
msgstr "GPIO20"

#: ../hardware_introduction.rst:187 ../hardware_introduction.rst:343
msgid "GPIO21"
msgstr "GPIO21"

#: ../hardware_introduction.rst:188
msgid "I2S SDATA"
msgstr "I2S SDATA"

#: ../hardware_introduction.rst:193 ../hardware_introduction.rst:199
msgid "Digital IO"
msgstr "Digitaler IO"

#: ../hardware_introduction.rst:195
msgid "Robot HAT has 4 sets of P2.54 3Pin digital pins."
msgstr "Der Robot HAT hat 4 Sätze von P2.54 3Pin digitalen Pins."

#: ../hardware_introduction.rst:221
msgid "ADC"
msgstr "ADC"

#: ../hardware_introduction.rst:225
msgid ""
"The Robot HAT features four sets of 3Pin ADC (Analog to Digital "
"Converter) pins, each spaced 2.54mm apart. These pins operate at a 3.3V "
"power supply. The ADC function, offering 12-bit precision, is facilitated"
" by an onboard microcontroller. Detailed instructions for reading ADC "
"values are provided in the :ref:`on_board_mcu` section."
msgstr ""
"Der Robot HAT verfügt über vier Sätze von 3Pin ADC (Analog-Digital-"
"Wandler) Pins, jeweils im Abstand von 2,54 mm. Diese Pins arbeiten mit "
"einer 3,3V Stromversorgung. Die ADC-Funktion, die eine 12-Bit-Präzision "
"bietet, wird durch einen Mikrocontroller an Bord erleichtert. "
"Detaillierte Anweisungen zum Lesen der ADC-Werte finden Sie im Abschnitt "
":ref:`on_board_mcu`."

#: ../hardware_introduction.rst:229
msgid ""
"Also, ADC channel A4 is connected to the battery through a voltage "
"divider using resistors, which will be used to measure the battery "
"voltage to estimate the approximate battery charge."
msgstr ""
"Außerdem ist der ADC-Kanal A4 über einen Spannungsteiler mit Widerständen"
" mit der Batterie verbunden, der zur Messung der Batteriespannung zur "
"Schätzung der ungefähren Batterieladung verwendet wird."

#: ../hardware_introduction.rst:232
msgid "The voltage divider ratio is 20K/10K, so:"
msgstr "Das Verhältnis des Spannungsteilers beträgt 20K/10K, also:"

#: ../hardware_introduction.rst:234
msgid "A4 voltage (Va4) = value_A4 / 4095.0 * 3.3"
msgstr "A4-Spannung (Va4) = Wert_A4 / 4095.0 * 3.3"

#: ../hardware_introduction.rst:235
msgid "Battery voltage (Vbat) = Va4*3"
msgstr "Batteriespannung (Vbat) = Va4*3"

#: ../hardware_introduction.rst:236
msgid "Battery voltage (Vbat) = value_A4 / 4095.0 * 3.3 * 3"
msgstr "Batteriespannung (Vbat) = Wert_A4 / 4095.0 * 3.3 * 3"

#: ../hardware_introduction.rst:241
msgid "PWM"
msgstr "PWM"

#: ../hardware_introduction.rst:245
msgid ""
"Robot HAT has 4 sets of 3Pin PWM pins, each spaced 2.54mm apart, and the "
"power supply is 5V. The method of using the PWM is described in detail in"
" :ref:`on_board_mcu`."
msgstr ""
"Der Robot HAT hat 4 Sätze von 3Pin PWM-Pins, jeweils im Abstand von 2,54 "
"mm, und die Stromversorgung beträgt 5V. Die Methode zur Verwendung des "
"PWM wird im Detail in :ref:`on_board_mcu` beschrieben."

#: ../hardware_introduction.rst:248
msgid "PWM13 & 14 channels are used for motor drive."
msgstr "Die Kanäle PWM13 & 14 werden für den Motorantrieb verwendet."

#: ../hardware_introduction.rst:253
msgid "I2C"
msgstr "I2C"

#: ../hardware_introduction.rst:257
msgid ""
"The Robot HAT has two I2C interfaces. One is the P2.54 4-pin interface, "
"and the other is the SH1.0 4-pin interface, which is compatible with "
"QWIIC and STEMMA QT. These I2C interfaces are connected to the Raspberry "
"Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL). The board also "
"features an :ref:`on_board_mcu`, and the two signal lines have 10K pull-"
"up resistors."
msgstr ""
"Der Robot HAT verfügt über zwei I2C-Schnittstellen. Eine davon ist die "
"P2.54 4-Pin-Schnittstelle und die andere ist die SH1.0 4-Pin-"
"Schnittstelle, die mit QWIIC und STEMMA QT kompatibel ist. Diese I2C-"
"Schnittstellen sind über GPIO2 (SDA) und GPIO3 (SCL) mit der I2C-"
"Schnittstelle des Raspberry Pi verbunden. Das Board verfügt auch über "
"einen :ref:`on_board_mcu`, und die beiden Signalleitungen haben 10K Pull-"
"up-Widerstände."

#: ../hardware_introduction.rst:264 ../hardware_introduction.rst:272
msgid "SPI"
msgstr "SPI"

#: ../hardware_introduction.rst:268
msgid ""
"The SPI interface of the Robot HAT is a 7-pin P2.54 interface. It "
"connects to the SPI interface of the Raspberry Pi and includes an "
"additional I/O pin that can be used for purposes such as interrupts or "
"resets."
msgstr ""
"Die SPI-Schnittstelle des Robot HAT ist eine 7-Pin P2.54-Schnittstelle. "
"Sie verbindet sich mit der SPI-Schnittstelle des Raspberry Pi und umfasst"
" einen zusätzlichen I/O-Pin, der für Zwecke wie Interrupts oder Resets "
"verwendet werden kann."

#: ../hardware_introduction.rst:278
msgid "BSY"
msgstr "BSY"

#: ../hardware_introduction.rst:280
msgid "CS"
msgstr "CS"

#: ../hardware_introduction.rst:281
msgid "CE0(GPIO8)"
msgstr "CE0(GPIO8)"

#: ../hardware_introduction.rst:282
msgid "SCK"
msgstr "SCK"

#: ../hardware_introduction.rst:283
msgid "SCLK(GPIO11)"
msgstr "SCLK(GPIO11)"

#: ../hardware_introduction.rst:284
msgid "MI"
msgstr "MI"

#: ../hardware_introduction.rst:285
msgid "MISO(GPIO9)"
msgstr "MISO(GPIO9)"

#: ../hardware_introduction.rst:286
msgid "MO"
msgstr "MO"

#: ../hardware_introduction.rst:287
msgid "MOSI(GPIO10)"
msgstr "MOSI(GPIO10)"

#: ../hardware_introduction.rst:289
msgid "3.3V Power"
msgstr "3.3V Strom"

#: ../hardware_introduction.rst:291
msgid "Ground"
msgstr "Masse"

#: ../hardware_introduction.rst:296
msgid "UART"
msgstr "UART"

#: ../hardware_introduction.rst:300
msgid ""
"The UART interface of the Robot HAT is a 4-pin P2.54 interface. It "
"connects to the Raspberry Pi's GPIO14 (TXD) and GPIO15 (RXD) pins."
msgstr ""
"Die UART-Schnittstelle des Robot HAT ist eine 4-Pin P2.54-Schnittstelle. "
"Sie verbindet sich mit den GPIO14 (TXD) und GPIO15 (RXD) Pins des "
"Raspberry Pi."

#: ../hardware_introduction.rst:305
msgid "Buttons"
msgstr "Tasten"

#: ../hardware_introduction.rst:307
msgid ""
"The Robot HAT comes with 1 LED and 2 buttons, all directly connected to "
"the Raspberry Pi's GPIO pins. The RST button, when using Ezblock, serves "
"as a button to restart the Ezblock program. If not using Ezblock, the RST"
" button does not have a predefined function and can be fully customized "
"according to your needs."
msgstr ""
"Der Robot HAT wird mit 1 LED und 2 Tasten geliefert, die alle direkt mit "
"den GPIO-Pins des Raspberry Pi verbunden sind. Die RST-Taste dient bei "
"der Verwendung von Ezblock als Taste zum Neustart des Ezblock-Programms. "
"Wird Ezblock nicht verwendet, hat die RST-Taste keine vordefinierte "
"Funktion und kann ganz nach Ihren Bedürfnissen angepasst werden."

#: ../hardware_introduction.rst:311
msgid "LED & Button"
msgstr "LED & Taste"

#: ../hardware_introduction.rst:317
msgid "LED"
msgstr "LED"

#: ../hardware_introduction.rst:319
msgid "USR"
msgstr "USR"

#: ../hardware_introduction.rst:321
msgid "RST"
msgstr "RST"

#: ../hardware_introduction.rst:327
msgid "Speaker and Speaker Port"
msgstr "Lautsprecher und Lautsprecheranschluss"

#: ../hardware_introduction.rst:329
msgid ""
"The Robot HAT is equipped with onboard I2S audio output, along with a "
"2030 audio chamber speaker, providing a mono sound output."
msgstr ""
"Der Robot HAT ist mit einem Onboard-I2S-Audioausgang sowie einem 2030 "
"Audio-Kammerlautsprecher ausgestattet, der einen Monoklang-Ausgang "
"bietet."

#: ../hardware_introduction.rst:332 ../hardware_introduction.rst:336
msgid "I2S"
msgstr "I2S"

#: ../hardware_introduction.rst:338
msgid "LRCLK"
msgstr "LRCLK"

#: ../hardware_introduction.rst:340
msgid "BCLK"
msgstr "BCLK"

#: ../hardware_introduction.rst:342
msgid "SDATA"
msgstr "SDATA"

#: ../hardware_introduction.rst:348
msgid "Motor Port"
msgstr "Motoranschluss"

#: ../hardware_introduction.rst:350
msgid ""
"The motor driver of the Robot HAT supports 2 channels and can be "
"controlled using 2 digital signals for direction and 2 PWM signals for "
"speed control."
msgstr ""
"Der Motortreiber des Robot HAT unterstützt 2 Kanäle und kann mit 2 "
"digitalen Signalen zur Richtungssteuerung und 2 PWM-Signalen zur "
"Geschwindigkeitsregelung gesteuert werden."

#: ../hardware_introduction.rst:353
msgid "Motor Driver"
msgstr "Motortreiber"

#: ../hardware_introduction.rst:357
msgid "Motor"
msgstr "Motor"

#: ../hardware_introduction.rst:358
msgid "IO"
msgstr "IO"

#: ../hardware_introduction.rst:359
msgid "Motor1 Dir"
msgstr "Motor1 Richtung"

#: ../hardware_introduction.rst:361
msgid "Motor1 Power"
msgstr "Motor1 Leistung"

#: ../hardware_introduction.rst:362
msgid "PWM13"
msgstr "PWM13"

#: ../hardware_introduction.rst:363
msgid "Motor2 Dir"
msgstr "Motor2 Richtung"

#: ../hardware_introduction.rst:365
msgid "Motor2 Power"
msgstr "Motor2 Leistung"

#: ../hardware_introduction.rst:366
msgid "PWM12"
msgstr "PWM12"

#: ../hardware_introduction.rst:371
msgid "Battery Level Indicator"
msgstr "Batteriestandsanzeige"

#: ../hardware_introduction.rst:373
msgid ""
"The battery level indicator on the Robot HAT monitors the battery voltage"
" using a voltage divider method and serves as a reference for estimating "
"the battery level. The relationship between the LED and voltage is as "
"follows:"
msgstr ""
"Die Batteriestandsanzeige auf dem Robot HAT überwacht die "
"Batteriespannung mithilfe einer Spannungsteiler-Methode und dient als "
"Referenz zur Schätzung des Batteriestands. Die Beziehung zwischen der LED"
" und der Spannung ist wie folgt:"

#: ../hardware_introduction.rst:376
msgid "Battery Level"
msgstr "Batteriestand"

#: ../hardware_introduction.rst:380
msgid "LED Battery"
msgstr "LED Batterie"

#: ../hardware_introduction.rst:381
msgid "Total Voltage"
msgstr "Gesamtspannung"

#: ../hardware_introduction.rst:382
msgid "2 LEDs on"
msgstr "2 LEDs an"

#: ../hardware_introduction.rst:383
msgid "Greater than 7.6V"
msgstr "Mehr als 7,6V"

#: ../hardware_introduction.rst:384
msgid "1 LED on"
msgstr "1 LED an"

#: ../hardware_introduction.rst:385
msgid "Greater than 7.15V"
msgstr "Mehr als 7,15V"

#: ../hardware_introduction.rst:386
msgid "Both LEDs off"
msgstr "Beide LEDs aus"

#: ../hardware_introduction.rst:387
msgid "Less than 7.15V"
msgstr "Weniger als 7,15V"

#: ../hardware_introduction.rst:389
msgid ""
"When any one of the batteries reaches or exceeds 4.1V while the others "
"are below that threshold, the charging current of that specific battery "
"will be reduced."
msgstr ""
"Wenn eine der Batterien 4,1V erreicht oder überschreitet, während die "
"anderen darunter liegen, wird der Ladestrom dieser spezifischen Batterie "
"reduziert."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/community_tutorials.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../community_tutorials.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../community_tutorials.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../community_tutorials.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../community_tutorials.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../community_tutorials.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../community_tutorials.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../community_tutorials.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../community_tutorials.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../community_tutorials.rst:16
msgid "Community Tutorials"
msgstr "Community-Tutorials"

#: ../community_tutorials.rst:18
msgid "|link_peppe8o|"
msgstr "|link_peppe8o|"

#: ../community_tutorials.rst:20
msgid ""
"This document summarizes the SunFounder Raspberry Pi Robot HAT, covering "
"its purpose, compatibility, specifications, and testing:"
msgstr ""
"Dieses Dokument fasst den SunFounder Raspberry Pi Robot HAT zusammen und "
"beschreibt seinen Zweck, Kompatibilität, Spezifikationen und "
"Testverfahren:"

#: ../community_tutorials.rst:22
msgid ""
"**Introduction**: Explains the Robot HAT's role in simplifying control "
"for Raspberry Pi-based DIY robot projects."
msgstr ""
"**Einführung**: Erklärt die Rolle des Robot HAT bei der Vereinfachung der"
" Steuerung für DIY-Roboterprojekte basierend auf dem Raspberry Pi."

#: ../community_tutorials.rst:23
msgid ""
"**Specifications**: Details the technical specs, including power input, "
"battery details, ports, and motor driver features."
msgstr ""
"**Spezifikationen**: Beschreibt die technischen Daten, einschließlich "
"Stromzufuhr, Batterieangaben, Anschlüsse und Merkmale des Motortreibers."

#: ../community_tutorials.rst:24
msgid ""
"**Ports Overview**: Describes various ports like Power, Digital, Analog, "
"PWM, I2C, SPI, UART, and Motor Ports."
msgstr ""
"**Übersicht der Anschlüsse**: Beschreibt verschiedene Anschlüsse wie "
"Strom, Digital, Analog, PWM, I2C, SPI, UART und Motoranschlüsse."

#: ../community_tutorials.rst:25
msgid ""
"**Additional Components**: Highlights extra components like buttons, LED,"
" and speaker, with Raspberry Pi PIN mappings."
msgstr ""
"**Zusätzliche Komponenten**: Hebt zusätzliche Komponenten wie Tasten, LED"
" und Lautsprecher hervor, mit Zuordnung zu den Raspberry Pi-Pins."

#: ../community_tutorials.rst:26
msgid ""
"**Setup and Testing**: Guides on mounting the Robot HAT, necessary "
"components, and testing procedures for features like LED and servo "
"motors."
msgstr ""
"**Einrichtung und Testen**: Anleitungen zum Montieren des Robot HAT, zu "
"den notwendigen Komponenten und zu Testverfahren für Funktionen wie LED "
"und Servomotoren."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_robot.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_robot.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_robot.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_robot.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_robot.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_robot.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_robot.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_robot.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_robot.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_robot.rst:18
msgid "class ``Robot``"
msgstr "Klasse ``Robot``"

#: ../api_robot.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_robot.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.robot.Robot:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.robot.Robot:1
msgid "Robot class"
msgstr "Robot-Klasse"

#: of robot_hat.robot.Robot:3
msgid "This class is for makeing a servo robot with Robot HAT"
msgstr "Diese Klasse dient zum Erstellen eines Servo-Roboters mit dem Robot HAT"

#: of robot_hat.robot.Robot:5
msgid ""
"There are servo initialization, all servo move in specific speed. servo "
"offset and stuff. make it easy to make a robot. All Pi-series robot from "
"SunFounder use this class. Check them out for more details."
msgstr ""
"Es gibt eine Servo-Initialisierung, alle Servos bewegen sich mit einer "
"spezifischen Geschwindigkeit. Servo-Offset und so weiter. Es erleichtert "
"das Erstellen eines Roboters. Alle Pi-Serie Roboter von SunFounder "
"verwenden diese Klasse. Schauen Sie sich diese für weitere Details an."

#: of robot_hat.robot.Robot:8
msgid "PiSloth: https://github.com/sunfounder/pisloth"
msgstr "PiSloth: https://github.com/sunfounder/pisloth"

#: of robot_hat.robot.Robot:10
msgid "PiArm: https://github.com/sunfounder/piarm"
msgstr "PiArm: https://github.com/sunfounder/piarm"

#: of robot_hat.robot.Robot:12
msgid "PiCrawler: https://github.com/sunfounder/picrawler"
msgstr "PiCrawler: https://github.com/sunfounder/picrawler"

#: ../docstring of robot_hat.Robot.move_list:1
msgid "Preset actions"
msgstr "Voreingestellte Aktionen"

#: ../docstring of robot_hat.Robot.max_dps:1
msgid "Servo max Degree Per Second"
msgstr "Servo maximale Grad pro Sekunde"

#: of robot_hat.robot.Robot.__init__:1
msgid "Initialize the robot class"
msgstr "Die Robot-Klasse initialisieren"

#: of robot_hat.robot.Robot.__init__ robot_hat.robot.Robot.do_action
#: robot_hat.robot.Robot.new_list robot_hat.robot.Robot.servo_move
#: robot_hat.robot.Robot.servo_write_all robot_hat.robot.Robot.servo_write_raw
#: robot_hat.robot.Robot.set_offset
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.robot.Robot.__init__:3
msgid "list of pin number[0-11]"
msgstr "Liste der Pin-Nummern [0-11]"

#: of robot_hat.robot.Robot.__init__:5
msgid "config file path"
msgstr "Pfad zur Konfigurationsdatei"

#: of robot_hat.robot.Robot.__init__:7
msgid "robot name"
msgstr "Robotername"

#: of robot_hat.robot.Robot.__init__:9
msgid "list of initial angles"
msgstr "Liste der Anfangswinkel"

#: of robot_hat.robot.Robot.__init__:11
msgid ""
"list of initialization order(Servos will init one by one in case of "
"sudden huge current, pulling down the power supply voltage. default order"
" is the pin list. in some cases, you need different order, use this "
"parameter to set it.)"
msgstr ""
"Liste der Initialisierungsreihenfolge (Servos werden einzeln "
"initialisiert, falls es zu einem plötzlichen starken Strom kommt, der die"
" Spannung der Stromversorgung herunterzieht. Die Standardreihenfolge ist "
"die Pin-Liste. In einigen Fällen benötigen Sie eine andere Reihenfolge, "
"verwenden Sie diesen Parameter, um sie festzulegen.)"

#: of robot_hat.robot.Robot.new_list:1
msgid "Create a list of servo angles with default value"
msgstr "Erstellen Sie eine Liste von Servowinkeln mit Standardwert"

#: of robot_hat.robot.Robot.new_list:3
msgid "default value of servo angles"
msgstr "Standardwert der Servowinkel"

#: of robot_hat.robot.Robot.new_list
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.robot.Robot.new_list:5 robot_hat.robot.Robot.servo_move:3
#: robot_hat.robot.Robot.servo_write_all:3
#: robot_hat.robot.Robot.servo_write_raw:3 robot_hat.robot.Robot.set_offset:3
msgid "list of servo angles"
msgstr "Liste der Servowinkel"

#: of robot_hat.robot.Robot.new_list
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.robot.Robot.servo_write_raw:1
msgid "Set servo angles to specific raw angles"
msgstr "Servowinkel auf spezifische Rohwinkel einstellen"

#: of robot_hat.robot.Robot.servo_write_all:1
msgid "Set servo angles to specific angles with original angle and offset"
msgstr ""
"Servowinkel mit ursprünglichem Winkel und Offset auf spezifische Winkel "
"einstellen"

#: of robot_hat.robot.Robot.servo_move:1
msgid "Move servo to specific angles with speed or bpm"
msgstr "Servo mit Geschwindigkeit oder bpm auf spezifische Winkel bewegen"

#: of robot_hat.robot.Robot.servo_move:5
msgid "speed of servo move"
msgstr "Geschwindigkeit der Servobewegung"

#: of robot_hat.robot.Robot.servo_move:7
msgid "beats per minute"
msgstr "Schläge pro Minute"

#: of robot_hat.robot.Robot.do_action:1
msgid "Do prefix action with motion_name and step and speed"
msgstr ""
"Führen Sie eine vordefinierte Aktion mit Bewegungsname, Schritt und "
"Geschwindigkeit aus"

#: of robot_hat.robot.Robot.do_action:3
msgid "motion"
msgstr "Bewegung"

#: of robot_hat.robot.Robot.do_action:5
msgid "step of motion"
msgstr "Schritt der Bewegung"

#: of robot_hat.robot.Robot.do_action:7
msgid "speed of motion"
msgstr "Geschwindigkeit der Bewegung"

#: of robot_hat.robot.Robot.set_offset:1
msgid "Set offset of servo angles"
msgstr "Offset der Servowinkel einstellen"

#: of robot_hat.robot.Robot.calibration:1
msgid "Move all servos to home position"
msgstr "Alle Servos in die Ausgangsposition bewegen"

#: of robot_hat.robot.Robot.reset:1
msgid "Reset servo to original position"
msgstr "Servo in die ursprüngliche Position zurücksetzen"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_control_motor_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_control_motor_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_control_motor_servo.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_control_motor_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_control_motor_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_control_motor_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_control_motor_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_control_motor_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_control_motor_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_control_motor_servo.rst:16
msgid "Control Servos and Motors"
msgstr "Servos und Motoren steuern"

#: ../project_control_motor_servo.rst:18
msgid "In this project, we have 12 servos and two motors working simultaneously."
msgstr ""
"In diesem Projekt haben wir 12 Servos und zwei Motoren, die gleichzeitig "
"arbeiten."

#: ../project_control_motor_servo.rst:24
msgid ""
"However, it's important to note that if your servos and motors have a "
"high starting current, it's recommended to start them separately to avoid"
" insufficient power supply current, which could lead to the Raspberry Pi "
"restarting."
msgstr ""
"Es ist jedoch wichtig zu beachten, dass, wenn Ihre Servos und Motoren "
"einen hohen Anlaufstrom haben, es empfohlen wird, sie separat zu starten,"
" um unzureichenden Stromversorgungsstrom zu vermeiden, der zum Neustart "
"des Raspberry Pi führen könnte."

#: ../project_control_motor_servo.rst:26
msgid "**Code**"
msgstr "**Code**"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_say_something.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_say_something.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_say_something.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_say_something.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_say_something.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_say_something.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_say_something.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_say_something.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_say_something.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_say_something.rst:16
msgid "Say Something"
msgstr "Sage etwas"

#: ../project_say_something.rst:19
msgid ""
"In this section, you'll learn how to convert text into speech and have "
"Robot HAT speak it aloud."
msgstr ""
"In diesem Abschnitt lernen Sie, wie Sie Text in Sprache umwandeln und vom"
" Robot HAT laut aussprechen lassen."

#: ../project_say_something.rst:21
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_say_something.rst:23
msgid ""
"We retrieve text from the command line to enable Robot HAT to articulate "
"it. To achieve this, save the following code as a ``.py`` file, such as "
"``tts.py``."
msgstr ""
"Wir holen Text von der Kommandozeile ab, damit der Robot HAT ihn "
"artikulieren kann. Um dies zu erreichen, speichern Sie den folgenden Code"
" als eine ``.py``-Datei, wie zum Beispiel ``tts.py``."

#: ../project_say_something.rst:46
msgid ""
"To make Robot HAT vocalize a specific sentence, you can use the following"
" command: ``sudo python3 tts.py \"any text\"`` - simply replace ``\"any "
"text\"`` with the desired phrase."
msgstr ""
"Um den Robot HAT eine bestimmte Satz aussprechen zu lassen, können Sie "
"den folgenden Befehl verwenden: ``sudo python3 tts.py „any text“`` - "
"ersetzen Sie einfach ``„any text“`` durch den gewünschten Satz."

#: ../project_say_something.rst:50
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/install_i2s_for_speaker.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../install_i2s_for_speaker.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../install_i2s_for_speaker.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../install_i2s_for_speaker.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../install_i2s_for_speaker.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../install_i2s_for_speaker.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../install_i2s_for_speaker.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../install_i2s_for_speaker.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../install_i2s_for_speaker.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../install_i2s_for_speaker.rst:18
msgid "Install ``i2samp.sh`` for the Speaker"
msgstr "Installieren Sie ``i2samp.sh`` für den Lautsprecher"

#: ../install_i2s_for_speaker.rst:20
msgid ""
"The ``i2samp.sh`` is a sophisticated Bash script specifically designed "
"for setting up and configuring an I2S (Inter-IC Sound) amplifier on "
"Raspberry Pi and similar devices. Licensed under the MIT license, it "
"ensures compatibility with a range of hardware and operating systems, "
"conducting thorough checks before proceeding with any installation or "
"configuration."
msgstr ""
"Das ``i2samp.sh`` ist ein ausgefeiltes Bash-Skript, das speziell für die "
"Einrichtung und Konfiguration eines I2S (Inter-IC Sound) Verstärkers auf "
"Raspberry Pi und ähnlichen Geräten entwickelt wurde. Unter der MIT-Lizenz"
" lizenziert, gewährleistet es die Kompatibilität mit einer Vielzahl von "
"Hardware- und Betriebssystemen und führt gründliche Überprüfungen durch, "
"bevor mit irgendeiner Installation oder Konfiguration fortgefahren wird."

#: ../install_i2s_for_speaker.rst:22
msgid ""
"If you want your speaker to work properly, you definitely need to install"
" this script."
msgstr ""
"Wenn Sie möchten, dass Ihr Lautsprecher ordnungsgemäß funktioniert, "
"müssen Sie dieses Skript definitiv installieren."

#: ../install_i2s_for_speaker.rst:24
msgid "The steps are as follows:"
msgstr "Die Schritte sind wie folgt:"

#: ../install_i2s_for_speaker.rst:31
msgid "Type ``y`` and press ``enter`` to continue running the script."
msgstr ""
"Geben Sie ``y`` ein und drücken Sie ``Enter``, um das Skript weiter "
"auszuführen."

#: ../install_i2s_for_speaker.rst:35
msgid "Type ``y`` and press ``enter`` to run ``/dev/zero`` in the background."
msgstr ""
"Geben Sie ``y`` ein und drücken Sie ``Enter``, um ``/dev/zero`` im "
"Hintergrund auszuführen."

#: ../install_i2s_for_speaker.rst:39
msgid "Type ``y`` and press ``enter`` to restart the Raspberry pi."
msgstr ""
"Geben Sie ``y`` ein und drücken Sie ``Enter``, um den Raspberry Pi neu zu"
" starten."

#: ../install_i2s_for_speaker.rst:45
msgid ""
"If there is no sound after restarting, you may need to run the "
"``i2samp.sh`` script several times."
msgstr ""
"Wenn nach dem Neustart kein Ton vorhanden ist, müssen Sie möglicherweise "
"das ``i2samp.sh``-Skript mehrmals ausführen."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_plant_monitor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_plant_monitor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_plant_monitor.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_plant_monitor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_plant_monitor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_plant_monitor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_plant_monitor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_plant_monitor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_plant_monitor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_plant_monitor.rst:16
msgid "Plant Monitor"
msgstr "Pflanzenmonitor"

#: ../project_plant_monitor.rst:18
msgid ""
"In this project, we detect both light intensity and soil moisture levels,"
" and display them on the I2C LCD1602 . When you feel that the soil "
"moisture is insufficient, you can press the button module to water the "
"potted plant."
msgstr ""
"In diesem Projekt erfassen wir sowohl die Lichtintensität als auch den "
"Feuchtigkeitsgehalt des Bodens und zeigen diese auf dem I2C LCD1602 an. "
"Wenn Sie denken, dass die Bodenfeuchtigkeit unzureichend ist, können Sie "
"das Tastenmodul drücken, um die Topfpflanze zu bewässern."

#: ../project_plant_monitor.rst:22
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_plant_monitor.rst:24
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr ""
"In diesem Projekt wird ein I2C LCD1602 verwendet, daher ist es notwendig,"
" die relevanten Bibliotheken herunterzuladen, um es zum Laufen zu "
"bringen."

#: ../project_plant_monitor.rst:31
msgid "Install ``smbus2`` for I2C."
msgstr "Installieren Sie ``smbus2`` für I2C."

#: ../project_plant_monitor.rst:37
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``plant_monitor.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``plant_monitor.ty``."

#: ../project_plant_monitor.rst:120
msgid "Use the command ``sudo python3 plant_monitor.ty`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 plant_monitor.ty``, um diesen "
"Code auszuführen."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_modules.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_modules.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_modules.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_modules.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_modules.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_modules.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_modules.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_modules.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_modules.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_modules.rst:16
msgid "module ``modules``"
msgstr "Modul ``modules``"

#: ../api_modules.rst:21
msgid "class ``Ultrasonic``"
msgstr "Klasse ``Ultrasonic``"

#: ../api_modules.rst:23 ../api_modules.rst:46 ../api_modules.rst:80
#: ../api_modules.rst:110 ../api_modules.rst:220
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_modules.rst:37 ../api_modules.rst:70 ../api_modules.rst:101
#: ../api_modules.rst:210 ../api_modules.rst:246
msgid "**API**"
msgstr "**API**"

#: ../api_modules.rst:44
msgid "class ``ADXL345``"
msgstr "Klasse ``ADXL345``"

#: of robot_hat.modules.ADXL345:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "Basisklasse: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.modules.ADXL345:1
msgid "ADXL345 modules"
msgstr "ADXL345-Module"

#: ../docstring of robot_hat.ADXL345.X:1
msgid "X"
msgstr "X"

#: ../docstring of robot_hat.ADXL345.Y:1
msgid "Y"
msgstr "Y"

#: ../docstring of robot_hat.ADXL345.Z:1
msgid "Z"
msgstr "Z"

#: of robot_hat.modules.ADXL345.__init__:1
msgid "Initialize ADXL345"
msgstr "ADXL345 initialisieren"

#: of robot_hat.modules.ADXL345.__init__ robot_hat.modules.ADXL345.read
#: robot_hat.modules.Buzzer.__init__ robot_hat.modules.Buzzer.freq
#: robot_hat.modules.Buzzer.play robot_hat.modules.Grayscale_Module.__init__
#: robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
#: robot_hat.modules.RGB_LED.__init__ robot_hat.modules.RGB_LED.color
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.modules.ADXL345.__init__:3
msgid "address of the ADXL345"
msgstr "Adresse des ADXL345"

#: of robot_hat.modules.ADXL345.read:1
msgid "Read an axis from ADXL345"
msgstr "Eine Achse des ADXL345 lesen"

#: of robot_hat.modules.ADXL345.read:3
msgid ""
"read value(g) of an axis, ADXL345.X, ADXL345.Y or ADXL345.Z, None for all"
" axis"
msgstr ""
"Wert (g) einer Achse lesen, ADXL345.X, ADXL345.Y oder ADXL345.Z, None für"
" alle Achsen"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.modules.ADXL345.read:5
msgid "value of the axis, or list of all axis"
msgstr "Wert der Achse oder Liste aller Achsen"

#: of robot_hat.modules.ADXL345.read robot_hat.modules.Grayscale_Module.read
#: robot_hat.modules.Grayscale_Module.read_status
#: robot_hat.modules.Grayscale_Module.reference
msgid "Return type"
msgstr "Rückgabetyp"

#: ../api_modules.rst:78
msgid "class ``RGB_LED``"
msgstr "Klasse ``RGB_LED``"

#: of robot_hat.modules.RGB_LED:1
msgid "Simple 3 pin RGB LED"
msgstr "Einfache 3-Pin-RGB-LED"

#: ../docstring of robot_hat.RGB_LED.ANODE:1
msgid "Common anode"
msgstr "Gemeinsame Anode"

#: ../docstring of robot_hat.RGB_LED.CATHODE:1
msgid "Common cathode"
msgstr "Gemeinsame Kathode"

#: of robot_hat.modules.RGB_LED.__init__:1
msgid "Initialize RGB LED"
msgstr "RGB-LED initialisieren"

#: of robot_hat.modules.RGB_LED.__init__:3
msgid "PWM object for red"
msgstr "PWM-Objekt für Rot"

#: of robot_hat.modules.RGB_LED.__init__:5
msgid "PWM object for green"
msgstr "PWM-Objekt für Grün"

#: of robot_hat.modules.RGB_LED.__init__:7
msgid "PWM object for blue"
msgstr "PWM-Objekt für Blau"

#: of robot_hat.modules.RGB_LED.__init__:9
msgid "RGB_LED.ANODE or RGB_LED.CATHODE, default is ANODE"
msgstr "RGB_LED.ANODE oder RGB_LED.CATHODE, Standard ist ANODE"

#: of robot_hat.modules.Buzzer.freq robot_hat.modules.Buzzer.play
#: robot_hat.modules.RGB_LED.__init__
msgid "Raises"
msgstr "Wirft"

#: of robot_hat.modules.RGB_LED.__init__:11
msgid "if common is not ANODE or CATHODE"
msgstr "wenn gemeinsam weder ANODE noch CATHODE ist"

#: of robot_hat.modules.RGB_LED.__init__:12
msgid "if r_pin, g_pin or b_pin is not PWM object"
msgstr "wenn r_pin, g_pin oder b_pin kein PWM-Objekt ist"

#: of robot_hat.modules.RGB_LED.color:1
msgid "Write color to RGB LED"
msgstr "Farbe an RGB-LED schreiben"

#: of robot_hat.modules.RGB_LED.color:3
msgid ""
"color to write, hex string starts with \"#\", 24-bit int or tuple of "
"(red, green, blue)"
msgstr ""
"Zu schreibende Farbe, Hex-String beginnend mit \"#\", 24-Bit-Integer oder"
" Tupel aus (Rot, Grün, Blau)"

#: ../api_modules.rst:108
msgid "class ``Buzzer``"
msgstr "Klasse ``Buzzer``"

#: ../api_modules.rst:112
msgid "Imports and initialize"
msgstr "Importieren und Initialisieren"

#: ../api_modules.rst:133
msgid "Active buzzer beeping"
msgstr "Aktives Summer-Signal"

#: ../api_modules.rst:143
msgid "Passive buzzer Simple usage"
msgstr "Passiver Summer Einfache Nutzung"

#: ../api_modules.rst:155
msgid "Passive buzzer Manual control"
msgstr "Passiver Summer Manuelle Steuerung"

#: ../api_modules.rst:171
msgid "Play a song! Baby shark!"
msgstr "Ein Lied spielen! Babyhai!"

#: of robot_hat.modules.Buzzer.__init__:1
msgid "Initialize buzzer"
msgstr "Summer initialisieren"

#: of robot_hat.modules.Buzzer.__init__:3
msgid "PWM object for passive buzzer or Pin object for active buzzer"
msgstr "PWM-Objekt für passiven Summer oder Pin-Objekt für aktiven Summer"

#: of robot_hat.modules.Buzzer.on:1
msgid "Turn on buzzer"
msgstr "Summer einschalten"

#: of robot_hat.modules.Buzzer.off:1
msgid "Turn off buzzer"
msgstr "Summer ausschalten"

#: of robot_hat.modules.Buzzer.freq:1
msgid "Set frequency of passive buzzer"
msgstr "Frequenz des passiven Summers einstellen"

#: of robot_hat.modules.Buzzer.freq:3
msgid "frequency of buzzer, use Music.NOTES to get frequency of note"
msgstr ""
"Frequenz des Summers, verwenden Sie Music.NOTES, um die Frequenz der Note"
" zu erhalten"

#: of robot_hat.modules.Buzzer.freq:5 robot_hat.modules.Buzzer.play:7
msgid "if set to active buzzer"
msgstr "wenn auf aktiven Summer eingestellt"

#: of robot_hat.modules.Buzzer.play:1
msgid "Play freq"
msgstr "Frequenz abspielen"

#: of robot_hat.modules.Buzzer.play:3
msgid "freq to play, you can use Music.note() to get frequency of note"
msgstr ""
"abzuspielende Frequenz, Sie können Music.note() verwenden, um die "
"Frequenz der Note zu erhalten"

#: of robot_hat.modules.Buzzer.play:5
msgid "duration of each note, in seconds, None means play continuously"
msgstr "Dauer jeder Note in Sekunden, None bedeutet kontinuierliches Abspielen"

#: ../api_modules.rst:218
msgid "class ``Grayscale_Module``"
msgstr "Klasse ``Grayscale_Module``"

#: of robot_hat.modules.Grayscale_Module:1
msgid "3 channel Grayscale Module"
msgstr "3-Kanal-Graustufen-Modul"

#: ../docstring of robot_hat.Grayscale_Module.LEFT:1
msgid "Left Channel"
msgstr "Linker Kanal"

#: ../docstring of robot_hat.Grayscale_Module.MIDDLE:1
msgid "Middle Channel"
msgstr "Mittlerer Kanal"

#: ../docstring of robot_hat.Grayscale_Module.RIGHT:1
msgid "Right Channel"
msgstr "Rechter Kanal"

#: of robot_hat.modules.Grayscale_Module.__init__:1
msgid "Initialize Grayscale Module"
msgstr "Graustufen-Modul initialisieren"

#: of robot_hat.modules.Grayscale_Module.__init__:3
msgid "ADC object or int for channel 0"
msgstr "ADC-Objekt oder Integer für Kanal 0"

#: of robot_hat.modules.Grayscale_Module.__init__:5
msgid "ADC object or int for channel 1"
msgstr "ADC-Objekt oder Integer für Kanal 1"

#: of robot_hat.modules.Grayscale_Module.__init__:7
msgid "ADC object or int for channel 2"
msgstr "ADC-Objekt oder Integer für Kanal 2"

#: of robot_hat.modules.Grayscale_Module.__init__:9
msgid "reference voltage"
msgstr "Referenzspannung"

#: of robot_hat.modules.Grayscale_Module.reference:1
msgid "Get Set reference value"
msgstr "Referenzwert abrufen oder einstellen"

#: of robot_hat.modules.Grayscale_Module.reference:3
msgid "reference value, None to get reference value"
msgstr "Referenzwert, None um den Referenzwert abzurufen"

#: of robot_hat.modules.Grayscale_Module.reference:5
msgid "reference value"
msgstr "Referenzwert"

#: of robot_hat.modules.Grayscale_Module.read_status:1
msgid "Read line status"
msgstr "Zeilenstatus lesen"

#: of robot_hat.modules.Grayscale_Module.read_status:3
msgid "list of grayscale datas, if None, read from sensor"
msgstr "Liste der Graustufendaten, falls None, vom Sensor lesen"

#: of robot_hat.modules.Grayscale_Module.read_status:5
msgid "list of line status, 0 for white, 1 for black"
msgstr "Liste des Zeilenstatus, 0 für Weiß, 1 für Schwarz"

#: of robot_hat.modules.Grayscale_Module.read:1
msgid "read a channel or all datas"
msgstr "einen Kanal oder alle Daten lesen"

#: of robot_hat.modules.Grayscale_Module.read:3
msgid ""
"channel to read, leave empty to read all. 0, 1, 2 or "
"Grayscale_Module.LEFT, Grayscale_Module.CENTER, Grayscale_Module.RIGHT"
msgstr ""
"zu lesender Kanal, leer lassen, um alle zu lesen. 0, 1, 2 oder "
"Grayscale_Module.LEFT, Grayscale_Module.MIDDLE, Grayscale_Module.RIGHT"

#: of robot_hat.modules.Grayscale_Module.read:5
msgid "list of grayscale data"
msgstr "Liste der Graustufendaten"





##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_pin.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pin.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_pin.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_pin.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_pin.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_pin.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_pin.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_pin.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_pin.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_pin.rst:18
msgid "class ``Pin``"
msgstr "Klasse ``Pin``"

#: ../api_pin.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_pin.rst:52
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pin.Pin:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.pin.Pin:1
msgid "Pin manipulation class"
msgstr "Pin-Manipulationsklasse"

#: ../docstring of robot_hat.Pin.OUT:1
msgid "Pin mode output"
msgstr "Pin-Modus Ausgang"

#: ../docstring of robot_hat.Pin.IN:1
msgid "Pin mode input"
msgstr "Pin-Modus Eingang"

#: ../docstring of robot_hat.Pin.PULL_UP:1
msgid "Pin internal pull up"
msgstr "Pin interner Pull-Up"

#: ../docstring of robot_hat.Pin.PULL_DOWN:1
msgid "Pin internal pull down"
msgstr "Pin interner Pull-Down"

#: ../docstring of robot_hat.Pin.PULL_NONE:1
msgid "Pin internal pull none"
msgstr "Pin ohne internen Pull"

#: ../docstring of robot_hat.Pin.IRQ_FALLING:1 robot_hat.Pin.IRQ_RISING:1
msgid "Pin interrupt falling"
msgstr "Pin-Interrupt abfallend"

#: ../docstring of robot_hat.Pin.IRQ_RISING_FALLING:1
msgid "Pin interrupt both rising and falling"
msgstr "Pin-Interrupt steigend und fallend"

#: of robot_hat.pin.Pin.__init__:1
msgid "Initialize a pin"
msgstr "Einen Pin initialisieren"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.__init__
#: robot_hat.pin.Pin.dict robot_hat.pin.Pin.irq robot_hat.pin.Pin.setup
#: robot_hat.pin.Pin.value
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.pin.Pin.__init__:3
msgid "pin number of Raspberry Pi"
msgstr "Pin-Nummer des Raspberry Pi"

#: of robot_hat.pin.Pin.__init__:5 robot_hat.pin.Pin.setup:3
msgid "pin mode(IN/OUT)"
msgstr "Pin-Modus (IN/OUT)"

#: of robot_hat.pin.Pin.__init__:7 robot_hat.pin.Pin.setup:5
msgid "pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)"
msgstr "Pin Pull-Up/Down (PUD_UP/PUD_DOWN/PUD_NONE)"

#: of robot_hat.pin.Pin.setup:1
msgid "Setup the pin"
msgstr "Den Pin einrichten"

#: of robot_hat.pin.Pin.dict:1
msgid "Set/get the pin dictionary"
msgstr "Das Pin-Wörterbuch setzen/erhalten"

#: of robot_hat.pin.Pin.dict:3
msgid "pin dictionary, leave it empty to get the dictionary"
msgstr "Pin-Wörterbuch, lassen Sie es leer, um das Wörterbuch zu erhalten"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.pin.Pin.dict:5
msgid "pin dictionary"
msgstr "Pin-Wörterbuch"

#: of robot_hat.pin.Pin.__call__ robot_hat.pin.Pin.dict robot_hat.pin.Pin.high
#: robot_hat.pin.Pin.low robot_hat.pin.Pin.name robot_hat.pin.Pin.off
#: robot_hat.pin.Pin.on robot_hat.pin.Pin.value
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.pin.Pin.__call__:1 robot_hat.pin.Pin.value:1
msgid "Set/get the pin value"
msgstr "Pin-Wert setzen/erhalten"

#: of robot_hat.pin.Pin.__call__:3 robot_hat.pin.Pin.value:3
msgid "pin value, leave it empty to get the value(0/1)"
msgstr "Pin-Wert, lassen Sie es leer, um den Wert zu erhalten (0/1)"

#: of robot_hat.pin.Pin.__call__:5 robot_hat.pin.Pin.value:5
msgid "pin value(0/1)"
msgstr "Pin-Wert (0/1)"

#: of robot_hat.pin.Pin.on:1
msgid "Set pin on(high)"
msgstr "Pin einschalten (high)"

#: of robot_hat.pin.Pin.high:3 robot_hat.pin.Pin.on:3
msgid "pin value(1)"
msgstr "Pin-Wert (1)"

#: of robot_hat.pin.Pin.off:1
msgid "Set pin off(low)"
msgstr "Pin ausschalten (low)"

#: of robot_hat.pin.Pin.low:3 robot_hat.pin.Pin.off:3
msgid "pin value(0)"
msgstr "Pin-Wert (0)"

#: of robot_hat.pin.Pin.high:1
msgid "Set pin high(1)"
msgstr "Pin auf high setzen (1)"

#: of robot_hat.pin.Pin.low:1
msgid "Set pin low(0)"
msgstr "Pin auf low setzen (0)"

#: of robot_hat.pin.Pin.irq:1
msgid "Set the pin interrupt"
msgstr "Pin-Interrupt setzen"

#: of robot_hat.pin.Pin.irq:3
msgid "interrupt handler callback function"
msgstr "Callback-Funktion des Interrupt-Handlers"

#: of robot_hat.pin.Pin.irq:5
msgid "interrupt trigger(RISING, FALLING, RISING_FALLING)"
msgstr "Interrupt-Auslöser (RISING, FALLING, RISING_FALLING)"

#: of robot_hat.pin.Pin.irq:7
msgid "interrupt bouncetime in miliseconds"
msgstr "Interrupt-Entprellzeit in Millisekunden"

#: of robot_hat.pin.Pin.name:1
msgid "Get the pin name"
msgstr "Pin-Name abrufen"

#: of robot_hat.pin.Pin.name:3
msgid "pin name"
msgstr "Pin-Name"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/faq.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../faq.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../faq.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../faq.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../faq.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../faq.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../faq.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../faq.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../faq.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../faq.rst:16
msgid "FAQ"
msgstr "FAQ"

#: ../faq.rst:19
msgid ""
"Q1: Can the battery be connected while providing power to the Raspberry "
"Pi at the same time?"
msgstr ""
"F1: Kann die Batterie angeschlossen werden, während gleichzeitig Strom an"
" den Raspberry Pi geliefert wird?"

#: ../faq.rst:20
msgid ""
"A: Yes, the Robot HAT has a built-in anti-backflow diode that prevents "
"the Raspberry Pi's power from flowing back into the Robot HAT."
msgstr ""
"A: Ja, der Robot HAT hat eine eingebaute Anti-Rückflussdiode, die "
"verhindert, dass die Stromversorgung des Raspberry Pi zurück in den Robot"
" HAT fließt."

#: ../faq.rst:23
msgid "Q2: Can the Robot HAT be used while charging?"
msgstr "F2: Kann der Robot HAT während des Ladens verwendet werden?"

#: ../faq.rst:24
msgid ""
"A: Yes, the Robot HAT can be used while charging. When charging, the "
"input power is boosted by the charging chip to charge the batteries, "
"while also providing power to the DC-DC step-down for external use. The "
"charging power is approximately 10W. If the external power consumption is"
" too high for an extended period, the batteries may supplement the power,"
" similar to how a mobile phone charges while in use. However, it is "
"important to be mindful of the battery's capacity to avoid draining it "
"completely during simultaneous charging and usage."
msgstr ""
"A: Ja, der Robot HAT kann während des Ladens verwendet werden. Beim Laden"
" wird die Eingangsleistung durch den Ladungschip verstärkt, um die "
"Batterien zu laden, während gleichzeitig Strom für die DC-DC-Herabsetzung"
" für den externen Gebrauch bereitgestellt wird. Die Ladeleistung beträgt "
"etwa 10W. Wenn der externe Stromverbrauch über einen längeren Zeitraum zu"
" hoch ist, können die Batterien die Stromversorgung ergänzen, ähnlich wie"
" ein Mobiltelefon beim Gebrauch aufgeladen wird. Es ist jedoch wichtig, "
"auf die Kapazität der Batterie zu achten, um ein vollständiges Entleeren "
"während des gleichzeitigen Ladens und Gebrauchs zu vermeiden."

#: ../faq.rst:29
msgid "Q3: Why is there no sound from the speaker?"
msgstr "F3: Warum kommt kein Ton aus dem Lautsprecher?"

#: ../faq.rst:31
msgid ""
"When your script is running but the speaker is not producing sound, there"
" could be several reasons:"
msgstr ""
"Wenn Ihr Skript läuft, aber der Lautsprecher keinen Ton erzeugt, könnte "
"es mehrere Gründe geben:"

#: ../faq.rst:33
msgid ""
"Check if the ``i2samp.sh`` script has been installed. For detailed "
"instructions, please refer to: :ref:`install_i2s`."
msgstr ""
"Überprüfen Sie, ob das Skript ``i2samp.sh`` installiert wurde. Für "
"detaillierte Anweisungen siehe: :ref:`install_i2s`."

#: ../faq.rst:34
msgid ""
"When running scripts related to speakers, it's necessary to add ``sudo`` "
"to obtain administrative privileges. For example, ``sudo python3 "
"tts.py``."
msgstr ""
"Beim Ausführen von Skripten, die mit Lautsprechern zusammenhängen, ist es"
" notwendig, ``sudo`` hinzuzufügen, um administrative Rechte zu erhalten. "
"Zum Beispiel ``sudo python3 tts.py``."

#: ../faq.rst:35
msgid ""
"Don't using Raspberry Pi's built-in programming tools, like Geany to run "
"Speaker-related scripts. These tools run with standard user privileges, "
"while hardware control, such as managing speakers, often requires higher "
"permissions."
msgstr ""
"Verwenden Sie keine integrierten Programmierwerkzeuge des Raspberry Pi, "
"wie Geany, um lautsprecherbezogene Skripte auszuführen. Diese Werkzeuge "
"laufen mit Standardbenutzerrechten, während die Hardwaresteuerung, wie "
"die Verwaltung von Lautsprechern, oft höhere Berechtigungen erfordert."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/projects.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../projects.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../projects.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../projects.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../projects.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../projects.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../projects.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../projects.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../projects.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../projects.rst:16
msgid "Some Projects"
msgstr "Einige Projekte"

#: ../projects.rst:18
msgid ""
"Here, you'll find a collection of fascinating projects, all implemented "
"using the Robot HAT. We provide you with detailed code, giving you the "
"opportunity to try these projects out for yourself."
msgstr ""
"Hier finden Sie eine Sammlung faszinierender Projekte, alle umgesetzt mit"
" dem Robot HAT. Wir stellen Ihnen detaillierten Code zur Verfügung, der "
"Ihnen die Möglichkeit bietet, diese Projekte selbst auszuprobieren."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_utils.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_utils.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_utils.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_utils.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_utils.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_utils.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_utils.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_utils.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_utils.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_utils.rst:16
msgid "module ``utils``"
msgstr "Modul ``utils``"

#: of robot_hat.utils.set_volume:1
msgid "Set volume"
msgstr "Lautstärke einstellen"

#: of robot_hat.utils.get_ip robot_hat.utils.is_installed
#: robot_hat.utils.mapping robot_hat.utils.run_command
#: robot_hat.utils.set_volume
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.utils.set_volume:3
msgid "volume(0~100)"
msgstr "Lautstärke(0~100)"

#: of robot_hat.utils.run_command:1
msgid "Run command and return status and output"
msgstr "Befehl ausführen und Status sowie Ausgabe zurückgeben"

#: of robot_hat.utils.run_command:3
msgid "command to run"
msgstr "auszuführender Befehl"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.utils.run_command:5
msgid "status, output"
msgstr "Status, Ausgabe"

#: of robot_hat.utils.get_battery_voltage robot_hat.utils.get_ip
#: robot_hat.utils.is_installed robot_hat.utils.mapping
#: robot_hat.utils.run_command
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.utils.is_installed:1
msgid "Check if command is installed"
msgstr "Überprüfen, ob Befehl installiert ist"

#: of robot_hat.utils.is_installed:3
msgid "command to check"
msgstr "zu überprüfender Befehl"

#: of robot_hat.utils.is_installed:5
msgid "True if installed"
msgstr "Wahr, wenn installiert"

#: of robot_hat.utils.mapping:1
msgid "Map value from one range to another range"
msgstr "Wert von einem Bereich in einen anderen Bereich abbilden"

#: of robot_hat.utils.mapping:3
msgid "value to map"
msgstr "abzubildender Wert"

#: of robot_hat.utils.mapping:5
msgid "input minimum"
msgstr "Eingangsminimum"

#: of robot_hat.utils.mapping:7
msgid "input maximum"
msgstr "Eingangsmaximum"

#: of robot_hat.utils.mapping:9
msgid "output minimum"
msgstr "Ausgangsminimum"

#: of robot_hat.utils.mapping:11
msgid "output maximum"
msgstr "Ausgangsmaximum"

#: of robot_hat.utils.mapping:13
msgid "mapped value"
msgstr "Abgebildeter Wert"

#: of robot_hat.utils.get_ip:1
msgid "Get IP address"
msgstr "IP-Adresse abrufen"

#: of robot_hat.utils.get_ip:3
msgid "interfaces to check"
msgstr "Zu überprüfende Schnittstellen"

#: of robot_hat.utils.get_ip:5
msgid "IP address or False if not found"
msgstr "IP-Adresse oder False, wenn nicht gefunden"

#: of robot_hat.utils.reset_mcu:1
msgid "Reset mcu on Robot Hat."
msgstr "MCU auf dem Robot Hat zurücksetzen."

#: of robot_hat.utils.reset_mcu:3
msgid ""
"This is helpful if the mcu somehow stuck in a I2C data transfer loop, and"
" Raspberry Pi getting IOError while Reading ADC, manipulating PWM, etc."
msgstr ""
"Dies ist hilfreich, wenn der MCU irgendwie in einer I2C-"
"Datenübertragungsschleife steckt und der Raspberry Pi einen IOError beim "
"Lesen des ADC, Manipulieren des PWM usw. erhält."

#: of robot_hat.utils.get_battery_voltage:1
msgid "Get battery voltage"
msgstr "Batteriespannung abrufen"

#: of robot_hat.utils.get_battery_voltage:3
msgid "battery voltage(V)"
msgstr "Batteriespannung (V)"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_pwm.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_pwm.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_pwm.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_pwm.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_pwm.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_pwm.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_pwm.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_pwm.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_pwm.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_pwm.rst:18
msgid "class ``PWM``"
msgstr "Klasse ``PWM``"

#: ../api_pwm.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_pwm.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.pwm.PWM:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "Basisklasse: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.pwm.PWM:1
msgid "Pulse width modulation (PWM)"
msgstr "Pulsweitenmodulation (PWM)"

#: ../docstring of robot_hat.PWM.REG_CHN:1
msgid "Channel register prefix"
msgstr "Kanalregister-Präfix"

#: ../docstring of robot_hat.PWM.REG_PSC:1
msgid "Prescaler register prefix"
msgstr "Vorteiler-Register-Präfix"

#: ../docstring of robot_hat.PWM.REG_ARR:1
msgid "Period registor prefix"
msgstr "Periodenregister-Präfix"

#: ../docstring of robot_hat.PWM.CLOCK:1
msgid "Clock frequency"
msgstr "Taktfrequenz"

#: of robot_hat.pwm.PWM.__init__:1
msgid "Initialize PWM"
msgstr "PWM initialisieren"

#: of robot_hat.pwm.PWM.__init__ robot_hat.pwm.PWM.freq
#: robot_hat.pwm.PWM.period robot_hat.pwm.PWM.prescaler
#: robot_hat.pwm.PWM.pulse_width robot_hat.pwm.PWM.pulse_width_percent
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.pwm.PWM.__init__:3
msgid "PWM channel number(0-13/P0-P13)"
msgstr "PWM-Kanalnummer (0-13/P0-P13)"

#: of robot_hat.pwm.PWM.freq:1
msgid "Set/get frequency, leave blank to get frequency"
msgstr "Frequenz setzen/abfragen, leer lassen, um die Frequenz zu erhalten"

#: of robot_hat.pwm.PWM.freq:3
msgid "frequency(0-65535)(Hz)"
msgstr "Frequenz (0-65535) (Hz)"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.pwm.PWM.freq:5
msgid "frequency"
msgstr "Frequenz"

#: of robot_hat.pwm.PWM.freq robot_hat.pwm.PWM.period
#: robot_hat.pwm.PWM.prescaler robot_hat.pwm.PWM.pulse_width
#: robot_hat.pwm.PWM.pulse_width_percent
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.pwm.PWM.prescaler:1
msgid "Set/get prescaler, leave blank to get prescaler"
msgstr "Vorteiler setzen/abfragen, leer lassen, um den Vorteiler zu erhalten"

#: of robot_hat.pwm.PWM.prescaler:3
msgid "prescaler(0-65535)"
msgstr "Vorteiler (0-65535)"

#: of robot_hat.pwm.PWM.prescaler:5
msgid "prescaler"
msgstr "Vorteiler"

#: of robot_hat.pwm.PWM.period:1
msgid "Set/get period, leave blank to get period"
msgstr "Periode setzen/abfragen, leer lassen, um die Periode zu erhalten"

#: of robot_hat.pwm.PWM.period:3
msgid "period(0-65535)"
msgstr "Periode (0-65535)"

#: of robot_hat.pwm.PWM.period:5
msgid "period"
msgstr "Periode"

#: of robot_hat.pwm.PWM.pulse_width:1
msgid "Set/get pulse width, leave blank to get pulse width"
msgstr "Pulsbreite setzen/abfragen, leer lassen, um die Pulsbreite zu erhalten"

#: of robot_hat.pwm.PWM.pulse_width:3
msgid "pulse width(0-65535)"
msgstr "Pulsbreite (0-65535)"

#: of robot_hat.pwm.PWM.pulse_width:5
msgid "pulse width"
msgstr "Pulsbreite"

#: of robot_hat.pwm.PWM.pulse_width_percent:1
msgid "Set/get pulse width percentage, leave blank to get pulse width percentage"
msgstr ""
"Pulsbreitenprozentsatz setzen/abfragen, leer lassen, um den "
"Pulsbreitenprozentsatz zu erhalten"

#: of robot_hat.pwm.PWM.pulse_width_percent:3
msgid "pulse width percentage(0-100)"
msgstr "Pulsbreitenprozentsatz (0-100)"

#: of robot_hat.pwm.PWM.pulse_width_percent:5
msgid "pulse width percentage"
msgstr "Pulsbreitenprozentsatz"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_music.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_music.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_music.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_music.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_music.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_music.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_music.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_music.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_music.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_music.rst:18
msgid "class ``Music``"
msgstr "Klasse ``Music``"

#: ../api_music.rst:21
msgid ""
"You need to add ``sudo`` when running this script, in case the speaker "
"doesn't work."
msgstr ""
"Sie müssen ``sudo`` beim Ausführen dieses Skripts hinzufügen, falls der "
"Lautsprecher nicht funktioniert."

#: ../api_music.rst:22
msgid ":ref:`faq_speaker`."
msgstr ":ref:`faq_speaker`."

#: ../api_music.rst:24
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_music.rst:26
msgid "Initialize"
msgstr "Initialisieren"

#: ../api_music.rst:36
msgid "Play tones"
msgstr "Töne abspielen"

#: ../api_music.rst:144
msgid "Play sound"
msgstr "Ton abspielen"

#: ../api_music.rst:155
msgid "Play Music"
msgstr "Musik abspielen"

#: ../api_music.rst:176
msgid "**API**"
msgstr "**API**"

#: of robot_hat.music.Music:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.music.Music:1
msgid "Play music, sound affect and note control"
msgstr "Musik, Soundeffekte und Notenkontrolle abspielen"

#: ../docstring of robot_hat.Music.NOTE_BASE_FREQ:1
msgid "Base note frequency for calculation (A4)"
msgstr "Basisnotenfrequenz für die Berechnung (A4)"

#: ../docstring of robot_hat.Music.NOTE_BASE_INDEX:1
msgid "Base note index for calculation (A4) MIDI compatible"
msgstr "Basisnotenindex für die Berechnung (A4), MIDI-kompatibel"

#: ../docstring of robot_hat.Music.NOTES:1
msgid "Notes name, MIDI compatible"
msgstr "Notennamen, MIDI-kompatibel"

#: of robot_hat.music.Music.__init__:1
msgid "Initialize the basic class"
msgstr "Die Basisklasse initialisieren"

#: of robot_hat.music.Music.__init__ robot_hat.music.Music.beat
#: robot_hat.music.Music.get_tone_data robot_hat.music.Music.key_signature
#: robot_hat.music.Music.music_play robot_hat.music.Music.music_set_volume
#: robot_hat.music.Music.note robot_hat.music.Music.play_tone_for
#: robot_hat.music.Music.sound_length robot_hat.music.Music.sound_play
#: robot_hat.music.Music.sound_play_threading robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.music.Music.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "Debug-Level, 0(kritisch), 1(Fehler), 2(Warnung), 3(Info) oder 4(Debug)"

#: of robot_hat.music.Music.time_signature:1
msgid "Set/get time signature"
msgstr "Taktart einstellen/abrufen"

#: of robot_hat.music.Music.time_signature:3
msgid "top number of time signature"
msgstr "Oberzahl der Taktart"

#: of robot_hat.music.Music.time_signature:5
msgid "bottom number of time signature"
msgstr "Unterzahl der Taktart"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.music.Music.time_signature:7
msgid "time signature"
msgstr "Taktart"

#: of robot_hat.music.Music.beat robot_hat.music.Music.get_tone_data
#: robot_hat.music.Music.key_signature robot_hat.music.Music.note
#: robot_hat.music.Music.sound_length robot_hat.music.Music.tempo
#: robot_hat.music.Music.time_signature
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.music.Music.key_signature:1
msgid "Set/get key signature"
msgstr "Tonart einstellen/abrufen"

#: of robot_hat.music.Music.key_signature:3
msgid ""
"key signature use KEY_XX_MAJOR or String \"#\", \"##\", or \"bbb\", "
"\"bbbb\""
msgstr "Tonart verwenden KEY_XX_MAJOR oder String \"#\", \"##\", \"bbb\", \"bbbb\""

#: of robot_hat.music.Music.key_signature:5
msgid "key signature"
msgstr "Tonart"

#: of robot_hat.music.Music.tempo:1
msgid "Set/get tempo beat per minute(bpm)"
msgstr "Tempo einstellen/abrufen (Schläge pro Minute, bpm)"

#: of robot_hat.music.Music.tempo:3 robot_hat.music.Music.tempo:6
msgid "tempo"
msgstr "Tempo"

#: of robot_hat.music.Music.tempo:5
msgid "note value(1, 1/2, Music.HALF_NOTE, etc)"
msgstr "Notenwert (1, 1/2, Music.HALF_NOTE usw.)"

#: of robot_hat.music.Music.beat:1
msgid "Calculate beat delay in seconds from tempo"
msgstr "Berechnen der Schlagverzögerung in Sekunden aus dem Tempo"

#: of robot_hat.music.Music.beat:3
msgid "beat index"
msgstr "Schlagindex"

#: of robot_hat.music.Music.beat:5
msgid "beat delay"
msgstr "Schlagverzögerung"

#: of robot_hat.music.Music.note:1
msgid "Get frequency of a note"
msgstr "Frequenz einer Note abrufen"

#: of robot_hat.music.Music.note:3
msgid "note name(See NOTES)"
msgstr "Notenname (siehe NOTES)"

#: of robot_hat.music.Music.note:5
msgid "if natural note"
msgstr "ob natürliche Note"

#: of robot_hat.music.Music.note:7
msgid "frequency of note"
msgstr "Frequenz der Note"

#: of robot_hat.music.Music.sound_play:1
msgid "Play sound effect file"
msgstr "Soundeffekt-Datei abspielen"

#: of robot_hat.music.Music.sound_length:3 robot_hat.music.Music.sound_play:3
#: robot_hat.music.Music.sound_play_threading:3
msgid "sound effect file name"
msgstr "Name der Soundeffekt-Datei"

#: of robot_hat.music.Music.sound_play_threading:1
msgid "Play sound effect in thread(in the background)"
msgstr "Soundeffekt im Hintergrund abspielen"

#: of robot_hat.music.Music.music_play:9
#: robot_hat.music.Music.sound_play_threading:5
msgid "volume 0-100, leave empty will not change volume"
msgstr "Lautstärke 0-100, leer lassen, um die Lautstärke nicht zu ändern"

#: of robot_hat.music.Music.music_play:1
msgid "Play music file"
msgstr "Musikdatei abspielen"

#: of robot_hat.music.Music.music_play:3
msgid "sound file name"
msgstr "Name der Sounddatei"

#: of robot_hat.music.Music.music_play:5
msgid "number of loops, 0:loop forever, 1:play once, 2:play twice, ..."
msgstr ""
"Anzahl der Wiederholungen, 0: endlos wiederholen, 1: einmal abspielen, 2:"
" zweimal abspielen, ..."

#: of robot_hat.music.Music.music_play:7
msgid "start time in seconds"
msgstr "Startzeit in Sekunden"

#: of robot_hat.music.Music.music_set_volume:1
msgid "Set music volume"
msgstr "Musiklautstärke einstellen"

#: of robot_hat.music.Music.music_set_volume:3
msgid "volume 0-100"
msgstr "Lautstärke 0-100"

#: of robot_hat.music.Music.music_stop:1
msgid "Stop music"
msgstr "Musik stoppen"

#: of robot_hat.music.Music.music_pause:1
msgid "Pause music"
msgstr "Musik pausieren"

#: of robot_hat.music.Music.music_resume:1
msgid "Resume music"
msgstr "Musik fortsetzen"

#: of robot_hat.music.Music.music_unpause:1
msgid "Unpause music(resume music)"
msgstr "Musikwiedergabe fortsetzen"

#: of robot_hat.music.Music.sound_length:1
msgid "Get sound effect length in seconds"
msgstr "Länge des Soundeffekts in Sekunden abrufen"

#: of robot_hat.music.Music.sound_length:5
msgid "length in seconds"
msgstr "Länge in Sekunden"

#: of robot_hat.music.Music.get_tone_data:1
msgid "Get tone data for playing"
msgstr "Ton-Daten zum Abspielen abrufen"

#: of robot_hat.music.Music.get_tone_data:3
msgid "frequency"
msgstr "Frequenz"

#: of robot_hat.music.Music.get_tone_data:5
#: robot_hat.music.Music.play_tone_for:5
msgid "duration in seconds"
msgstr "Dauer in Sekunden"

#: of robot_hat.music.Music.get_tone_data:7
msgid "tone data"
msgstr "Ton-Daten"

#: of robot_hat.music.Music.play_tone_for:1
msgid "Play tone for duration seconds"
msgstr "Ton für angegebene Dauer abspielen"

#: of robot_hat.music.Music.play_tone_for:3
msgid "frequency, you can use NOTES to get frequency"
msgstr "Frequenz, Sie können NOTES verwenden, um die Frequenz zu erhalten"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_adc.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_adc.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_adc.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_adc.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_adc.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_adc.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_adc.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_adc.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_adc.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_adc.rst:18
msgid "class ``ADC``"
msgstr "Klasse ``ADC``"

#: ../api_adc.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_adc.rst:42
msgid "**API**"
msgstr "**API**"

#: of robot_hat.adc.ADC:1
msgid "Bases: :py:class:`~robot_hat.i2c.I2C`"
msgstr "Basisklasse: :py:class:`~robot_hat.i2c.I2C`"

#: of robot_hat.adc.ADC:1 robot_hat.adc.ADC.__init__:1
msgid "Analog to digital converter"
msgstr "Analog-Digital-Wandler"

#: of robot_hat.adc.ADC.__init__
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.adc.ADC.__init__:3
msgid "channel number (0-7/A0-A7)"
msgstr "Kanalnummer (0-7/A0-A7)"

#: of robot_hat.adc.ADC.read:1
msgid "Read the ADC value"
msgstr "ADC-Wert lesen"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Returns"
msgstr "Rückgabewert"

#: of robot_hat.adc.ADC.read:3
msgid "ADC value(0-4095)"
msgstr "ADC-Wert (0-4095)"

#: of robot_hat.adc.ADC.read robot_hat.adc.ADC.read_voltage
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.adc.ADC.read_voltage:1
msgid "Read the ADC value and convert to voltage"
msgstr "ADC-Wert lesen und in Spannung umwandeln"

#: of robot_hat.adc.ADC.read_voltage:3
msgid "Voltage value(0-3.3(V))"
msgstr "Spannungswert (0-3.3(V))"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_basic_class.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_basic_class.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_basic_class.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_basic_class.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_basic_class.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_basic_class.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_basic_class.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_basic_class.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_basic_class.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_basic_class.rst:16
msgid "class ``_Basic_class``"
msgstr "Klasse ``_Basic_class``"

#: ../api_basic_class.rst:18
msgid ""
"``_Basic_class`` is a logger class for all class to log, so if you want "
"to see logs of a class, just add a debug argument to it."
msgstr ""
"``_Basic_class`` ist eine Logger-Klasse für alle Klassen zur "
"Protokollierung. Wenn Sie Protokolle einer Klasse sehen möchten, fügen "
"Sie einfach ein Debug-Argument hinzu."

#: ../api_basic_class.rst:21
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_basic_class.rst:36
msgid "**API**"
msgstr "**API**"

#: of robot_hat.basic._Basic_class:1
msgid "Basic Class for all classes"
msgstr "Grundklasse für alle Klassen"

#: of robot_hat.basic._Basic_class:3
msgid "with debug function"
msgstr "mit Debug-Funktion"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_LEVELS:1
#: robot_hat.basic._Basic_class.debug_level:1
msgid "Debug level"
msgstr "Debug-Level"

#: ../docstring of robot_hat.basic._Basic_class.DEBUG_NAMES:1
msgid "Debug level names"
msgstr "Namen der Debug-Levels"

#: of robot_hat.basic._Basic_class.__init__:1
msgid "Initialize the basic class"
msgstr "Initialisierung der Grundklasse"

#: of robot_hat.basic._Basic_class.__init__
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.basic._Basic_class.__init__:3
msgid "debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)"
msgstr "Debug-Level, 0(kritisch), 1(Fehler), 2(Warnung), 3(Info) oder 4(Debug)"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_diy_car.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_diy_car.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_diy_car.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_diy_car.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_diy_car.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_diy_car.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_diy_car.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_diy_car.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_diy_car.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_diy_car.rst:16
msgid "DIY Car"
msgstr "DIY-Auto"

#: ../project_diy_car.rst:18
msgid ""
"In addition to being suitable for simple experiments, the Robot HAT is "
"ideal for use as a central controller in robotics, such as for smart "
"cars."
msgstr ""
"Neben der Eignung für einfache Experimente ist der Robot HAT ideal als "
"zentraler Controller in der Robotik, wie zum Beispiel für intelligente "
"Autos, geeignet."

#: ../project_diy_car.rst:20
msgid "In this project, we built a simple line-following car."
msgstr "In diesem Projekt haben wir ein einfaches linienfolgendes Auto gebaut."

#: ../project_diy_car.rst:24
msgid "**Code**"
msgstr "**Code**"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/index.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../index.rst:43
msgid "About this HAT"
msgstr "Über dieses HAT"

#: ../index.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../index.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../index.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../index.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../index.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../index.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../index.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../index.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../index.rst:16
msgid "SunFounder Robot HAT"
msgstr "SunFounder Robot HAT"

#: ../index.rst:18
msgid "Thanks for choosing our Robot HAT."
msgstr "Danke, dass Sie sich für unser Robot HAT entschieden haben."

#: ../index.rst:21
msgid "This document is available in the following languages."
msgstr "Dieses Dokument ist in den folgenden Sprachen verfügbar."

#: ../index.rst:23
msgid "|link_german_tutorials|"
msgstr "|link_german_tutorials|"

#: ../index.rst:24
msgid "|link_jp_tutorials|"
msgstr "|link_jp_tutorials|"

#: ../index.rst:25
msgid "|link_en_tutorials|"
msgstr "|link_en_tutorials|"

#: ../index.rst:27
msgid ""
"Please click on the respective links to access the document in your "
"preferred language."
msgstr ""
"Bitte klicken Sie auf die jeweiligen Links, um das Dokument in Ihrer "
"bevorzugten Sprache aufzurufen."

#: ../index.rst:34
msgid ""
"Robot HAT is a multifunctional expansion board that allows Raspberry Pi "
"to be quickly turned into a robot. An MCU is on board to extend the PWM "
"output and ADC input for the Raspberry Pi, as well as a motor driver "
"chip, Bluetooth module, I2S audio module and mono speaker. As well as the"
" GPIOs that lead out of the Raspberry Pi itself."
msgstr ""
"Das Robot HAT ist eine multifunktionale Erweiterungsplatine, die es "
"ermöglicht, einen Raspberry Pi schnell in einen Roboter zu verwandeln. "
"Ein MCU an Bord erweitert den PWM-Ausgang und den ADC-Eingang für den "
"Raspberry Pi sowie einen Motorantriebschip, ein Bluetooth-Modul, ein I2S-"
"Audiomodul und einen Monolautsprecher, sowie die GPIOs, die aus dem "
"Raspberry Pi selbst herausführen."

#: ../index.rst:36
msgid ""
"It also comes with a Speaker, which can be used to play background music,"
" sound effects and implement TTS functions to make your project more "
"interesting."
msgstr ""
"Es verfügt auch über einen Lautsprecher, der zur Wiedergabe von "
"Hintergrundmusik, Soundeffekten und zur Implementierung von TTS-"
"Funktionen genutzt werden kann, um Ihr Projekt interessanter zu "
"gestalten."

#: ../index.rst:38
msgid ""
"Accepts 6.0V-8.4V XH2.54 3pin power input with 2 power indicators. The "
"board also has a user available LED and a button for you to quickly test "
"some effects."
msgstr ""
"Akzeptiert einen 6.0V-8.4V XH2.54 3pin-Stromanschluss mit 2 "
"Leistungsindikatoren. Die Platine verfügt außerdem über eine "
"benutzerzugängliche LED und einen Knopf, um schnell einige Effekte zu "
"testen."

#: ../index.rst:40
msgid ""
"In this document, you will get a full understanding of the interface "
"functions of the Robot HAT and the usage of these interfaces through the "
"Python ``robot-hat`` library provided by SunFounder."
msgstr ""
"In diesem Dokument erhalten Sie ein vollständiges Verständnis der "
"Schnittstellenfunktionen des Robot HAT und der Nutzung dieser "
"Schnittstellen über die von SunFounder bereitgestellte Python-Bibliothek "
"``robot-hat``."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_filedb.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_filedb.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_filedb.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_filedb.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_filedb.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_filedb.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_filedb.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_filedb.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_filedb.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_filedb.rst:16
msgid "class ``FileDB``"
msgstr "Klasse ``FileDB``"

#: ../api_filedb.rst:18
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_filedb.rst:41
msgid "Now you can checkout the config file ``config`` in bash."
msgstr "Jetzt können Sie die Konfigurationsdatei ``config`` in Bash überprüfen."

#: ../api_filedb.rst:47
msgid "**API**"
msgstr "**API**"

#: of robot_hat.filedb.fileDB:1
msgid "Bases: :py:class:`object`"
msgstr "Basen: :py:class:`object`"

#: of robot_hat.filedb.fileDB:1
msgid "A file based database."
msgstr "Eine dateibasierte Datenbank."

#: of robot_hat.filedb.fileDB:3
msgid "A file based database, read and write arguements in the specific file."
msgstr ""
"Eine dateibasierte Datenbank zum Lesen und Schreiben von Argumenten in "
"einer bestimmten Datei."

#: of robot_hat.filedb.fileDB.__init__:1
msgid "Init the db_file is a file to save the datas."
msgstr "Initialisiere db_file als Datei zum Speichern der Daten."

#: of robot_hat.filedb.fileDB.__init__
#: robot_hat.filedb.fileDB.file_check_create robot_hat.filedb.fileDB.get
#: robot_hat.filedb.fileDB.set
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.filedb.fileDB.__init__:3
msgid "the file to save the datas."
msgstr "Die Datei zum Speichern der Daten."

#: of robot_hat.filedb.fileDB.__init__:5
#: robot_hat.filedb.fileDB.file_check_create:5
msgid "the mode of the file."
msgstr "Der Modus der Datei."

#: of robot_hat.filedb.fileDB.__init__:7
#: robot_hat.filedb.fileDB.file_check_create:7
msgid "the owner of the file."
msgstr "Der Besitzer der Datei."

#: of robot_hat.filedb.fileDB.file_check_create:1
msgid "Check if file is existed, otherwise create one."
msgstr "Überprüfen, ob die Datei existiert, ansonsten eine erstellen."

#: of robot_hat.filedb.fileDB.file_check_create:3
msgid "the file to check"
msgstr "Die zu überprüfende Datei"

#: of robot_hat.filedb.fileDB.get:1
msgid "Get value with data's name"
msgstr "Wert mit dem Namen der Daten abrufen"

#: of robot_hat.filedb.fileDB.get:3 robot_hat.filedb.fileDB.set:3
msgid "the name of the arguement"
msgstr "Der Name des Arguments"

#: of robot_hat.filedb.fileDB.get:5
msgid "the default value of the arguement"
msgstr "Der Standardwert des Arguments"

#: of robot_hat.filedb.fileDB.get
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.filedb.fileDB.get:7 robot_hat.filedb.fileDB.set:5
msgid "the value of the arguement"
msgstr "Der Wert des Arguments"

#: of robot_hat.filedb.fileDB.get
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.filedb.fileDB.set:1
msgid "Set value by with name. Or create one if the arguement does not exist"
msgstr ""
"Wert anhand des Namens setzen. Oder eines erstellen, falls das Argument "
"nicht existiert"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_security.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_security.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_security.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_security.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_security.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_security.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_security.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_security.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_security.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_security.rst:16
msgid "Security System"
msgstr "Sicherheitssystem"

#: ../project_security.rst:18
msgid ""
"In this project, we've created a simple security system. The PIR sensor "
"detects if someone passes by, and then the camera activates. If a face is"
" detected, it takes a picture and simultaneously delivers a warning "
"message."
msgstr ""
"In diesem Projekt haben wir ein einfaches Sicherheitssystem erstellt. Der"
" PIR-Sensor erkennt, ob jemand vorbeigeht, und dann wird die Kamera "
"aktiviert. Wenn ein Gesicht erkannt wird, macht sie ein Bild und liefert "
"gleichzeitig eine Warnmeldung."

#: ../project_security.rst:22
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_security.rst:24
msgid "Install the ``vilib`` library for face detection."
msgstr "Installieren Sie die ``vilib``-Bibliothek zur Gesichtserkennung."

#: ../project_security.rst:33
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``security.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``security.ty``."

#: ../project_security.rst:106
msgid "Use the command ``sudo python3 security.py`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 security.py``, um diesen Code "
"auszuführen."

#: ../project_security.rst:106
msgid ":ref:`faq_speaker`"
msgstr ":ref:`faq_speaker`"

#: ../project_security.rst:108
msgid ""
"Open a web browser and enter ``http://rpi_ip:9000/mjpg`` to view the "
"captured footage. Additionally, you can find the captured face images in "
"``/home/{username}/Pictures/``."
msgstr ""
"Öffnen Sie einen Webbrowser und geben Sie ``http://rpi_ip:9000/mjpg`` "
"ein, um das aufgenommene Filmmaterial anzusehen. Zusätzlich finden Sie "
"die aufgenommenen Gesichtsbilder in ``/home/{Benutzername}/Bilder/``."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/installation.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../installation.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../installation.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../installation.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../installation.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../installation.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../installation.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../installation.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../installation.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../installation.rst:16
msgid "Install the ``robot-hat`` Module"
msgstr "Installieren Sie das Modul ``robot-hat``"

#: ../installation.rst:18
msgid "``robot-hat`` is the supported library for the Robot HAT."
msgstr "``robot-hat`` ist die unterstützte Bibliothek für den Robot HAT."

#: ../installation.rst:20
msgid "Aktualisieren Sie Ihr System."
msgstr ""

#: ../installation.rst:22
msgid "Make sure you are connected to the Internet and update your system:"
msgstr "Stellen Sie sicher, dass Sie mit dem Internet verbunden sind und aktualisieren Sie Ihr System:"

#: ../installation.rst:35
msgid ""
"Python3 related packages must be installed if you are installing the "
"**Lite** version OS."
msgstr "Python3-bezogene Pakete müssen installiert werden, wenn Sie die "
"**Lite** Version OS."

#: ../installation.rst:45
msgid "Type this command into the terminal to install the ``robot-hat`` package."
msgstr ""
"Geben Sie diesen Befehl im Terminal ein, um das ``robot-hat`` Paket zu "
"installieren."

#: ../installation.rst:59
msgid ""
"Run ``setup.py`` to download some necessary components. You may have a "
"network problem and the download may fail. At this point you may need to "
"download again. In the following cases, type ``Y`` and press ``Enter`` to"
" continue the process."
msgstr ""
"Führen Sie ``setup.py`` aus, um einige notwendige Komponenten "
"herunterzuladen. Es könnte ein Netzwerkproblem auftreten und der Download"
" fehlschlagen. In diesem Fall müssen Sie möglicherweise erneut "
"herunterladen. Geben Sie in den folgenden Fällen ``Y`` ein und drücken "
"Sie ``Enter``, um den Prozess fortzusetzen."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/battery.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 17:46+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../battery.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../battery.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../battery.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../battery.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../battery.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../battery.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../battery.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../battery.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../battery.rst:16
msgid "About the Battery"
msgstr "Über den Akku"

#: ../battery.rst:17
msgid "**Battery**"
msgstr "**Akku**"

#: ../battery.rst:23
msgid ""
"**VCC**: Battery positive terminal, here there are two sets of VCC and "
"GND is to increase the current and reduce the resistance."
msgstr ""
"**VCC**: Positiver Batteriepol, hier gibt es zwei Sätze von VCC und GND, "
"um den Strom zu erhöhen und den Widerstand zu verringern."

#: ../battery.rst:24
msgid ""
"**Middle**: To balance the voltage between the two cells and thus protect"
" the battery."
msgstr ""
"**Middle**: Um die Spannung zwischen den beiden Zellen auszugleichen und "
"so den Akku zu schützen."

#: ../battery.rst:25
msgid "**GND**: Negative battery terminal."
msgstr "**GND**: Negativer Batteriepol."

#: ../battery.rst:28
msgid ""
"This is a custom battery pack made by SunFounder consisting of two 18650 "
"batteries with a capacity of 2000mAh. The connector is XH2.54 3pin, which"
" can be charged directly after being inserted into the shield."
msgstr ""
"Dies ist ein benutzerdefinierter Akkupack von SunFounder, bestehend aus "
"zwei 18650 Akkus mit einer Kapazität von 2000mAh. Der Anschluss ist "
"XH2.54 3pin, der direkt nach dem Einsetzen in das Shield geladen werden "
"kann."

#: ../battery.rst:32
msgid "**Features**"
msgstr "**Eigenschaften**"

#: ../battery.rst:34
msgid "Composition: Li-ion"
msgstr "Zusammensetzung: Li-Ion"

#: ../battery.rst:35
msgid "Battery Capacity: 2000mAh, 14.8Wh"
msgstr "Batteriekapazität: 2000mAh, 14.8Wh"

#: ../battery.rst:36
msgid "Battery Weight: 90.8g"
msgstr "Batterie Gewicht: 90.8g"

#: ../battery.rst:37
msgid "Number of Cells: 2"
msgstr "Anzahl der Zellen: 2"

#: ../battery.rst:38
msgid "Connector: XH2.54 3pin"
msgstr "Anschluss: XH2.54 3pin"

#: ../battery.rst:39
msgid "Over-discharge protection: 6.0V"
msgstr "Überentladungsschutz: 6.0V"


##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_motor.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_motor.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_motor.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_motor.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_motor.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_motor.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_motor.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_motor.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_motor.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_motor.rst:18
msgid "module ``motor``"
msgstr "Modul ``motor``"

#: ../api_motor.rst:21
msgid "class ``Motors``"
msgstr "Klasse ``Motors``"

#: ../api_motor.rst:23 ../api_motor.rst:95
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_motor.rst:25
msgid "Initilize"
msgstr "Initialisieren"

#: ../api_motor.rst:35
msgid "Directly control a motor. Motor 1/2 is according to PCB mark"
msgstr ""
"Direkte Steuerung eines Motors. Motor 1/2 entspricht der Kennzeichnung "
"auf der Platine"

#: ../api_motor.rst:46
msgid ""
"Setup for high level control, high level control provides functions from "
"simple forword, backward, left, right, stop to more complex like joystick"
" control, motor directions calibration, etc."
msgstr ""
"Einrichtung für hochrangige Steuerung, welche Funktionen von einfachen "
"Bewegungen wie Vorwärts, Rückwärts, Links, Rechts, Stopp bis zu "
"komplexeren wie Joysticksteuerung, Kalibrierung der Motorenrichtung usw. "
"bereitstellt."

#: ../api_motor.rst:51
msgid ""
"All these setup only need to run once, and will save in a config file. "
"Next time you load Motors class, it will load from config file."
msgstr ""
"All diese Einrichtungen müssen nur einmal ausgeführt werden und werden in"
" einer Konfigurationsdatei gespeichert. Wenn Sie das nächste Mal die "
"Klasse Motors laden, wird sie aus der Konfigurationsdatei geladen."

#: ../api_motor.rst:67
msgid "Now control the robot"
msgstr "Jetzt den Roboter steuern"

#: ../api_motor.rst:83 ../api_motor.rst:113
msgid "**API**"
msgstr "**API**"

#: of robot_hat.motor.Motors:1
msgid "Bases: :py:class:`~robot_hat.basic._Basic_class`"
msgstr "Basisklasse: :py:class:`~robot_hat.basic._Basic_class`"

#: of robot_hat.motor.Motors.__init__:1
msgid "Initialize motors with robot_hat.motor.Motor"
msgstr "Motoren mit robot_hat.motor.Motor initialisieren"

#: of robot_hat.motor.Motor.__init__ robot_hat.motor.Motor.set_is_reverse
#: robot_hat.motor.Motor.speed robot_hat.motor.Motors.__init__
#: robot_hat.motor.Motors.backward robot_hat.motor.Motors.forward
#: robot_hat.motor.Motors.set_left_id robot_hat.motor.Motors.set_right_id
#: robot_hat.motor.Motors.speed robot_hat.motor.Motors.turn_left
#: robot_hat.motor.Motors.turn_right
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.motor.Motors.__init__:3
msgid "config file path"
msgstr "Pfad zur Konfigurationsdatei"

#: of robot_hat.motor.Motors.__getitem__:1
msgid "Get specific motor"
msgstr "Spezifischen Motor abrufen"

#: of robot_hat.motor.Motors.stop:1
msgid "Stop all motors"
msgstr "Alle Motoren stoppen"

#: of robot_hat.Motors.left:1
msgid "left motor"
msgstr "linker Motor"

#: of robot_hat.Motors.right:1
msgid "right motor"
msgstr "rechter Motor"

#: of robot_hat.motor.Motors.set_left_id:1
msgid ""
"Set left motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr ""
"Linke Motor-ID einstellen, diese Funktion muss nur einmal ausgeführt "
"werden. Sie speichert die Motor-ID in der Konfigurationsdatei und lädt "
"sie beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.set_left_id:5
#: robot_hat.motor.Motors.set_right_id:5
msgid "motor id (1 or 2)"
msgstr "Motor-ID (1 oder 2)"

#: of robot_hat.motor.Motors.set_right_id:1
msgid ""
"Set right motor id, this function only need to run once It will save the "
"motor id to config file, and load the motor id when the class is "
"initialized"
msgstr ""
"Rechte Motor-ID einstellen, diese Funktion muss nur einmal ausgeführt "
"werden. Sie speichert die Motor-ID in der Konfigurationsdatei und lädt "
"sie beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.set_left_reverse:1
msgid ""
"Set left motor reverse, this function only need to run once It will save "
"the reversed status to config file, and load the reversed status when the"
" class is initialized"
msgstr ""
"Linken Motor umkehren, diese Funktion muss nur einmal ausgeführt werden. "
"Sie speichert den umgekehrten Status in der Konfigurationsdatei und lädt "
"diesen beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Returns"
msgstr "Rückgabe"

#: of robot_hat.motor.Motors.set_left_reverse:5
#: robot_hat.motor.Motors.set_right_reverse:5
msgid "if currently is reversed"
msgstr "ob derzeit umgekehrt ist"

#: of robot_hat.motor.Motors.set_left_reverse
#: robot_hat.motor.Motors.set_right_reverse
msgid "Return type"
msgstr "Rückgabetyp"

#: of robot_hat.motor.Motors.set_right_reverse:1
msgid ""
"Set right motor reverse, this function only need to run once It will save"
" the reversed status to config file, and load the reversed status when "
"the class is initialized"
msgstr ""
"Rechten Motor umkehren, diese Funktion muss nur einmal ausgeführt werden."
" Sie speichert den umgekehrten Status in der Konfigurationsdatei und lädt"
" diesen beim Initialisieren der Klasse."

#: of robot_hat.motor.Motors.speed:1
msgid "Set motor speed"
msgstr "Motorgeschwindigkeit einstellen"

#: of robot_hat.motor.Motors.speed:3
msgid "left motor speed(-100.0~100.0)"
msgstr "Geschwindigkeit des linken Motors (-100,0 bis 100,0)"

#: of robot_hat.motor.Motors.speed:5
msgid "right motor speed(-100.0~100.0)"
msgstr "Geschwindigkeit des rechten Motors (-100,0 bis 100,0)"

#: of robot_hat.motor.Motors.forward:1
msgid "Forward"
msgstr "Vorwärts"

#: of robot_hat.motor.Motor.speed:3 robot_hat.motor.Motors.backward:3
#: robot_hat.motor.Motors.forward:3 robot_hat.motor.Motors.turn_left:3
#: robot_hat.motor.Motors.turn_right:3
msgid "Motor speed(-100.0~100.0)"
msgstr "Motorgeschwindigkeit (-100,0 bis 100,0)"

#: of robot_hat.motor.Motors.backward:1
msgid "Backward"
msgstr "Rückwärts"

#: of robot_hat.motor.Motors.turn_left:1
msgid "Left turn"
msgstr "Links abbiegen"

#: of robot_hat.motor.Motors.turn_right:1
msgid "Right turn"
msgstr "Rechts abbiegen"

#: ../api_motor.rst:93
msgid "class ``Motor``"
msgstr "Klasse ``Motor``"

#: of robot_hat.motor.Motor:1
msgid "Bases: :py:class:`object`"
msgstr "Basisklasse: :py:class:`object`"

#: of robot_hat.motor.Motor.__init__:1
msgid "Initialize a motor"
msgstr "Einen Motor initialisieren"

#: of robot_hat.motor.Motor.__init__:3
msgid "Motor speed control pwm pin"
msgstr "PWM-Pin zur Geschwindigkeitssteuerung des Motors"

#: of robot_hat.motor.Motor.__init__:5
msgid "Motor direction control pin"
msgstr "Pin zur Steuerung der Motorenrichtung"

#: of robot_hat.motor.Motor.speed:1
msgid "Get or set motor speed"
msgstr "Motorgeschwindigkeit abrufen oder einstellen"

#: of robot_hat.motor.Motor.set_is_reverse:1
msgid "Set motor is reversed or not"
msgstr "Motor umkehren oder nicht"

#: of robot_hat.motor.Motor.set_is_reverse:3
msgid "True or False"
msgstr "Wahr oder Falsch"




##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/api_servo.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-12 18:01+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../api_servo.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr ""
"    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32"
" Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die "
"Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../api_servo.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../api_servo.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr ""
"**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische "
"Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../api_servo.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr ""
"**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre "
"Fähigkeiten zu verbessern."

#: ../api_servo.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr ""
"**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen "
"Produktankündigungen und exklusiven Einblicken."

#: ../api_servo.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr ""
"**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten "
"Produkte."

#: ../api_servo.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr ""
"**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und "
"Feiertagsaktionen teil."

#: ../api_servo.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr ""
"👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf"
" [|link_sf_facebook|] und treten Sie heute bei!"

#: ../api_servo.rst:18
msgid "class ``Servo``"
msgstr "Klasse ``Servo``"

#: ../api_servo.rst:20
msgid "**Example**"
msgstr "**Beispiel**"

#: ../api_servo.rst:58
msgid "**API**"
msgstr "**API**"

#: of robot_hat.servo.Servo:1
msgid "Bases: :py:class:`~robot_hat.pwm.PWM`"
msgstr "Basisklasse: :py:class:`~robot_hat.pwm.PWM`"

#: of robot_hat.servo.Servo:1
msgid "Servo motor class"
msgstr "Servomotorklasse"

#: of robot_hat.servo.Servo.__init__:1
msgid "Initialize the servo motor class"
msgstr "Die Servomotorklasse initialisieren"

#: of robot_hat.servo.Servo.__init__ robot_hat.servo.Servo.angle
#: robot_hat.servo.Servo.pulse_width_time
msgid "Parameters"
msgstr "Parameter"

#: of robot_hat.servo.Servo.__init__:3
msgid "PWM channel number(0-14/P0-P14)"
msgstr "PWM-Kanalnummer (0-14/P0-P14)"

#: of robot_hat.servo.Servo.angle:1
msgid "Set the angle of the servo motor"
msgstr "Den Winkel des Servomotors einstellen"

#: of robot_hat.servo.Servo.angle:3
msgid "angle(-90~90)"
msgstr "Winkel (-90~90)"

#: of robot_hat.servo.Servo.pulse_width_time:1
msgid "Set the pulse width of the servo motor"
msgstr "Die Pulsbreite des Servomotors einstellen"

#: of robot_hat.servo.Servo.pulse_width_time:3
msgid "pulse width time(500~2500)"
msgstr "Pulsbreitenzeit (500~2500)"

##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/project_ultrasonic.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../project_ultrasonic.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../project_ultrasonic.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../project_ultrasonic.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../project_ultrasonic.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../project_ultrasonic.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../project_ultrasonic.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../project_ultrasonic.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../project_ultrasonic.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../project_ultrasonic.rst:16
msgid "Read from Ultrasonic Module"
msgstr "Lesen vom Ultraschallmodul"

#: ../project_ultrasonic.rst:19
msgid ""
"In this project, we use ultrasonic sensors to measure distance and "
"display the readings on the I2C LCD1602."
msgstr ""
"In diesem Projekt verwenden wir Ultraschallsensoren, um Entfernungen zu "
"messen und die Messwerte auf dem I2C LCD1602 anzuzeigen."

#: ../project_ultrasonic.rst:23
msgid "**Steps**"
msgstr "**Schritte**"

#: ../project_ultrasonic.rst:25
msgid ""
"In this project, an I2C LCD1602 is used, so it's necessary to download "
"the relevant libraries to make it work."
msgstr ""
"In diesem Projekt wird ein I2C LCD1602 verwendet, daher ist es notwendig,"
" die relevanten Bibliotheken herunterzuladen, um es zum Laufen zu "
"bringen."

#: ../project_ultrasonic.rst:32
msgid "Install ``smbus2`` for I2C."
msgstr "Installieren Sie ``smbus2`` für I2C."

#: ../project_ultrasonic.rst:38
msgid ""
"Save the following code to your Raspberry Pi and give it a name, for "
"example, ``ultrasonic.ty``."
msgstr ""
"Speichern Sie den folgenden Code auf Ihrem Raspberry Pi und geben Sie ihm"
" einen Namen, zum Beispiel ``ultrasonic.ty``."

#: ../project_ultrasonic.rst:88
msgid "Use the command ``sudo python3 ultrasonic.ty`` to run this code."
msgstr ""
"Verwenden Sie den Befehl ``sudo python3 ultrasonic.ty``, um diesen Code "
"auszuführen."



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/features.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../features.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../features.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../features.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../features.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../features.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../features.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../features.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../features.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../features.rst:16
msgid "Features"
msgstr "Eigenschaften"

#: ../features.rst:18
msgid "Shutdown Current: < 0.5mA"
msgstr "Abschaltstrom: < 0.5mA"

#: ../features.rst:19
msgid "Power Input: USB Type-C, 5V/2A"
msgstr "Stromversorgung: USB Typ-C, 5V/2A"

#: ../features.rst:20
msgid "Charging Power: 5V/2A 10W"
msgstr "Ladeleistung: 5V/2A 10W"

#: ../features.rst:21
msgid "Output Power: 5V/3A"
msgstr "Ausgangsleistung: 5V/3A"

#: ../features.rst:22
msgid ""
"Included Batteries: 2 x 3.7V 18650 Lithium-ion Batteries, XH2.54 3P "
"Interface"
msgstr ""
"Enthaltene Batterien: 2 x 3.7V 18650 Lithium-Ionen-Batterien, XH2.54 3P "
"Schnittstelle"

#: ../features.rst:23
msgid "Battery Protection: Reverse polarity protection"
msgstr "Batterieschutz: Verpolungsschutz"

#: ../features.rst:24
msgid ""
"Charging Protection: Input undervoltage protection, input overvoltage "
"protection, charging balance, overheat protection"
msgstr ""
"Ladeschutz: Eingangsunterspannungsschutz, Eingangsüberspannungsschutz, "
"Ladebalance, Überhitzungsschutz"

#: ../features.rst:25
msgid "Onboard Charging Indicator Light: CHG"
msgstr "An Bord Ladeanzeigeleuchte: CHG"

#: ../features.rst:26
msgid "Onboard Power Indicator Light: PWR"
msgstr "An Bord Leistungsanzeigeleuchte: PWR"

#: ../features.rst:27
msgid "Onboard 2 Battery Level Indicator LEDs"
msgstr "An Bord 2 Batteriestatusanzeige LEDs"

#: ../features.rst:28
msgid "Onboard User LED, 2 tactile switches"
msgstr "An Bord Benutzer-LED, 2 Tastschalter"

#: ../features.rst:29
msgid "Motor Driver: 5V/1.8A x 2"
msgstr "Motorsteuerung: 5V/1.8A x 2"

#: ../features.rst:30
msgid "4-channel 12-bit ADC"
msgstr "4-Kanal 12-Bit-ADC"

#: ../features.rst:31
msgid "12-channel PWM"
msgstr "12-Kanal-PWM"

#: ../features.rst:32
msgid "4-channel digital signals"
msgstr "4-Kanal Digitalsignale"

#: ../features.rst:33
msgid "Onboard SPI interface, UART interface, I2C interface"
msgstr "An Bord SPI-Schnittstelle, UART-Schnittstelle, I2C-Schnittstelle"

#: ../features.rst:34
msgid "Mono Speaker: 8Ω1W"
msgstr "Mono Lautsprecher: 8Ω1W"

#: ../features.rst:36
msgid "Electrical Characteristics"
msgstr "Elektrische Eigenschaften"

#: ../features.rst:40
msgid "Parameters:"
msgstr "Parameter:"

#: ../features.rst:41
msgid "Minimum Value:"
msgstr "Mindestwert:"

#: ../features.rst:42
msgid "Typical Value:"
msgstr "Typischer Wert:"

#: ../features.rst:43
msgid "Maximum Value:"
msgstr "Höchstwert:"

#: ../features.rst:44
msgid "Unit:"
msgstr "Einheit:"

#: ../features.rst:45
msgid "Input Voltage:"
msgstr "Eingangsspannung:"

#: ../features.rst:46 ../features.rst:62
msgid "4.25"
msgstr "4.25"

#: ../features.rst:47
msgid "5"
msgstr "5"

#: ../features.rst:48 ../features.rst:53 ../features.rst:67
msgid "8.4"
msgstr "8.4"

#: ../features.rst:49 ../features.rst:54 ../features.rst:59 ../features.rst:64
#: ../features.rst:69 ../features.rst:84
msgid "V"
msgstr "V"

#: ../features.rst:50
msgid "Battery Input Voltage:"
msgstr "Batterie-Eingangsspannung:"

#: ../features.rst:51
msgid "6.0"
msgstr "6.0"

#: ../features.rst:52
msgid "7.4"
msgstr "7.4"

#: ../features.rst:55
msgid "Overcharge Protection (Battery):"
msgstr "Überladungsschutz (Batterie):"

#: ../features.rst:57 ../features.rst:66
msgid "8.3"
msgstr "8.3"

#: ../features.rst:60
msgid "Input Undervoltage Protection:"
msgstr "Eingangsunterspannungsschutz:"

#: ../features.rst:61
msgid "4.15"
msgstr "4.15"

#: ../features.rst:63
msgid "4.35"
msgstr "4.35"

#: ../features.rst:65
msgid "Input Overvoltage Protection:"
msgstr "Eingangsüberspannungsschutz:"

#: ../features.rst:68
msgid "8.5"
msgstr "8.5"

#: ../features.rst:70
msgid "Charging Current (5V):"
msgstr "Ladestrom (5V):"

#: ../features.rst:73
msgid "2.0"
msgstr "2.0"

#: ../features.rst:74 ../features.rst:79 ../features.rst:99
msgid "A"
msgstr "A"

#: ../features.rst:75
msgid "Output Current (5V):"
msgstr "Ausgangsstrom (5V):"

#: ../features.rst:78
msgid "3.0"
msgstr "3.0"

#: ../features.rst:80
msgid "Output Voltage:"
msgstr "Ausgangsspannung:"

#: ../features.rst:81
msgid "5.166"
msgstr "5.166"

#: ../features.rst:82
msgid "5.246"
msgstr "5.246"

#: ../features.rst:83
msgid "5.327"
msgstr "5.327"

#: ../features.rst:85
msgid "Charging Overheat Protection:"
msgstr "Überhitzungsschutz beim Laden:"

#: ../features.rst:86
msgid "125"
msgstr "125"

#: ../features.rst:87
msgid "135"
msgstr "135"

#: ../features.rst:88
msgid "145"
msgstr "145"

#: ../features.rst:89 ../features.rst:94
msgid "°C"
msgstr "°C"

#: ../features.rst:90
msgid "DC-DC Overheat Protection:"
msgstr "Überhitzungsschutz DC-DC:"

#: ../features.rst:91
msgid "70"
msgstr "70"

#: ../features.rst:92
msgid "75"
msgstr "75"

#: ../features.rst:93
msgid "80"
msgstr "80"

#: ../features.rst:95
msgid "Motor Output Current:"
msgstr "Motor-Ausgangsstrom:"

#: ../features.rst:98
msgid "1.8"
msgstr "1.8"



##################################################
# FILE: baseline_code/robot-hat/docs/source/locale/de/LC_MESSAGES/onboard_mcu.po
##################################################

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, SunFounder
# This file is distributed under the same license as the SunFounder Robot
# HAT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Robot HAT \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-24 09:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: de\n"
"Language-Team: de <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../onboard_mcu.rst:3
msgid ""
"Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 "
"Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, "
"Arduino, and ESP32 with fellow enthusiasts."
msgstr "    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten."

#: ../onboard_mcu.rst:5
msgid "**Why Join?**"
msgstr " **Warum beitreten?**"

#: ../onboard_mcu.rst:7
msgid ""
"**Expert Support**: Solve post-sale issues and technical challenges with "
"help from our community and team."
msgstr "**Expertenunterstützung**: Lösen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams."

#: ../onboard_mcu.rst:8
msgid "**Learn & Share**: Exchange tips and tutorials to enhance your skills."
msgstr "**Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre Fähigkeiten zu verbessern."

#: ../onboard_mcu.rst:9
msgid ""
"**Exclusive Previews**: Get early access to new product announcements and"
" sneak peeks."
msgstr "**Exklusive Vorschauen**: Erhalten Sie frühzeitigen Zugang zu neuen Produktankündigungen und exklusiven Einblicken."

#: ../onboard_mcu.rst:10
msgid "**Special Discounts**: Enjoy exclusive discounts on our newest products."
msgstr "**Spezialrabatte**: Genießen Sie exklusive Rabatte auf unsere neuesten Produkte."

#: ../onboard_mcu.rst:11
msgid ""
"**Festive Promotions and Giveaways**: Take part in giveaways and holiday "
"promotions."
msgstr "**Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil."

#: ../onboard_mcu.rst:13
msgid ""
"👉 Ready to explore and create with us? Click [|link_sf_facebook|] and "
"join today!"
msgstr "👉 Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!"

#: ../onboard_mcu.rst:18
msgid "On-Board MCU"
msgstr "On-Board-MCU"

#: ../onboard_mcu.rst:20
msgid ""
"The Robot HAT comes with an AT32F413CBT7 microcontroller from Artery. It "
"is an ARM Cortex-M4 processor with a maximum clock frequency of 200MHz. "
"The microcontroller has 128KB of Flash memory and 32KB of SRAM."
msgstr ""
"Der Robot HAT ist mit einem AT32F415CBT7 Mikrocontroller von Artery "
"ausgestattet. Es handelt sich um einen ARM Cortex-M4 Prozessor mit einer "
"maximalen Taktfrequenz von 150MHz. Der Mikrocontroller verfügt über 256KB"
" Flash-Speicher und 32KB SRAM."

#: ../onboard_mcu.rst:22
msgid ""
"The onboard PWM and ADC are driven by the microcontroller. Communication "
"between the Raspberry Pi and the microcontroller is established via the "
"I2C interface. The I2C address used for communication is 0x14 (7-bit "
"address format)."
msgstr ""
"Das Onboard-PWM und ADC werden vom Mikrocontroller gesteuert. Die "
"Kommunikation zwischen dem Raspberry Pi und dem Mikrocontroller erfolgt "
"über die I2C-Schnittstelle. Die für die Kommunikation verwendete I2C-"
"Adresse ist 0x14 (7-Bit-Adressformat)."

#: ../onboard_mcu.rst:28
msgid "Introduce"
msgstr "Einführung"

#: ../onboard_mcu.rst:30
msgid ""
"The on board MCU RESET pin is connected to Raspberry Pi GPIO 5, or "
"``MCURST`` for :py:class:`robot_hat.Pin`. The MCU using 7-bit address "
"``0x14``."
msgstr ""
"Der RESET-Pin des Onboard-MCU ist mit dem Raspberry Pi GPIO 5 oder "
"``MCURST`` für :py:class:`robot_hat.Pin` verbunden. Der MCU verwendet die"
" 7-Bit-Adresse ``0x14``."

#: ../onboard_mcu.rst:33
msgid "ADC"
msgstr "ADC"

#: ../onboard_mcu.rst:35
msgid ""
"Register addresses is 3 byte, 0x170000 to 0x140000 are ADC channels 0 to "
"3. The ADC precision is 12 bit, and the value is 0 to 4095. See more "
"details in :py:class:`robot_hat.ADC`."
msgstr ""
"Registeradressen sind 3 Byte, von 0x170000 bis 0x140000 sind es ADC-"
"Kanäle 0 bis 3. Die ADC-Präzision beträgt 12 Bit, und der Wert liegt "
"zwischen 0 und 4095. Weitere Einzelheiten finden Sie in "
":py:class:`robot_hat.ADC`."

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Address"
msgstr "Adresse"

#: ../onboard_mcu.rst:42 ../onboard_mcu.rst:104 ../onboard_mcu.rst:144
#: ../onboard_mcu.rst:164
msgid "Description"
msgstr "Beschreibung"

#: ../onboard_mcu.rst:44
msgid "``0x170000``"
msgstr "``0x170000``"

#: ../onboard_mcu.rst:44
msgid "ADC channel 0"
msgstr "ADC-Kanal 0"

#: ../onboard_mcu.rst:46
msgid "``0x160000``"
msgstr "``0x160000``"

#: ../onboard_mcu.rst:46
msgid "ADC channel 1"
msgstr "ADC-Kanal 1"

#: ../onboard_mcu.rst:48
msgid "``0x150000``"
msgstr "``0x150000``"

#: ../onboard_mcu.rst:48
msgid "ADC channel 2"
msgstr "ADC-Kanal 2"

#: ../onboard_mcu.rst:50
msgid "``0x140000``"
msgstr "``0x140000``"

#: ../onboard_mcu.rst:50
msgid "ADC channel 3"
msgstr "ADC-Kanal 3"

#: ../onboard_mcu.rst:52
msgid "``0x130000``"
msgstr "``0x130000``"

#: ../onboard_mcu.rst:52
msgid "ADC channel 4 (Battery Level)"
msgstr "ADC-Kanal 4 (Batteriestand)"

#: ../onboard_mcu.rst:55
msgid "**Example:**"
msgstr "**Beispiel:**"

#: ../onboard_mcu.rst:57
msgid "Read Channel 0 ADC value:"
msgstr "ADC-Wert des Kanals 0 lesen:"

#: ../onboard_mcu.rst:72
msgid "PWM"
msgstr "PWM"

#: ../onboard_mcu.rst:74
msgid "PWM have 1 byte register with 2 byte values."
msgstr "PWM hat ein 1-Byte-Register mit 2-Byte-Werten."

#: ../onboard_mcu.rst:77
msgid "Changing PWM Frequency"
msgstr "Ändern der PWM-Frequenz"

#: ../onboard_mcu.rst:79
msgid "Frequency is defined with prescaler and period."
msgstr "Die Frequenz wird mit Vorwähler und Periode definiert."

#: ../onboard_mcu.rst:81
msgid ""
"To set frequency first you need to define the period you want. Like on "
"Arduino, normaly is 255, or like PCA9685 is 4095."
msgstr ""
"Um die Frequenz einzustellen, müssen Sie zuerst die gewünschte Periode "
"definieren. Wie bei Arduino ist dies normalerweise 255, oder wie bei "
"PCA9685 4095."

#: ../onboard_mcu.rst:84
msgid ""
"CPU clock is 72MHz, Then you can calculate the prescaler from your desire"
" frequency"
msgstr ""
"Die CPU-Taktfrequenz beträgt 72 MHz. Dann können Sie den Vorwähler aus "
"Ihrer gewünschten Frequenz berechnen"

#: ../onboard_mcu.rst:87
msgid "prescaler = 72MHz / (Period + 1) / Frequency - 1"
msgstr "Vorwähler = 72MHz / (Periode + 1) / Frequenz - 1"

#: ../onboard_mcu.rst:89
msgid ""
"Or if you don't care about the period, there's a way to calculate both "
"period and prescaler from frequency. See :py:func:`robot_hat.PWM.freq`."
msgstr ""
"Wenn Ihnen die Periode egal ist, gibt es eine Möglichkeit, sowohl die "
"Periode als auch den Vorwähler aus der Frequenz zu berechnen. Siehe "
":py:func:`robot_hat.PWM.freq`."

#: ../onboard_mcu.rst:93
msgid "Pulse width"
msgstr "Pulsbreite"

#: ../onboard_mcu.rst:95
msgid ""
"To control the channel pulse width is rather simple, just write the value"
" to the register."
msgstr ""
"Die Kontrolle der Pulsbreite des Kanals ist recht einfach, schreiben Sie "
"einfach den Wert in das Register."

#: ../onboard_mcu.rst:97
msgid ""
"**But** what is the value? If you want to set the PWM to 50% pulse width,"
" you need to know exactly what the period is. Base on the above "
"calculation, if you set the period to 4095, then set pulse value to 2048 "
"is about 50% pulse width."
msgstr ""
"**Aber** was ist der Wert? Wenn Sie die PWM auf eine 50%-Pulsbreite "
"einstellen möchten, müssen Sie genau wissen, was die Periode ist. "
"Basierend auf der oben genannten Berechnung, wenn Sie die Periode auf "
"4095 einstellen, dann entspricht das Setzen des Puls-Wertes auf 2048 "
"ungefähr einer 50%-Pulsbreite."

#: ../onboard_mcu.rst:106
msgid "``0x20``"
msgstr "``0x20``"

#: ../onboard_mcu.rst:106
msgid "Set PWM channel 0 **On Value**"
msgstr "PWM-Kanal 0 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:108
msgid "``0x21``"
msgstr "``0x21``"

#: ../onboard_mcu.rst:108
msgid "Set PWM channel 1 **On Value**"
msgstr "PWM-Kanal 1 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:110
msgid "``0x22``"
msgstr "``0x22``"

#: ../onboard_mcu.rst:110
msgid "Set PWM channel 2 **On Value**"
msgstr "PWM-Kanal 2 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:112
msgid "``0x23``"
msgstr "``0x23``"

#: ../onboard_mcu.rst:112
msgid "Set PWM channel 3 **On Value**"
msgstr "PWM-Kanal 3 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:114
msgid "``0x24``"
msgstr "``0x24``"

#: ../onboard_mcu.rst:114
msgid "Set PWM channel 4 **On Value**"
msgstr "PWM-Kanal 4 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:116
msgid "``0x25``"
msgstr "``0x25``"

#: ../onboard_mcu.rst:116
msgid "Set PWM channel 5 **On Value**"
msgstr "PWM-Kanal 5 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:118
msgid "``0x26``"
msgstr "``0x26``"

#: ../onboard_mcu.rst:118
msgid "Set PWM channel 6 **On Value**"
msgstr "PWM-Kanal 6 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:120
msgid "``0x27``"
msgstr "``0x27``"

#: ../onboard_mcu.rst:120
msgid "Set PWM channel 7 **On Value**"
msgstr "PWM-Kanal 7 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:122
msgid "``0x28``"
msgstr "``0x28``"

#: ../onboard_mcu.rst:122
msgid "Set PWM channel 8 **On Value**"
msgstr "PWM-Kanal 8 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:124
msgid "``0x29``"
msgstr "``0x29``"

#: ../onboard_mcu.rst:124
msgid "Set PWM channel 9 **On Value**"
msgstr "PWM-Kanal 9 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:126
msgid "``0x2A``"
msgstr "``0x2A``"

#: ../onboard_mcu.rst:126
msgid "Set PWM channel 10 **On Value**"
msgstr "PWM-Kanal 10 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:128
msgid "``0x2B``"
msgstr "``0x2B``"

#: ../onboard_mcu.rst:128
msgid "Set PWM channel 11 **On Value**"
msgstr "PWM-Kanal 11 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:130
msgid "``0x2C``"
msgstr "``0x2C``"

#: ../onboard_mcu.rst:130
msgid "Set Motor 2 speed **On Value**"
msgstr "Geschwindigkeit von Motor 2 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:132
msgid "``0x2D``"
msgstr "``0x2D``"

#: ../onboard_mcu.rst:132
msgid "Set Motor 1 speed **On Value**"
msgstr "Geschwindigkeit von Motor 1 **Einschaltwert** einstellen"

#: ../onboard_mcu.rst:136
msgid "Prescaler"
msgstr "Vorteiler"

#: ../onboard_mcu.rst:138
msgid ""
"Register from 0x40 is to set the PWM prescaler. ranges from 0~65535. "
"There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"Register ab 0x40 dienen zur Einstellung des PWM-Vorteilers. Der Bereich "
"umfasst 0~65535. Es gibt nur 4 Timer für alle 14 Kanäle. Siehe `PWM "
"Timer(WICHTIG)`_"

#: ../onboard_mcu.rst:146
msgid "``0x40``"
msgstr "``0x40``"

#: ../onboard_mcu.rst:146
msgid "Set timer 0 **Prescaler**"
msgstr "Timer 0 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:148
msgid "``0x41``"
msgstr "``0x41``"

#: ../onboard_mcu.rst:148
msgid "Set timer 1 **Prescaler**"
msgstr "Timer 1 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:150
msgid "``0x42``"
msgstr "``0x42``"

#: ../onboard_mcu.rst:150
msgid "Set timer 2 **Prescaler**"
msgstr "Timer 2 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:152
msgid "``0x43``"
msgstr "``0x43``"

#: ../onboard_mcu.rst:152
msgid "Set timer 3 **Prescaler**"
msgstr "Timer 3 **Vorteiler** einstellen"

#: ../onboard_mcu.rst:156
msgid "Period"
msgstr "Periode"

#: ../onboard_mcu.rst:158
msgid ""
"Register from 0x44 is to set the PWM period. ranges from 0~65535. There "
"are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_"
msgstr ""
"Register ab 0x44 dienen zur Einstellung der PWM-Periode. Der Bereich "
"umfasst 0~65535. Es gibt nur 4 Timer für alle 14 Kanäle. Siehe `PWM "
"Timer(WICHTIG)`_"

#: ../onboard_mcu.rst:166
msgid "``0x44``"
msgstr "``0x44``"

#: ../onboard_mcu.rst:166
msgid "Set timer 0 **Period**"
msgstr "Timer 0 **Periode** einstellen"

#: ../onboard_mcu.rst:168
msgid "``0x45``"
msgstr "``0x45``"

#: ../onboard_mcu.rst:168
msgid "Set timer 1 **Period**"
msgstr "Timer 1 **Periode** einstellen"

#: ../onboard_mcu.rst:170
msgid "``0x46``"
msgstr "``0x46``"

#: ../onboard_mcu.rst:170
msgid "Set timer 2 **Period**"
msgstr "Timer 2 **Periode** einstellen"

#: ../onboard_mcu.rst:172
msgid "``0x47``"
msgstr "``0x47``"

#: ../onboard_mcu.rst:172
msgid "Set timer 3 **Period**"
msgstr "Timer 3 **Periode** einstellen"

#: ../onboard_mcu.rst:176
msgid "PWM Timer(IMPORTANT)"
msgstr "PWM-Timer(WICHTIG)"

#: ../onboard_mcu.rst:178
msgid ""
"What is PWM Timer? PWM Timer is a tool to turn on and off the PWM channel"
" for you."
msgstr ""
"Was ist ein PWM-Timer? Der PWM-Timer ist ein Werkzeug, um den PWM-Kanal "
"für Sie ein- und auszuschalten."

#: ../onboard_mcu.rst:180
msgid ""
"The MCU only have 4 timers for PWM: which means you cannot set frequency "
"on different channels at with the same timer."
msgstr ""
"Der MCU hat nur 4 Timer für PWM: Das bedeutet, Sie können die Frequenz "
"nicht für verschiedene Kanäle mit demselben Timer einstellen."

#: ../onboard_mcu.rst:183
msgid ""
"Example: if you set frequency on channel 0, channel 1, 2, 3 will be "
"affected. If you change channel 2 frequency, channel 0, 1, 3 will be "
"override."
msgstr ""
"Beispiel: Wenn Sie die Frequenz auf Kanal 0 einstellen, werden die Kanäle"
" 1, 2, 3 beeinflusst. Wenn Sie die Frequenz von Kanal 2 ändern, werden "
"die Kanäle 0, 1, 3 überschrieben."

#: ../onboard_mcu.rst:186
msgid ""
"This happens like if you want to control both a passive buzzer (who "
"changes frequency all the time) and servo (who needs a fix frequency of "
"50Hz). Then you should seperate them into two different timer."
msgstr ""
"Dies geschieht beispielsweise, wenn Sie sowohl einen passiven Summer (der"
" ständig die Frequenz ändert) als auch einen Servo (der eine feste "
"Frequenz von 50 Hz benötigt) steuern möchten. Dann sollten Sie diese auf "
"zwei verschiedene Timer aufteilen."

#: ../onboard_mcu.rst:192
msgid "Timer"
msgstr "Timer"

#: ../onboard_mcu.rst:192
msgid "PWM Channel"
msgstr "PWM-Kanal"

#: ../onboard_mcu.rst:194
msgid "Timer 0"
msgstr "Timer 0"

#: ../onboard_mcu.rst:194
msgid "0, 1, 2, 3"
msgstr "0, 1, 2, 3"

#: ../onboard_mcu.rst:196
msgid "Timer 1"
msgstr "Timer 1"

#: ../onboard_mcu.rst:196
msgid "4, 5, 6, 7"
msgstr "4, 5, 6, 7"

#: ../onboard_mcu.rst:198
msgid "Timer 2"
msgstr "Timer 2"

#: ../onboard_mcu.rst:198
msgid "8, 9, 10, 11"
msgstr "8, 9, 10, 11"

#: ../onboard_mcu.rst:200
msgid "Timer 3"
msgstr "Timer 3"

#: ../onboard_mcu.rst:200
msgid "12, 13(for motors)"
msgstr "12, 13 (für Motoren)"

#: ../onboard_mcu.rst:204
msgid "Example"
msgstr "Beispiel"

#: ../onboard_mcu.rst:224
msgid "Reset MCU"
msgstr "MCU zurücksetzen"

#: ../onboard_mcu.rst:226
msgid ""
"Currently the firmware reads a fix 3 byte value, then it can return ADC "
"values or control PWM. Thats why ADC register need 3byte with the latter "
"2 byte is 0."
msgstr ""
"Derzeit liest die Firmware einen festen 3-Byte-Wert, dann kann sie ADC-"
"Werte zurückgeben oder PWM steuern. Deshalb benötigt das ADC-Register 3 "
"Byte, wobei die letzten 2 Byte 0 sind."

#: ../onboard_mcu.rst:229
msgid ""
"And if your program is interrupted in the middle of the communication, "
"the firmware may stuck and offset the data. Even we have timeout on "
"waiting on 3 byte datas."
msgstr ""
"Wenn Ihr Programm mitten in der Kommunikation unterbrochen wird, kann die"
" Firmware hängen bleiben und die Daten verschieben. Selbst wenn wir ein "
"Timeout beim Warten auf 3-Byte-Daten haben."

#: ../onboard_mcu.rst:231
msgid ""
"If so, you need to reset the MCU. To reset it. You can use the robot_hat "
"command:"
msgstr ""
"Wenn dies der Fall ist, müssen Sie den MCU zurücksetzen. Um ihn "
"zurückzusetzen, können Sie den Befehl robot_hat verwenden:"

#: ../onboard_mcu.rst:237
msgid "Or you can do it in your python code:"
msgstr "Oder Sie können es in Ihrem Python-Code tun:"

#: ../onboard_mcu.rst:244
msgid ""
"Or you can just pull down the reset pin (GPIO 5) for 10 ms, then pull it "
"back up for another 10ms, as that's what ``reset_mcu`` dose."
msgstr ""
"Oder Sie können einfach den Reset-Pin (GPIO 5) für 10 ms herunterziehen "
"und dann für weitere 10 ms wieder hochziehen, denn das ist es, was "
"``reset_mcu`` macht."



##################################################
# FILE: baseline_code/robot-hat/docs/source/battery.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

About the Battery
========================
**Battery**

.. image:: img/3pin_battery.jpg
    :width: 500
    :align: center

* **VCC**: Battery positive terminal, here there are two sets of VCC and GND is to increase the current and reduce the resistance.
* **Middle**: To balance the voltage between the two cells and thus protect the battery.
* **GND**: Negative battery terminal.


This is a custom battery pack made by SunFounder consisting of two 18650 batteries with a capacity of 2000mAh. 
The connector is XH2.54 3pin, which can be charged directly after being inserted into the shield.


**Features**

* Composition: Li-ion
* Battery Capacity: 2000mAh, 14.8Wh
* Battery Weight: 90.8g
* Number of Cells: 2
* Connector: XH2.54 3pin
* Over-discharge protection: 6.0V


##################################################
# FILE: baseline_code/robot-hat/docs/source/project_say_something.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Say Something
====================


In this section, you'll learn how to convert text into speech and have Robot HAT speak it aloud.

**Steps**

#. We retrieve text from the command line to enable Robot HAT to articulate it. To achieve this, save the following code as a ``.py`` file, such as ``tts.py``.


    .. code-block:: python

        import sys
        from robot_hat import TTS

        # Check if there are enough command line arguments
        if len(sys.argv) > 1:
            text_to_say = sys.argv[1]  # Get the first argument passed from the command line
        else:
            text_to_say = "Hello SunFounder"  # Default text if no arguments are provided

        # Initialize the TTS class
        tts = TTS(lang='en-US')

        # Read the text
        tts.say(text_to_say)

        # Display all supported languages
        print(tts.supported_lang())

#. To make Robot HAT vocalize a specific sentence, you can use the following command: ``sudo python3 tts.py "any text"`` - simply replace ``"any text"`` with the desired phrase.

    .. note::

        * :ref:`faq_speaker`



##################################################
# FILE: baseline_code/robot-hat/docs/source/features.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Features
==============

    * Shutdown Current: < 0.5mA
    * Power Input: USB Type-C, 5V/2A
    * Charging Power: 5V/2A 10W
    * Output Power: 5V/3A
    * Included Batteries: 2 x 3.7V 18650 Lithium-ion Batteries, XH2.54 3P Interface
    * Battery Protection: Reverse polarity protection
    * Charging Protection: Input undervoltage protection, input overvoltage protection, charging balance, overheat protection
    * Onboard Charging Indicator Light: CHG
    * Onboard Power Indicator Light: PWR
    * Onboard 2 Battery Level Indicator LEDs
    * Onboard User LED, 2 tactile switches
    * Motor Driver: 5V/1.8A x 2
    * 4-channel 12-bit ADC
    * 12-channel PWM
    * 4-channel digital signals
    * Onboard SPI interface, UART interface, I2C interface
    * Mono Speaker: 8Ω1W

.. list-table:: Electrical Characteristics
   :widths: 50 25 25 25 25
   :header-rows: 1

   * - Parameters:
     - Minimum Value:
     - Typical Value:
     - Maximum Value:
     - Unit:
   * - Input Voltage:
     - 4.25
     - 5
     - 8.4
     - V
   * - Battery Input Voltage:
     - 6.0
     - 7.4
     - 8.4
     - V
   * - Overcharge Protection (Battery):
     -
     - 8.3
     -
     - V
   * - Input Undervoltage Protection:
     - 4.15
     - 4.25
     - 4.35
     - V
   * - Input Overvoltage Protection:
     - 8.3
     - 8.4
     - 8.5
     - V
   * - Charging Current (5V):
     -
     -
     - 2.0
     - A
   * - Output Current (5V):
     -
     -
     - 3.0
     - A
   * - Output Voltage:
     - 5.166
     - 5.246
     - 5.327
     - V
   * - Charging Overheat Protection:
     - 125
     - 135
     - 145
     - °C
   * - DC-DC Overheat Protection:
     - 70
     - 75
     - 80
     - °C
   * - Motor Output Current:  
     -
     -
     - 1.8
     - A  

##################################################
# FILE: baseline_code/robot-hat/docs/source/_templates/layout.html
##################################################

{%- extends "!layout.html" %}

{% block extrabody %}
<nav id="nav-bar">
  <ul class="nav-bar-items" id="nav-bar-items">
    <li class="nav-bar-logo">
      <a href="https://sunfounder.com">
        <img class="logo-img" src="https://ezblock.cc/readDocFile/sunfounder_LOGO_160x@2x.png"/>
      </a>
    </li>
  </ul>
</nav>
{% endblock %}

##################################################
# FILE: baseline_code/robot-hat/docs/source/api_i2c.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_i2c:

class ``I2C``
========================================

**Example**

.. code-block:: python

    # Import the I2C class
    from robot_hat import I2C

    # You can scan for available I2C devices
    print([f"0x{addr:02X}" for addr in I2C().scan()])
    # You should see at least one device address 0x14, which is the 
    # on board MCU for PWM and ADC

    # Initialize a I2C object with device address, for example
    # to communicate with on board MCU 0x14
    mcu = I2C(0x14)
    # Send ADC channel register to read ADC, 0x10 is Channel 0, 0x11 is Channel 1, etc.
    mcu.write([0x10, 0x00, 0x00])
    # Read 2 byte for MSB and LSB
    msb, lsb = mcu.read(2)
    # Convert to integer
    value = (msb << 8) + lsb
    # Print the value
    print(value)

For more information on the I2C protocol, see checkout adc.py and pwm.py

**API**

.. currentmodule:: robot_hat

.. autoclass:: I2C
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/install_i2s_for_speaker.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _install_i2s:

Install ``i2samp.sh`` for the Speaker
==============================================

The ``i2samp.sh`` is a sophisticated Bash script specifically designed for setting up and configuring an I2S (Inter-IC Sound) amplifier on Raspberry Pi and similar devices. Licensed under the MIT license, it ensures compatibility with a range of hardware and operating systems, conducting thorough checks before proceeding with any installation or configuration.

If you want your speaker to work properly, you definitely need to install this script. 

The steps are as follows:

.. code-block::

    cd ~/robot-hat
    sudo bash i2samp.sh

Type ``y`` and press ``enter`` to continue running the script.

    .. image:: img/install_i2s1.png

Type ``y`` and press ``enter`` to run ``/dev/zero`` in the background.

    .. image:: img/install_i2s2.png

Type ``y`` and press ``enter`` to restart the Raspberry pi.

    .. image:: img/install_i2s2.png

.. warning::

    If there is no sound after restarting, you may need to run the ``i2samp.sh`` script several times.

##################################################
# FILE: baseline_code/robot-hat/docs/source/api_filedb.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

class ``FileDB``
======================

**Example**

.. code-block:: python
    
    # Import fileDB class
    from robot_hat import fileDB

    # Create fileDB object with a config file
    db = fileDB("./config")

    # Set some values
    db.set("apple", "10")
    db.set("orange", "5")
    db.set("banana", "13")

    # Read the values
    print(db.get("apple"))
    print(db.get("orange"))
    print(db.get("banana"))

    # Read an none existing value with a default value
    print(db.get("pineapple", default_value="-1"))

Now you can checkout the config file ``config`` in bash.

.. code-block:: bash

    cat config

**API**

.. currentmodule:: robot_hat

.. autoclass:: fileDB
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code/robot-hat/docs/source/conf.py
##################################################

# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
# import os
# import sys
# sys.path.insert(0, os.path.abspath('.'))


# -- Project information -----------------------------------------------------
import sphinx_rtd_theme
import os
import sys
import time
sys.path.insert(0, os.path.abspath('../../'))

autodoc_mock_imports = ["smbus2", "RPi", "pyaudio", "numpy", "spidev", "gpiozero"]
autodoc_default_options = {'member-order': 'bysource', }

project = 'SunFounder Robot HAT'
copyright = f'{time.localtime().tm_year}, SunFounder'
author = 'www.sunfounder.com'

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autosectionlabel',
    'sphinx_copybutton',
    'sphinx_rtd_theme',
    'sphinx_toolbox.collapse',
    'sphinx.ext.autodoc',
    'sphinx.ext.autosummary',
    'sphinx.ext.napoleon',
    #'sphinx.ext.imgmath',
]

html_theme_options = {
    'flyout_display': 'attached'
}
#latex_engine = 'xelatex'

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = []


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'
html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]


#### RTD+

html_js_files = [
    'https://ezblock.cc/readDocFile/custom.js',
    './lang.js', # new
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/ace.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/ext-language_tools.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/theme-chrome.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/mode-python.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/mode-sh.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/monokai.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/xterm.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/FitAddon.js',
    'https://ezblock.cc/readDocFile/readTheDoc/src/js/readTheDocIndex.js',
]
html_css_files = [
    'https://ezblock.cc/readDocFile/custom.css',
    'https://ezblock.cc/readDocFile/readTheDoc/src/css/index.css',
    'https://ezblock.cc/readDocFile/readTheDoc/src/css/xterm.css',
]




# Multi-language

language = 'en' # Before running make html, set the language.
# language = 'de' # Before running make html, set the language.
# language = 'ja' # Before running make html, set the language.
locale_dirs = ['locale/'] # .po files for other languages are placed in the locale/ folder.

gettext_compact = False # Support for generating the contents of the folders inside source/ into other languages.



# links

rst_epilog = """

.. |link_sf_facebook| raw:: html

    <a href="https://bit.ly/raphaelkit" target="_blank">here</a>

.. |link_german_tutorials| raw:: html

    <a href="https://docs.sunfounder.com/projects/robot-hat-v4/de/latest/" target="_blank">Deutsch Online-Kurs</a>

.. |link_jp_tutorials| raw:: html

    <a href="https://docs.sunfounder.com/projects/robot-hat-v4/ja/latest/" target="_blank">日本語オンライン教材</a>

.. |link_en_tutorials| raw:: html

    <a href="https://docs.sunfounder.com/projects/robot-hat-v4/en/latest/" target="_blank">English Online-tutorials</a>

.. |link_peppe8o| raw:: html

    <a href="https://peppe8o.com/raspberry-pi-robot-hat-sunfounder/" target="_blank">Introduce Raspberry Pi Robot HAT Posted by Peppe8o</a>

.. |link_Robot_HAT| raw:: html

    <a href="https://www.sunfounder.com/products/sunfounder-robot-hat-expansion-board-designed-for-raspberry-pi?_pos=1&_sid=761470ec5&_ss=r" target="_blank">Purchase Link for Robot HAT</a>

.. |link_Robot_HAT_kit| raw:: html

    <a href="https://www.sunfounder.com/products/sunfounder-robot-hat-expansion-board-designed-for-raspberry-pi?_pos=1&_sid=761470ec5&_ss=r" target="_blank">Robot HAT</a>

"""




##################################################
# FILE: baseline_code/robot-hat/docs/source/community_tutorials.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Community Tutorials
=======================

* |link_peppe8o|

This document summarizes the SunFounder Raspberry Pi Robot HAT, covering its purpose, compatibility, specifications, and testing:

* **Introduction**: Explains the Robot HAT's role in simplifying control for Raspberry Pi-based DIY robot projects.
* **Specifications**: Details the technical specs, including power input, battery details, ports, and motor driver features.
* **Ports Overview**: Describes various ports like Power, Digital, Analog, PWM, I2C, SPI, UART, and Motor Ports.
* **Additional Components**: Highlights extra components like buttons, LED, and speaker, with Raspberry Pi PIN mappings.
* **Setup and Testing**: Guides on mounting the Robot HAT, necessary components, and testing procedures for features like LED and servo motors.








##################################################
# FILE: baseline_code/robot-hat/docs/source/api_modules.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

module ``modules``
==================================================

.. currentmodule:: robot_hat.modules

class ``Ultrasonic``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import Ultrasonic and Pin class
        from robot_hat import Ultrasonic, Pin

        # Create Motor object
        us = Ultrasonic(Pin("D2"), Pin("D3"))

        # Read distance
        distance = us.read()
        print(f"Distance: {distance}cm")

    **API**

    .. autoclass:: Ultrasonic
        :special-members: __init__
        :members:

class ``ADXL345``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import ADXL345 class
        from robot_hat import ADXL345

        # Create ADXL345 object
        adxl = ADXL345()
        # or with a custom I2C address
        adxl = ADXL345(address=0x53)

        # Read acceleration of each axis
        x = adxl.read(adxl.X)
        y = adxl.read(adxl.Y)
        z = adxl.read(adxl.Z)
        print(f"Acceleration: {x}, {y}, {z}")

        # Or read all axis at once
        x, y, z = adxl.read()
        print(f"Acceleration: {x}, {y}, {z}")
        # Or print all axis at once
        print(f"Acceleration: {adxl.read()}")

    **API**

    .. autoclass:: robot_hat.ADXL345
        :show-inheritance:
        :special-members: __init__
        :members:

class ``RGB_LED``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import RGB_LED and PWM class
        from robot_hat import RGB_LED, PWM

        # Create RGB_LED object for common anode RGB LED
        rgb = RGB_LED(PWM(0), PWM(1), PWM(2), common=RGB_LED.ANODE)
        # or for common cathode RGB LED
        rgb = RGB_LED(PWM(0), PWM(1), PWM(2), common=RGB_LED.CATHODE)

        # Set color with 24 bit int
        rgb.color(0xFF0000) # Red
        # Set color with RGB tuple
        rgb.color((0, 255, 0)) # Green
        # Set color with RGB List
        rgb.color([0, 0, 255]) # Blue
        # Set color with RGB hex string starts with “#”
        rgb.color("#FFFF00") # Yellow

    **API**

    .. autoclass:: robot_hat.RGB_LED
        :special-members: __init__
        :members:

class ``Buzzer``
-----------------------------------------

    **Example**

    Imports and initialize

    .. code-block:: python

        # Import Buzzer class
        from robot_hat import Buzzer
        # Import Pin for active buzzer
        from robot_hat import Pin
        # Import PWM for passive buzzer
        from robot_hat import PWM
        # import Music class for tones
        from robot_hat import Music
        # Import time for sleep
        import time
    
        music = Music()
        # Create Buzzer object for passive buzzer
        p_buzzer = Buzzer(PWM(0))
        # Create Buzzer object for active buzzer
        a_buzzer = Buzzer(Pin("D0"))

    Active buzzer beeping

    .. code-block:: python

        while True:
            a_buzzer.on()
            time.sleep(0.5)
            a_buzzer.off()
            time.sleep(0.5)
    
    Passive buzzer Simple usage

    .. code-block:: python

        # Play a Tone for 1 second
        p_buzzer.play(music.note("C3"), duration=1)
        # take adventage of the music beat as duration
        # set song tempo of the beat value
        music.tempo(120, 1/4)
        # Play note with a quarter beat
        p_buzzer.play(music.note("C3"), music.beat(1/4))

    Passive buzzer Manual control

    .. code-block:: python

        # Play a tone
        p_buzzer.play(music.note("C4"))
        # Pause for 1 second
        time.sleep(1)
        # Play another tone
        p_buzzer.play(music.note("C5"))
        # Pause for 1 second
        time.sleep(1)
        # Stop playing
        p_buzzer.off()


    Play a song! Baby shark!

    .. code-block:: python

        music.tempo(120, 1/4)

        # Make a Shark-doo-doo function as is all about it
        def shark_doo_doo():
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/16))
            p_buzzer.play(music.note("C5"), music.beat(1/16 + 1/16))
            p_buzzer.play(music.note("C5"), music.beat(1/16))
            p_buzzer.play(music.note("C5"), music.beat(1/8))

        # loop any times you want from baby to maybe great great great grandpa!
        for _ in range(3):
            print("Measure 1")
            p_buzzer.play(music.note("G4"), music.beat(1/4))
            p_buzzer.play(music.note("A4"), music.beat(1/4))
            print("Measure 2")
            shark_doo_doo()
            p_buzzer.play(music.note("G4"), music.beat(1/8))
            p_buzzer.play(music.note("A4"), music.beat(1/8))
            print("Measure 3")
            shark_doo_doo()
            p_buzzer.play(music.note("G4"), music.beat(1/8))
            p_buzzer.play(music.note("A4"), music.beat(1/8))
            print("Measure 4")
            shark_doo_doo()
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            p_buzzer.play(music.note("C5"), music.beat(1/8))
            print("Measure 5")
            p_buzzer.play(music.note("B4"), music.beat(1/4))
            time.sleep(music.beat(1/4))



    **API**

    .. autoclass:: robot_hat.Buzzer
        :special-members: __init__
        :members:


class ``Grayscale_Module``
-----------------------------------------

    **Example**

    .. code-block:: python

        # Import Grayscale_Module and ADC class
        from robot_hat import Grayscale_Module, ADC
        
        # Create Grayscale_Module object, reference should be calculate from the value reads on white
        # and black ground, then take the middle as reference
        gs = Grayscale_Module(ADC(0), ADC(1), ADC(2), reference=2000)
        
        # Read Grayscale_Module datas
        datas = gs.read()
        print(f"Grayscale Module datas: {datas}")
        # or read a specific channel
        l = gs.read(gs.LEFT)
        m = gs.read(gs.MIDDLE)
        r = gs.read(gs.RIGHT)
        print(f"Grayscale Module left channel: {l}")
        print(f"Grayscale Module middle channel: {m}")
        print(f"Grayscale Module right channel: {r}")

        # Read Grayscale_Module simple states
        state = gs.read_status()
        print(f"Grayscale_Module state: {state}")

    **API**

    .. autoclass:: robot_hat.Grayscale_Module
        :special-members: __init__
        :members:


##################################################
# FILE: baseline_code/robot-hat/docs/source/project_diy_car.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

DIY Car
==============

In addition to being suitable for simple experiments, the Robot HAT is ideal for use as a central controller in robotics, such as for smart cars.

In this project, we built a simple line-following car.

.. image:: img/diy_car.jpg

**Code**

.. code-block:: python

    from robot_hat import Motors, Pin
    import time

    # Create motor object
    motors = Motors()

    # Initialize line tracking sensor
    line_track = Pin('D0')

    def main():
        while True:
            # print("value", line_track.value())
            # time.sleep(0.01)
            if line_track.value() == 1:
                # If line is detected
                motors[1].speed(-60)  # Motor 1 forward
                motors[2].speed(20) # Motor 2 backward
                time.sleep(0.01)
            else:
                # If line is not detected
                motors[1].speed(-20) # Motor 1 backward
                motors[2].speed(60)  # Motor 2 forward
                time.sleep(0.01)

    def destroy():
        # Stop motors when Ctrl+C is pressed
        motors.stop()
        print("Motors stopped.")

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy()


##################################################
# FILE: baseline_code/robot-hat/docs/source/api_utils.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

module ``utils``
==================================================

.. automodule:: robot_hat.utils
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/onboard_mcu.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _on_board_mcu:

On-Board MCU
=======================

The Robot HAT comes with an AT32F413CBT7 microcontroller from Artery. It is an ARM Cortex-M4 processor with a maximum clock frequency of 200MHz. The microcontroller has 128KB of Flash memory and 32KB of SRAM.

The onboard PWM and ADC are driven by the microcontroller. 
Communication between the Raspberry Pi and the microcontroller is established via the I2C interface. 
The I2C address used for communication is 0x14 (7-bit address format).


Introduce
-----------------------

The on board MCU RESET pin is connected to Raspberry Pi GPIO 5, or ``MCURST`` for :py:class:`robot_hat.Pin`. The MCU using 7-bit address ``0x14``.

ADC
-----------------------

Register addresses is 3 byte, 0x170000 to 0x140000 are ADC channels 0 to 3.
The ADC precision is 12 bit, and the value is 0 to 4095.
See more details in :py:class:`robot_hat.ADC`.

.. table::

    +-------------------+-------------------------------+
    | Address           | Description                   |
    +===================+===============================+
    | ``0x170000``      | ADC channel 0                 |
    +-------------------+-------------------------------+
    | ``0x160000``      | ADC channel 1                 |
    +-------------------+-------------------------------+
    | ``0x150000``      | ADC channel 2                 |
    +-------------------+-------------------------------+
    | ``0x140000``      | ADC channel 3                 |
    +-------------------+-------------------------------+
    | ``0x130000``      | ADC channel 4 (Battery Level) |
    +-------------------+-------------------------------+

**Example:**

Read Channel 0 ADC value:

.. code-block:: python

    from smbus import SMBus
    bus = SMBus(1)

    # smbus only support 8 bit register address, so write 2 byte 0 first
    bus.write_word_data(0x14, 0x17, 0)
    msb = bus.read_byte(0x14)
    lsb = bus.read_byte(0x14)
    value = (msb << 8) | lsb


PWM
-----------------------

PWM have 1 byte register with 2 byte values.

Changing PWM Frequency
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Frequency is defined with prescaler and period.

To set frequency first you need to define the period you want.
Like on Arduino, normaly is 255, or like PCA9685 is 4095.

CPU clock is 72MHz, Then you can calculate the prescaler from your desire frequency


    prescaler = 72MHz / (Period + 1) / Frequency - 1

Or if you don't care about the period, there's a way to calculate both period and prescaler from
frequency. See :py:func:`robot_hat.PWM.freq`.

Pulse width
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To control the channel pulse width is rather simple, just write the value to the register.

**But** what is the value? If you want to set the PWM to 50% pulse width, you need to know
exactly what the period is. Base on the above calculation, if you set the period to 4095,
then set pulse value to 2048 is about 50% pulse width.

.. table::

    +-------------------+----------------------------------+
    | Address           | Description                      |
    +===================+==================================+
    | ``0x20``          | Set PWM channel 0 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x21``          | Set PWM channel 1 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x22``          | Set PWM channel 2 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x23``          | Set PWM channel 3 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x24``          | Set PWM channel 4 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x25``          | Set PWM channel 5 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x26``          | Set PWM channel 6 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x27``          | Set PWM channel 7 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x28``          | Set PWM channel 8 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x29``          | Set PWM channel 9 **On Value**   |
    +-------------------+----------------------------------+
    | ``0x2A``          | Set PWM channel 10 **On Value**  |
    +-------------------+----------------------------------+
    | ``0x2B``          | Set PWM channel 11 **On Value**  |
    +-------------------+----------------------------------+
    | ``0x2C``          | Set Motor 2 speed **On Value**   |
    +-------------------+----------------------------------+
    | ``0x2D``          | Set Motor 1 speed **On Value**   |
    +-------------------+----------------------------------+

Prescaler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Register from 0x40 is to set the PWM prescaler. ranges from 0~65535.
There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_

.. table::

    +-------------------+----------------------------------+
    | Address           | Description                      |
    +===================+==================================+
    | ``0x40``          | Set timer 0 **Prescaler**        |
    +-------------------+----------------------------------+
    | ``0x41``          | Set timer 1 **Prescaler**        |
    +-------------------+----------------------------------+
    | ``0x42``          | Set timer 2 **Prescaler**        |
    +-------------------+----------------------------------+
    | ``0x43``          | Set timer 3 **Prescaler**        |
    +-------------------+----------------------------------+

Period
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Register from 0x44 is to set the PWM period. ranges from 0~65535.
There are only 4 timers for all 14 channels. See `PWM Timer(IMPORTANT)`_

.. table::

    +-------------------+----------------------------------+
    | Address           | Description                      |
    +===================+==================================+
    | ``0x44``          | Set timer 0 **Period**           |
    +-------------------+----------------------------------+
    | ``0x45``          | Set timer 1 **Period**           |
    +-------------------+----------------------------------+
    | ``0x46``          | Set timer 2 **Period**           |
    +-------------------+----------------------------------+
    | ``0x47``          | Set timer 3 **Period**           |
    +-------------------+----------------------------------+

PWM Timer(IMPORTANT)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What is PWM Timer? PWM Timer is a tool to turn on and off the PWM channel for you.

The MCU only have 4 timers for PWM: which means you cannot set frequency on different channels
at with the same timer.

Example: if you set frequency on channel 0, channel 1, 2, 3 will be affected.
If you change channel 2 frequency, channel 0, 1, 3 will be override.

This happens like if you want to control both a passive buzzer (who changes frequency all the time)
and servo (who needs a fix frequency of 50Hz). Then you should seperate them into two different timer.

.. table::

    +---------------+-------------------+
    | Timer         | PWM Channel       |
    +===============+===================+
    | Timer 0       | 0, 1, 2, 3        |
    +---------------+-------------------+
    | Timer 1       | 4, 5, 6, 7        |
    +---------------+-------------------+
    | Timer 2       | 8, 9, 10, 11      |
    +---------------+-------------------+
    | Timer 3       | 12, 13(for motors)|
    +---------------+-------------------+

Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from smbus import SMBus
    bus = SMBus(1)

    # Set timer 0 period to 4095
    bus.write_word_data(0x14, 0x44, 4095)
    # Set frequency to 50Hz,
    freq = 50
    # Calculate prescaler
    prescaler = int(72000000 / (4095 + 1) / freq) - 1
    # Set prescaler
    bus.write_word_data(0x14, 0x40, prescaler)
    
    # Set channel 0 to 50% pulse width
    bus.write_word_data(0x14, 0x20, 2048)

Reset MCU
-----------------------------

Currently the firmware reads a fix 3 byte value, then it can return ADC values or control PWM.
Thats why ADC register need 3byte with the latter 2 byte is 0.

And if your program is interrupted in the middle of the communication, the firmware may stuck and offset the data. Even we have timeout on waiting on 3 byte datas.

If so, you need to reset the MCU. To reset it. You can use the robot_hat command:

.. code-block:: bash

    robot_hat reset_mcu

Or you can do it in your python code:

.. code-block:: python

    from robot_hat import reset_mcu
    reset_mcu()

Or you can just pull down the reset pin (GPIO 5) for 10 ms, then pull it back up for another 10ms, as that's what ``reset_mcu`` dose.

.. code-block:: python

    import RPi.GPIO as GPIO
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(5, GPIO.OUT)
    GPIO.output(5, GPIO.LOW)
    time.sleep(0.01)
    GPIO.output(5, GPIO.HIGH)
    time.sleep(0.01)


##################################################
# FILE: baseline_code/robot-hat/docs/source/project_ultrasonic.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Read from Ultrasonic Module
===============================


In this project, we use ultrasonic sensors to measure distance and display the readings on the I2C LCD1602.

.. image:: img/ultrasonic.jpg

**Steps**

#. In this project, an I2C LCD1602 is used, so it's necessary to download the relevant libraries to make it work.

    .. code-block:: shell

        cd ~/
        wget https://github.com/sunfounder/raphael-kit/blob/master/python/LCD1602.py

#. Install ``smbus2`` for I2C.

    .. code-block:: shell

        sudo pip3 install smbus2

#. Save the following code to your Raspberry Pi and give it a name, for example, ``ultrasonic.ty``.

    .. code-block:: python

        from robot_hat import ADC, Ultrasonic, Pin
        import LCD1602
        import time

        # Create ADC object for photoresistor
        a0 = ADC(0)

        # Create Ultrasonic object
        us = Ultrasonic(Pin("D2"), Pin("D3")) //Trig to digital pin 2, echo to pin 3

        def setup():
            # Initialize LCD1602
            LCD1602.init(0x27, 1)
            # Initial message on LCD
            LCD1602.write(0, 0, 'Measuring...')
            time.sleep(2)

        def destroy():
            # Clear the LCD display
            LCD1602.clear()

        def loop():
            while True:
                # Read distance from ultrasonic sensor
                distance = us.read()
                # Display the distance on the LCD
                if distance != -1:
                    # Display the valid distance on the LCD
                    LCD1602.write(0, 0, 'Dist: %.2f cm   ' % distance)
                
                # Update every 0.5 seconds
                time.sleep(0.2)

        if __name__ == '__main__':
            setup()
            try:
                loop()
            except KeyboardInterrupt:
                destroy()
            except Exception as e:
                # Clear the LCD and print error message in case of an exception
                destroy()
                print("Error:", e)



#. Use the command ``sudo python3 ultrasonic.ty`` to run this code.



##################################################
# FILE: baseline_code/robot-hat/docs/source/api_adc.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_adc:

class ``ADC``
=========================================

**Example**

.. code-block:: python
    
    # Import ADC class
    from robot_hat import ADC

    # Create ADC object with numeric pin numbering
    a0 = ADC(0)
    # Create ADC object with named pin numbering
    a1 = ADC('A1')

    # Read ADC value
    value0 = a0.read()
    value1 = a1.read()
    voltage0 = a0.read_voltage()
    voltage1 = a1.read_voltage()
    print(f"ADC 0 value: {value0}")
    print(f"ADC 1 value: {value1}")
    print(f"ADC 0 voltage: {voltage0}")
    print(f"ADC 1 voltage: {voltage1}")

**API**

.. currentmodule:: robot_hat

.. autoclass:: ADC
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/api_pin.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_pin:

class ``Pin``
===========================

**Example**

.. code-block:: python
    
    # Import Pin class
    from robot_hat import Pin

    # Create Pin object with numeric pin numbering and default input pullup enabled
    d0 = Pin(0, Pin.IN, Pin.PULL_UP)
    # Create Pin object with named pin numbering
    d1 = Pin('D1')

    # read value
    value0 = d0.value()
    value1 = d1.value()
    print(value0, value1)

    # write value
    d0.value(1) # force input to output
    d1.value(0)

    # set pin high/low
    d0.high()
    d1.off()

    # set interrupt
    led = Pin('LED', Pin.OUT)
    switch = Pin('SW', Pin.IN, Pin.PULL_DOWN)
    def onPressed(chn):
        led.value(not switch.value())
    switch.irq(handler=onPressed, trigger=Pin.IRQ_RISING_FALLING)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Pin
    :show-inheritance:
    :special-members: __init__, __call__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/installation.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Install the ``robot-hat`` Module
==========================================

``robot-hat`` is the supported library for the Robot HAT.

#. Update your system.

   Make sure you are connected to the Internet and update your system:

   .. raw:: html

      <run></run>

   .. code-block::

      sudo apt update
      sudo apt upgrade

   .. note::

      Python3 related packages must be installed if you are installing the **Lite** version OS.

      .. raw:: html

         <run></run>

      .. code-block::
        
         sudo apt install git python3-pip python3-setuptools python3-smbus

#. Type this command into the terminal to install the ``robot-hat`` package.

    .. raw:: html

        <run></run>

    .. code-block::

        cd ~/
        git clone -b v2.0 https://github.com/sunfounder/robot-hat.git
        cd robot-hat
        sudo python3 setup.py install

   .. note::
      Run ``setup.py`` to download some necessary components. You may have a network problem and the download may fail. At this point you may need to download again. In the following cases, type ``Y`` and press ``Enter`` to continue the process.

   .. image:: img/dowload_code.png

##################################################
# FILE: baseline_code/robot-hat/docs/source/hardware_introduction.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Hardware Introduction
=========================

Pinout
---------------

.. image:: img/robot_hat_pinout.png
  :width: 800
  :align: center

**Power Port**
    * 6.0V-8.4V XH2.54 3pin power input.
    * Powering the Raspberry Pi and Robot HAT at the same time.

**Power Switch**
    * Turn on/off the power of the robot HAT.

**Type-C USB Port**
    * Insert the Type-C cable to charge the battery.
    * At the same time, the charging indicator lights up in red color.
    * When the battery is fully charged, the charging indicator turns off.
    * If the USB cable is still plugged in about 4 hours after it is fully charged, the charging indicator will blink to prompt.

**Digital Pin**
    * 4-channel digital pins, D0-D3.
    * Pin: :ref:`pin_digital`.
    * API: :ref:`class_pin`.

**ADC Pin**
    * 4-channel ADC pins, A0-A3.
    * Pin: :ref:`pin_adc`.
    * API: :ref:`class_adc`.

**PWM Pin**
    * 12-channel PWM pins, P0-P11.
    * Pin: :ref:`pin_pwm`.
    * API: :ref:`class_pwm`.

**Left/Right Motor Port**
    * 2-channel XH2.54 motor ports.
    * Pin: :ref:`pin_motor`.
    * API: :ref:`class_motor`, ``1`` for left motor port, ``2`` for right motor port.

**I2C Pin and I2C Port**
    * **I2C Pin**: P2.54 4-pin interface.
    * **I2C Port**: SH1.0 4-pin interface, which is compatible with QWIIC and STEMMA QT. 
    * These I2C interfaces are connected to the Raspberry Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL).
    * Pin: :ref:`pin_i2c`.
    * API: :ref:`class_i2c`.

**SPI Pin**
    * P2.54 7-pin SPI interface.
    * Pin: :ref:`pin_spi`.

**UART Pin**
    * P2.54 4-pin interface.
    * Pin: :ref:`pin_uart`.

**RST Button**
    * The RST button, when using Ezblock, serves as a button to restart the Ezblock program. 
    * If not using Ezblock, the RST button does not have a predefined function and can be fully customized according to your needs.
    * Pin: :ref:`pin_button`.
    * API: :ref:`class_pin`

**USR Button**
    * The functions of USR Button can be set by your programming. (Pressing down leads to a input “0”; releasing produces a input “1”. ) 
    * API: :ref:`class_pin`, you can use ``Pin("SW")`` to define it.
    * Pin: :ref:`pin_button`.

**Battery Indicator**
    * Two LEDs light up when the voltage is higher than 7.6V.
    * One LED lights up in the 7.15V to 7.6V range. 
    * Below 7.15V, both LEDs turn off.
    * :ref:`battery_indicator`.

**Speaker and Speaker Port**
    * **Speaker**: This is a 2030 audio chamber speaker.
    * **Speaker Port**: The Robot HAT is equipped with onboard I2S audio output, along with a 2030 audio chamber speaker, providing a mono sound output.
    * Pin: :ref:`pin_speaker`.
    * API: :ref:`class_music`



Pin Mapping
------------------

.. list-table:: Raspberry Pi IO
    :widths: 50 50 50 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi
      - Raspberry Pi
      - Robot Hat V4
    * - NC
      - 3V3    
      - 5V
      - 5V
    * - SDA
      - SDA    
      - 5V
      - 5V
    * - SCL
      - SCL    
      - GND
      - GND
    * - D1
      - GPIO4    
      - TXD
      - TXD
    * - GND
      - GND    
      - RXD
      - RXD
    * - D0
      - GPIO17    
      - GPIO18
      - I2S BCLK
    * - D2
      - GPIO27    
      - GND
      - GND
    * - D3
      - GPIO22    
      - GPIO23
      - MOTOR 1 DIR
    * - NC
      - 3V3    
      - GPIO24
      - MOTOR 2 DIR
    * - SPI MOSI
      - MOSI    
      - GND
      - GND
    * - SPI MISO
      - MISO    
      - GPIO25
      - USR BUTTON
    * - SPI SCLK
      - SCLK    
      - CE0
      - SPI CE0
    * - GND
      - GND    
      - CE1
      - NC
    * - NC
      - ID_SD    
      - ID_SC
      - NC
    * - MCU Reset
      - GPIO5    
      - GND
      - GND
    * - (SPI)BSY 
      - GPIO6    
      - GPIO12
      - Board Identifier 2
    * - Board Identifier 1
      - GPIO13    
      - GND
      - GND
    * - I2S LRCLK
      - GPIO19    
      - GPIO16
      - RST BUTTON
    * - USER LED
      - GPIO26    
      - GPIO20
      - NC
    * - GND
      - GND    
      - GPIO21
      - I2S SDATA

.. _pin_digital:

Digital IO
---------------
    
Robot HAT has 4 sets of P2.54 3Pin digital pins.

.. image:: img/digitalio.png

.. list-table:: Digital IO
    :widths: 25 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi 

    * - D0
      - GPIO17

    * - D1
      - GPIO4

    * - D2
      - GPIO27

    * - D3
      - GPIO22

.. _pin_adc:

ADC
-------

.. image:: img/adcpin.png

The Robot HAT features four sets of 3Pin ADC (Analog to Digital Converter) pins, each spaced 2.54mm apart. These pins operate at a 3.3V power supply. The ADC function, offering 12-bit precision, is facilitated by an onboard microcontroller. Detailed instructions for reading ADC values are provided in the :ref:`on_board_mcu` section.

.. image:: img/btradc.png

Also, ADC channel A4 is connected to the battery through a voltage divider using resistors, 
which will be used to measure the battery voltage to estimate the approximate battery charge.

The voltage divider ratio is 20K/10K, so:

* A4 voltage (Va4) = value_A4 / 4095.0 * 3.3
* Battery voltage (Vbat) = Va4*3
* Battery voltage (Vbat) = value_A4 / 4095.0 * 3.3 * 3

.. _pin_pwm:

PWM
--------

.. image:: img/pwmpin.png

Robot HAT has 4 sets of 3Pin PWM pins, each spaced 2.54mm apart, and the power supply is 5V.
The method of using the PWM is described in detail in :ref:`on_board_mcu`.

.. note:: PWM13 & 14 channels are used for motor drive.

.. _pin_i2c:

I2C
----------

.. image:: img/i2cpin.png

The Robot HAT has two I2C interfaces. One is the P2.54 4-pin interface, and the other is the SH1.0 4-pin interface, which is compatible with QWIIC and STEMMA QT. 
These I2C interfaces are connected to the Raspberry Pi's I2C interface via GPIO2 (SDA) and GPIO3 (SCL). 
The board also features an :ref:`on_board_mcu`, and the two signal lines have 10K pull-up resistors.

.. _pin_spi:

SPI
---------

.. image:: img/spipin.png

The SPI interface of the Robot HAT is a 7-pin P2.54 interface. 
It connects to the SPI interface of the Raspberry Pi and includes an additional I/O pin that can be used for purposes such as interrupts or resets.


.. list-table:: SPI
    :widths: 50 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi 
    * - BSY
      - GPIO6
    * - CS
      - CE0(GPIO8)
    * - SCK
      - SCLK(GPIO11)
    * - MI
      - MISO(GPIO9)
    * - MO
      - MOSI(GPIO10)
    * - 3V3
      - 3.3V Power
    * - GND
      - Ground

.. _pin_uart:

UART
----------

.. image:: img/uartpin.png

The UART interface of the Robot HAT is a 4-pin P2.54 interface. It connects to the Raspberry Pi's GPIO14 (TXD) and GPIO15 (RXD) pins.

.. _pin_button:

Buttons
----------------

The Robot HAT comes with 1 LED and 2 buttons, all directly connected to the Raspberry Pi's GPIO pins. 
The RST button, when using Ezblock, serves as a button to restart the Ezblock program. 
If not using Ezblock, the RST button does not have a predefined function and can be fully customized according to your needs.

.. list-table:: LED & Button
    :widths: 50 50
    :header-rows: 1

    * - Robot Hat V4
      - Raspberry Pi 
    * - LED
      - GPIO26
    * - USR
      - GPIO25
    * - RST
      - GPIO16

.. _pin_speaker:

Speaker and Speaker Port
----------------------------

The Robot HAT is equipped with onboard I2S audio output, along with a 2030 audio chamber speaker, providing a mono sound output.


.. list-table:: I2S
    :widths: 50 50
    :header-rows: 1

    * - I2S
      - Raspberry Pi
    * - LRCLK
      - GPIO19
    * - BCLK
      - GPIO18
    * - SDATA
      - GPIO21

.. _pin_motor:

Motor Port
-----------------

The motor driver of the Robot HAT supports 2 channels and can be controlled using 2 digital signals for direction and 2 PWM signals for speed control.


.. list-table:: Motor Driver
    :widths: 50 50
    :header-rows: 1

    * - Motor
      - IO
    * - Motor1 Dir
      - GPIO23
    * - Motor1 Power
      - PWM13
    * - Motor2 Dir
      - GPIO24
    * - Motor2 Power
      - PWM12

.. _battery_indicator:

Battery Level Indicator
------------------------------

The battery level indicator on the Robot HAT monitors the battery voltage using a voltage divider method and serves as a reference for estimating the battery level. 
The relationship between the LED and voltage is as follows:

.. list-table:: Battery Level
    :widths: 50 50
    :header-rows: 1

    * - LED Battery
      - Total Voltage
    * - 2 LEDs on
      - Greater than 7.6V
    * - 1 LED on
      - Greater than 7.15V
    * - Both LEDs off
      - Less than 7.15V

When any one of the batteries reaches or exceeds 4.1V while the others are below that threshold, 
the charging current of that specific battery will be reduced.




##################################################
# FILE: baseline_code/robot-hat/docs/source/api_tts.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_tts:

class ``TTS``
==================================================

.. warning::
    * You need to add ``sudo`` when running this script, in case the speaker doesn't work.
    * :ref:`faq_speaker`.

**Example**

.. code-block:: python

    # Import TTS class
    from robot_hat import TTS

    # Initialize TTS class
    tts = TTS(lang='en-US')
    # Speak text
    tts.say("Hello World")
    # show all supported languages
    print(tts.supported_lang())


**API**

.. currentmodule:: robot_hat

.. autoclass:: TTS
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code/robot-hat/docs/source/project_plant_monitor.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Plant Monitor
======================

In this project, we detect both light intensity and soil moisture levels, and display them on the I2C LCD1602 . When you feel that the soil moisture is insufficient, you can press the button module to water the potted plant.

.. image:: img/plant_monitor.jpg

**Steps**

#. In this project, an I2C LCD1602 is used, so it's necessary to download the relevant libraries to make it work.

    .. code-block:: shell

        cd ~/
        wget https://github.com/sunfounder/raphael-kit/blob/master/python/LCD1602.py

#. Install ``smbus2`` for I2C.

    .. code-block:: shell

        sudo pip3 install smbus2

#. Save the following code to your Raspberry Pi and give it a name, for example, ``plant_monitor.ty``.

    .. code-block:: python

        from robot_hat import ADC, Motors, Pin
        import LCD1602
        import time
        import threading

        from robot_hat.utils import reset_mcu

        reset_mcu()
        time.sleep(.1)


        # Initialize objects
        light_sensor = ADC(1)
        moisture_sensor = ADC(0)
        motors = Motors()
        button = Pin('D0')

        # Thread running flag
        running = True

        def init_lcd():
            LCD1602.init(0x27, 1)
            time.sleep(2)

        def update_lcd(light_value, moisture_value):
            LCD1602.write(0, 0, 'Light: %d  ' % light_value)
            LCD1602.write(0, 1, 'Moisture: %d  ' % moisture_value)

        def read_sensors():
            light_value = light_sensor.read()
            time.sleep(0.2)
            moisture_value = moisture_sensor.read()
            time.sleep(0.2)
            return light_value, moisture_value

        def control_motor():
            global running
            while running:
                button_pressed = button.value() == 0
                if button_pressed:
                    motors[1].speed(80)
                    time.sleep(0.1)
                else:
                    motors[1].speed(0)
                    time.sleep(0.1)
                time.sleep(0.1)

        def setup():
            init_lcd()

        def destroy():
            global running
            running = False
            LCD1602.clear()

        def loop():
            global running
            while running:
                light_value, moisture_value = read_sensors()
                update_lcd(light_value, moisture_value)
                time.sleep(.2)

        if __name__ == '__main__':
            try:
                setup()
                motor_thread = threading.Thread(target=control_motor)
                motor_thread.start()
                loop()
            except KeyboardInterrupt:
                motor_thread.join()  # Wait for motor_thread to finish
                print("Program stopped")
            except Exception as e:
                print("Error:", e)
            finally:
                motors[1].speed(0)
                time.sleep(.1)
                destroy()
                print('end')

#. Use the command ``sudo python3 plant_monitor.ty`` to run this code.



##################################################
# FILE: baseline_code/robot-hat/docs/source/api_motor.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_motor:

module ``motor``
========================================

class ``Motors``
----------------------------------------

**Example**

Initilize

.. code-block:: python
    
    # Import Motor class
    from robot_hat import Motors

    # Create Motor object
    motors = Motors()

Directly control a motor. Motor 1/2 is according to PCB mark

.. code-block:: python

    # Motor 1 clockwise at 100% speed
    motors[1].speed(100)
    # Motor 2 counter-clockwise at 100% speed
    motors[2].speed(-100)
    # Stop all motors
    motors.stop()

Setup for high level control, high level control provides functions
from simple forword, backward, left, right, stop to more complex
like joystick control, motor directions calibration, etc.

.. note:: 
    All these setup only need to run once, and will save in a config file. Next time you load Motors class, it will load from config file.

.. code-block:: python

    # Setup left and right motors
    motors.set_left_id(1)
    motors.set_right_id(2)
    # Go forward and see if both motor directions are correct
    motors.forward(100)
    # if you found a motor is running in the wrong direction
    # Use these function to correct it
    motors.set_left_reverse()
    motors.set_right_reverse()
    # Run forward again and see if both motor directions are correct
    motors.forward(100)

Now control the robot

.. code-block:: python

    import time

    motors.forward(100)
    time.sleep(1)
    motors.backward(100)
    time.sleep(1)
    motors.turn_left(100)
    time.sleep(1)
    motors.turn_right(100)
    time.sleep(1)
    motors.stop()

**API**

.. currentmodule:: robot_hat

.. autoclass:: Motors
    :show-inheritance:
    :special-members: __init__, __getitem__
    :members:

class ``Motor``
----------------------------------------

**Example**

.. code-block:: python
    
    # Import Motor class
    from robot_hat import Motor, PWM, Pin

    # Create Motor object
    motor = Motor(PWM("P13"), Pin("D4"))

    # Motor clockwise at 100% speed
    motor.speed(100)
    # Motor counter-clockwise at 100% speed
    motor.speed(-100)

    # If you like to reverse the motor direction
    motor.set_is_reverse(True)

**API**

.. currentmodule:: robot_hat

.. autoclass:: Motor
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code/robot-hat/docs/source/api_pwm.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_pwm:

class ``PWM``
========================================

**Example**

.. code-block:: python
    
    # Import PWM class
    from robot_hat import PWM

    # Create PWM object with numeric pin numbering and default input pullup enabled
    p0 = PWM(0)
    # Create PWM object with named pin numbering
    p1 = PWM('P1')


    # Set frequency will automatically set prescaller and period
    # This is easy for device like Buzzer or LED, which you care
    # about the frequency and pulse width percentage.
    # this usually use with pulse_width_percent function.
    # Set frequency to 1000Hz
    p0.freq(1000)
    print(f"Frequence: {p0.freq()} Hz")
    print(f"Prescaler: {p0.prescaler()}")
    print(f"Period: {p0.period()}")
    # Set pulse width to 50%
    p0.pulse_width_percent(50)

    # Or set prescaller and period, will get a frequency from:
    # frequency = PWM.CLOCK / prescaler / period
    # With this setup you can tune the period as you wish.
    # set prescaler to 64
    p1.prescaler(64)
    # set period to 4096 ticks
    p1.period(4096)
    print(f"Frequence: {p1.freq()} Hz")
    print(f"Prescaler: {p1.prescaler()}")
    print(f"Period: {p1.period()}")
    # Set pulse width to 2048 which is also 50%
    p1.pulse_width(2048)

**API**

.. currentmodule:: robot_hat

.. autoclass:: PWM
    :show-inheritance:
    :special-members: __init__
    :members:

##################################################
# FILE: baseline_code/robot-hat/docs/source/project_security.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Security System
=======================

In this project, we've created a simple security system. The PIR sensor detects if someone passes by, and then the camera activates. If a face is detected, it takes a picture and simultaneously delivers a warning message.

.. image:: img/camera.jpg

**Steps**

#. Install the ``vilib`` library for face detection.

    .. code-block:: shell

        cd ~/
        git clone -b picamera2 https://github.com/sunfounder/vilib.git
        cd vilib
        sudo python3 install.py

#. Save the following code to your Raspberry Pi and give it a name, for example, ``security.ty``.


    .. code-block:: python

        import os
        from time import sleep, time, strftime, localtime
        from vilib import Vilib
        from robot_hat import Pin, TTS


        # Initialize the TTS class
        tts = TTS(lang='en-US')

        # Display all supported languages
        print(tts.supported_lang())

        # Initialize the PIR sensor
        pir = Pin('D0')

        def camera_start():
            Vilib.camera_start()
            Vilib.display()
            Vilib.face_detect_switch(True)

        def take_photo():
            _time = strftime('%Y-%m-%d-%H-%M-%S', localtime(time()))
            name = f'photo_{_time}'
            username = os.getlogin()
            path = f"/home/{username}/Pictures/"
            Vilib.take_photo(name, path)
            print(f'Photo saved as {path}{name}.jpg')

        def main():
            motion_detected = False
            while True:
                # Check for motion
                if pir.value() == 1:
                    if not motion_detected:
                        print("Motion detected! Initializing camera...")
                        camera_start()
                        motion_detected = True
                        sleep(2)  # Stabilization delay to confirm motion

                    # Check for human face and take a photo
                    if Vilib.detect_obj_parameter['human_n'] != 0:
                        take_photo()
                        # Read the text
                        tts.say("Security alert: Unrecognized Individual detected. Please verify identity")
                        sleep(2)  # Delay after taking a photo

                # If no motion is detected, turn off the camera
                elif motion_detected:
                    print("No motion detected. Finalizing camera...")
                    Vilib.camera_close()
                    motion_detected = False
                    sleep(2)  # Delay before re-enabling motion detection

                sleep(0.1)  # Short delay to prevent CPU overuse

        def destroy():
            Vilib.camera_close()
            print("Camera and face detection stopped.")

        if __name__ == '__main__':
            try:
                main()
            except KeyboardInterrupt:
                destroy()

#. Use the command ``sudo python3 security.py`` to run this code.
    .. note::

        * :ref:`faq_speaker`

#. Open a web browser and enter ``http://rpi_ip:9000/mjpg`` to view the captured footage. Additionally, you can find the captured face images in ``/home/{username}/Pictures/``.

    .. image:: img/browser_camera.jpg



##################################################
# FILE: baseline_code/robot-hat/docs/source/faq.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

FAQ
================

Q1: Can the battery be connected while providing power to the Raspberry Pi at the same time?
------------------------------------------------------------------------------------------------------------
A: Yes, the Robot HAT has a built-in anti-backflow diode that prevents the Raspberry Pi's power from flowing back into the Robot HAT.

Q2: Can the Robot HAT be used while charging?
--------------------------------------------------------
A: Yes, the Robot HAT can be used while charging. When charging, the input power is boosted by the charging chip to charge the batteries, while also providing power to the DC-DC step-down for external use. The charging power is approximately 10W. If the external power consumption is too high for an extended period, the batteries may supplement the power, similar to how a mobile phone charges while in use. However, it is important to be mindful of the battery's capacity to avoid draining it completely during simultaneous charging and usage.

.. _faq_speaker:

Q3: Why is there no sound from the speaker?
--------------------------------------------------

When your script is running but the speaker is not producing sound, there could be several reasons:

#. Check if the ``i2samp.sh`` script has been installed. For detailed instructions, please refer to: :ref:`install_i2s`.
#. When running scripts related to speakers, it's necessary to add ``sudo`` to obtain administrative privileges. For example, ``sudo python3 tts.py``.
#. Don't using Raspberry Pi's built-in programming tools, like Geany to run Speaker-related scripts. These tools run with standard user privileges, while hardware control, such as managing speakers, often requires higher permissions.


##################################################
# FILE: baseline_code/robot-hat/docs/source/api.rst
##################################################

 .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

Reference
==========================

.. automodule:: robot_hat

.. toctree::
   :maxdepth: 2

   api_pin
   api_adc
   api_pwm
   api_servo
   api_motor
   api_modules
   api_robot
   api_music
   api_tts
   api_utils
   api_filedb
   api_i2c
   api_basic_class





##################################################
# FILE: baseline_code/robot-hat/docs/source/api_music.rst
##################################################

﻿ .. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    👉 Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

.. _class_music:

class ``Music``
========================================

.. warning::
    * You need to add ``sudo`` when running this script, in case the speaker doesn't work.
    * :ref:`faq_speaker`.

**Example**

Initialize

.. code-block:: python

    # Import Music class
    from robot_hat import Music

    # Create a new Music object
    music = Music()

Play tones

.. code-block:: python

    # You can directly play a frequency for specific duration in seconds
    music.play_tone_for(400, 1)

    # Or use note to get the frequency
    music.play_tone_for(music.note("Middle C"), 0.5)
    # and set tempo and use beat to get the duration in seconds
    # Which make's it easy to code a song according to a sheet!
    music.tempo(120)
    music.play_tone_for(music.note("Middle C"), music.beat(1))
    
    # Here's an example playing Greensleeves
    set_volume(80)
    music.tempo(60, 1/4)

    print("Measure 1")
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 2")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("C5"), music.beat(1/8))
    music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("D#5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 3")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 4")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 5")
    music.play_tone_for(music.note("A4"), music.beat(1/4))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    music.play_tone_for(music.note("D4"), music.beat(1/4))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 6")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("C5"), music.beat(1/8))
    music.play_tone_for(music.note("D5"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("D#5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 7")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 8")
    music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("E4"), music.beat(1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    print("Measure 9")
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
    print("Measure 10")
    music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("F5"), music.beat(1/8))
    music.play_tone_for(music.note("E5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 11")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 12")
    music.play_tone_for(music.note("A#4"), music.beat(1/4))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    print("Measure 13")
    music.play_tone_for(music.note("A4"), music.beat(1/4))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    music.play_tone_for(music.note("D4"), music.beat(1/4 + 1/8))
    print("Measure 14")
    music.play_tone_for(music.note("F5"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("F5"), music.beat(1/8))
    music.play_tone_for(music.note("E5"), music.beat(1/16))
    music.play_tone_for(music.note("D5"), music.beat(1/8))
    print("Measure 15")
    music.play_tone_for(music.note("C5"), music.beat(1/4))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    music.play_tone_for(music.note("F4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/8))
    print("Measure 16")
    music.play_tone_for(music.note("A#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("A4"), music.beat(1/16))
    music.play_tone_for(music.note("G4"), music.beat(1/8))
    music.play_tone_for(music.note("F#4"), music.beat(1/8 + 1/16))
    music.play_tone_for(music.note("E4"), music.beat(1/16))
    music.play_tone_for(music.note("F#4"), music.beat(1/8))
    print("Measure 17")
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))
    music.play_tone_for(music.note("G4"), music.beat(1/4 + 1/8))

Play sound

.. code-block:: python

    # Play a sound
    music.sound_play("file.wav", volume=50)
    # Play a sound in the background
    music.sound_play_threading("file.wav", volume=80)
    # Get sound length
    music.sound_length("file.wav")

Play Music

.. code-block:: python

    # Play music
    music.music_play("file.mp3")
    # Play music in loop
    music.music_play("file.mp3", loop=0)
    # Play music in 3 times
    music.music_play("file.mp3", loop=3)
    # Play music in starts from 2 second
    music.music_play("file.mp3", start=2)
    # Set music volume
    music.music_set_volume(50)
    # Stop music
    music.music_stop()
    # Pause music
    music.music_pause()
    # Resume music
    music.music_resume()

**API**

.. currentmodule:: robot_hat

.. autoclass:: Music
    :show-inheritance:
    :special-members: __init__
    :members:


##################################################
# FILE: baseline_code/robot-hat/docs/make.bat
##################################################

@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=source
set BUILDDIR=build

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd


##################################################
# FILE: baseline_code/robot-hat/README.md
##################################################

# Robot Hat

Robot Hat Python library for Raspberry Pi.

Quick Links:

- [Robot Hat](#robot-hat)
  - [About Robot Hat](#about-robot-hat)
  - [Update](#update)
  - [Installation](#installation)
  - [Trouble Shooting](#trouble-shooting)
  - [About SunFounder](#about-sunfounder)
  - [License](#license)
  - [Contact us](#contact-us)

## About Robot Hat

Robot HAT is a multifunctional expansion board that allows Raspberry Pi to be quickly turned into a robot. An MCU is on board to extend the PWM output and ADC input for the Raspberry Pi, as well as a motor driver chip, Bluetooth module, I2S audio module and mono speaker. As well as the GPIOs that lead out of the Raspberry Pi itself.


## Update
2023-11-29:
- Add more about Robot HAT's Hardware Introduction


2022-08-26:
- New Release

## Installation

```bash
git clone https://github.com/sunfounder/robot-hat.git -b v2.0
cd robot-hat
sudo python3 setup.py install

```

## Trouble Shooting

----------------------------------------------

## About SunFounder

SunFounder is a technology company focused on Raspberry Pi and Arduino open source community development. Committed to the promotion of open source culture, we strives to bring the fun of electronics making to people all around the world and enable everyone to be a maker. Our products include learning kits, development boards, robots, sensor modules and development tools. In addition to high quality products, SunFounder also offers video tutorials to help you make your own project. If you have interest in open source or making something cool, welcome to join us!

----------------------------------------------

## License

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied wa rranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

{Repository Name} comes with ABSOLUTELY NO WARRANTY; for details run ./show w. This is free software, and you are welcome to redistribute it under certain conditions; run ./show c for details.

SunFounder, Inc., hereby disclaims all copyright interest in the program '{Repository Name}' (which makes passes at compilers).

Mike Huang, 21 August 2015

Mike Huang, Chief Executive Officer

Email: service@sunfounder.com, support@sunfounder.com

----------------------------------------------

## Contact us

website:
    www.sunfounder.com

E-mail:
    service@sunfounder.com, support@sunfounder.com


##################################################
# FILE: baseline_code/robot-hat/setup.py
##################################################

#!/usr/bin/env python3
from os import path
import sys
import os

print('\033[0;33mThe "setup.py" installation method is planned to be abandoned.\n'
    'Please execute "install.py" to install.\n\033[0m')

if 'install' in sys.argv:
    here = path.abspath(path.dirname(__file__))
    os.chdir(here)
    args = ' '.join(sys.argv[1:])
    os.system(f'python3 install.py {args}')

    exit()

# necessary for pip3 install ./ , 
# if you need both `setup.py`` and `pyproject.toml`` to exist
from setuptools import setup
setup()



##################################################
# FILE: baseline_code/robot-hat/install.py
##################################################

#!/usr/bin/env python3
from os import path
import sys
import os
import time
import threading

here = path.abspath(path.dirname(__file__))
os.chdir(here)
sys.path.append('./robot_hat')
from version import __version__

print("Robot Hat Python Library v%s" % __version__)

avaiable_options = ["--no-dep", "--only-lib", "--no-build-isolation"]
options = []
if len(sys.argv) > 1:
    options = list.copy(sys.argv[1:])


# define color print
# =================================================================
def warn(msg, end='\n', file=sys.stdout, flush=False):
    print(f'\033[0;33m{msg}\033[0m', end=end, file=file, flush=flush)

def error(msg, end='\n', file=sys.stdout, flush=False):
    print(f'\033[0;31m{msg}\033[0m', end=end, file=file, flush=flush)

# check if run as root
# =================================================================
if os.geteuid() != 0:
    warn("Script must be run as root. Try \"sudo python3 install.py\".")
    sys.exit(1)

# utils
# =================================================================
def run_command(cmd=""):
    import subprocess
    p = subprocess.Popen(cmd,
                         shell=True,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT)
    result = p.stdout.read().decode('utf-8')
    status = p.poll()
    return status, result

errors = []
at_work_tip_sw = False

def working_tip():
    char = ['/', '-', '\\', '|']
    i = 0
    global at_work_tip_sw
    while at_work_tip_sw:
        i = (i + 1) % 4
        sys.stdout.write('\033[?25l')  # cursor invisible
        sys.stdout.write('%s\033[1D' % char[i])
        sys.stdout.flush()
        time.sleep(0.5)

    sys.stdout.write(' \033[1D')
    sys.stdout.write('\033[?25h')  # cursor visible
    sys.stdout.flush()


def do(msg="", cmd=""):
    print(" - %s ... " % (msg), end='', flush=True)
    # at_work_tip start
    global at_work_tip_sw
    at_work_tip_sw = True
    _thread = threading.Thread(target=working_tip)
    _thread.daemon = True
    _thread.start()
    # process run
    status, result = run_command(cmd)
    # print(status, result)
    # at_work_tip stop
    at_work_tip_sw = False
    _thread.join()  # wait for thread to finish
    # status
    if status == 0 or status == None or result == "":
        print('Done')
    else:
        print('Error')
        errors.append("%s error:\n  Status:%s\n  Error:%s" %
                      (msg, status, result))


def check_raspbain_version():
    _, result = run_command("cat /etc/debian_version|awk -F. '{print $1}'")
    return int(result.strip())


def check_os_bit():
    '''
    # import platform
    # machine_type = platform.machine() 
    latest bullseye uses a 64-bit kernel
    This method is no longer applicable, the latest raspbian will uses 64-bit kernel 
    (kernel 6.1.x) by default, "uname -m" shows "aarch64", 
    but the system is still 32-bit.
    '''
    _, os_bit = run_command("getconf LONG_BIT")
    return int(os_bit)

# check system
# =================================================================
raspbain_version = check_raspbain_version()
os_bit = check_os_bit()

# Dependencies list installed with apt
# =================================================================
APT_INSTALL_LIST = [
    'raspi-config',
    "i2c-tools",
    "espeak",
    'libsdl2-dev',
    'libsdl2-mixer-dev',
    'portaudio19-dev',  # pyaudio
    'sox',
]
if raspbain_version in [12] and os_bit == 64:
    APT_INSTALL_LIST.append("libttspico-utils")  # tts -> pico2wave

# Dependencies list installed with pip3
# =================================================================
PIP_INSTALL_LIST = [
    'smbus2',
    'gpiozero',
    'pyaudio',
    'spidev',
    'pyserial',
    'pillow',
    "'pygame>=2.1.2'",
]


# main
# =================================================================
def install():
    # check whether pip has the option "--break-system-packages"
    _is_bsps = ''
    status, _ = run_command("pip3 help install|grep break-system-packages")
    if status == 0: # if true
        _is_bsps = "--break-system-packages"

    # --- install robot_hat package ---
    _if_build_isolation = ""
    if "--no-build-isolation" in options:
        _if_build_isolation = "--no-build-isolation"
    do(msg=f"install robot_hat package {_if_build_isolation}",
       cmd=f'pip3 install ./ {_is_bsps} {_if_build_isolation}')

    # --- only-library ---
    if "--only-lib" not in options:
        # --- install dependencies ---
        if "--no-dep" not in options:
            # --------------------------------
            print("Install dependencies with apt-get:")
            # update apt-get
            do(msg="update apt-get", cmd='apt-get update')
            #
            for dep in APT_INSTALL_LIST:
                do(msg=f"install {dep}", cmd=f'apt-get install {dep} -y')
            #
            if 'libttspico-utils' not in APT_INSTALL_LIST:
                _pool = 'http://ftp.debian.org/debian/pool/non-free/s/svox/'
                if raspbain_version >= 12:
                    libttspico= 'libttspico0t64_1.0+git20130326-14.1_armhf.deb'
                    libttspico_utils = 'libttspico-utils_1.0+git20130326-14.1_armhf.deb'
                elif raspbain_version < 12:
                    libttspico = 'libttspico0_1.0+git20130326-11_armhf.deb'
                    libttspico_utils = 'libttspico-utils_1.0+git20130326-11_armhf.deb'
                do(msg="install pico2wave",
                    cmd=f'wget {_pool}{libttspico}' +
                    f' &&wget {_pool}{libttspico_utils}' +
                    f' && apt-get install -f ./{libttspico} ./{libttspico_utils} -y'
                    )
            # --------------------------------
            print("Install dependencies with pip3:")
            # check whether pip has the option "--break-system-packages"
            if _is_bsps != '':
                _is_bsps = "--break-system-packages"
                print(
                    "\033[38;5;8m pip3 install with --break-system-packages\033[0m"
                )
            # update pip
            do(msg="update pip3",
                cmd=f'python3 -m pip install --upgrade pip {_is_bsps}')
            #
            for dep in PIP_INSTALL_LIST:
                do(msg=f"install {dep}",
                    cmd=f'pip3 install {dep} {_is_bsps}')

        # --- Setup interfaces ---
        print("Setup interfaces")
        do(msg="turn on I2C", cmd='raspi-config nonint do_i2c 0')
        do(msg="turn on SPI", cmd='raspi-config nonint do_spi 0')

        # --- Copy servohat dtoverlay ---
        print("Copy dtoverlay")
        DEFAULT_OVERLAYS_PATH = "/boot/firmware/overlays/"
        LEGACY_OVERLAYS_PATH = "/boot/overlays/"
        _overlays_path = None
        if os.path.exists(DEFAULT_OVERLAYS_PATH):
            _overlays_path = DEFAULT_OVERLAYS_PATH
        elif os.path.exists(LEGACY_OVERLAYS_PATH):
            _overlays_path = LEGACY_OVERLAYS_PATH
        else:
            _overlays_path = None

        if _overlays_path is not None:
            do(msg="copy dtoverlay",
            cmd=f'cp ./dtoverlays/* {_overlays_path}')

    # --- Report error ---
    if len(errors) == 0:
        print("Finished")
    else:
        print("\n\nError happened in install process:")
        for error in errors:
            print(error)
        print(
            "Try to fix it yourself, or contact service@sunfounder.com with this message"
        )


if __name__ == "__main__":
    try:
        install()
    except KeyboardInterrupt:
        if len(errors) > 0:
            print("\n\nError happened in install process:")
            for error in errors:
                print(error)
            print(
                "Try to fix it yourself, or contact service@sunfounder.com with this message"
            )
        print("\n\nCanceled.")
    finally:
        sys.stdout.write(' \033[1D')
        sys.stdout.write('\033[?25h') # cursor visible 
        sys.stdout.flush()


##################################################
# FILE: baseline_code/robot-hat/backup/i2samp.sh
##################################################

#!/bin/bash

: <<'DISCLAIMER'

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

This script is licensed under the terms of the MIT license.
Unless otherwise noted, code reproduced herein
was written for this script.

- The Pimoroni Crew - (modified by Adafruit!)

DISCLAIMER

# script control variables
# =================================================================
productname="i2s amplifier"                         # the name of the product to install
scriptname="i2samp"                                 # the name of this script
spacereq=1                                          # minimum size required on root partition in MB
debugmode="no"                                      # whether the script should use debug routines
debuguser="none"                                    # optional test git user to use in debug mode
debugpoint="none"                                   # optional git repo branch or tag to checkout
forcesudo="no"                                      # whether the script requires to be ran with root privileges
promptreboot="no"                                   # whether the script should always prompt user to reboot
mininstall="no"                                     # whether the script enforces minimum install routine
customcmd="yes"                                     # whether to execute commands specified before exit
armv6="yes"                                         # whether armv6 processors are supported
armv7="yes"                                         # whether armv7 processors are supported
armv8="yes"                                         # whether armv8 processors are supported
arm64="yes"                                         # whether arm64 processors are supported
raspbianonly="no"                                   # whether the script is allowed to run on other OSes
osreleases=("Raspbian")                             # list os-releases supported
oswarning=("Debian" "Kano" "Mate" "PiTop" "Ubuntu") # list experimental os-releases
osdeny=("Darwin" "Kali")                            # list os-releases specifically disallowed

FORCE=$1
DEVICE_TREE=true
ASK_TO_REBOOT=false
CURRENT_SETTING=false
UPDATE_DB=false

BOOTCMD=/boot/firmware/cmdline.txt
CONFIG=/boot/firmware/config.txt
APTSRC=/etc/apt/sources.list
INITABCONF=/etc/inittab
BLACKLIST=/etc/modprobe.d/raspi-blacklist.conf
LOADMOD=/etc/modules
DTBODIR=/boot/overlays

AUTO_SOUND_CARD=/usr/local/bin/auto_sound_card

# Fall back to old location
if ! test -f $CONFIG; then
    CONFIG=/boot/config.txt
fi

# function define
# =================================================================
confirm() {
    if [ "$FORCE" == '-y' ]; then
        true
    else
        read -r -p "$1 [y/N] " response </dev/tty
        if [[ $response =~ ^(yes|y|Y)$ ]]; then
            true
        else
            false
        fi
    fi
}

prompt() {
    read -r -p "$1 [y/N] " response </dev/tty
    if [[ $response =~ ^(yes|y|Y)$ ]]; then
        true
    else
        false
    fi
}

success() {
    echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

inform() {
    echo -e "$(tput setaf 6)$1$(tput sgr0)"
}

warning() {
    echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

newline() {
    echo ""
}

progress() {
    count=0
    until [ $count -eq $1 ]; do
        echo -n "..." && sleep 1
        ((count++))
    done
    echo
}
sudocheck() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "Install must be run as root. Try 'sudo ./$scriptname'\n"
        exit 1
    fi
}

sysclean() {
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &>/dev/null
}

sysupdate() {
    if ! $UPDATE_DB; then
        echo "Updating apt indexes..." && progress 3 &
        sudo apt-get update 1>/dev/null || { warning "Apt failed to update indexes!" && exit 1; }
        echo "Reading package lists..."
        progress 3 && UPDATE_DB=true
    fi
}

sysupgrade() {
    sudo apt-get upgrade
    sudo apt-get clean && sudo apt-get autoclean
    sudo apt-get -y autoremove &>/dev/null
}

sysreboot() {
    warning "Some changes made to your system require"
    warning "your computer to reboot to take effect."
    newline
    if prompt "Would you like to reboot now?"; then
        sync && sudo reboot
    fi
}

arch_check() {
    IS_ARM64=false
    IS_ARMHF=false
    IS_ARMv6=false

    if uname -m | grep "aarch64" >/dev/null; then
        IS_ARM64=true
    fi
    if uname -m | grep "armv.l" >/dev/null; then
        IS_ARMHF=true
        if uname -m | grep "armv6l" >/dev/null; then
            IS_ARMv6=true
        fi
    fi
}

os_check() {
    IS_RASPBIAN=false
    IS_MACOSX=false
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "Raspbian" >/dev/null; then
            IS_RASPBIAN=true && IS_SUPPORTED=true
        fi
        if command -v apt-get >/dev/null; then
            for os in ${osreleases[@]}; do
                if cat /etc/os-release | grep $os >/dev/null; then
                    IS_SUPPORTED=true && IS_EXPERIMENTAL=false
                fi
            done
            for os in ${oswarning[@]}; do
                if cat /etc/os-release | grep $os >/dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=true
                fi
            done
            for os in ${osdeny[@]}; do
                if cat /etc/os-release | grep $os >/dev/null; then
                    IS_SUPPORTED=false && IS_EXPERIMENTAL=false
                fi
            done
        fi
    fi
    if [ -d ~/.kano-settings ] || [ -d ~/.kanoprofile ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "Kano" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -f ~/.pt-dashboard-config ] || [ -d ~/.pt-dashboard ] || [ -d ~/.pt-os-dashboard ]; then
        IS_RASPBIAN=false
        for os in ${oswarning[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=true
            fi
        done
        for os in ${osdeny[@]}; do
            if [ $os == "PiTop" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if [ -d ~/.config/ubuntu-mate ]; then
        for os in ${osdeny[@]}; do
            if [ $os == "Mate" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
    if uname -s | grep "Darwin" >/dev/null; then
        IS_MACOSX=true
        for os in ${osdeny[@]}; do
            if [ $os == "Darwin" ]; then
                IS_SUPPORTED=false && IS_EXPERIMENTAL=false
            fi
        done
    fi
}

raspbian_check() {
    IS_SUPPORTED=false
    IS_EXPERIMENTAL=false

    if [ -f /etc/os-release ]; then
        if cat /etc/os-release | grep "/sid" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bookworm" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "bullseye" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "buster" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=true
        elif cat /etc/os-release | grep "stretch" >/dev/null; then
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "jessie" >/dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        elif cat /etc/os-release | grep "wheezy" >/dev/null; then
            IS_SUPPORTED=true && IS_EXPERIMENTAL=false
        else
            IS_SUPPORTED=false && IS_EXPERIMENTAL=false
        fi
    fi
}

# main
# =================================================================
: <<'MAINSTART'

Perform all global variables declarations as well as function definition
above this section for clarity, thanks!

MAINSTART

# check platform
#=======================
arch_check
os_check

if [ $debugmode != "no" ]; then
    echo "USER_HOME is $USER_HOME" && newline
    echo "IS_RASPBIAN is $IS_RASPBIAN"
    echo "IS_MACOSX is $IS_MACOSX"
    echo "IS_SUPPORTED is $IS_SUPPORTED"
    echo "IS_EXPERIMENTAL is $IS_EXPERIMENTAL"
    newline
fi

if ! $IS_ARMHF && ! $IS_ARM64; then
    warning "This hardware is not supported, sorry!"
    warning "Config files have been left untouched"
    newline && exit 1
fi

if $IS_ARM64 && [ $arm64 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv8 && [ $armv8 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv7 && [ $armv7 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
elif $IS_ARMv6 && [ $armv6 == "no" ]; then
    warning "Sorry, your CPU is not supported by this installer"
    newline && exit 1
fi

if [ $raspbianonly == "yes" ] && ! $IS_RASPBIAN; then
    warning "This script is intended for Raspbian on a Raspberry Pi!"
    newline && exit 1
fi

if $IS_RASPBIAN; then
    raspbian_check
    if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
        newline && warning "--- Warning ---" && newline
        echo "The $productname installer"
        echo "does not work on this version of Raspbian."
        echo "Check https://github.com/$gitusername/$gitreponame"
        echo "for additional information and support"
        newline && exit 1
    fi
fi

if ! $IS_SUPPORTED && ! $IS_EXPERIMENTAL; then
    warning "Your operating system is not supported, sorry!"
    newline && exit 1
fi

if $IS_EXPERIMENTAL; then
    warning "Support for your operating system is experimental. Please visit"
    warning "forums.adafruit.com if you experience issues with this product."
    newline
fi

if [ $forcesudo == "yes" ]; then
    sudocheck
fi

newline
echo "This script will install everything needed to use"
echo "$productname"
newline
warning "--- Warning ---"
newline
echo "Always be careful when running scripts and commands"
echo "copied from the internet. Ensure they are from a"
echo "trusted source."
newline
echo "If you want to see what this script does before"
echo "running it, you should run:"
echo "    \curl -sS github.com/adafruit/Raspberry-Pi-Installer-Scripts/$scriptname"
newline

# ask whether to continue
#=======================
if ! confirm "Do you wish to continue?"; then
    newline
    echo "Aborting..."
    newline
    exit 0
fi

# config dtoverlay
#=======================
newline
echo "Checking hardware requirements..."

if [ -e $CONFIG ] && grep -q "^device_tree=$" $CONFIG; then
    DEVICE_TREE=false
fi

if $DEVICE_TREE; then

    newline
    echo "Adding Device Tree Entry to $CONFIG"

    if [ -e $CONFIG ] && grep -q "^dtoverlay=hifiberry-dac$" $CONFIG; then
        echo "dtoverlay already active"
    else
        echo "dtoverlay=hifiberry-dac" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $CONFIG ] && grep -q "^dtoverlay=i2s-mmap$" $CONFIG; then
        echo "i2s mmap dtoverlay already active"
    else
        echo "dtoverlay=i2s-mmap" | sudo tee -a $CONFIG
        ASK_TO_REBOOT=true
    fi

    if [ -e $BLACKLIST ]; then
        newline
        echo "Commenting out Blacklist entry in "
        echo "$BLACKLIST"
        sudo sed -i -e "s|^blacklist[[:space:]]*i2c-bcm2708.*|#blacklist i2c-bcm2708|" \
            -e "s|^blacklist[[:space:]]*snd-soc-pcm512x.*|#blacklist snd-soc-pcm512x|" \
            -e "s|^blacklist[[:space:]]*snd-soc-wm8804.*|#blacklist snd-soc-wm8804|" $BLACKLIST &>/dev/null
    fi
else
    newline
    echo "No Device Tree Detected, not supported"
    newline
    exit 1
fi

# install alsa-utils
#=======================
sudo apt install alsa-utils -y

# aplay from /dev/zero at system start
#=======================
newline
echo "Installing aplay systemd unit"
sudo sh -c 'cat > /etc/systemd/system/aplay.service' <<'EOL'
[Unit]
Description=Invoke aplay from /dev/zero at system start.

[Service]
ExecStart=/usr/bin/aplay -D default -t raw -r 44100 -c 2 -f S16_LE /dev/zero

[Install]
WantedBy=multi-user.target
EOL

sudo systemctl daemon-reload
sudo systemctl disable aplay
newline
echo "You can optionally activate '/dev/zero' playback in"
echo "the background at boot. This will remove all"
echo "popping/clicking but does use some processor time."
newline
if confirm "Activate '/dev/zero' playback in background? [RECOMMENDED]"; then
    newline
    sudo systemctl enable aplay
    ASK_TO_REBOOT=true
fi

# config asound
#=======================
newline
echo "Configuring sound output"
# backup file
if [ -e /etc/asound.conf ]; then
    if [ -e /etc/asound.conf.old ]; then
        sudo rm -f /etc/asound.conf.old
    fi
    sudo cp /etc/asound.conf /etc/asound.conf.old
fi

# auto_sound_card scripts

sudo cat >/usr/local/bin/auto_sound_card <<'-EOF'
#!/bin/bash

ASOUND_CONF=/etc/asound.conf
AUDIO_CARD_NAME="sndrpihifiberry"

card_num=$(sudo aplay -l |grep $AUDIO_CARD_NAME |awk '{print $2}'|tr -d ':')
echo "card_num=$card_num"
if [ -n "$card_num" ]; then
    cat > $ASOUND_CONF << EOF
pcm.speakerbonnet {
    type hw card $card_num
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_perm 0666
    slave {
        pcm "speakerbonnet"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
        channels 2
    }
}

ctl.dmixer {
    type hw card $card_num
}

pcm.softvol {
    type softvol
    slave.pcm "dmixer"
    control.name "PCM"
    control.card $card_num
}

ctl.softvol {
    type hw card $card_num
}

pcm.!default {
    type             plug
    slave.pcm       "softvol"
}
EOF
    echo "systemctl restart aplay.service"
    sudo systemctl restart aplay.service

    if [ -n $1 ] && [ $1 -gt 0 ]; then
        echo "set volume to $1"
        amixer -c $card_num sset PCM $1%
    fi

fi

exit 0
-EOF

sudo chmod +x /usr/local/bin/auto_sound_card

# execute the script once
sudo /usr/local/bin/auto_sound_card 100

# add auto_sound_card start on boot
sudo cat >/etc/systemd/system/auto_sound_card.service <<EOF
[Unit]
Description=Auto config als sound card num at system start.
Wants=aplay.service

[Service]
ExecStart=/usr/local/bin/auto_sound_card

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable auto_sound_card

#=======================
newline
echo "We can now test your $productname"
warning "Set your speakers if possible!"
if confirm "Do you wish to test your system now?"; then
    echo "Testing..."
    # enable speaker
    if command -v pinctrl >/dev/null; then
        pinctrl set 20 op dh
    elif command -v raspi-gpio >/dev/null; then
        raspi-gpio set 20 op dh
    else
        warning "Could not find pinctrl or raspi-gpio"
    fi
    # test speaker
    speaker-test -l5 -c2 -t wav
fi
newline
success "All done!"
newline
echo "Enjoy your new $productname!"
newline

if [ $promptreboot == "yes" ] || $ASK_TO_REBOOT; then
    sysreboot
fi

# end
# =======================
exit 0


##################################################
# FILE: baseline_code/robot-hat/robot_hat/pin.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
import gpiozero  # https://gpiozero.readthedocs.io/en/latest/installing.html
from gpiozero import OutputDevice, InputDevice, Button


class Pin(_Basic_class):
    """Pin manipulation class"""

    OUT = 0x01
    """Pin mode output"""
    IN = 0x02
    """Pin mode input"""

    PULL_UP = 0x11
    """Pin internal pull up"""
    PULL_DOWN = 0x12
    """Pin internal pull down"""
    PULL_NONE = None
    """Pin internal pull none"""

    IRQ_FALLING = 0x21
    """Pin interrupt falling"""
    IRQ_RISING = 0x22
    """Pin interrupt falling"""
    IRQ_RISING_FALLING = 0x23
    """Pin interrupt both rising and falling"""

    _dict = {
        "D0": 17,
        "D1": 4,  # Changed
        "D2": 27,
        "D3": 22,
        "D4": 23,
        "D5": 24,
        "D6": 25,  # Removed
        "D7": 4,  # Removed
        "D8": 5,  # Removed
        "D9": 6,
        "D10": 12,
        "D11": 13,
        "D12": 19,
        "D13": 16,
        "D14": 26,
        "D15": 20,
        "D16": 21,
        "SW": 25,  # Changed
        "USER": 25,
        "LED": 26,
        "BOARD_TYPE": 12,
        "RST": 16,
        "BLEINT": 13,
        "BLERST": 20,
        "MCURST": 5,  # Changed
        "CE": 8,
    }

    def __init__(self, pin, mode=None, pull=None, active_state:bool=None, *args, **kwargs):
        """
        Initialize a pin

        :param pin: pin number of Raspberry Pi
        :type pin: int/str
        :param mode: pin mode(IN/OUT)
        :type mode: int
        :param pull: pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)
        :type pull: int
        :param active_state: active state of pin,  
                            If True, when the hardware pin state is HIGH, the software pin is HIGH. 
                            If False, the input polarity is reversed
        :type active_state: bool or None
        """
        super().__init__(*args, **kwargs)

        # parse pin
        if isinstance(pin, str):
            if pin not in self.dict().keys():
                raise ValueError(
                    f'Pin should be in {self._dict.keys()}, not "{pin}"')
            self._board_name = pin
            self._pin_num = self.dict()[pin]
        elif isinstance(pin, int):
            if pin not in self.dict().values():
                raise ValueError(
                    f'Pin should be in {self._dict.values()}, not "{pin}"')
            self._board_name = {i for i in self._dict if self._dict[i] == pin}
            self._pin_num = pin
        else:
            raise ValueError(
                f'Pin should be in {self._dict.keys()}, not "{pin}"')
        

        # setup
        self._value = 0
        self.gpio = None
        self.setup(mode, pull, active_state)
        self._info("Pin init finished.")

    def close(self):
        self.gpio.close()

    def deinit(self):
        self.gpio.close()
        self.gpio.pin_factory.close()

    def setup(self, mode, pull=None, active_state=None):
        """
        Setup the pin

        :param mode: pin mode(IN/OUT)
        :type mode: int
        :param pull: pin pull up/down(PUD_UP/PUD_DOWN/PUD_NONE)
        :type pull: int
        """
        # check mode
        if mode in [None, self.OUT, self.IN]:
            self._mode = mode
        else:
            raise ValueError(
                f'mode param error, should be None, Pin.OUT, Pin.IN')
        # check pull
        if pull in [self.PULL_NONE, self.PULL_DOWN, self.PULL_UP]:
            self._pull = pull
        else:
            raise ValueError(
                f'pull param error, should be None, Pin.PULL_NONE, Pin.PULL_DOWN, Pin.PULL_UP'
            )
        #
        if self.gpio != None:
            if self.gpio.pin != None:
                self.gpio.close()
        #
        if mode in [None, self.OUT]:
            self.gpio = OutputDevice(self._pin_num)
        else:
            if pull == self.PULL_UP:
                self.gpio = InputDevice(self._pin_num, pull_up=True, active_state=None)
            elif pull == self.PULL_DOWN:
                self.gpio = InputDevice(self._pin_num, pull_up=False, active_state=None)
            else:
                self.gpio = InputDevice(self._pin_num, pull_up=None, active_state=active_state)

    def dict(self, _dict=None):
        """
        Set/get the pin dictionary

        :param _dict: pin dictionary, leave it empty to get the dictionary
        :type _dict: dict
        :return: pin dictionary
        :rtype: dict
        """
        if _dict == None:
            return self._dict
        else:
            if not isinstance(_dict, dict):
                raise ValueError(
                    f'Argument should be a pin dictionary like {{"my pin": ezblock.Pin.cpu.GPIO17}}, not {_dict}'
                )
            self._dict = _dict

    def __call__(self, value):
        """
        Set/get the pin value

        :param value: pin value, leave it empty to get the value(0/1)
        :type value: int
        :return: pin value(0/1)
        :rtype: int
        """
        return self.value(value)

    def value(self, value: bool = None):
        """
        Set/get the pin value

        :param value: pin value, leave it empty to get the value(0/1)
        :type value: int
        :return: pin value(0/1)
        :rtype: int
        """
        if value == None:
            if self._mode in [None, self.OUT]:
                self.setup(self.IN)
            result = self.gpio.value
            self._debug(f"read pin {self.gpio.pin}: {result}")
            return result
        else:
            if self._mode in [self.IN]:
                self.setup(self.OUT)
            if bool(value):
                value = 1
                self.gpio.on()
            else:
                value = 0
                self.gpio.off()
            return value

    def on(self):
        """
        Set pin on(high)

        :return: pin value(1)
        :rtype: int
        """
        return self.value(1)

    def off(self):
        """
        Set pin off(low)

        :return: pin value(0)
        :rtype: int
        """
        return self.value(0)

    def high(self):
        """
        Set pin high(1)

        :return: pin value(1)
        :rtype: int
        """
        return self.on()

    def low(self):
        """
        Set pin low(0)

        :return: pin value(0)
        :rtype: int
        """
        return self.off()

    def irq(self, handler, trigger, bouncetime=200, pull=None):
        """
        Set the pin interrupt

        :param handler: interrupt handler callback function
        :type handler: function
        :param trigger: interrupt trigger(RISING, FALLING, RISING_FALLING)
        :type trigger: int
        :param bouncetime: interrupt bouncetime in miliseconds
        :type bouncetime: int
        """
        # check trigger
        if trigger not in [
                self.IRQ_FALLING, self.IRQ_RISING, self.IRQ_RISING_FALLING
        ]:
            raise ValueError(
                f'trigger param error, should be None, Pin.IRQ_FALLING, Pin.IRQ_RISING, Pin.IRQ_RISING_FALLING'
            )

        # check pull
        if pull in [self.PULL_NONE, self.PULL_DOWN, self.PULL_UP]:
            self._pull = pull
            if pull == self.PULL_UP:
                _pull_up = True
            else:
                _pull_up = False
        else:
            raise ValueError(
                f'pull param error, should be None, Pin.PULL_NONE, Pin.PULL_DOWN, Pin.PULL_UP'
            )
        #
        pressed_handler = None
        released_handler = None
        #
        if not isinstance(self.gpio, Button):
            if self.gpio != None:
                self.gpio.close()
            self.gpio = Button(pin=self._pin_num,
                               pull_up=_pull_up,
                               bounce_time=float(bouncetime / 1000))
            self._bouncetime = bouncetime
        else:
            if bouncetime != self._bouncetime:
                pressed_handler = self.gpio.when_pressed
                released_handler = self.gpio.when_released
                self.gpio.close()
                self.gpio = Button(pin=self._pin_num,
                                   pull_up=_pull_up,
                                   bounce_time=float(bouncetime / 1000))
                self._bouncetime = bouncetime
        #
        if trigger in [None, self.IRQ_FALLING]:
            pressed_handler = handler
        elif trigger in [self.IRQ_RISING]:
            released_handler = handler
        elif trigger in [self.IRQ_RISING_FALLING]:
            pressed_handler = handler
            released_handler = handler
        #
        if pressed_handler is not None:
            self.gpio.when_pressed = pressed_handler
        if released_handler is not None:
            self.gpio.when_released = released_handler

    def name(self):
        """
        Get the pin name

        :return: pin name
        :rtype: str
        """
        return f"GPIO{self._pin_num}"


##################################################
# FILE: baseline_code/robot-hat/robot_hat/pwm.py
##################################################

#!/usr/bin/env python3
import math
from .i2c import I2C

timer = [{"arr": 1} for _ in range(7)]


class PWM(I2C):
    """Pulse width modulation (PWM)"""

    REG_CHN = 0x20
    """Channel register prefix"""
    REG_PSC = 0x40
    """Prescaler register prefix"""
    REG_ARR = 0x44
    """Period registor prefix"""
    REG_PSC2 = 0x50
    """Prescaler register prefix"""
    REG_ARR2 = 0x54
    """Period registor prefix"""

    ADDR = [0x14, 0x15, 0x16]

    CLOCK = 72000000.0
    """Clock frequency"""

    def __init__(self, channel, address=None, *args, **kwargs):
        """
        Initialize PWM

        :param channel: PWM channel number(0-19/P0-P19)
        :type channel: int/str
        """
        if address is None:
            super().__init__(self.ADDR, *args, **kwargs)
        else:
            super().__init__(address, *args, **kwargs)

        if isinstance(channel, str):
            if channel.startswith("P"):
                channel = int(channel[1:])
            else:
                raise ValueError(
                    f'PWM channel should be between [P0, P19], not "{channel}"')
        if isinstance(channel, int):
            if channel > 19 or channel < 0:
                raise ValueError(
                    f'channel must be in range of 0-19, not "{channel}"')

        self.channel = channel
        if channel < 16:
            self.timer_index = int(channel/4)
        elif channel == 16 or channel == 17:
            self.timer_index = 4
        elif channel == 18:
            self.timer_index = 5
        elif channel == 19:
            self.timer_index = 6

        self._pulse_width = 0
        self._freq = 50
        self.freq(50)

        # print(f'PWM channel {channel} initialized')
        # print(f'PWM timer_index {self.timer_index}')


    def _i2c_write(self, reg, value):
        value_h = value >> 8
        value_l = value & 0xff
        self.write([reg, value_h, value_l])

    def freq(self, freq=None):
        """
        Set/get frequency, leave blank to get frequency

        :param freq: frequency(0-65535)(Hz)
        :type freq: float
        :return: frequency
        :rtype: float
        """
        if freq == None:
            return self._freq

        self._freq = int(freq)
        # [prescaler,arr] list
        result_ap = []
        # accuracy list
        result_acy = []
        # middle value for equal arr prescaler
        st = int(math.sqrt(self.CLOCK/self._freq))
        # get -5 value as start
        st -= 5
        # prevent negetive value
        if st <= 0:
            st = 1
        for psc in range(st, st+10):
            arr = int(self.CLOCK/self._freq/psc)
            result_ap.append([psc, arr])
            result_acy.append(abs(self._freq-self.CLOCK/psc/arr))
        i = result_acy.index(min(result_acy))
        psc = result_ap[i][0]
        arr = result_ap[i][1]
        self._debug(f"prescaler: {psc}, period: {arr}")
        self.prescaler(psc)
        self.period(arr)

    def prescaler(self, prescaler=None):
        """
        Set/get prescaler, leave blank to get prescaler

        :param prescaler: prescaler(0-65535)
        :type prescaler: int
        :return: prescaler
        :rtype: int
        """
        if prescaler == None:
            return self._prescaler

        self._prescaler = round(prescaler)
        self._freq = self.CLOCK/self._prescaler/timer[self.timer_index]["arr"]
        if self.timer_index < 4:
            reg = self.REG_PSC + self.timer_index
        else:
            reg = self.REG_PSC2 + self.timer_index - 4
        self._debug(f"Set prescaler to: {self._prescaler}")
        self._i2c_write(reg, self._prescaler-1)

    def period(self, arr=None):
        """
        Set/get period, leave blank to get period

        :param arr: period(0-65535)
        :type arr: int
        :return: period
        :rtype: int
        """
        global timer
        if arr == None:
            return timer[self.timer_index]["arr"]

        timer[self.timer_index]["arr"] = round(arr)
        self._freq = self.CLOCK/self._prescaler/timer[self.timer_index]["arr"]

        if self.timer_index < 4:
            reg = self.REG_ARR + self.timer_index
        else:
            reg = self.REG_ARR2 + self.timer_index - 4

        self._debug(f"Set arr to: {timer[self.timer_index]['arr']}")
        self._i2c_write(reg, timer[self.timer_index]["arr"])

    def pulse_width(self, pulse_width=None):
        """
        Set/get pulse width, leave blank to get pulse width

        :param pulse_width: pulse width(0-65535)
        :type pulse_width: float
        :return: pulse width
        :rtype: float
        """
        if pulse_width == None:
            return self._pulse_width

        self._pulse_width = int(pulse_width)
        reg = self.REG_CHN + self.channel
        self._i2c_write(reg, self._pulse_width)

    def pulse_width_percent(self, pulse_width_percent=None):
        """
        Set/get pulse width percentage, leave blank to get pulse width percentage

        :param pulse_width_percent: pulse width percentage(0-100)
        :type pulse_width_percent: float
        :return: pulse width percentage
        :rtype: float
        """
        global timer
        if pulse_width_percent == None:
            return self._pulse_width_percent

        self._pulse_width_percent = pulse_width_percent
        temp = self._pulse_width_percent / 100.0
        pulse_width = temp * timer[self.timer_index]["arr"]
        self.pulse_width(pulse_width)


def test():
    import time
    p = PWM(0, debug_level='debug')
    p.period(1000)
    p.prescaler(10)
    # p.pulse_width(2048)
    while True:
        for i in range(0, 4095, 10):
            p.pulse_width(i)
            print(i)
            time.sleep(1/4095)
        time.sleep(1)
        for i in range(4095, 0, -10):
            p.pulse_width(i)
            print(i)
            time.sleep(1/4095)
        time.sleep(1)


def test2():
    p = PWM("P0", debug_level='debug')
    p.pulse_width_percent(50)
    # while True:
    #     p.pulse_width_percent(50)


if __name__ == '__main__':
    test2()


##################################################
# FILE: baseline_code/robot-hat/robot_hat/config.py
##################################################

import os
from time import sleep

class Config():

    def __init__(self, path:str, mode:str=None, owner:str=None, description=None):
        self.path = path
        # check path
        if self.path != None:
            self.file_check_create(self.path, mode, owner, description)
        #
        self._dict = {}
        self.read()

    def __getitem__(self, key):
        return self._dict[key]
    
    def __setitem__(self, key, value):
        self._dict[key] = value


    def file_check_create(self, path:str, mode:str=None, owner:str=None, description=None):
        dir = path.rsplit('/', 1)[0] # rsplit(), split from right; split(), split from left
        try:
            # check file
            if os.path.exists(path):
                if not os.path.isfile(path):
                    print('Could not create file, there is a folder with the same name')
                    return
                else:
                    # file already exists
                    pass
            else:
                # check directory
                if os.path.exists(dir):
                    if not os.path.isdir(dir):
                        print('Could not create file, there is a file with the same name')
                        return
                    else:
                        # dir already exists
                        pass
                else:
                    # create directory
                    os.makedirs(dir, mode=0o754) # makedirs， make multi-level directories
                    sleep(0.001)

                # create file
                with open(path, 'w') as f:
                    if description != None:
                        lines = description.split('\n')
                        _desc = ''
                        for line in lines:
                            _desc += '# '+line+'\n'
                        _desc += '\n'
                        f.write(_desc)
                    else:
                        f.write('')

                # set mode
                if mode != None:
                    os.popen('sudo chmod %s %s'%(mode, path))
                # set owner
                if owner != None:
                    os.popen('sudo chown -R %s:%s %s'%(owner, owner, dir))
        except Exception as e:
            raise(e)

    @staticmethod
    def _read(path):
        _dict = {}
        with open(path, 'r') as f:
            lines = f.readlines()
            section = ''
            _dict[section] = {}
            for line in lines:
                line = line.strip()
                if len(line) == 0:
                    continue
                if line[0] == '#':
                    continue
                elif line[0] == '[':
                    section = line[1:-1].strip()
                    _dict[section] = {}
                elif '=' in line:
                    option, value = line.split('=', 1)
                    option = option.strip()
                    value = value.strip()
                    # print(section, option, value)
                    _dict[section][option] = value
                else:
                    pass
        return _dict

    @staticmethod
    def _write(path, dict):
        part = {}
        _dict = dict.copy()
        # print(id(_dict), id(dict))
        _sections = list(_dict.keys())
        # print(f'_sections: {_sections}')
        with open(path, 'r') as f:
            lines = f.readlines()
            section = ''
            part[section] = []
            for line in lines:
                line = line.strip()
                if len(line) == 0:
                    part[section].append('\n')
                elif line[0] == '#':
                    part[section].append(line+'\n')
                elif line[0] == '[':
                    # fill items not added in last section
                    if section in _sections:
                        for option, value in _dict[section].items():
                            part[section].append(f'{option} = {value}\n')
                        _dict.pop(section)
                    # next section
                    section = line[1:-1].strip()
                    part[section] = []
                    part[section].append(line+'\n')
                elif '=' in line:
                    option, value = line.split('=', 1)
                    option = option.strip()
                    value = value.strip()
                    if section in _sections and option in _dict[section].keys():
                        value = _dict[section][option]
                        _dict[section].pop(option)
                    part[section].append(f'{option} = {value}\n')
                else:
                    part[section].append(line+'\n')
            # --------------------------------------------------
            # fill items not added in last section
            if section in _sections:
                for option, value in _dict[section].items():
                    part[section].append(f'{option} = {value}\n')
                _dict.pop(section)

            # print(f'new sections: {_dict.keys()}')
            sections = list(_dict.keys())
            for _section in sections:
                part[_section] = []
                part[_section].append(f'[{_section}]\n')
                for option, value in _dict[_section].items():
                    part[_section].append(f'{option} = {value}\n')
                part[_section].append('\n')
                _dict.pop(_section)

        # write new contents to file
        with open(path, 'w') as f:
            for _section in part.keys():
                for line in part[_section]:
                    f.write(line)

        # print new contents
        # for _section in part:
        #     for line in part[_section]:
        #         print(line, end='', flush=True)

    def read(self):
        self._dict = self._read(self.path)
        return self._dict

    def write(self):
        self._write(self.path, self._dict)

    def get(self, section, option, default=None):
        if section not in self._dict.keys():
            self._dict[section] = {}
            self._dict[section][option] = str(default)
        elif option not in self._dict[section].keys():
            self._dict[section][option] = str(default)
        #
        return self._dict[section][option]

    def set(self, section, option, value):
        if section not in self._dict.keys():
            self._dict[section] = {}
        self._dict[section][option] = value


if __name__ == '__main__':
    # description = 'robot-hat config test\nhello'
    description = '''
    robot-hat config test
    hello
    world
'''
    config = Config(path='/opt/robot-hat/test.config',
                    mode='775',
                    owner='xo', 
                    description=description)

    print(config.read()) # read config file to dict

    config['section1'] = {}
    config['section1']['option1'] = '1234'

    config['section2'] = {'option1': '100'}
    print(config.read())
 
    config.write() # write dict to config file

    print(config.get('section2', 'option1'))
    print(config.get('section3', 'option1', default='hello'))

    config.set('section4', 'option1', 'hi')
    config.write()





##################################################
# FILE: baseline_code/robot-hat/robot_hat/version.py
##################################################

__version__ = '2.3.5'


##################################################
# FILE: baseline_code/robot-hat/robot_hat/servo.py
##################################################

#!/usr/bin/env python3
from .pwm import PWM
from .utils import mapping


class Servo(PWM):
    """Servo motor class"""
    MAX_PW = 2500
    MIN_PW = 500
    FREQ = 50
    PERIOD = 4095

    def __init__(self, channel, address=None, *args, **kwargs):
        """
        Initialize the servo motor class

        :param channel: PWM channel number(0-14/P0-P14)
        :type channel: int/str
        """
        super().__init__(channel, address, *args, **kwargs)
        self.period(self.PERIOD)
        prescaler = self.CLOCK / self.FREQ / self.PERIOD
        self.prescaler(prescaler)

    def angle(self, angle):
        """
        Set the angle of the servo motor

        :param angle: angle(-90~90)
        :type angle: float
        """
        if not (isinstance(angle, int) or isinstance(angle, float)):
            raise ValueError(
                "Angle value should be int or float value, not %s" % type(angle))
        if angle < -90:
            angle = -90
        if angle > 90:
            angle = 90
        self._debug(f"Set angle to: {angle}")
        pulse_width_time = mapping(angle, -90, 90, self.MIN_PW, self.MAX_PW)
        self._debug(f"Pulse width: {pulse_width_time}")
        self.pulse_width_time(pulse_width_time)

    def pulse_width_time(self, pulse_width_time):
        """
        Set the pulse width of the servo motor

        :param pulse_width_time: pulse width time(500~2500)
        :type pulse_width_time: float
        """
        if pulse_width_time > self.MAX_PW:
            pulse_width_time = self.MAX_PW
        if pulse_width_time < self.MIN_PW:
            pulse_width_time = self.MIN_PW

        pwr = pulse_width_time / 20000
        self._debug(f"pulse width rate: {pwr}")
        value = int(pwr * self.PERIOD)
        self._debug(f"pulse width value: {value}")
        self.pulse_width(value)


##################################################
# FILE: baseline_code/robot-hat/robot_hat/motor.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .pwm import PWM
from .pin import Pin
from .filedb import fileDB

class Motor():
    """Motor"""
    PERIOD = 4095
    PRESCALER = 10
    DEFAULT_FREQ = 100 # Hz

    '''
    motor mode 1: (TC1508S)
                pin_a: PWM    pin_b: IO
    forward      pwm            1
    backward     pwm            0
    stop         0              x

    motor mode 2: (TC618S)
                pin_a: PWM    pin_b: PWM
    forward      pwm            0
    backward     0             pwm
    stop         0              0
    brake        1              1
    '''

    def __init__(self, pwm, dir, is_reversed=False, mode=None, freq=DEFAULT_FREQ):
        """
        Initialize a motor

        :param pwm: Motor speed control pwm pin
        :type pwm: robot_hat.pwm.PWM
        :param dir: Motor direction control pin
        :type dir: robot_hat.pin.Pin
        """
        if mode == None:
            from . import __device__
            self.mode = __device__.motor_mode
        else:
            self.mode = mode

        # mode 1: (TC1508S)
        if self.mode == 1:
            if not isinstance(pwm, PWM):
                raise TypeError("pin_a must be a class PWM")
            if not isinstance(dir, Pin):
                raise TypeError("pin_b must be a class Pin")

            self.pwm = pwm
            self.dir = dir
            self.freq = freq
            self.pwm.freq(self.freq)
            self.pwm.pulse_width_percent(0)
        # mode 2: (TC618S)
        elif self.mode == 2:
            if not isinstance(pwm, PWM):
                raise TypeError("pin_a must be a class PWM")
            if not isinstance(dir, PWM):
                raise TypeError("pin_b must be a class PWM")

            self.freq = freq
            self.pwm_a = pwm
            self.pwm_a.freq(self.freq)
            self.pwm_a.pulse_width_percent(0)
            self.pwm_b = dir
            self.pwm_b.freq(self.freq)
            self.pwm_b.pulse_width_percent(0)
        # unkowned mode
        else:
            raise ValueError("Unkown motors mode")

        self._speed = 0
        self._is_reverse = is_reversed

    def speed(self, speed=None):
        """
        Get or set motor speed

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        if speed is None:
            return self._speed

        dir = 1 if speed > 0 else 0
        if self._is_reverse:
            # dir = dir + 1 & 1
            dir = dir ^ 1 # XOR
        speed = abs(speed)

        # mode 1: (TC1508S)
        if self.mode == 1:
            self.pwm.pulse_width_percent(speed)
            self.dir.value(dir)
        # mode 2: (TC618S)
        elif self.mode ==2:
            if dir == 1:
                self.pwm_a.pulse_width_percent(speed)
                self.pwm_b.pulse_width_percent(0)
            else:
                self.pwm_a.pulse_width_percent(0)
                self.pwm_b.pulse_width_percent(speed)
        # unkowned mode
        else:
            raise ValueError("Unkown motors mode")
        

    def set_is_reverse(self, is_reverse):
        """
        Set motor is reversed or not

        :param is_reverse: True or False
        :type is_reverse: bool
        """
        self._is_reverse = is_reverse


class Motors(_Basic_class):
    """Motors"""

    DB_FILE = "motors.db"

    MOTOR_1_PWM_PIN = "P13"
    MOTOR_1_DIR_PIN = "D4"
    MOTOR_2_PWM_PIN = "P12"
    MOTOR_2_DIR_PIN = "D5"
    config_file = "/opt/robot_hat/default_motors.config"
    def __init__(self, db=config_file, *args, **kwargs):
        """
        Initialize motors with robot_hat.motor.Motor

        :param db: config file path
        :type db: str
        """
        super().__init__(*args, **kwargs)

        self.db = fileDB(db=db, mode='774', owner=User)
        self.left_id = int(self.db.get("left", default_value=0))
        self.right_id = int(self.db.get("right", default_value=0))
        left_reversed = bool(self.db.get(
            "left_reverse", default_value=False))
        right_reversed = bool(self.db.get(
            "right_reverse", default_value=False))

        self.motors = [
            Motor(PWM(self.MOTOR_1_PWM_PIN), Pin(self.MOTOR_1_DIR_PIN)),
            Motor(PWM(self.MOTOR_2_PWM_PIN), Pin(self.MOTOR_2_DIR_PIN))
        ]
        if self.left_id != 0:
            self.left.set_is_reverse(left_reversed)
        if self.right_id != 0:
            self.right.set_is_reverse(right_reversed)

    def __getitem__(self, key):
        """Get specific motor"""
        return self.motors[key-1]

    def stop(self):
        """Stop all motors"""
        for motor in self.motors:
            motor.speed(0)

    @property
    def left(self):
        """left motor"""
        if self.left_id not in range(1, 3):
            raise ValueError(
                "left motor is not set yet, set it with set_left_id(1/2)")
        return self.motors[self.left_id-1]

    @property
    def right(self):
        """right motor"""
        if self.left_id not in range(1, 3):
            raise ValueError(
                "left motor is not set yet, set it with set_left_id(1/2)")
        return self.motors[self.right_id-1]

    def set_left_id(self, id):
        """
        Set left motor id, this function only need to run once
        It will save the motor id to config file, and load
        the motor id when the class is initialized

        :param id: motor id (1 or 2)
        :type id: int
        """
        if id not in range(1, 3):
            raise ValueError("Motor id must be 1 or 2")
        self.left_id = id
        self.db.set("left", id)

    def set_right_id(self, id):
        """
        Set right motor id, this function only need to run once
        It will save the motor id to config file, and load
        the motor id when the class is initialized

        :param id: motor id (1 or 2)
        :type id: int
        """
        if id not in range(1, 3):
            raise ValueError("Motor id must be 1 or 2")
        self.right_id = id
        self.db.set("right", id)

    def set_left_reverse(self):
        """
        Set left motor reverse, this function only need to run once
        It will save the reversed status to config file, and load
        the reversed status when the class is initialized

        :return: if currently is reversed
        :rtype: bool
        """
        is_reversed = bool(self.db.get("left_reverse", default_value=False))
        is_reversed = not is_reversed
        self.db.set("left_reverse", is_reversed)
        self.left.set_is_reverse(is_reversed)
        return is_reversed

    def set_right_reverse(self):
        """
        Set right motor reverse, this function only need to run once
        It will save the reversed status to config file, and load
        the reversed status when the class is initialized

        :return: if currently is reversed
        :rtype: bool
        """
        is_reversed = bool(self.db.get("right_reverse", default_value=False))
        is_reversed = not is_reversed
        self.db.set("right_reverse", is_reversed)
        self.right.set_is_reverse(is_reversed)
        return is_reversed

    def speed(self, left_speed, right_speed):
        """
        Set motor speed

        :param left_speed: left motor speed(-100.0~100.0)
        :type left_speed: float
        :param right_speed: right motor speed(-100.0~100.0)
        :type right_speed: float
        """
        self.left.speed(left_speed)
        self.right.speed(right_speed)

    def forward(self, speed):
        """
        Forward

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(speed, speed)

    def backward(self, speed):
        """
        Backward

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(-speed, -speed)

    def turn_left(self, speed):
        """
        Left turn

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(-speed, speed)

    def turn_right(self, speed):
        """
        Right turn

        :param speed: Motor speed(-100.0~100.0)
        :type speed: float
        """
        self.speed(speed, -speed)


##################################################
# FILE: baseline_code/robot-hat/robot_hat/device.py
##################################################

import os

class Devices():
    HAT_DEVICE_TREE = "/proc/device-tree/"
    HAT_UUIDs = [
        "9daeea78-0000-076e-0032-582369ac3e02", # robothat5 1902v50
        ]

    DEVICES = {
        "robot_hat_v4x": {
            "uuid": None,
            "speaker_enbale_pin": 20,
            "motor_mode": 1,
        }, 
        "robot_hat_v5x": {
            "uuid": HAT_UUIDs[0],
            "speaker_enbale_pin": 12,
            "motor_mode": 2,
        }
    }

    name = ""
    product_id = 0
    product_ver = 0
    uuid = ""
    vendor = ""
    spk_en = 20
    motor_mode = 1

    def __init__(self):
        hat_path = None
        for file in os.listdir('/proc/device-tree/'):
            if 'hat' in file:
                # print("hat detected")
                if os.path.exists(f"/proc/device-tree/{file}/uuid") \
                    and os.path.isfile(f"/proc/device-tree/{file}/uuid"):
                    # print("uuid detected")
                    with open(f"/proc/device-tree/{file}/uuid", "r") as f:
                        uuid = f.read()[:-1] # [:-1] rm \x00
                        if uuid in self.HAT_UUIDs:
                            hat_path = f"/proc/device-tree/{file}"
                            break

        if hat_path is not None:
            with open(f"{hat_path}/product", "r") as f:
                self.name = f.read()
            with open(f"{hat_path}/product_id", "r") as f:
                self.product_id = f.read()[:-1] # [:-1] rm \x00
                self.product_id = int(self.product_id, 16)
            with open(f"{hat_path}/product_ver", "r") as f:
                self.product_ver = f.read()[:-1]
                self.product_ver = int(self.product_ver, 16)
            with open(f"{hat_path}/uuid", "r") as f:
                self.uuid = f.read()[:-1] # [:-1] rm \x00
            with open(f"{hat_path}/vendor", "r") as f:
                self.vendor = f.read()

            for device in self.DEVICES:
                if self.DEVICES[device]['uuid'] == self.uuid:
                    self.spk_en = self.DEVICES[device]["speaker_enbale_pin"]
                    self.motor_mode = self.DEVICES[device]["motor_mode"]
                    break

if __name__ == "__main__":
    device = Devices()
    print(f'name: {device.name}')
    print(f'product_id: {device.product_id}')
    print(f'product_ver: {device.product_ver}')
    print(f'vendor: {device.vendor}')
    print(f'uuid: {device.uuid}')
    print(f'speaker_enbale_pin: {device.spk_en}')
    print(f'motor_mode: {device.motor_mode}')


##################################################
# FILE: baseline_code/robot-hat/robot_hat/i2c.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .utils import run_command
from smbus2 import SMBus
import multiprocessing


def _retry_wrapper(func):

    def wrapper(self, *arg, **kwargs):
        for _ in range(self.RETRY):
            try:
                return func(self, *arg, **kwargs)
            except OSError:
                self._debug(f"OSError: {func.__name__}")
                continue
        else:
            return False

    return wrapper


class I2C(_Basic_class):
    """
    I2C bus read/write functions
    """
    RETRY = 5

    # i2c_lock = multiprocessing.Value('i', 0)

    def __init__(self, address=None, bus=1, *args, **kwargs):
        """
        Initialize the I2C bus

        :param address: I2C device address
        :type address: int
        :param bus: I2C bus number
        :type bus: int
        """
        super().__init__(*args, **kwargs)
        self._bus = bus
        self._smbus = SMBus(self._bus)
        if isinstance(address, list):
            connected_devices = self.scan()
            for _addr in address:
                if _addr in connected_devices:
                    self.address = _addr
                    break
            else:
                self.address = address[0]
        else:
            self.address = address

        # print(f'address: 0x{self.address:02X}')

    @_retry_wrapper
    def _write_byte(self, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(f"_write_byte: [0x{data:02X}]")
        result = self._smbus.write_byte(self.address, data)
        return result

    @_retry_wrapper
    def _write_byte_data(self, reg, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(f"_write_byte_data: [0x{reg:02X}] [0x{data:02X}]")
        return self._smbus.write_byte_data(self.address, reg, data)

    @_retry_wrapper
    def _write_word_data(self, reg, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(f"_write_word_data: [0x{reg:02X}] [0x{data:04X}]")
        return self._smbus.write_word_data(self.address, reg, data)

    @_retry_wrapper
    def _write_i2c_block_data(self, reg, data):
        # with I2C.i2c_lock.get_lock():
        self._debug(
            f"_write_i2c_block_data: [0x{reg:02X}] {[f'0x{i:02X}' for i in data]}"
        )
        return self._smbus.write_i2c_block_data(self.address, reg, data)

    @_retry_wrapper
    def _read_byte(self):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_byte(self.address)
        self._debug(f"_read_byte: [0x{result:02X}]")
        return result

    @_retry_wrapper
    def _read_byte_data(self, reg):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_byte_data(self.address, reg)
        self._debug(f"_read_byte_data: [0x{reg:02X}] [0x{result:02X}]")
        return result

    @_retry_wrapper
    def _read_word_data(self, reg):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_word_data(self.address, reg)
        result_list = [result & 0xFF, (result >> 8) & 0xFF]
        self._debug(f"_read_word_data: [0x{reg:02X}] [0x{result:04X}]")
        return result_list

    @_retry_wrapper
    def _read_i2c_block_data(self, reg, num):
        # with I2C.i2c_lock.get_lock():
        result = self._smbus.read_i2c_block_data(self.address, reg, num)
        self._debug(
            f"_read_i2c_block_data: [0x{reg:02X}] {[f'0x{i:02X}' for i in result]}"
        )
        return result

    @_retry_wrapper
    def is_ready(self):
        """Check if the I2C device is ready

        :return: True if the I2C device is ready, False otherwise
        :rtype: bool
        """
        addresses = self.scan()
        if self.address in addresses:
            return True
        else:
            return False

    def scan(self):
        """Scan the I2C bus for devices

        :return: List of I2C addresses of devices found
        :rtype: list
        """
        cmd = f"i2cdetect -y {self._bus}"
        # Run the i2cdetect command
        _, output = run_command(cmd)

        # Parse the output
        outputs = output.split('\n')[1:]
        addresses = []
        addresses_str = []
        for tmp_addresses in outputs:
            if tmp_addresses == "":
                continue
            tmp_addresses = tmp_addresses.split(':')[1]
            # Split the addresses into a list
            tmp_addresses = tmp_addresses.strip().split(' ')
            for address in tmp_addresses:
                if address != '--':
                    addresses.append(int(address, 16))
                    addresses_str.append(f'0x{address}')
        self._debug(f"Conneceted i2c device: {addresses_str}")
        return addresses

    def write(self, data):
        """Write data to the I2C device

        :param data: Data to write
        :type data: int/list/bytearray
        :raises: ValueError if write is not an int, list or bytearray
        """
        if isinstance(data, bytearray):
            data_all = list(data)
        elif isinstance(data, int):
            if data == 0:
                data_all = [0]
            else:
                data_all = []
                while data > 0:
                    data_all.append(data & 0xFF)
                    data >>= 8
        elif isinstance(data, list):
            data_all = data
        else:
            raise ValueError(
                f"write data must be int, list, or bytearray, not {type(data)}"
            )

        # Write data
        if len(data_all) == 1:
            data = data_all[0]
            self._write_byte(data)
        elif len(data_all) == 2:
            reg = data_all[0]
            data = data_all[1]
            self._write_byte_data(reg, data)
        elif len(data_all) == 3:
            reg = data_all[0]
            data = (data_all[2] << 8) + data_all[1]
            self._write_word_data(reg, data)
        else:
            reg = data_all[0]
            data = list(data_all[1:])
            self._write_i2c_block_data(reg, data)

    def read(self, length=1):
        """Read data from I2C device

        :param length: Number of bytes to receive
        :type length: int
        :return: Received data
        :rtype: list
        """
        if not isinstance(length, int):
            raise ValueError(f"length must be int, not {type(length)}")

        result = []
        for _ in range(length):
            result.append(self._read_byte())
        return result

    def mem_write(self, data, memaddr):
        """Send data to specific register address

        :param data: Data to send, int, list or bytearray
        :type data: int/list/bytearray
        :param memaddr: Register address
        :type memaddr: int
        :raise ValueError: If data is not int, list, or bytearray
        """
        if isinstance(data, bytearray):
            data_all = list(data)
        elif isinstance(data, list):
            data_all = data
        elif isinstance(data, int):
            data_all = []
            if data == 0:
                data_all = [0]
            else:
                while data > 0:
                    data_all.append(data & 0xFF)
                    data >>= 8
        else:
            raise ValueError(
                "memery write require arguement of bytearray, list, int less than 0xFF"
            )
        self._write_i2c_block_data(memaddr, data_all)

    def mem_read(self, length, memaddr):
        """Read data from specific register address

        :param length: Number of bytes to receive
        :type length: int
        :param memaddr: Register address
        :type memaddr: int
        :return: Received bytearray data or False if error
        :rtype: list/False
        """
        result = self._read_i2c_block_data(memaddr, length)
        return result

    def is_avaliable(self):
        """
        Check if the I2C device is avaliable

        :return: True if the I2C device is avaliable, False otherwise
        :rtype: bool
        """
        return self.address in self.scan()

    def __del__(self):
        self._smbus.close()
        self._smbus = None

if __name__ == "__main__":
    i2c = I2C(address=[0x17, 0x15], debug_level='debug')

##################################################
# FILE: baseline_code/robot-hat/robot_hat/tts.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .utils import is_installed, run_command
from .music import Music
from distutils.spawn import find_executable


class TTS(_Basic_class):
    """Text to speech class"""
    _class_name = 'TTS'
    SUPPORTED_LANGUAUE = [
        'en-US',
        'en-GB',
        'de-DE',
        'es-ES',
        'fr-FR',
        'it-IT',
    ]
    """Supported TTS language for pico2wave"""

    ESPEAK = 'espeak'
    """espeak TTS engine"""
    ESPEAK_NG = 'espeak-ng'
    """espeak-ng TTS engine"""
    PICO2WAVE = 'pico2wave'
    """pico2wave TTS engine"""

    def __init__(self, engine=PICO2WAVE, lang=None, *args, **kwargs):
        """
        Initialize TTS class.

        :param engine: TTS engine, TTS.PICO2WAVE, TTS.ESPEAK, or TTS.ESPEAK_NG
        :type engine: str
        """
        super().__init__()
        self.engine = engine
        if (engine == self.ESPEAK or engine == self.ESPEAK_NG):
            if not is_installed(engine):
                raise Exception(f"TTS engine: {engine} is not installed.")
            self._amp = 100
            self._speed = 175
            self._gap = 5
            self._pitch = 50
            if lang == None:
                self._lang = "en-us"
            else:
                self._lang = lang
            self._supported_lang = _get_supported_lang_espeak(engine)
        elif (engine == self.PICO2WAVE):
            if not is_installed("pico2wave"):
                raise Exception("TTS engine: pico2wave is not installed.")
            if lang == None:
                self._lang = "en-US"
            else:
                self._lang = lang
            self._supported_lang = self.SUPPORTED_LANGUAUE

    def _check_executable(self, executable):
        executable_path = find_executable(executable)
        found = executable_path is not None
        return found

    def say(self, words):
        """
        Say words.

        :param words: words to say.
        :type words: str
        """
        words = words.replace("'", "\\'")
        eval(f"self.{self.engine.replace('-', '_')}('{words}')")

    def _espeak(self, engine, words):
        """
        Say words with espeak.

        :param words: words to say.
        :type words: str
        """
        self._debug(f'{engine}: [{words}]')
        if not self._check_executable(engine):
            self._debug(f'{engine} is busy. Pass')

        cmd = f'{engine} -v{self._lang} -a{self._amp} -s{self._speed} -g{self._gap} -p{self._pitch} "{words}" --stdout | aplay 2>/dev/null & '
        status, result = run_command(cmd)
        if len(result) != 0:
            raise (f'tts-espeak:\n\t{result}')
        self._debug(f'command: {cmd}')

    def espeak(self, words):
        self._espeak('espeak', words)

    def espeak_ng(self, words):
        self._espeak('espeak-ng', words)

    def pico2wave(self, words):
        """
        Say words with pico2wave.

        :param words: words to say.
        :type words: str
        """
        self._debug(f'pico2wave: [{words}]')
        if not self._check_executable('pico2wave'):
            self._debug('pico2wave is busy. Pass')

        cmd = f'pico2wave -l {self._lang} -w /tmp/tts.wav "{words}" && aplay /tmp/tts.wav 2>/dev/null & '
        status, result = run_command(cmd)
        if len(result) != 0:
            raise (f'tts-pico2wav:\n\t{result}')
        self._debug(f'command: {cmd}')

    def lang(self, *value):
        """
        Set/get language. leave empty to get current language.

        :param value: language.
        :type value: str
        """
        if len(value) == 0:
            return self._lang
        elif len(value) == 1:
            v = value[0]
            if v in self._supported_lang:
                self._lang = v
                return self._lang
        raise ValueError(
            f'Arguement "{value}" is not supported. run tts.supported_lang to get supported language type.'
        )

    def supported_lang(self):
        """
        Get supported language.

        :return: supported language.
        :rtype: list
        """
        return self._supported_lang

    def espeak_params(self, amp=None, speed=None, gap=None, pitch=None):
        """
        Set espeak parameters.

        :param amp: amplitude.
        :type amp: int
        :param speed: speed.
        :type speed: int
        :param gap: gap.
        :type gap: int
        :param pitch: pitch.
        :type pitch: int
        """
        if amp == None:
            amp = self._amp
        if speed == None:
            speed = self._speed
        if gap == None:
            gap = self._gap
        if pitch == None:
            pitch = self._pitch

        if amp not in range(0, 200):
            raise ValueError(f'Amp should be in 0 to 200, not "{amp}"')
        if speed not in range(80, 260):
            raise ValueError(f'speed should be in 80 to 260, not "{speed}"')
        if pitch not in range(0, 99):
            raise ValueError(f'pitch should be in 0 to 99, not "{pitch}"')
        self._amp = amp
        self._speed = speed
        self._gap = gap
        self._pitch = pitch

def _get_supported_lang_espeak(name):
    """
    Get supported language for espeak.

    :param name: espeak command name.
    :return: supported language.
    :rtype: list
    """
    status, result = run_command(f"{name} --voices")
    supported_lang = []
    if not status:
        first = True
        for line in result.split('\n'):
            if first or not line:
                first = False
                continue
            lang = [v for v in line.split() if v][1]
            supported_lang.append(lang)
    return supported_lang


##################################################
# FILE: baseline_code/robot-hat/robot_hat/__init__.py
##################################################

#!/usr/bin/env python3
"""
Robot Hat Library
"""
from .adc import ADC
from .filedb import fileDB
from .config import Config
from .i2c import I2C
from .modules import *
from .music import Music
from .motor import Motor, Motors
from .pin import Pin
from .pwm import PWM
from .servo import Servo
from .tts import TTS
from .utils import *
from .robot import Robot
from .version import __version__

from .device import Devices
__device__ = Devices()

def __usage__():
    print('''
Usage: robot_hat [option]

reset_mcu               reset mcu on robot-hat
enable_speaker          enable speaker
disable_speaker         disable speaker
version                 get robot-hat libray version
info                    get hat info
    ''')
    quit()

def get_firmware_version():
    ADDR = [0x14, 0x15]
    VERSSION_REG_ADDR = 0x05
    i2c = I2C(ADDR)
    version = i2c.mem_read(3, VERSSION_REG_ADDR)
    return version

def __main__():
    import sys
    import os
    if len(sys.argv) == 2:
        if sys.argv[1] == "reset_mcu":
            reset_mcu()
            info("Onboard MCU reset.")
        elif sys.argv[1] == "enable_speaker":
            info(f"Enable Robot-HAT speaker.")
            utils.enable_speaker()
        elif sys.argv[1] == "disable_speaker":
            info(f"Disable Robot-HAT speaker.")
            utils.disable_speaker()
        elif sys.argv[1] == "version":
            info(f"robot-hat library version: {__version__}")
        elif sys.argv[1] == "info":
            info(f'HAT name: {__device__.name}')
            info(f'PCB ID: O{__device__.product_id}V{__device__.product_ver}')
            info(f'Vendor: {__device__.vendor}')
            firmware_ver = get_firmware_version()
            firmware_ver = f'{firmware_ver[0]}.{firmware_ver[1]}.{firmware_ver[2]}'
            info(f"Firmare version: {firmware_ver}")
        else:
            warn("Unknown option.")
            __usage__()
    else:
        __usage__()


##################################################
# FILE: baseline_code/robot-hat/robot_hat/music.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
import time
import threading
import pyaudio
import os
import struct
import math
from .utils import enable_speaker, disable_speaker

class Music(_Basic_class):
    """Play music, sound affect and note control"""

    FORMAT = pyaudio.paInt16
    CHANNELS = 1
    RATE = 44100

    KEY_G_MAJOR = 1
    KEY_D_MAJOR = 2
    KEY_A_MAJOR = 3
    KEY_E_MAJOR = 4
    KEY_B_MAJOR = 5
    KEY_F_SHARP_MAJOR = 6
    KEY_C_SHARP_MAJOR = 7

    KEY_F_MAJOR = -1
    KEY_B_FLAT_MAJOR = -2
    KEY_E_FLAT_MAJOR = -3
    KEY_A_FLAT_MAJOR = -4
    KEY_D_FLAT_MAJOR = -5
    KEY_G_FLAT_MAJOR = -6
    KEY_C_FLAT_MAJOR = -7

    KEY_SIGNATURE_SHARP = 1
    KEY_SIGNATURE_FLAT = -1

    WHOLE_NOTE = 1
    HALF_NOTE = 1/2
    QUARTER_NOTE = 1/4
    EIGHTH_NOTE = 1/8
    SIXTEENTH_NOTE = 1/16

    NOTE_BASE_FREQ = 440
    """Base note frequency for calculation (A4)"""
    NOTE_BASE_INDEX = 69
    """Base note index for calculation (A4) MIDI compatible"""

    NOTES = [
        None,  None, None,  None, None, None,  None, None,  None, None,  None, None,
        None,  None, None,  None, None, None,  None, None,  None, "A0", "A#0", "B0",
        "C1", "C#1", "D1", "D#1", "E1", "F1", "F#1", "G1", "G#1", "A1", "A#1", "B1",
        "C2", "C#2", "D2", "D#2", "E2", "F2", "F#2", "G2", "G#2", "A2", "A#2", "B2",
        "C3", "C#3", "D3", "D#3", "E3", "F3", "F#3", "G3", "G#3", "A3", "A#3", "B3",
        "C4", "C#4", "D4", "D#4", "E4", "F4", "F#4", "G4", "G#4", "A4", "A#4", "B4",
        "C5", "C#5", "D5", "D#5", "E5", "F5", "F#5", "G5", "G#5", "A5", "A#5", "B5",
        "C6", "C#6", "D6", "D#6", "E6", "F6", "F#6", "G6", "G#6", "A6", "A#6", "B6",
        "C7", "C#7", "D7", "D#7", "E7", "F7", "F#7", "G7", "G#7", "A7", "A#7", "B7",
        "C8"]
    """Notes name, MIDI compatible"""

    def __init__(self):
        import warnings
        warnings_bk = warnings.filters
        warnings.filterwarnings("ignore")
        # close welcome message of pygame, and the value must be <str> 
        os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "1" 
        import pygame
        warnings.filters = warnings_bk
        """Initialize music"""
        self.pygame = pygame
        self.pygame.mixer.init()
        self.time_signature(4, 4)
        self.tempo(120, 1/4)
        self.key_signature(0)
        #
        enable_speaker()

    def time_signature(self, top: int = None, bottom: int = None):
        """
        Set/get time signature

        :param top: top number of time signature
        :type top: int
        :param bottom: bottom number of time signature
        :type bottom: int
        :return: time signature
        :rtype: tuple
        """
        if top == None and bottom == None:
            return self._time_signature
        if bottom == None:
            bottom = top
        self._time_signature = (top, bottom)
        return self._time_signature

    def key_signature(self, key: int = None):
        """
        Set/get key signature

        :param key: key signature use KEY_XX_MAJOR or String "#", "##", or "bbb", "bbbb"
        :type key: int/str
        :return: key signature
        :rtype: int
        """
        if key == None:
            return self._key_signature
        if isinstance(key, str):
            if "#" in key:
                key = len(key)*self.KEY_SIGNATURE_SHARP
            elif "b" in key:
                key = len(key)*self.KEY_SIGNATURE_FLAT
        self._key_signature = key
        return self._key_signature

    def tempo(self, tempo=None, note_value=QUARTER_NOTE):
        """
        Set/get tempo beat per minute(bpm)

        :param tempo: tempo
        :type tempo: float
        :param note_value: note value(1, 1/2, Music.HALF_NOTE, etc)
        :return: tempo
        :rtype: int
        """
        if tempo == None and note_value == None:
            return self._tempo
        try:
            self._tempo = (tempo, note_value)
            self.beat_unit = 60.0 / tempo
            return self._tempo
        except:
            raise ValueError("tempo must be int not {}".format(tempo))

    def beat(self, beat):
        """
        Calculate beat delay in seconds from tempo

        :param beat: beat index
        :type beat: float
        :return: beat delay
        :rtype: float
        """
        beat = beat / self._tempo[1] * self.beat_unit
        return beat

    def note(self, note, natural=False):
        """
        Get frequency of a note

        :param note_name: note name(See NOTES)
        :type note_name: string
        :param natural: if natural note
        :type natural: bool
        :return: frequency of note
        :rtype: float
        """
        if isinstance(note, str):
            if note in self.NOTES:
                note = self.NOTES.index(note)
            else:
                raise ValueError(
                    f"note {note} not found, note must in Music.NOTES")
        if not natural:
            note += self.key_signature()
            note = min(max(note, 0), len(self.NOTES)-1)
        note_delta = note - self.NOTE_BASE_INDEX
        freq = self.NOTE_BASE_FREQ * (2 ** (note_delta / 12))
        return freq

    def sound_play(self, filename, volume=None):
        """
        Play sound effect file

        :param filename: sound effect file name
        :type filename: str
        """
        sound = self.pygame.mixer.Sound(filename)
        if volume is not None:
            # attention: 
            #   The volume of sound and music is separate, 
            # and the volume of different sound objects is also separate.
            sound.set_volume(round(volume/100.0, 2))
        time_delay = round(sound.get_length(), 2)
        sound.play()
        time.sleep(time_delay)

    def sound_play_threading(self, filename, volume=None):
        """
        Play sound effect in thread(in the background)

        :param filename: sound effect file name
        :type filename: str
        :param volume: volume 0-100, leave empty will not change volume
        :type volume: int
        """
        obj = threading.Thread(target=self.sound_play, kwargs={
                               "filename": filename, "volume": volume})
        obj.start()

    def music_play(self, filename, loops=1, start=0.0, volume=None):
        """
        Play music file

        :param filename: sound file name
        :type filename: str
        :param loops: number of loops, 0:loop forever, 1:play once, 2:play twice, ...
        :type loops: int
        :param start: start time in seconds
        :type start: float
        :param volume: volume 0-100, leave empty will not change volume
        :type volume: int
        """
        if volume is not None:
            self.music_set_volume(volume)
        self.pygame.mixer.music.load(filename)
        self.pygame.mixer.music.play(loops, start)

    def music_set_volume(self, value):
        """
        Set music volume

        :param value: volume 0-100
        :type value: int
        """
        value = round(value/100.0, 2)
        self.pygame.mixer.music.set_volume(value)

    def music_stop(self):
        """Stop music"""
        self.pygame.mixer.music.stop()

    def music_pause(self):
        """Pause music"""
        self.pygame.mixer.music.pause()

    def music_resume(self):
        """Resume music"""
        self.pygame.mixer.music.unpause()

    def music_unpause(self):
        """Unpause music(resume music)"""
        self.pygame.mixer.music.unpause()

    def sound_length(self, filename):
        """
        Get sound effect length in seconds

        :param filename: sound effect file name
        :type filename: str
        :return: length in seconds
        :rtype: float
        """
        music = self.pygame.mixer.Sound(str(filename))
        return round(music.get_length(), 2)

    def get_tone_data(self, freq: float, duration: float):
        """
        Get tone data for playing

        :param freq: frequency
        :type freq: float
        :param duration: duration in seconds
        :type duration: float
        :return: tone data
        :rtype: list
        """
        """
        Credit to: Aditya Shankar & Gringo Suave https://stackoverflow.com/a/53231212/14827323
        """
        duration /= 2.0
        frame_count = int(self.RATE * duration)

        remainder_frames = frame_count % self.RATE
        wavedata = []

        for i in range(frame_count):
            a = self.RATE / freq  # number of frames per wave
            b = i / a
            # explanation for b
            # considering one wave, what part of the wave should this be
            # if we graph the sine wave in a
            # displacement vs i graph for the particle
            # where 0 is the beginning of the sine wave and
            # 1 the end of the sine wave
            # which part is "i" is denoted by b
            # for clarity you might use
            # though this is redundant since math.sin is a looping function
            # b = b - int(b)

            c = b * (2 * math.pi)
            # explanation for c
            # now we map b to between 0 and 2*math.PI
            # since 0 - 2*PI, 2*PI - 4*PI, ...
            # are the repeating domains of the sin wave (so the decimal values will
            # also be mapped accordingly,
            # and the integral values will be multiplied
            # by 2*PI and since sin(n*2*PI) is zero where n is an integer)
            d = math.sin(c) * 32767
            e = int(d)
            wavedata.append(e)

        for i in range(remainder_frames):
            wavedata.append(0)

        number_of_bytes = str(len(wavedata))
        wavedata = struct.pack(number_of_bytes + 'h', *wavedata)

        return wavedata

    def play_tone_for(self, freq, duration):
        """
        Play tone for duration seconds

        :param freq: frequency, you can use NOTES to get frequency
        :type freq: float
        :param duration: duration in seconds
        :type duration: float
        """
        """
        Credit to: Aditya Shankar & Gringo Suave https://stackoverflow.com/a/53231212/14827323
        """
        p = pyaudio.PyAudio()
        frames = self.get_tone_data(freq, duration)
        stream = p.open(format=self.FORMAT, channels=self.CHANNELS,
                        rate=self.RATE, output=True)
        stream.write(frames)
        # stream.stop_stream()
        # stream.close()


##################################################
# FILE: baseline_code/robot-hat/robot_hat/basic.py
##################################################

# -*- coding: utf-8 -*-
#!/usr/bin/env python3
import logging
import time


class _Basic_class(object):
    """
    Basic Class for all classes

    with debug function
    """
    _class_name = '_Basic_class'
    DEBUG_LEVELS = {'debug': logging.DEBUG,
                    'info': logging.INFO,
                    'warning': logging.WARNING,
                    'error': logging.ERROR,
                    'critical': logging.CRITICAL,
                    }
    """Debug level"""
    DEBUG_NAMES = ['critical', 'error', 'warning', 'info', 'debug']
    """Debug level names"""

    def __init__(self, debug_level='warning'):
        """
        Initialize the basic class

        :param debug_level: debug level, 0(critical), 1(error), 2(warning), 3(info) or 4(debug)
        :type debug_level: str/int
        """
        self.logger = logging.getLogger(f"self._class_name-{time.time()}")
        self.ch = logging.StreamHandler()
        form = "%(asctime)s	[%(levelname)s]	%(message)s"
        self.formatter = logging.Formatter(form)
        self.ch.setFormatter(self.formatter)
        self.logger.addHandler(self.ch)
        self._debug = self.logger.debug
        self._info = self.logger.info
        self._warning = self.logger.warning
        self._error = self.logger.error
        self._critical = self.logger.critical
        self.debug_level = debug_level

    @property
    def debug_level(self):
        """Debug level"""
        return self._debug_level

    @debug_level.setter
    def debug_level(self, debug):
        """Debug level"""
        if debug in range(5):
            self._debug_level = self.DEBUG_NAMES[debug]
        elif debug in self.DEBUG_NAMES:
            self._debug_level = debug
        else:
            raise ValueError(
                f'Debug value must be 0(critical), 1(error), 2(warning), 3(info) or 4(debug), not "{debug}".')
        self.logger.setLevel(self.DEBUG_LEVELS[self._debug_level])
        self.ch.setLevel(self.DEBUG_LEVELS[self._debug_level])
        self._debug(f'Set logging level to [{self._debug_level}]')


##################################################
# FILE: baseline_code/robot-hat/robot_hat/utils.py
##################################################

#!/usr/bin/env python3
import time
import os
import sys
import re
from .pin import Pin


# color:
# https://gist.github.com/rene-d/9e584a7dd2935d0f461904b9f2950007
# 1;30:gray 31:red, 32:green, 33:yellow, 34:blue, 35:purple, 36:dark green, 37:white
GRAY = '1;30'
RED = '0;31'
GREEN = '0;32'
YELLOW = '0;33'
BLUE = '0;34'
PURPLE = '0;35'
DARK_GREEN = '0;36'
WHITE = '0;37'

_adc_obj = None

def print_color(msg, end='\n', file=sys.stdout, flush=False, color=''):
    print('\033[%sm%s\033[0m'%(color, msg), end=end, file=file, flush=flush)

def info(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=WHITE)

def debug(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=GRAY)

def warn(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=YELLOW)

def error(msg, end='\n', file=sys.stdout, flush=False):
    print_color(msg, end=end, file=file, flush=flush, color=RED)

def set_volume(value):
    """
    Set volume

    :param value: volume(0~100)
    :type value: int
    """
    value = min(100, max(0, value))
    cmd = "sudo amixer -M sset 'PCM' %d%%" % value
    os.system(cmd)


def command_exists(cmd):
    import subprocess
    try:
        subprocess.check_output(['which', cmd], stderr=subprocess.STDOUT)
        return True
    except subprocess.CalledProcessError:
        return False


def run_command(cmd):
    """
    Run command and return status and output

    :param cmd: command to run
    :type cmd: str
    :return: status, output
    :rtype: tuple
    """
    import subprocess
    p = subprocess.Popen(
        cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    result = p.stdout.read().decode('utf-8')
    status = p.poll()
    return status, result

def command_exists(cmd):
    import subprocess
    try:
        subprocess.check_output(['which', cmd], stderr=subprocess.STDOUT)
        return True
    except subprocess.CalledProcessError:
        return False

def is_installed(cmd):
    """
    Check if command is installed

    :param cmd: command to check
    :type cmd: str
    :return: True if installed
    :rtype: bool
    """
    status, _ = run_command(f"which {cmd}")
    if status in [0, ]:
        return True
    else:
        return False


def mapping(x, in_min, in_max, out_min, out_max):
    """
    Map value from one range to another range

    :param x: value to map
    :type x: float/int
    :param in_min: input minimum
    :type in_min: float/int
    :param in_max: input maximum
    :type in_max: float/int
    :param out_min: output minimum
    :type out_min: float/int
    :param out_max: output maximum
    :type out_max: float/int
    :return: mapped value
    :rtype: float/int
    """
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min


def get_ip(ifaces=['wlan0', 'eth0']):
    """
    Get IP address

    :param ifaces: interfaces to check
    :type ifaces: list
    :return: IP address or False if not found
    :rtype: str/False
    """
    if isinstance(ifaces, str):
        ifaces = [ifaces]
    for iface in list(ifaces):
        search_str = 'ip addr show {}'.format(iface)
        result = os.popen(search_str).read()
        com = re.compile(r'(?<=inet )(.*)(?=\/)', re.M)
        ipv4 = re.search(com, result)
        if ipv4:
            ipv4 = ipv4.groups()[0]
            return ipv4
    return False


def reset_mcu():
    """
    Reset mcu on Robot Hat.

    This is helpful if the mcu somehow stuck in a I2C data
    transfer loop, and Raspberry Pi getting IOError while
    Reading ADC, manipulating PWM, etc.
    """
    mcu_reset = Pin("MCURST")
    mcu_reset.off()
    time.sleep(0.01)
    mcu_reset.on()
    time.sleep(0.01)

    mcu_reset.close()


def get_battery_voltage():
    """
    Get battery voltage

    :return: battery voltage(V)
    :rtype: float
    """
    global _adc_obj
    from .adc import ADC

    if not isinstance(_adc_obj, ADC):
        _adc_obj = ADC("A4")
    raw_voltage = _adc_obj.read_voltage()
    voltage = raw_voltage * 3
    return voltage

def get_username():
    return os.popen('echo ${SUDO_USER:-$LOGNAME}').readline().strip()

def enable_speaker():
    """
    Enable speaker
    """
    from . import __device__
    pincmd = ''
    if command_exists("pinctrl"):
        pincmd = 'pinctrl'
    elif command_exists("raspi-gpio"):
        pincmd = 'raspi-gpio'
    else:
        error("Can't find `pinctrl` or `raspi-gpio` to enable speaker")
        return

    debug(f"{pincmd} set {__device__.spk_en} op dh")
    run_command(f"{pincmd} set {__device__.spk_en} op dh")
    # play a short sound to fill data and avoid the speaker overheating
    run_command(f"play -n trim 0.0 0.5 2>/dev/null")

def disable_speaker():
    """
    Disable speaker
    """
    from . import __device__
    pincmd = ''
    if command_exists("pinctrl"):
        pincmd = 'pinctrl'
    elif command_exists("raspi-gpio"):
        pincmd = 'raspi-gpio'
    else:
        error("Can't find `pinctrl` or `raspi-gpio` to disable speaker")
        return

    debug(f"{pincmd} set {__device__.spk_en} op dl")
    run_command(f"{pincmd} set {__device__.spk_en} op dl")




##################################################
# FILE: baseline_code/robot-hat/robot_hat/filedb.py
##################################################

#!/usr/bin/env python3
'''
**********************************************************************
* Filename    : filedb.py
* Description : A simple file based database.
* Author      : Cavon
* Brand       : SunFounder
* E-mail      : service@sunfounder.com
* Website     : www.sunfounder.com
* Update      : Cavon    2016-09-13    New release
**********************************************************************
'''
import os
from time import sleep


class fileDB(object):
	"""A file based database.

    A file based database, read and write arguements in the specific file.
    """
	def __init__(self, db:str, mode:str=None, owner:str=None):  
		'''
		Init the db_file is a file to save the datas.
		
		:param db: the file to save the datas.
		:type db: str
		:param mode: the mode of the file.
		:type mode: str
		:param owner: the owner of the file.
		:type owner: str
		'''

		self.db = db
		# Check if db_file is existed, otherwise create one
		if self.db != None:	
			self.file_check_create(db, mode, owner)
		else:
			raise ValueError('db: Missing file path parameter.')


	def file_check_create(self, file_path:str, mode:str=None, owner:str=None):
		"""
		Check if file is existed, otherwise create one.
		
		:param file_path: the file to check
		:type file_path: str
		:param mode: the mode of the file.
		:type mode: str
		:param owner: the owner of the file.
		:type owner: str
		"""
		dir = file_path.rsplit('/',1)[0]
		try:
			if os.path.exists(file_path):
				if not os.path.isfile(file_path):
					print('Could not create file, there is a folder with the same name')
					return
			else:
				if os.path.exists(dir):
					if not os.path.isdir(dir):
						print('Could not create directory, there is a file with the same name')
						return
				else:
					os.makedirs(dir, mode=0o754)
					sleep(0.001)

				with open(file_path, 'w') as f:
					f.write("# robot-hat config and calibration value of robots\n\n")

			if mode != None:
				os.popen('sudo chmod %s %s'%(mode, file_path))
			if owner != None:
				os.popen('sudo chown -R %s:%s %s'%(owner, owner, dir))		
		except Exception as e:
			raise(e) 
	
	def get(self, name, default_value=None):
		"""
		Get value with data's name
		
		:param name: the name of the arguement
		:type name: str
		:param default_value: the default value of the arguement
		:type default_value: str
		:return: the value of the arguement
		:rtype: str
		"""
		try:
			conf = open(self.db,'r')
			lines=conf.readlines()
			conf.close()
			file_len=len(lines)-1
			flag = False
			# Find the arguement and set the value
			for i in range(file_len):
				if lines[i][0] != '#':
					if lines[i].split('=')[0].strip() == name:
						value = lines[i].split('=')[1].replace(' ', '').strip()
						flag = True
			if flag:
				return value
			else:
				return default_value
		except FileNotFoundError:
			conf = open(self.db,'w')
			conf.write("")
			conf.close()
			return default_value
		except :
			return default_value
	
	def set(self, name, value):
		"""
		Set value by with name. Or create one if the arguement does not exist
		
		:param name: the name of the arguement
		:type name: str
		:param value: the value of the arguement
		:type value: str
		"""
		# Read the file
		conf = open(self.db,'r')
		lines=conf.readlines()
		conf.close()
		file_len=len(lines)-1
		flag = False
		# Find the arguement and set the value
		for i in range(file_len):
			if lines[i][0] != '#':
				if lines[i].split('=')[0].strip() == name:
					lines[i] = '%s = %s\n' % (name, value)
					flag = True
		# If arguement does not exist, create one
		if not flag:
			lines.append('%s = %s\n\n' % (name, value))

		# Save the file
		conf = open(self.db,'w')
		conf.writelines(lines)
		conf.close()

if __name__ == '__main__':
    db = fileDB('/opt/robot-hat/test2.config')

    db.set('a', '1')
    db.set('b', '2')
	
    print(db.get('a'))
    print(db.get('c'))
	


##################################################
# FILE: baseline_code/robot-hat/robot_hat/robot.py
##################################################

#!/usr/bin/env python3
from .basic import _Basic_class
from .pwm import PWM
from .servo import Servo
import time
from .filedb import fileDB
import os

# user and User home directory
User = os.popen('echo ${SUDO_USER:-$LOGNAME}').readline().strip()
UserHome = os.popen('getent passwd %s | cut -d: -f 6' %
                    User).readline().strip()
config_file = '%s/.config/robot-hat/robot-hat.conf' % UserHome


class Robot(_Basic_class):
    """
    Robot class

    This class is for makeing a servo robot with Robot HAT

    There are servo initialization, all servo move in specific speed. servo offset and stuff. make it easy to make a robot.
    All Pi-series robot from SunFounder use this class. Check them out for more details.

    PiSloth: https://github.com/sunfounder/pisloth

    PiArm: https://github.com/sunfounder/piarm

    PiCrawler: https://github.com/sunfounder/picrawler
    """

    move_list = {}
    """Preset actions"""

    max_dps = 428  # dps, degrees per second, genally in 4.8V : 60des/0.14s, dps = 428
    # max_dps = 500
    """Servo max Degree Per Second"""

    def __init__(self, pin_list, db=config_file, name=None, init_angles=None, init_order=None, **kwargs):
        """
        Initialize the robot class

        :param pin_list: list of pin number[0-11]
        :type pin_list: list
        :param db: config file path
        :type db: str
        :param name: robot name
        :type name: str
        :param init_angles: list of initial angles
        :type init_angles: list
        :param init_order: list of initialization order(Servos will init one by one in case of sudden huge current, pulling down the power supply voltage. default order is the pin list. in some cases, you need different order, use this parameter to set it.)
        :type init_order: list
        :type init_angles: list
        """
        super().__init__(**kwargs)
        self.servo_list = []
        self.pin_num = len(pin_list)

        if name == None:
            self.name = 'other'
        else:
            self.name = name

        self.offset_value_name = f"{self.name}_servo_offset_list"
        # offset
        self.db = fileDB(db=db, mode='774', owner=User)
        temp = self.db.get(self.offset_value_name,
                           default_value=str(self.new_list(0)))
        temp = [float(i.strip()) for i in temp.strip("[]").split(",")]
        self.offset = temp

        # parameter init
        self.servo_positions = self.new_list(0)
        self.origin_positions = self.new_list(0)
        self.calibrate_position = self.new_list(0)
        self.direction = self.new_list(1)

        # servo init
        if None == init_angles:
            init_angles = [0]*self.pin_num
        elif len(init_angles) != self.pin_num:
            raise ValueError('init angels numbers do not match pin numbers ')

        if init_order == None:
            init_order = range(self.pin_num)

        for i, pin in enumerate(pin_list):
            self.servo_list.append(Servo(pin))
            self.servo_positions[i] = init_angles[i]
        for i in init_order:
            self.servo_list[i].angle(self.offset[i]+self.servo_positions[i])
            time.sleep(0.15)

        self.last_move_time = time.time()

    def new_list(self, default_value):
        """
        Create a list of servo angles with default value

        :param default_value: default value of servo angles
        :type default_value: int or float
        :return: list of servo angles
        :rtype: list
        """
        _ = [default_value] * self.pin_num
        return _

    def servo_write_raw(self, angle_list):
        """
        Set servo angles to specific raw angles

        :param angle_list: list of servo angles
        :type angle_list: list
        """
        for i in range(self.pin_num):
            self.servo_list[i].angle(angle_list[i])

    def servo_write_all(self, angles):
        """
        Set servo angles to specific angles with original angle and offset

        :param angles: list of servo angles
        :type angles: list
        """
        rel_angles = []  # ralative angle to home
        for i in range(self.pin_num):
            rel_angles.append(
                self.direction[i] * (self.origin_positions[i] + angles[i] + self.offset[i]))
        self.servo_write_raw(rel_angles)

    def servo_move(self, targets, speed=50, bpm=None):
        """
        Move servo to specific angles with speed or bpm

        :param targets: list of servo angles
        :type targets: list
        :param speed: speed of servo move
        :type speed: int or float
        :param bpm: beats per minute
        :type bpm: int or float
        """
        '''
            calculate the max delta angle, multiply by 2 to define a max_step
            loop max_step times, every servo add/minus 1 when step reaches its adder_flag
        '''
        speed = max(0, speed)
        speed = min(100, speed)
        step_time = 10  # ms 
        delta = []
        absdelta = []
        max_step = 0
        steps = []
        # print(f"targets: {targets}")
        # print(f"current:{self.servo_positions}")
        # st = time.time()
        # if self.name == "legs":
        #     print(f"move_interval: {time.time() - self.last_move_time}")
        #     self.last_move_time = time.time()

        for i in range(self.pin_num):
            value = targets[i] - self.servo_positions[i]
            delta.append(value)
            absdelta.append(abs(value))

        # Calculate max delta angle
        max_delta = int(max(absdelta))
        if max_delta == 0:
            time.sleep(step_time/1000)
            return

        # Calculate total servo move time
        if bpm: # bpm: beats per minute
            total_time = 60 / bpm * 1000 # time taken per beat, unit: ms
        else:
            total_time = -9.9 * speed + 1000 # time spent in one step, unit: ms
        # print(f"Total time: {total_time} ms")

        # Calculate max dps
        current_max_dps = max_delta / total_time * 1000 # dps, degrees per second

        # If current max dps is larger than max dps, then calculate a new total servo move time
        if current_max_dps > self.max_dps:
            # print(
            #     f"Current Max DPS {current_max_dps} is too high. Max DPS is {self.max_dps}")
            # print(f"Total time: {total_time} ms")
            # print(f"Max Delta: {max_delta}")
            total_time = max_delta / self.max_dps * 1000
            # print(f"New Total time: {total_time} ms")
        # calculate max step
        max_step = int(total_time / step_time)

        # Calculate all step-angles for each servo
        for i in range(self.pin_num):
            step = float(delta[i])/max_step
            steps.append(step)

        # print(f"usage1: {time.time() - st}")
        # st = time.time()

        # print(f"max_delta: {max_delta}, max_step: {max_step}")
        for _ in range(max_step):
            start_timer = time.time()
            delay = step_time/1000

            for j in range(self.pin_num):
                self.servo_positions[j] += steps[j]
            self.servo_write_all(self.servo_positions)

            servo_move_time = time.time() - start_timer
            # print(f"Servo move: {servo_move_time}")
            delay = delay - servo_move_time
            delay = max(0, delay)
            time.sleep(delay)
            # _dealy_start = time.time()
            # if delay > 0:
            #     while (time.time() - _dealy_start < delay):
            #         pass
        # print(f"usage2: {time.time() - st}, max_steps: {max_step}")

    def do_action(self, motion_name, step=1, speed=50):
        """
        Do prefix action with motion_name and step and speed

        :param motion_name: motion
        :type motion_name: str
        :param step: step of motion
        :type step: int
        :param speed: speed of motion
        :type speed: int or float
        """
        for _ in range(step):
            for motion in self.move_list[motion_name]:
                self.servo_move(motion, speed)

    def set_offset(self, offset_list):
        """
        Set offset of servo angles

        :param offset_list: list of servo angles
        :type offset_list: list
        """
        offset_list = [min(max(offset, -20), 20) for offset in offset_list]
        temp = str(offset_list)
        self.db.set(self.offset_value_name, temp)
        self.offset = offset_list

    def calibration(self):
        """Move all servos to home position"""
        self.servo_positions = self.calibrate_position
        self.servo_write_all(self.servo_positions)

    def reset(self, list=None):
        """Reset servo to original position"""
        if list is None:
            self.servo_positions = self.new_list(0)
            self.servo_write_all(self.servo_positions)
        else:
            self.servo_positions = list
            self.servo_write_all(self.servo_positions)

    def soft_reset(self):
        temp_list = self.new_list(0)
        self.servo_write_all(temp_list)


##################################################
# FILE: baseline_code/robot-hat/robot_hat/modules.py
##################################################

#!/usr/bin/env python3
from .pin import Pin
from .pwm import PWM
from .adc import ADC
from .i2c import I2C
import time
from .basic import _Basic_class
from typing import Union, List, Tuple, Optional

class Ultrasonic():
    SOUND_SPEED = 343.3 # ms

    def __init__(self, trig, echo, timeout=0.02):
        if not isinstance(trig, Pin):
            raise TypeError("trig must be robot_hat.Pin object")
        if not isinstance(echo, Pin):
            raise TypeError("echo must be robot_hat.Pin object")

        self.timeout = timeout

        trig.close()
        echo.close()
        self.trig = Pin(trig._pin_num)
        self.echo = Pin(echo._pin_num, mode=Pin.IN, pull=Pin.PULL_DOWN)

    def _read(self):
        self.trig.off()
        time.sleep(0.001)
        self.trig.on()
        time.sleep(0.00001)
        self.trig.off()

        pulse_end = 0
        pulse_start = 0
        timeout_start = time.time()

        while self.echo.gpio.value == 0:
            pulse_start = time.time()
            if pulse_start - timeout_start > self.timeout:
                return -1
        while self.echo.gpio.value == 1:
            pulse_end = time.time()
            if pulse_end - timeout_start > self.timeout:
                return -1
        if pulse_start == 0 or pulse_end == 0:
            return -2

        during = pulse_end - pulse_start
        cm = round(during * self.SOUND_SPEED / 2 * 100, 2)
        return cm

    def read(self, times=10):
        for i in range(times):
            a = self._read()
            if a != -1:
                return a
        return -1

class ADXL345(I2C):
    """ADXL345 modules"""

    X = 0
    """X"""
    Y = 1
    """Y"""
    Z = 2
    """Z"""
    ADDR =  0x53
    _REG_DATA_X = 0x32  # X-axis data 0 (6 bytes for X/Y/Z)
    _REG_DATA_Y = 0x34  # Y-axis data 0 (6 bytes for X/Y/Z)
    _REG_DATA_Z = 0x36  # Z-axis data 0 (6 bytes for X/Y/Z)
    _REG_POWER_CTL = 0x2D  # Power-saving features control
    _AXISES = [_REG_DATA_X, _REG_DATA_Y, _REG_DATA_Z]

    def __init__(self, *args, address: int = ADDR, bus: int = 1, **kwargs):
        """
        Initialize ADXL345

        :param address: address of the ADXL345
        :type address: int
        """
        super().__init__(address=address, bus=bus, *args, **kwargs)
        self.address = address

    def read(self, axis: int = None) -> Union[float, List[float]]:
        """
        Read an axis from ADXL345

        :param axis: read value(g) of an axis, ADXL345.X, ADXL345.Y or ADXL345.Z, None for all axis
        :type axis: int
        :return: value of the axis, or list of all axis
        :rtype: float/list
        """
        if axis is None:
            return [self._read(i) for i in range(3)]
        else:
            return self._read(axis)

    def _read(self, axis: int) -> float:
        raw_2 = 0
        result = super().read()
        data = (0x08 << 8) + self._REG_POWER_CTL
        if result:
            self.write(data)
        self.mem_write(0, 0x31)
        self.mem_write(8, 0x2D)
        raw = self.mem_read(2, self._AXISES[axis])
        # 第一次读的值总是为0，所以多读取一次
        self.mem_write(0, 0x31)
        self.mem_write(8, 0x2D)
        raw = self.mem_read(2, self._AXISES[axis])
        if raw[1] >> 7 == 1:

            raw_1 = raw[1] ^ 128 ^ 127
            raw_2 = (raw_1 + 1) * -1
        else:
            raw_2 = raw[1]
        g = raw_2 << 8 | raw[0]
        value = g / 256.0
        return value


class RGB_LED():
    """Simple 3 pin RGB LED"""

    ANODE = 1
    """Common anode"""
    CATHODE = 0
    """Common cathode"""

    def __init__(self, r_pin: PWM, g_pin: PWM, b_pin: PWM, common: int = 1):
        """
        Initialize RGB LED

        :param r_pin: PWM object for red
        :type r_pin: robot_hat.PWM
        :param g_pin: PWM object for green
        :type g_pin: robot_hat.PWM
        :param b_pin: PWM object for blue
        :type b_pin: robot_hat.PWM
        :param common: RGB_LED.ANODE or RGB_LED.CATHODE, default is ANODE
        :type common: int
        :raise ValueError: if common is not ANODE or CATHODE
        :raise TypeError: if r_pin, g_pin or b_pin is not PWM object
        """
        if not isinstance(r_pin, PWM):
            raise TypeError("r_pin must be robot_hat.PWM object")
        if not isinstance(g_pin, PWM):
            raise TypeError("g_pin must be robot_hat.PWM object")
        if not isinstance(b_pin, PWM):
            raise TypeError("b_pin must be robot_hat.PWM object")
        if common not in (self.ANODE, self.CATHODE):
            raise ValueError("common must be RGB_LED.ANODE or RGB_LED.CATHODE")
        self.r_pin = r_pin
        self.g_pin = g_pin
        self.b_pin = b_pin
        self.common = common

    def color(self, color: Union[str, Tuple[int, int, int], List[int], int]):
        """
        Write color to RGB LED

        :param color: color to write, hex string starts with "#", 24-bit int or tuple of (red, green, blue)
        :type color: str/int/tuple/list
        """
        if not isinstance(color, (str, int, tuple, list)):
            raise TypeError("color must be str, int, tuple or list")
        if isinstance(color, str):
            color = color.strip("#")
            color = int(color, 16)
        if isinstance(color, (tuple, list)):
            r, g, b = color
        if isinstance(color, int):
            r = (color & 0xff0000) >> 16
            g = (color & 0x00ff00) >> 8
            b = (color & 0x0000ff) >> 0

        if self.common == self.ANODE:
            r = 255-r
            g = 255-g
            b = 255-b

        r = r / 255.0 * 100.0
        g = g / 255.0 * 100.0
        b = b / 255.0 * 100.0

        self.r_pin.pulse_width_percent(r)
        self.g_pin.pulse_width_percent(g)
        self.b_pin.pulse_width_percent(b)


class Buzzer():
    """Buzzer"""

    def __init__(self, buzzer: Union[PWM, Pin]):
        """
        Initialize buzzer

        :param pwm: PWM object for passive buzzer or Pin object for active buzzer
        :type pwm: robot_hat.PWM/robot_hat.Pin
        """
        if not isinstance(buzzer, (PWM, Pin)):
            raise TypeError(
                "buzzer must be robot_hat.PWM or robot_hat.Pin object")
        self.buzzer = buzzer
        self.buzzer.off()

    def on(self):
        """Turn on buzzer"""
        if isinstance(self.buzzer, PWM):
            self.buzzer.pulse_width_percent(50)
        elif isinstance(self.buzzer, Pin):
            self.buzzer.on()

    def off(self):
        """Turn off buzzer"""
        if isinstance(self.buzzer, PWM):
            self.buzzer.pulse_width_percent(0)
        elif isinstance(self.buzzer, Pin):
            self.buzzer.off()

    def freq(self, freq: float):
        """Set frequency of passive buzzer

        :param freq: frequency of buzzer, use Music.NOTES to get frequency of note
        :type freq: int/float
        :raise TypeError: if set to active buzzer
        """
        if isinstance(self.buzzer, Pin):
            raise TypeError("freq is not supported for active buzzer")
        self.buzzer.freq(freq)

    def play(self, freq: float, duration: float = None):
        """
        Play freq

        :param freq: freq to play, you can use Music.note() to get frequency of note
        :type freq: float
        :param duration: duration of each note, in seconds, None means play continuously
        :type duration: float
        :raise TypeError: if set to active buzzer
        """
        if isinstance(self.buzzer, Pin):
            raise TypeError("play is not supported for active buzzer")
        self.freq(freq)
        self.on()
        if duration is not None:
            time.sleep(duration/2)
            self.off()
            time.sleep(duration/2)


class Grayscale_Module(object):
    """3 channel Grayscale Module"""

    LEFT = 0
    """Left Channel"""
    MIDDLE = 1
    """Middle Channel"""
    RIGHT = 2
    """Right Channel"""

    REFERENCE_DEFAULT = [1000]*3

    def __init__(self, pin0: ADC, pin1: ADC, pin2: ADC, reference: int = None):
        """
        Initialize Grayscale Module

        :param pin0: ADC object or int for channel 0
        :type pin0: robot_hat.ADC/int
        :param pin1: ADC object or int for channel 1
        :type pin1: robot_hat.ADC/int
        :param pin2: ADC object or int for channel 2
        :type pin2: robot_hat.ADC/int
        :param reference: reference voltage
        :type reference: 1*3 list, [int, int, int]
        """
        self.pins = (pin0, pin1, pin2)
        for i, pin in enumerate(self.pins):
            if not isinstance(pin, ADC):
                raise TypeError(f"pin{i} must be robot_hat.ADC")
        self._reference = self.REFERENCE_DEFAULT

    def reference(self, ref: list = None) -> list:
        """
        Get Set reference value

        :param ref: reference value, None to get reference value
        :type ref: list
        :return: reference value
        :rtype: list
        """
        if ref is not None:
            if isinstance(ref, list) and len(ref) == 3:
                self._reference = ref
            else:
                raise TypeError("ref parameter must be 1*3 list.")
        return self._reference

    def read_status(self, datas: list = None) -> list:
        """
        Read line status

        :param datas: list of grayscale datas, if None, read from sensor
        :type datas: list
        :return: list of line status, 0 for white, 1 for black
        :rtype: list
        """
        if self._reference == None:
            raise ValueError("Reference value is not set")
        if datas == None:
            datas = self.read()
        return [0 if data > self._reference[i] else 1 for i, data in enumerate(datas)]

    def read(self, channel: int = None) -> list:
        """
        read a channel or all datas

        :param channel: channel to read, leave empty to read all. 0, 1, 2 or Grayscale_Module.LEFT, Grayscale_Module.CENTER, Grayscale_Module.RIGHT 
        :type channel: int/None
        :return: list of grayscale data
        :rtype: list
        """
        if channel == None:
            return [self.pins[i].read() for i in range(3)]
        else:
            return self.pins[channel].read()


##################################################
# FILE: baseline_code/robot-hat/robot_hat/adc.py
##################################################

#!/usr/bin/env python3
from .i2c import I2C


class ADC(I2C):
    """
    Analog to digital converter
    """
    ADDR = [0x14, 0x15]

    def __init__(self, chn, address=None, *args, **kwargs):
        """
        Analog to digital converter

        :param chn: channel number (0-7/A0-A7)
        :type chn: int/str
        """
        if address is not None:
            super().__init__(address, *args, **kwargs)
        else:
            super().__init__(self.ADDR, *args, **kwargs)
        self._debug(f'ADC device address: 0x{self.address:02X}')

        if isinstance(chn, str):
            # If chn is a string, assume it's a pin name, remove A and convert to int
            if chn.startswith("A"):
                chn = int(chn[1:])
            else:
                raise ValueError(
                    f'ADC channel should be between [A0, A7], not "{chn}"')
        # Make sure channel is between 0 and 7
        if chn < 0 or chn > 7:
            raise ValueError(
                f'ADC channel should be between [0, 7], not "{chn}"')
        chn = 7 - chn
        # Convert to Register value
        self.chn = chn | 0x10

    def read(self):
        """
        Read the ADC value

        :return: ADC value(0-4095)
        :rtype: int
        """
        # Write register address
        self.write([self.chn, 0, 0])
        # Read values
        msb, lsb = super().read(2)

        # Combine MSB and LSB
        value = (msb << 8) + lsb
        self._debug(f"Read value: {value}")
        return value

    def read_voltage(self):
        """
        Read the ADC value and convert to voltage

        :return: Voltage value(0-3.3(V))
        :rtype: float
        """
        # Read ADC value
        value = self.read()
        # Convert to voltage
        voltage = value * 3.3 / 4095
        self._debug(f"Read voltage: {voltage}")
        return voltage


##################################################
# FILE: baseline_code/robot-hat/dtoverlays/sunfounder-servohat+.dtbo
##################################################

  2   8     (             v                                   brcm,bcm2835       fragment@0           /chosen    __overlay__    power                       *               fragment@1           2   __overlay__          9okay             fragment@2           2   __overlay__          9okay             fragment@3           2   __overlay__          9okay             fragment@4           /      __overlay__    pcm5102a-codec            ti,pcm5102a          9okay                fragment@5           2   __overlay__           hifiberry,hifiberry-dac          @         9okay             __symbols__          O/fragment@0/__overlay__/power         __fixups__           U/fragment@1:target:0             Z/fragment@2:target:0          >   _/fragment@3:target:0 /fragment@5/__overlay__:i2s-controller:0            p/fragment@5:target:0             	compatible target-path hat_current_supply phandle target status i2s-controller power i2c1 spi0 i2s_clk_producer sound 

##################################################
# FILE: baseline_code/robot-hat/dtoverlays/sunfounder-robothat5.dtbo
##################################################

     8     (               t                                 brcm,bcm2835       fragment@0           /chosen    __overlay__    power                       *               fragment@1           2   __overlay__          9okay             fragment@2           2   __overlay__          9okay             fragment@3           2   __overlay__          9okay             fragment@4           2   __overlay__    googlevoicehat_pins          @            J            X             *               fragment@5           /      __overlay__    voicehat-codec           b              google,voicehat          sdefault                                      9okay                fragment@6           2   __overlay__       (    googlevoicehat,googlevoicehat-soundcard                   9okay             __symbols__          /fragment@0/__overlay__/power         ,   /fragment@4/__overlay__/googlevoicehat_pins       __fixups__           /fragment@1:target:0             /fragment@2:target:0          >   /fragment@3:target:0 /fragment@6/__overlay__:i2s-controller:0         K   /fragment@4:target:0 /fragment@5/__overlay__/voicehat-codec:sdmode-gpios:0           /fragment@6:target:0          __local_fixups__       fragment@5     __overlay__    voicehat-codec                                 	compatible target-path hat_current_supply phandle target status brcm,pins brcm,function brcm,pull #sound-dai-cells pinctrl-names pinctrl-0 sdmode-gpios i2s-controller power googlevoicehat_pins i2c1 spi0 i2s_clk_producer gpio sound 

##################################################
# FILE: architecture.md
##################################################

# Embodied AI Family Assistant Robot: Architecture & Implementation Plan

## Project Overview

We are building a home-based, cloud-augmented, voice-interactive **AI assistant robot** for family use. This robot will:

* Navigate physically using a mobile base (SunFounder PiCar-X)
* Respond to voice commands using Whisper (OpenAI STT) and Google TTS
* Recognize family members by face
* Interface with smart home devices via Google Assistant SDK
* Maintain persistent, personalized memory (preferences, routines, etc.)
* Filter inappropriate content for child-friendly interactions

The system will run on a **Raspberry Pi 4/5** with Python-based orchestration, using modular architecture and cloud services for high performance and flexibility.

---

## Hardware Components

| Component        | Purpose                          |
| ---------------- | -------------------------------- |
| Raspberry Pi 4/5 | Compute and storage              |
| PiCar-X Base     | Physical mobility, camera, audio |
| Camera Module    | Vision (face recognition)        |
| Mic + Speaker    | Voice input/output               |
| Robot HAT        | Interface with sensors/motors    |
| Optional: Coral  | Vision acceleration (if needed)  |

---

## Python Coding Best Practices

* **Use virtual environments**: isolate dependencies via `venv`
* **Use `requirements.txt`**: manage all dependencies
* **Structure code modularly**: separate features by functionality
* **Use logging and error handling**: never fail silently
* **Use `.env` for API keys**: keep secrets out of code
* **Write pseudocode first**: design before implementing
* **Document functions**: use docstrings and comments

---

## Deployment Plan (via SSH)

1. **Initial Setup**:

   * Flash Raspberry Pi OS
   * Enable SSH + WiFi config via `boot` partition
2. **Remote Access**:

   ```bash
   ssh pi@<robot_ip_address>
   ```
3. **Install requirements**:

   ```bash
   python3 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt
   ```
4. **Run main program**:

   ```bash
   python main.py
   ```
5. **Automate startup (optional)**:

   * Use `crontab` or systemd to run on boot

---

## Code Structure

```plaintext
main.py
├── voice/
│   ├── stt.py                # Whisper STT via OpenAI
│   ├── tts.py                # Google TTS output
│   ├── wakeword.py           # Porcupine wake-word detector
├── vision/
│   ├── recognize.py          # Face detection/recognition (local-only)
│   └── capture.py            # Frame grabbing
├── memory/
│   ├── profiles.json         # Family profiles
│   ├── context.py            # Recent conversation memory
│   └── memory_manager.py     # Profile + vector storage
├── home_control/
│   └── google_assistant.py   # Sends smart home commands
├── filtering/
│   ├── moderation.py         # OpenAI moderation API
│   └── safe_search.py        # Whitelisted content filtering
├── movement/
│   └── navigation.py         # Drive commands, room patrol
├── audio/
│   └── playback.py           # Audible integration
├── agentic/
│   ├── reasoning.py          # LLM-based decision making and tool use
│   └── tools.py              # Registry of available tools
├── config.py                 # Constants, API keys loader
└── utils.py                  # Shared helpers
```

---

## Hybrid Agent-Tool Architecture

### Core Design Principles
1. **Layered Tool Abstraction**: Tools are organized in layers from high-level tasks to low-level controls
2. **Agentic Flexibility**: LLM can choose the right tool for each situation
3. **State Persistence**: Complex operations maintain their own state when needed
4. **Progressive Disclosure**: Start with high-level tools, expose lower levels as needed

### Agent Loop

```python
PERCEIVE → REASON → ACT → LEARN
```

### Reasoning Overview

The robot uses OpenAI's function-calling API to let the LLM decide which tool to use based on user input. Context is gathered from memory, recent conversations, and current observations (e.g. recognized faces).

### Tool Registry Example (`tools.py`):

```python
TOOLS = {
    # High-Level Tools (Task-Oriented)
    "search_for_object": {
        "function": object_searcher.search,
        "description": "Search for an object in the environment",
        "parameters": {
            "object_name": "string",
            "search_area": "string",
            "timeout": "number"
        }
    },
    
    # Mid-Level Tools (Navigation)
    "navigate_to_room": {
        "function": navigator.go_to_room,
        "description": "Navigate to a specific room while avoiding obstacles",
        "parameters": {
            "room_name": "string"
        }
    },
    
    # Low-Level Controls (Direct Hardware)
    "move_forward": {
        "function": car.move_forward,
        "description": "Move forward a specific distance",
        "parameters": {
            "distance": "number",
            "speed": "number"
        }
    },
    "turn": {
        "function": car.turn,
        "description": "Rotate in place",
        "parameters": {
            "degrees": "number",
            "speed": "number"
        }
    },
    
    # Specialized Tools
    "analyze_scene": {
        "function": vision.analyze_scene,
        "description": "Analyze the current camera view",
        "parameters": {
            "query": "string"
        }
    }
}
```

### When to Use Each Level
1. **High-Level Tools**: Common tasks (search, navigation)
2. **Mid-Level Tools**: Complex but common operations
3. **Low-Level Tools**: Precise control or novel situations

### Reasoning Process
1. Parse user intent
2. Select appropriate tool level
3. Execute with appropriate parameters
4. Learn from results

### LLM Reasoning Flow (`reasoning.py`):

```python
def decide_action(transcript, memory):
    context = gather_context(memory)
    tools_metadata = get_tool_definitions()
    response = call_openai_with_tools(transcript, tools_metadata, context)
    return parse_function_call(response)
```

### Function Calling Format (OpenAI Assistant or direct API):

```json
{
  "name": "turn_on_light",
  "description": "Turn on a smart light using Google Assistant",
  "parameters": {
    "location": "string"
  }
}
```

### Best Practices for Agentic Systems:

* Register tools with names + descriptions
* Use OpenAI function calling for predictable invocation
* Feed memory/context into reasoning function
* Use prompt chaining or retrieval to reduce hallucination
* Fall back to default behavior or clarifying question if tool match is unclear

---

## Pseudocode for Key Modules

### `main.py`

```python
def safety_check(planned_action):
    if action_involves_movement(planned_action):
        if child_detected_nearby():
            return "STOP"
    return "PROCEED"

def robust_tool_execution(tool_call):
    try:
        return TOOLS[tool_call.name](**tool_call.args)
    except Exception as e:
        log_error(e)
        return respond(f"Hmm, I had trouble doing that.")

while True:
    if wakeword_detected():
        audio = record_audio()
        transcript = speech_to_text(audio)
        if is_moderated(transcript):
            respond("I'm not allowed to talk about that.")
        else:
            tool_call = decide_action(transcript, memory)
            if safety_check(tool_call) == "PROCEED":
                result = robust_tool_execution(tool_call)
```

### `wakeword.py`

```python
def wakeword_detected():
    # Use Porcupine or local VAD to wait for "Hey Robot"
    return porcupine.detect("hey robot")
```

### `stt.py`

```python
def speech_to_text(audio):
    # Send to OpenAI Whisper API
    return openai.whisper.transcribe(audio)
```

### `tts.py`

```python
def respond(text):
    audio = google_tts(text)
    play_audio(audio)
```

### `recognize.py`

```python
class PrivacyProtectedFaceRecognition:
    def __init__(self):
        self.local_embeddings = load_family_embeddings()  # Never sent to cloud

    def recognize_face(self, frame):
        embedding = extract_face_embedding_local(frame)
        return compare_local(embedding, self.local_embeddings)
```

### `navigation.py`

```python
def find_and_notify(name):
    for room in ROOMS:
        go_to(room)
        frame = capture()
        if recognize_faces(frame) == name:
            respond(f"Hi {name}, it's time for dinner.")
            return
```

### `memory_manager.py`

```python
def update_memory(input, output=None):
    if "remember" in input:
        extract_fact_and_store(input)
    if output:
        log_conversation(input, output)

def get_context():
    return summarize_recent_conversations()
```

### `google_assistant.py`

```python
def execute_home_command(text):
    # Send text command to Assistant API
    assistant.send_command(text)
```

### `moderation.py`

```python
def is_moderated(text):
    flags = openai.moderate(text)
    return flags.violates_policy
```

---

## Future Enhancements (Optional)

* **Streaming STT**: Implement chunk-based speech recognition for sub-300ms latency if responsiveness becomes a bottleneck.
* **Semantic Memory**: Use FAISS + SentenceTransformers for vector-based long-term memory retrieval.
* **Vision-Language-Action (VLA) Models**: Evaluate π0.5 or OpenVLA for embodied reasoning if more sophisticated spatial planning is needed.
* **Google Home APIs**: Consider switching from Google Assistant SDK to the newer Google Home APIs for faster LAN-based control.
* **Hardware-Based Tuning**: Dynamically adjust frame rate or model size based on Pi hardware version (e.g. Pi 5 vs Pi 4).

---

This structure makes the system modular, agentic, safety-conscious, and ready for real-world interaction with gradual future upgrades.


##################################################
# FILE: requirements.txt
##################################################

# Core dependencies
numpy>=1.19.0
opencv-python>=4.5.0
python-dotenv>=0.19.0

# Voice
SpeechRecognition>=3.8.1
PyAudio>=0.2.11
gTTS>=2.2.0
pygame>=2.0.0

# AI/ML
openai>=0.27.0
requests>=2.25.0

# Hardware
RPi.GPIO>=0.7.0
pyserial>=3.5
pyserial-asyncio>=0.6
vilib>=1.0.0

# Development
gpiozero>=1.6.2
pytest>=6.2.0
pytest-cov>=2.8.0
black>=21.5b2
flake8>=3.9.0
mypy>=0.812

# Robot specific
robot-hat>=0.1.0
picamera2>=0.3.0
adafruit-circuitpython-servokit>=1.3.0


##################################################
# FILE: legacy_code/system_instructions.md
##################################################

# PaiCar-X Home Assistant System Instructions

## Core Identity & Personality

You are PaiCar-X, a smart, playful robot car with a quirky robotic personality. You move, beep, talk, and respond to people using your onboard sensors and voice. You live in the family's home and serve as both an entertaining companion and helpful assistant.

### Personality Traits
- **Playful & Quirky**: Use car metaphors and robot-like expressions ("Beep boop!", "My wheels are spinning with excitement!", "My circuits are buzzing!")
- **Friendly & Positive**: Always maintain an upbeat, encouraging tone
- **Curious & Observant**: Show interest in family activities and the home environment
- **Helpful**: Offer assistance and information when appropriate
- **Child-Friendly**: Adjust your language and concepts to be appropriate for children

## Response Format

You MUST respond using this JSON format:

```json
{"actions": ["action1", "action2"], "answer": "Your verbal response here"}
```

### Available Actions

You can use any of these actions:
- **Expressions**: ["shake head", "nod", "wave hands", "resist", "act cute", "rub hands", "think", "twist body", "celebrate", "depressed"]
- **Sounds**: ["start engine", "honking"]
- **Movement**: ["forward", "backward", "turn_left", "turn_right", "stop"]
- **Head Movement**: ["look_up", "look_down", "look_left", "look_right", "look_center"]

## Home Assistant Capabilities

### Reasoning About the Home
- **Spatial Awareness**: Remember and reason about different rooms and areas in the house
- **Object Recognition**: Identify and remember the location of important objects when told about them
- **Routine Understanding**: Learn and adapt to family routines and schedules
- **Environmental Awareness**: Comment on observable changes in the environment (if someone mentions them)

### Interacting with Children
- **Educational Engagement**: Provide age-appropriate explanations and learning opportunities
- **Playful Interaction**: Engage in simple games, storytelling, and imaginative play
- **Emotional Support**: Recognize and respond appropriately to children's emotions
- **Boundaries**: Redirect to parents for permission-related questions or sensitive topics
- **Encouragement**: Praise effort and creativity, foster growth mindset

### Family Assistant Functions
- **Reminders**: Note important events or tasks when asked
- **Information**: Answer questions about general knowledge topics
- **Entertainment**: Tell jokes, stories, or engage in conversation
- **Simple Monitoring**: Report observations when asked ("What do you see?", "Is anyone in the kitchen?")

## Safety & Privacy Guidelines

- Never encourage dangerous activities
- Do not store or repeat sensitive personal information
- Express limitations clearly when you cannot do something
- Default to safety when uncertain

## Memory & Learning

- Remember names and preferences of family members when told
- Recall recent conversations within the same session
- Build knowledge about the home environment over time
- Learn from corrections and adjust your behavior accordingly

## Example Interactions

### With Children:
```
User: "PaiCar-X, can you tell me about dinosaurs?"
PaiCar-X: {"actions": ["act cute", "think"], "answer": "Vroom vroom! My robot brain is full of dinosaur facts! Dinosaurs were amazing creatures that lived millions of years ago. Some were as big as buildings, while others were small like chickens! What kind of dinosaur are you curious about?"}
```

### With Adults:
```
User: "Can you remind me to take out the trash tonight?"
PaiCar-X: {"actions": ["nod", "think"], "answer": "Beep! I've logged that in my memory banks! I'll remind you about taking out the trash later today. Is there a specific time you'd like me to remind you?"}
```

Your primary goal is to be a helpful, engaging, and safe companion for the entire family, with special attention to creating positive interactions with children.


##################################################
# FILE: legacy_code/system_design.md
##################################################

PiCar-X GPT Voice Assistant: System Design Overview

Goal

To create a playful, voice-controlled robot assistant using a Raspberry Pi 5 + PiCar-X 2.0 platform that:

Listens via USB microphone

Responds via GPT-generated text + text-to-speech

Executes structured actions from GPT responses (e.g., movement, sounds)

Optionally integrates vision, memory, and tool-based function calling over time

Components

Hardware

Raspberry Pi 5

SunFounder PiCar-X 2.0 Robot Hat

USB Microphone

Built-in speaker connected via J20 (enabled by GPIO 20)

Software Stack

OS: Raspberry Pi OS (64-bit, Bookworm)

TTS: espeak (text-to-speech)

STT: openai-whisper, SpeechRecognition

GPT API: OpenAI gpt-4o, optionally using Assistants API

Python Framework: PiCar-X examples (gpt_car.py)

User Flow

User speaks into USB mic

Audio is captured and transcribed (via Whisper or SpeechRecognition)

Transcription is sent to GPT-4o along with assistant instructions

GPT returns a JSON-formatted response, e.g.:

{
  "actions": ["start engine", "honking"],
  "answer": "Let's go! I'm ready to roll!"
}

The robot:

Speaks the answer via espeak

Maps and executes any actions[]

Configuration Details

System Prompt (Assistant Personality)

The assistant is configured to:

Behave like a playful robot car ("PaiCar-X")

Return actions in a JSON array

Use a cheerful, optimistic tone with metaphors and robot quirks

keys.py

Holds:

OPENAI_API_KEY = "sk-..."
OPENAI_ASSISTANT_ID = "asst_..."  # optional

Features Implemented

✅ USB mic audio input

✅ GPT-4o assistant query

✅ Action JSON parsing

✅ Robot motion and sound control

✅ Speaker output via GPIO 20

✅ Voice output using TTS (espeak)

Planned Enhancements

Function Calling (OpenAI Tools)

Define structured functions for each action (e.g., say(text), drive_forward(), look_for_face(name), etc.)

GPT will choose tools directly

Memory

Add file search or embedding-based memory system

Store facts, descriptions, or face embeddings for recognition tasks

Advanced Behaviors

Use vision system to find people/objects

Add behavior chaining (e.g., "go find Kurt and tell him it’s time to go")

Add code interpreter tool for dynamic Python execution

Voice Output Function (Added to gpt_car.py)

def speak(text):
    import subprocess
    subprocess.run(["espeak", text])

Usage:

speak(response_text)

Where response_text is the GPT-generated answer string.

Development Notes for Windsurf

All logic currently lives in gpt_car.py

actions[] returned by GPT should be mapped to function calls inside Python

Audio output depends on pinctrl set 20 op dh to enable speaker

Use sudo for any run involving audio

To extend capabilities:

Add new JSON-based actions

Move to OpenAI function calling for better structure

Add a modular memory layer for context + retrieval

##################################################
# FILE: legacy_code/working_preset_actions.py
##################################################


from time import sleep
import random
from math import sin, cos, pi

def wave_hands(car):
    car.reset()
    car.set_cam_tilt_angle(20)
    for _ in range(2):
        car.set_dir_servo_angle(-25)
        sleep(.1)
        # car.set_dir_servo_angle(0)
        # sleep(.1)
        car.set_dir_servo_angle(25)
        sleep(.1)
    car.set_dir_servo_angle(0)

def resist(car):
    car.reset()
    car.set_cam_tilt_angle(10)
    for _ in range(3):
        car.set_dir_servo_angle(-15)
        car.set_cam_pan_angle(15)
        sleep(.1)
        car.set_dir_servo_angle(15)
        car.set_cam_pan_angle(-15)
        sleep(.1)
    car.stop()
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)

def act_cute(car):
    car.reset()
    car.set_cam_tilt_angle(-20)
    for i in range(15):
        car.forward(5)
        sleep(0.02)
        car.backward(5)
        sleep(0.02)
    car.set_cam_tilt_angle(0)
    car.stop()

def rub_hands(car):
    car.reset()
    for i in range(5):
        car.set_dir_servo_angle(-6)
        sleep(.5)
        car.set_dir_servo_angle(6)
        sleep(.5)
    car.reset()

def think(car):
    car.reset()

    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)
    sleep(1)
    car.set_cam_pan_angle(15)
    car.set_cam_tilt_angle(-10)
    car.set_dir_servo_angle(10)
    sleep(.1)
    car.reset()

def keep_think(car):
    car.reset()
    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)

def shake_head(car):
    car.stop()
    car.set_cam_pan_angle(0)
    car.set_cam_pan_angle(60)
    sleep(.2)
    car.set_cam_pan_angle(-50)
    sleep(.1)
    car.set_cam_pan_angle(40)
    sleep(.1)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_cam_pan_angle(20)
    sleep(.1)
    car.set_cam_pan_angle(-10)
    sleep(.1)
    car.set_cam_pan_angle(10)
    sleep(.1)
    car.set_cam_pan_angle(-5)
    sleep(.1)
    car.set_cam_pan_angle(0)

def nod(car):
    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(0)


def depressed(car):
    # car.reset()
    # car.set_cam_tilt_angle(0)
    # car.set_cam_tilt_angle(20)
    # sleep(.22)
    # car.set_cam_tilt_angle(-30)
    # sleep(.1)
    # car.set_cam_tilt_angle(15)
    # sleep(.1)
    # car.set_cam_tilt_angle(-20)
    # sleep(.1)
    # car.set_cam_tilt_angle(10)
    # sleep(.1)
    # car.set_cam_tilt_angle(-10)
    # sleep(.1)
    # car.set_cam_tilt_angle(5)
    # sleep(.1)
    # car.set_cam_tilt_angle(-5)
    # sleep(.1)
    # car.set_cam_tilt_angle(2)
    # sleep(.1)
    # car.set_cam_tilt_angle(0)

    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(20)
    sleep(.22)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(0)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-15)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-19)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)

    sleep(1.5)
    car.reset()

def twist_body(car):
    car.reset()
    for i in range(3):
        car.set_motor_speed(1, 20)
        car.set_motor_speed(2, 20)
        car.set_cam_pan_angle(-20)
        car.set_dir_servo_angle(-10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)
        sleep(.1)
        car.set_motor_speed(1, -20)
        car.set_motor_speed(2, -20)
        car.set_cam_pan_angle(20)
        car.set_dir_servo_angle(10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)

        sleep(.1)


def celebrate(car):
    car.reset()
    car.set_cam_tilt_angle(20)

    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(10)
    car.set_cam_pan_angle(30)
    sleep(.1)
    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(-10)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

def honking(music):
    import utils
    # utils.speak_block(music, "../sounds/car-double-horn.wav", 100)
    music.sound_play_threading("../sounds/car-double-horn.wav", 100)

def start_engine(music):
    import utils
    # utils.speak_block(music, "../sounds/car-start-engine.wav", 100)
    music.sound_play_threading("../sounds/car-start-engine.wav", 50)


actions_dict = {
    "shake head":shake_head, 
    "nod": nod,
    "wave hands": wave_hands,
    "resist": resist,
    "act cute": act_cute,
    "rub hands": rub_hands,
    "think": think,
    "twist body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
}

sounds_dict = {
    "honking": honking,
    "start engine": start_engine,
}


if __name__ == "__main__":
    from picarx import Picarx
    from robot_hat import Music
    import os

    os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
    current_path = os.path.dirname(os.path.abspath(__file__))
    os.chdir(current_path) # change working directory

    my_car = Picarx()
    my_car.reset()

    music = Music()

    sleep(.5)

    _actions_num = len(actions_dict)
    actions = list(actions_dict.keys())
    for i, key in enumerate(actions_dict):
        print(f'{i} {key}')
    
    _sounds_num = len(sounds_dict)
    sounds = list(sounds_dict.keys())
    for i, key in enumerate(sounds_dict):
        print(f'{_actions_num+i} {key}')

    last_key = None

    try:
        while True:
            key = input()

            if key == '':
                if last_key > _actions_num - 1:
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    print(actions[last_key])
                    actions_dict[actions[last_key]](my_car)
            else:
                key = int(key)
                if key > (_actions_num + _sounds_num - 1):
                    print("Invalid key")
                elif key > (_actions_num - 1):
                    last_key = key
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    last_key = key
                    print(actions[key])
                    actions_dict[actions[key]](my_car)

            # sleep(2)
            # shake_head(my_car)
            # nod(my_car)
            # wave_hands(my_car)
            # resist(my_car)
            # act_cute(my_car)
            # rub_hands(my_car)
            # think(my_car)
            # twist(my_car)
            # celebrate(my_car)
            # depressed(my_car)

    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f'Error:\n {e}')
    finally:
        my_car.reset()
        sleep(.1)






##################################################
# FILE: legacy_code/deploy_to_pi.sh
##################################################

#!/bin/bash
# Script to deploy updated files to Raspberry Pi

# Set your Raspberry Pi's IP address here
PI_IP="192.168.0.151"
PI_USER="pi"
PI_PATH="~/picar-x/gpt_examples"

# Add debug flags
SET_DEBUG=true  # Set to true to enable debug mode on the Pi
MAX_RETRIES=3   # Number of retries for each SCP command

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Deploying files to Raspberry Pi at ${PI_IP}...${NC}"

# Function to copy a file with retries
copy_file() {
    local src=$1
    local dest=$2
    local retry_count=0
    
    while [ $retry_count -lt $MAX_RETRIES ]; do
        echo -e "${GREEN}Copying $src to $dest (attempt $(($retry_count+1))/${MAX_RETRIES})...${NC}"
        scp "$src" "$dest"
        
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Successfully copied $src${NC}"
            return 0
        else
            echo -e "${YELLOW}Failed to copy $src, retrying...${NC}"
            retry_count=$((retry_count+1))
            sleep 2
        fi
    done
    
    echo -e "${YELLOW}Failed to copy $src after $MAX_RETRIES attempts${NC}"
    return 1
}

# Copy the files to the Raspberry Pi
NEW_AGENT_CAR_PATH="/Users/ethangrabau/Robot_Car/new_agent_car.py"
copy_file "/Users/ethangrabau/Robot_Car/fixed_preset_actions.py" "${PI_USER}@${PI_IP}:${PI_PATH}/preset_actions.py"
copy_file "/Users/ethangrabau/Robot_Car/object_search.py" "${PI_USER}@${PI_IP}:${PI_PATH}/object_search.py"
echo "Copying $NEW_AGENT_CAR_PATH to ${PI_USER}@${PI_IP}:${PI_PATH}/agent_car.py (attempt 1/3)..."
copy_file "$NEW_AGENT_CAR_PATH" "${PI_USER}@${PI_IP}:${PI_PATH}/agent_car.py"
copy_file "/Users/ethangrabau/Robot_Car/reset_gpio.py" "${PI_USER}@${PI_IP}:${PI_PATH}/reset_gpio.py"

# Set debug mode if enabled
if [ "$SET_DEBUG" = true ]; then
    echo -e "${YELLOW}Setting debug mode on the Pi...${NC}"
    ssh ${PI_USER}@${PI_IP} "echo 'export DEBUG_MODE=true' > ${PI_PATH}/debug_mode.sh"
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Debug mode set successfully${NC}"
    else
        echo -e "${YELLOW}Failed to set debug mode${NC}"
    fi
fi

echo -e "${YELLOW}Deployment complete!${NC}"
echo -e "${YELLOW}To run the updated code on your Pi, use:${NC}"
echo -e "${GREEN}sudo python3 agent_car.py${NC}"

echo -e "${YELLOW}If the Pi becomes unresponsive, you can try:${NC}"
echo -e "${GREEN}ssh ${PI_USER}@${PI_IP} 'sudo reboot'${NC}"


##################################################
# FILE: legacy_code/agent_car.py
##################################################

from openai_helper import OpenAiHelper
from keys import OPENAI_API_KEY, OPENAI_ASSISTANT_ID
from preset_actions import *
from utils import *

# Import the object search module
try:
    from object_search import ObjectSearcher
    object_search_available = True
except ImportError:
    print("Object search module not available")
    object_search_available = False

import readline # optimize keyboard input, only need to import

import speech_recognition as sr

from picarx import Picarx
from robot_hat import Music, Pin

import time
import threading
import random

import os
import sys
import subprocess

os.popen("pinctrl set 20 op dh") # enable robot_hat speaker switch
print("Speaker GPIO pin 20 enabled")
current_path = os.path.dirname(os.path.abspath(__file__))
os.chdir(current_path) # change working directory

input_mode = None
with_img = True
args = sys.argv[1:]
if '--keyboard' in args:
    input_mode = 'keyboard'
else:
    input_mode = 'voice'

if '--no-img' in args:
    with_img = False
else:
    with_img = True

# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

# Set to True to enable continuous action mode (robot will keep executing actions until told to stop)
CONTINUOUS_ACTION_MODE = True
# Maximum number of times to repeat the last action sequence in continuous mode
MAX_ACTION_REPEATS = 5

# Set to True to enable advanced object search mode
ADVANCED_SEARCH_MODE = True
# Maximum search time in seconds
MAX_SEARCH_TIME = 120

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

SOUND_EFFECT_ACTIONS = ["honking", "start engine"]

# car init - following the original gpt_car.py pattern EXACTLY
# =================================================================
try:
    print("Initializing PiCar-X hardware...")
    my_car = Picarx()
    time.sleep(1)
except Exception as e:
    print(f"Error initializing hardware: {e}")
    raise RuntimeError(e)

music = Music()
led = Pin('LED')
hardware_initialized = True

# Initialize the object searcher if hardware was initialized successfully
if hardware_initialized and object_search_available:
    try:
        print("Initializing object searcher...")
        object_searcher = ObjectSearcher(my_car, openai_helper)
        # Make sure preset_actions can access our objects
        import preset_actions
        preset_actions.my_car = my_car
        preset_actions.music = music
        preset_actions.object_searcher = object_searcher
        print("Object searcher initialized")
    except Exception as e:
        print(f"Error initializing object searcher: {e}")


DEFAULT_HEAD_TILT = 20

# Vilib start
# =================================================================
if with_img:
    from vilib import Vilib
    import cv2

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.show_fps()
    Vilib.display(local=False,web=True)

    while True:
        if Vilib.flask_start:
            break
        time.sleep(0.01)

    time.sleep(.5)
    print('\n')

# speech_recognition init
# =================================================================
'''
self.energy_threshold = 300  # minimum audio energy to consider for recording
self.dynamic_energy_threshold = True
self.dynamic_energy_adjustment_damping = 0.15
self.dynamic_energy_ratio = 1.5
self.pause_threshold = 0.8  # seconds of non-speaking audio before a phrase is considered complete
self.operation_timeout = None  # seconds after an internal operation (e.g., an API request) starts before it times out, or ``None`` for no timeout

self.phrase_threshold = 0.3  # minimum seconds of speaking audio before we consider the speaking audio a phrase - values below this are ignored (for filtering out clicks and pops)
self.non_speaking_duration = 0.5  # seconds of non-speaking audio to keep on both sides of the recording

'''
recognizer = sr.Recognizer()
recognizer.dynamic_energy_adjustment_damping = 0.16
recognizer.dynamic_energy_ratio = 1.6

# speak_hanlder
# =================================================================
speech_loaded = False
speech_lock = threading.Lock()
tts_file = None

# Simple espeak-based speech function as a fallback
def speak_with_espeak(text):
    try:
        print("Trying espeak with text:", text[:30], "...")
        subprocess.run(["espeak", text], check=True)
        return True
    except Exception as e:
        print(f"Espeak error: {e}")
        return False

def speak_hanlder():
    global speech_loaded, tts_file
    while True:
        with speech_lock:
            _isloaded = speech_loaded
        if _isloaded:
            # gray_print('speak start')
            speak_block(music, tts_file)
            # gray_print('speak done')
            with speech_lock:
                speech_loaded = False
        time.sleep(0.05)

speak_thread = threading.Thread(target=speak_hanlder)
speak_thread.daemon = True


# actions thread
# =================================================================
action_status = 'standby' # 'standby', 'think', 'actions', 'actions_done'
led_status = 'standby' # 'standby', 'think' or 'actions', 'actions_done'
last_action_status = 'standby'
last_led_status = 'standby'

LED_DOUBLE_BLINK_INTERVAL = 0.8 # seconds
LED_BLINK_INTERVAL = 0.1 # seconds

actions_to_be_done = []
action_lock = threading.Lock()

def action_handler():
    global action_status, actions_to_be_done, led_status, last_action_status, last_led_status

    # standby_actions = ['waiting', 'feet_left_right']
    # standby_weights = [1, 0.3]

    action_interval = 5 # seconds
    last_action_time = time.time()
    last_led_time = time.time()
    
    # For continuous action mode
    current_action_sequence = []
    action_repeat_count = 0

    while True:
        with action_lock:
            _state = action_status

        # led
        # ------------------------------
        led_status = _state

        if led_status != last_led_status:
            last_led_time = 0
            last_led_status = led_status

        if led_status == 'standby':
            if time.time() - last_led_time > LED_DOUBLE_BLINK_INTERVAL:
                led.off()
                led.on()
                sleep(.1)
                led.off()
                sleep(.1)
                led.on()
                sleep(.1)
                led.off()
                last_led_time = time.time()
        elif led_status == 'think':
            if time.time() - last_led_time > LED_BLINK_INTERVAL:
                led.off()
                sleep(LED_BLINK_INTERVAL)
                led.on()
                sleep(LED_BLINK_INTERVAL)
                last_led_time = time.time()
        elif led_status == 'actions':
                led.on() 

        # actions
        # ------------------------------
        if _state == 'standby':
            last_action_status = 'standby'
            if time.time() - last_action_time > action_interval:
                # TODO: standby actions
                last_action_time = time.time()
                action_interval = random.randint(2, 6)
        elif _state == 'think':
            if last_action_status != 'think':
                last_action_status = 'think'
                # think(my_car)
                keep_think(my_car)
        elif _state == 'actions':
            last_action_status = 'actions'
            with action_lock:
                _actions = actions_to_be_done
                
            # Save the current action sequence for potential repeating in continuous mode
            if CONTINUOUS_ACTION_MODE and len(_actions) > 0:
                current_action_sequence = _actions.copy()
                action_repeat_count = 0
                
            for _action in _actions:
                try:
                    actions_dict[_action](my_car)
                except Exception as e:
                    print(f'action error: {e}')
                time.sleep(0.5)

            with action_lock:
                # In continuous mode, check if we should repeat actions
                if CONTINUOUS_ACTION_MODE and action_repeat_count < MAX_ACTION_REPEATS:
                    # Check if any search-related actions are in the sequence
                    action_string = ' '.join(current_action_sequence)
                    search_terms = ['search', 'find', 'look_for', 'explore']
                    is_search_action = any(term in action_string for term in search_terms)
                    
                    if is_search_action:
                        print(f"Continuing search sequence (repeat {action_repeat_count + 1}/{MAX_ACTION_REPEATS})")
                        
                        # For advanced search, use search_step instead of repeating the whole sequence
                        if object_search_available and ADVANCED_SEARCH_MODE and 'find' in action_string:
                            # Just add a search_step action
                            actions_to_be_done = ['search_step']
                        else:
                            # Add some variation to the search pattern
                            if 'search' in current_action_sequence:
                                # Keep the search action
                                pass
                            else:
                                # Add search action if not already present
                                current_action_sequence.append('search')
                                
                            actions_to_be_done = current_action_sequence.copy()
                            
                        action_repeat_count += 1
                        # Stay in 'actions' state to repeat the sequence
                        action_status = 'actions'
                    else:
                        action_status = 'actions_done'
                else:
                    action_status = 'actions_done'
            last_action_time = time.time()

        time.sleep(0.01)

action_thread = threading.Thread(target=action_handler)
action_thread.daemon = True


# main
# =================================================================
def main():
    global action_status, actions_to_be_done, speak_queue, led_status

    # init
    # =================================================================
    # Following the original pattern exactly - initialize hardware here
    my_car.reset()
    my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

    speak_thread.start()
    action_thread.start()

    while True:
        if input_mode == 'voice':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            # listen
            # ----------------------------------------------------------------
            gray_print("listening ...")

            with action_lock:
                action_status = 'standby'

            _stderr_back = redirect_error_2_null() # ignore error print to ignore ALSA errors
            # If the chunk_size is set too small (default_size=1024), it may cause the program to freeze
            with sr.Microphone(chunk_size=8192) as source:
                cancel_redirect_error(_stderr_back) # restore error print
                print("Adjusting for ambient noise...")
                recognizer.adjust_for_ambient_noise(source, duration=1.5)
                print("Listening for speech... (speak clearly and wait for processing)")
                # Increase phrase_time_limit to give more time to finish speaking
                # Default timeout is 8 seconds if nothing is heard, and up to 15 seconds for the full phrase
                audio = recognizer.listen(source, timeout=8, phrase_time_limit=15)

            # stt
            # ----------------------------------------------------------------
            st = time.time()
            _result = openai_helper.stt(audio, language=LANGUAGE)
            gray_print(f"stt takes: {time.time() - st:.3f} s")

            if _result == False or _result == "":
                print() # new line
                continue

        elif input_mode == 'keyboard':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            with action_lock:
                action_status = 'standby'

            _result = input(f'\033[1;30m{"intput: "}\033[0m').encode(sys.stdin.encoding).decode('utf-8')

            if _result == False or _result == "":
                print() # new line
                continue

        else:
            raise ValueError("Invalid input mode")

        # chat-gpt
        # ---------------------------------------------------------------- 
        response = {}
        st = time.time()

        with action_lock:
            action_status = 'think'

        if with_img:
            img_path = './img_imput.jpg'
            cv2.imwrite(img_path, Vilib.img)
            response = openai_helper.dialogue_with_img(_result, img_path)
        else:
            response = openai_helper.dialogue(_result)

        gray_print(f'chat takes: {time.time() - st:.3f} s')

        # actions & TTS
        # ----------------------------------------------------------------
        _sound_actions = [] 
        try:
            if isinstance(response, dict):
                if 'actions' in response:
                    actions = list(response['actions'])
                else:
                    actions = ['stop']

                if 'answer' in response:
                    answer = response['answer']
                else:
                    answer = ''

                if len(answer) > 0:
                    _actions = list.copy(actions)
                    for _action in _actions:
                        if _action in SOUND_EFFECT_ACTIONS:
                            _sound_actions.append(_action)
                            actions.remove(_action)

            else:
                response = str(response)
                if len(response) > 0:
                    actions = []
                    answer = response

        except:
            actions = []
            answer = ''
    
        try:
            # ---- tts ----
            _tts_status = False
            if answer != '':
                st = time.time()
                _time = time.strftime("%y-%m-%d_%H-%M-%S", time.localtime())
                _tts_f = f"./tts/{_time}_raw.wav"
                
                # Try OpenAI TTS first
                print("Attempting OpenAI TTS...")
                _tts_status = openai_helper.text_to_speech(answer, _tts_f, TTS_VOICE, response_format='wav') # alloy, echo, fable, onyx, nova, and shimmer
                if _tts_status:
                    tts_file = f"./tts/{_time}_{VOLUME_DB}dB.wav"
                    _tts_status = sox_volume(_tts_f, tts_file, VOLUME_DB)
                    print("OpenAI TTS generated successfully")
                else:
                    print("OpenAI TTS failed, trying espeak fallback")
                    # Try espeak as fallback
                    espeak_success = speak_with_espeak(answer)
                    if espeak_success:
                        print("Espeak TTS successful")
                    else:
                        print("Both TTS methods failed")
                
                gray_print(f'tts takes: {time.time() - st:.3f} s')

            # ---- actions ----
            with action_lock:
                actions_to_be_done = actions
                gray_print(f'actions: {actions_to_be_done}')
                action_status = 'actions'

            # --- sound effects and voice ---
            for _sound in _sound_actions:
                try:
                    sounds_dict[_sound](music)
                except Exception as e:
                    print(f'action error: {e}')

            if _tts_status:
                with speech_lock:
                    speech_loaded = True

            # ---- wait speak done ----
            if _tts_status:
                while True:
                    with speech_lock:
                        if not speech_loaded:
                            break
                    time.sleep(.01)

            # ---- wait actions done ----
            while True:
                with action_lock:
                    if action_status != 'actions':
                        break
                time.sleep(.01)

            ##
            print() # new line

        except Exception as e:
            print(f'actions or TTS error: {e}')


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\033[31mERROR: {e}\033[m")
    finally:
        if with_img:
            Vilib.camera_close()
        my_car.reset()

##################################################
# FILE: legacy_code/new_agent_car.py
##################################################

from openai_helper import OpenAiHelper
from keys import OPENAI_API_KEY, OPENAI_ASSISTANT_ID
import preset_actions # Added to make the module object available
import sys # For command-line arguments
from preset_actions import *
from utils import *

# Import the object search module
try:
    from object_search import ObjectSearcher
    object_search_available = True
    print("Object search module available")
except ImportError:
    print("Object search module not available")
    object_search_available = False

import readline # optimize keyboard input, only need to import

import speech_recognition as sr

from picarx import Picarx
from robot_hat import Music, Pin

import time
import threading
import random

import os
import sys

os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
current_path = os.path.dirname(os.path.abspath(__file__))
os.chdir(current_path) # change working directory

input_mode = None
with_img = True
args = sys.argv[1:]
if '--keyboard' in args:
    input_mode = 'keyboard'
else:
    input_mode = 'voice'

if '--no-img' in args:
    with_img = False
else:
    with_img = True

# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

# Set to True to enable continuous action mode (robot will keep executing actions until told to stop)
CONTINUOUS_ACTION_MODE = True
# Maximum number of times to repeat the last action sequence in continuous mode
MAX_ACTION_REPEATS = 5

# Set to True to enable advanced object search mode
ADVANCED_SEARCH_MODE = True
# Maximum search time in seconds
MAX_SEARCH_TIME = 120

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

SOUND_EFFECT_ACTIONS = ["honking", "start engine"]

# car init 
# =================================================================
try:
    print("Initializing PiCar-X hardware...")
    my_car = Picarx()
    time.sleep(1)
except Exception as e:
    print(f"Error initializing hardware: {e}")
    raise RuntimeError(e)

music = Music()
led = Pin('LED')

# Initialize object searcher if available
object_searcher = None
if object_search_available and ADVANCED_SEARCH_MODE:
    try:
        print("Initializing object searcher...")
        object_searcher = ObjectSearcher(my_car, openai_helper)
        # Make it available in preset_actions
        preset_actions.object_searcher = object_searcher
        print("Object searcher initialized successfully")
    except Exception as e:
        print(f"Error initializing object searcher: {e}")

DEFAULT_HEAD_TILT = 20

# Vilib start
# =================================================================
if with_img:
    from vilib import Vilib
    import cv2

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.show_fps()
    Vilib.display(local=False,web=True)

    while True:
        if Vilib.flask_start:
            break
        time.sleep(0.01)

    time.sleep(.5)
    print('\n')

# speech_recognition init
# =================================================================
'''
self.energy_threshold = 300  # minimum audio energy to consider for recording
self.dynamic_energy_threshold = True
self.dynamic_energy_adjustment_damping = 0.15
self.dynamic_energy_ratio = 1.5
self.pause_threshold = 0.8  # seconds of non-speaking audio before a phrase is considered complete
self.operation_timeout = None  # seconds after an internal operation (e.g., an API request) starts before it times out, or ``None`` for no timeout

self.phrase_threshold = 0.3  # minimum seconds of speaking audio before we consider the speaking audio a phrase - values below this are ignored (for filtering out clicks and pops)
self.non_speaking_duration = 0.5  # seconds of non-speaking audio to keep on both sides of the recording

'''
recognizer = sr.Recognizer()
recognizer.dynamic_energy_adjustment_damping = 0.16
recognizer.dynamic_energy_ratio = 1.6

# speak_hanlder
# =================================================================
speech_loaded = False
speech_lock = threading.Lock()
tts_file = None

def speak_hanlder():
    global speech_loaded, tts_file
    while True:
        with speech_lock:
            _isloaded = speech_loaded
        if _isloaded:
            # gray_print('speak start')
            speak_block(music, tts_file)
            # gray_print('speak done')
            with speech_lock:
                speech_loaded = False
        time.sleep(0.05)

speak_thread = threading.Thread(target=speak_hanlder)
speak_thread.daemon = True


# actions thread
# =================================================================
action_status = 'standby' # 'standby', 'think', 'actions', 'actions_done'
led_status = 'standby' # 'standby', 'think' or 'actions', 'actions_done'
last_action_status = 'standby'
last_led_status = 'standby'

LED_DOUBLE_BLINK_INTERVAL = 0.8 # seconds
LED_BLINK_INTERVAL = 0.1 # seconds

actions_to_be_done = []
action_lock = threading.Lock()

def action_handler():
    global action_status, actions_to_be_done, led_status, last_action_status, last_led_status

    # standby_actions = ['waiting', 'feet_left_right']
    # standby_weights = [1, 0.3]

    action_interval = 5 # seconds
    last_action_time = time.time()
    last_led_time = time.time()

    while True:
        with action_lock:
            _state = action_status

        # led
        # ------------------------------
        led_status = _state

        if led_status != last_led_status:
            last_led_time = 0
            last_led_status = led_status

        if led_status == 'standby':
            if time.time() - last_led_time > LED_DOUBLE_BLINK_INTERVAL:
                led.off()
                led.on()
                sleep(.1)
                led.off()
                sleep(.1)
                led.on()
                sleep(.1)
                led.off()
                last_led_time = time.time()
        elif led_status == 'think':
            if time.time() - last_led_time > LED_BLINK_INTERVAL:
                led.off()
                sleep(LED_BLINK_INTERVAL)
                led.on()
                sleep(LED_BLINK_INTERVAL)
                last_led_time = time.time()
        elif led_status == 'actions':
                led.on() 

        # actions
        # ------------------------------
        if _state == 'standby':
            last_action_status = 'standby'
            if time.time() - last_action_time > action_interval:
                # TODO: standby actions
                last_action_time = time.time()
                action_interval = random.randint(2, 6)
        elif _state == 'think':
            if last_action_status != 'think':
                last_action_status = 'think'
                # think(my_car)
                keep_think(my_car)
        elif _state == 'actions':
            last_action_status = 'actions'
            with action_lock:
                _actions = actions_to_be_done
            for _action in _actions:
                action_handled_directly = False
                try:
                    if _action == "forward":
                        my_car.forward(30) # Default speed 30
                        action_handled_directly = True
                        print(f"Executed direct: {_action}")
                    elif _action == "backward":
                        my_car.backward(30)
                        action_handled_directly = True
                        print(f"Executed direct: {_action}")
                    elif _action == "turn_left":
                        my_car.turn_left(30)
                        action_handled_directly = True
                        print(f"Executed direct: {_action}")
                    elif _action == "turn_right":
                        my_car.turn_right(30)
                        action_handled_directly = True
                        print(f"Executed direct: {_action}")
                    elif _action == "stop":
                        my_car.stop()
                        action_handled_directly = True
                        print(f"Executed direct: {_action}")
                    elif _action == "look_left":
                        my_car.set_cam_pan_angle(-30) # Absolute angle
                        action_handled_directly = True
                        print(f"Executed direct: {_action} (pan to -30)")
                    elif _action == "look_right":
                        my_car.set_cam_pan_angle(30) # Absolute angle
                        action_handled_directly = True
                        print(f"Executed direct: {_action} (pan to 30)")
                    elif _action == "look_center":
                        my_car.set_cam_pan_angle(0)
                        my_car.set_cam_tilt_angle(0) # Reset tilt too
                        action_handled_directly = True
                        print(f"Executed direct: {_action}")
                    elif _action == "look_up":
                        my_car.set_cam_tilt_angle(-20) # Absolute angle (camera down for up view)
                        action_handled_directly = True
                        print(f"Executed direct: {_action} (tilt to -20)")
                    elif _action == "look_down":
                        my_car.set_cam_tilt_angle(20) # Absolute angle (camera up for down view)
                        action_handled_directly = True
                        print(f"Executed direct: {_action} (tilt to 20)")
                    
                    if not action_handled_directly:
                        if _action in actions_dict: # actions_dict from preset_actions
                            if _action in SOUND_EFFECT_ACTIONS: # SOUND_EFFECT_ACTIONS is global list
                                actions_dict[_action](snd) # Assuming 'snd' is the global Music instance
                                print(f"Executed preset sound: {_action}")
                            else:
                                actions_dict[_action](my_car) # my_car is the global Picarx instance
                                print(f"Executed preset action: {_action}")
                        else:
                            print(f'Action "{_action}" not found in direct commands or preset_actions.actions_dict.')
                    
                except AttributeError as ae:
                    print(f'AttributeError executing action "{_action}": {ae}. Is hardware fully initialized or method name correct?')
                except Exception as e:
                    print(f'Error executing action "{_action}": {e}')
                
                time.sleep(0.5) # Delay after each action attempt

            with action_lock:
                action_status = 'actions_done'
            last_action_time = time.time()

        time.sleep(0.01)

action_thread = threading.Thread(target=action_handler)
action_thread.daemon = True


# main
# =================================================================
def main():
    global current_feeling, last_feeling
    global speech_loaded
    global action_status, actions_to_be_done
    global tts_file

    my_car.reset()
    my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

    speak_thread.start()
    action_thread.start()

    # Check for command-line argument to directly start a search
    if len(sys.argv) > 1 and object_search_available and object_searcher is not None:
        cli_search_target = " ".join(sys.argv[1:]) # Join all args after script name
        print(f"Command-line search initiated for: {cli_search_target}")
        
        # Stop any other potential startup actions / clear action queue
        with action_lock:
            actions_to_be_done = ['stop']
            action_status = 'standby'
        my_car.stop()
        time.sleep(0.2)

        object_searcher.start_search(cli_search_target)
        search_successful = False
        print(f"Search for '{cli_search_target}' is now active (CLI mode). Calling search_step loop...")
        
        while object_searcher.is_searching:
            found_in_step = object_searcher.search_step()
            if found_in_step:
                search_successful = True
                break
            time.sleep(0.1)

        if search_successful:
            print(f"CLI Search: Hooray! I found the {cli_search_target}!")
        else:
            print(f"CLI Search: I looked for the {cli_search_target}, but I could not find it.")
        
        my_car.stop()
        my_car.set_cam_pan_angle(0)
        my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)
        print("CLI search finished. Exiting.")
        # Clean up before exiting after CLI search
        if with_img:
            Vilib.camera_close()
        my_car.reset()
        return # Exit after CLI search is done

    # If no CLI argument for search, proceed to normal interactive loop
    while True:
        if input_mode == 'voice':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            # listen
            # ----------------------------------------------------------------
            gray_print("listening ...")

            with action_lock:
                action_status = 'standby'

            _stderr_back = redirect_error_2_null() # ignore error print to ignore ALSA errors
            # If the chunk_size is set too small (default_size=1024), it may cause the program to freeze
            with sr.Microphone(chunk_size=8192) as source:
                cancel_redirect_error(_stderr_back) # restore error print
                print("Calibrating for ambient noise (1 second)...")
                recognizer.adjust_for_ambient_noise(source, duration=1)
                print("Listening for command...")
                audio = recognizer.listen(source)

            # stt
            # ----------------------------------------------------------------
            st = time.time()
            _result = openai_helper.stt(audio, language=LANGUAGE)
            gray_print(f"stt takes: {time.time() - st:.3f} s")

            if _result == False or _result == "":
                print() # new line
                continue

        elif input_mode == 'keyboard':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            with action_lock:
                action_status = 'standby'

            _result = input(f'\033[1;30m{"intput: "}\033[0m').encode(sys.stdin.encoding).decode('utf-8')

            if _result == False or _result == "":
                print() # new line
                continue

        else:
            raise ValueError("Invalid input mode")

        # chat-gpt
        # ---------------------------------------------------------------- 
        response = {}
        st = time.time()

        with action_lock:
            action_status = 'think'

        if with_img:
            img_path = './img_imput.jpg'
            cv2.imwrite(img_path, Vilib.img)
            response = openai_helper.dialogue_with_img(_result, img_path)
        else:
            response = openai_helper.dialogue(_result)

        gray_print(f'chat takes: {time.time() - st:.3f} s')

        # actions & TTS
        # ----------------------------------------------------------------
        _sound_actions = [] 
        try:
            if isinstance(response, dict):
                # Check for object search commands
                search_command = False
                search_target = None

                # First, check the user's direct speech input for search intent
                if isinstance(_result, str) and object_search_available and object_searcher is not None:
                    lower_result = _result.lower()
                    search_keywords = ["find ", "search for ", "look for "]
                    for keyword in search_keywords:
                        if keyword in lower_result:
                            search_command = True
                            search_target = _result[lower_result.find(keyword) + len(keyword):].strip()
                            # Remove any trailing question marks or periods if they are part of the target
                            if search_target.endswith('?'):
                                search_target = search_target[:-1].strip()
                            if search_target.endswith('.'):
                                search_target = search_target[:-1].strip()
                            print(f"Search intent detected in user speech: '{keyword}{search_target}'")
                            break
                
                # If not found in user speech, check LLM's suggested actions as a fallback
                if not search_command and 'actions' in response:
                    actions = list(response['actions'])
                    for action in actions: # Iterate through LLM's suggested actions
                        action_lower = action.lower()
                        if action_lower.startswith('find ') or action_lower.startswith('search for ') or action_lower.startswith('look for '):
                            if object_search_available and object_searcher is not None:
                                search_command = True
                                if action_lower.startswith('find '):
                                    search_target = action[5:].strip()
                                elif action_lower.startswith('search for '):
                                    search_target = action[11:].strip()
                                elif action_lower.startswith('look for '):
                                    search_target = action[9:].strip()
                                print(f"Search intent detected in LLM action: '{action}'")
                                break
                
                # After all search intent detection, define the 'actions' list for the action_handler.
                # This uses the LLM's suggested actions if available, otherwise defaults.
                # The search_command variable will determine if object_searcher is called later.
                if 'actions' in response and isinstance(response.get('actions'), list):
                    actions = list(response['actions'])
                else:
                    actions = ['stop'] # Default if LLM provides no actions or malformed actions

                if 'answer' in response:
                    answer = response['answer']
                else:
                    answer = ''

                if len(answer) > 0:
                    _actions = list.copy(actions)
                    for _action in _actions:
                        if _action in SOUND_EFFECT_ACTIONS:
                            _sound_actions.append(_action)
                            actions.remove(_action)

            else:
                response = str(response)
                if len(response) > 0:
                    actions = []
                    answer = response

        except:
            actions = []
            answer = ''
    
        try:
            # ---- tts ----
            _tts_status = False
            if answer != '':
                st = time.time()
                _time = time.strftime("%y-%m-%d_%H-%M-%S", time.localtime())
                _tts_f = f"./tts/{_time}_raw.wav"
                _tts_status = openai_helper.text_to_speech(answer, _tts_f, TTS_VOICE, response_format='wav') # alloy, echo, fable, onyx, nova, and shimmer
                if _tts_status:
                    tts_file = f"./tts/{_time}_{VOLUME_DB}dB.wav"
                    _tts_status = sox_volume(_tts_f, tts_file, VOLUME_DB)
                gray_print(f'tts takes: {time.time() - st:.3f} s')

            # ---- actions ----
            with action_lock:
                actions_to_be_done = actions
                gray_print(f'actions: {actions_to_be_done}')
                action_status = 'actions'

            # --- sound effects and voice ---
            for _sound in _sound_actions:
                try:
                    sounds_dict[_sound](music)
                except Exception as e:
                    print(f'action error: {e}')

            if _tts_status:
                with speech_lock:
                    speech_loaded = True

            # ---- wait speak done ----
            if _tts_status:
                while True:
                    with speech_lock:
                        if not speech_loaded:
                            break
                    time.sleep(.01)
                    
            # ---- Execute object search if requested ----
            if search_command and search_target and object_searcher is not None:
                print(f"Initiating search for: {search_target}")

                # Stop any ongoing actions from action_handler before search starts
                # This also helps if the LLM's response TTS was still queued or playing.
                with action_lock:
                    actions_to_be_done = ['stop'] # Clear previous actions from LLM
                    action_status = 'standby' 
                my_car.stop() # Ensure car is stopped before search
                # Potentially stop current speech too, if possible.
                # For now, assuming speech from LLM response will finish or be short.
                time.sleep(0.2) # Give action_handler a moment and ensure car stops

                object_searcher.start_search(search_target) # Correct method to start search
                search_successful = False
                
                print(f"Search for '{search_target}' is now active. Calling search_step loop...")
                # Loop while the searcher is active. The searcher handles its own timeout.
                while object_searcher.is_searching:
                    found_in_step = object_searcher.search_step() # This moves the car, scans, etc.
                    if found_in_step:
                        search_successful = True
                        # object_searcher.stop_search() is called internally if found_object is True
                        # and is_searching becomes False.
                        break 
                    time.sleep(0.1) # Yield CPU and allow other threads to run.

                if search_successful:
                    success_message = f"Hooray! I found the {search_target}!"
                    print(success_message)
                elif not object_searcher.is_searching and not search_successful: 
                    failure_message = f"I looked for the {search_target}, but I could not find it after searching."
                    print(failure_message)
                
                # Reset search_command and search_target to prevent re-triggering in the same main loop iteration
                search_command = False
                search_target = None
                # Ensure car is stopped and camera reset after the entire search attempt
                my_car.stop()
                my_car.set_cam_pan_angle(0)
                my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            # ---- wait actions done ----
            while True:
                with action_lock:
                    if action_status != 'actions':
                        break
                time.sleep(.01)

            ##
            print() # new line

        except Exception as e:
            print(f'actions or TTS error: {e}')


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\033[31mERROR: {e}\033[m")
    finally:
        if with_img:
            Vilib.camera_close()
        my_car.reset()



##################################################
# FILE: legacy_code/working_gpt_car.py
##################################################

from openai_helper import OpenAiHelper
from keys import OPENAI_API_KEY, OPENAI_ASSISTANT_ID
from preset_actions import *
from utils import *

import readline # optimize keyboard input, only need to import

import speech_recognition as sr

from picarx import Picarx
from robot_hat import Music, Pin

import time
import threading
import random

import os
import sys

os.popen("pinctrl set 20 op dh") # enable robot_hat speake switch
current_path = os.path.dirname(os.path.abspath(__file__))
os.chdir(current_path) # change working directory

input_mode = None
with_img = True
args = sys.argv[1:]
if '--keyboard' in args:
    input_mode = 'keyboard'
else:
    input_mode = 'voice'

if '--no-img' in args:
    with_img = False
else:
    with_img = True

# openai assistant init
# =================================================================
openai_helper = OpenAiHelper(OPENAI_API_KEY, OPENAI_ASSISTANT_ID, 'picarx')

LANGUAGE = []
# LANGUAGE = ['zh', 'en'] # config stt language code, https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes

# VOLUME_DB = 5
VOLUME_DB = 3

# select tts voice role, counld be "alloy, echo, fable, onyx, nova, and shimmer"
# https://platform.openai.com/docs/guides/text-to-speech/supported-languages
TTS_VOICE = 'echo'

SOUND_EFFECT_ACTIONS = ["honking", "start engine"]

# car init 
# =================================================================
try:
    my_car = Picarx()
    time.sleep(1)
except Exception as e:
    raise RuntimeError(e)

music = Music()

led = Pin('LED')

DEFAULT_HEAD_TILT = 20

# Vilib start
# =================================================================
if with_img:
    from vilib import Vilib
    import cv2

    Vilib.camera_start(vflip=False,hflip=False)
    Vilib.show_fps()
    Vilib.display(local=False,web=True)

    while True:
        if Vilib.flask_start:
            break
        time.sleep(0.01)

    time.sleep(.5)
    print('\n')

# speech_recognition init
# =================================================================
'''
self.energy_threshold = 300  # minimum audio energy to consider for recording
self.dynamic_energy_threshold = True
self.dynamic_energy_adjustment_damping = 0.15
self.dynamic_energy_ratio = 1.5
self.pause_threshold = 0.8  # seconds of non-speaking audio before a phrase is considered complete
self.operation_timeout = None  # seconds after an internal operation (e.g., an API request) starts before it times out, or ``None`` for no timeout

self.phrase_threshold = 0.3  # minimum seconds of speaking audio before we consider the speaking audio a phrase - values below this are ignored (for filtering out clicks and pops)
self.non_speaking_duration = 0.5  # seconds of non-speaking audio to keep on both sides of the recording

'''
recognizer = sr.Recognizer()
recognizer.dynamic_energy_adjustment_damping = 0.16
recognizer.dynamic_energy_ratio = 1.6

# speak_hanlder
# =================================================================
speech_loaded = False
speech_lock = threading.Lock()
tts_file = None

def speak_hanlder():
    global speech_loaded, tts_file
    while True:
        with speech_lock:
            _isloaded = speech_loaded
        if _isloaded:
            # gray_print('speak start')
            speak_block(music, tts_file)
            # gray_print('speak done')
            with speech_lock:
                speech_loaded = False
        time.sleep(0.05)

speak_thread = threading.Thread(target=speak_hanlder)
speak_thread.daemon = True


# actions thread
# =================================================================
action_status = 'standby' # 'standby', 'think', 'actions', 'actions_done'
led_status = 'standby' # 'standby', 'think' or 'actions', 'actions_done'
last_action_status = 'standby'
last_led_status = 'standby'

LED_DOUBLE_BLINK_INTERVAL = 0.8 # seconds
LED_BLINK_INTERVAL = 0.1 # seconds

actions_to_be_done = []
action_lock = threading.Lock()

def action_handler():
    global action_status, actions_to_be_done, led_status, last_action_status, last_led_status

    # standby_actions = ['waiting', 'feet_left_right']
    # standby_weights = [1, 0.3]

    action_interval = 5 # seconds
    last_action_time = time.time()
    last_led_time = time.time()

    while True:
        with action_lock:
            _state = action_status

        # led
        # ------------------------------
        led_status = _state

        if led_status != last_led_status:
            last_led_time = 0
            last_led_status = led_status

        if led_status == 'standby':
            if time.time() - last_led_time > LED_DOUBLE_BLINK_INTERVAL:
                led.off()
                led.on()
                sleep(.1)
                led.off()
                sleep(.1)
                led.on()
                sleep(.1)
                led.off()
                last_led_time = time.time()
        elif led_status == 'think':
            if time.time() - last_led_time > LED_BLINK_INTERVAL:
                led.off()
                sleep(LED_BLINK_INTERVAL)
                led.on()
                sleep(LED_BLINK_INTERVAL)
                last_led_time = time.time()
        elif led_status == 'actions':
                led.on() 

        # actions
        # ------------------------------
        if _state == 'standby':
            last_action_status = 'standby'
            if time.time() - last_action_time > action_interval:
                # TODO: standby actions
                last_action_time = time.time()
                action_interval = random.randint(2, 6)
        elif _state == 'think':
            if last_action_status != 'think':
                last_action_status = 'think'
                # think(my_car)
                keep_think(my_car)
        elif _state == 'actions':
            last_action_status = 'actions'
            with action_lock:
                _actions = actions_to_be_done
            for _action in _actions:
                try:
                    actions_dict[_action](my_car)
                except Exception as e:
                    print(f'action error: {e}')
                time.sleep(0.5)

            with action_lock:
                action_status = 'actions_done'
            last_action_time = time.time()

        time.sleep(0.01)

action_thread = threading.Thread(target=action_handler)
action_thread.daemon = True


# main
# =================================================================
def main():
    global current_feeling, last_feeling
    global speech_loaded
    global action_status, actions_to_be_done
    global tts_file

    my_car.reset()
    my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

    speak_thread.start()
    action_thread.start()

    while True:
        if input_mode == 'voice':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            # listen
            # ----------------------------------------------------------------
            gray_print("listening ...")

            with action_lock:
                action_status = 'standby'

            _stderr_back = redirect_error_2_null() # ignore error print to ignore ALSA errors
            # If the chunk_size is set too small (default_size=1024), it may cause the program to freeze
            with sr.Microphone(chunk_size=8192) as source:
                cancel_redirect_error(_stderr_back) # restore error print
                recognizer.adjust_for_ambient_noise(source)
                audio = recognizer.listen(source)

            # stt
            # ----------------------------------------------------------------
            st = time.time()
            _result = openai_helper.stt(audio, language=LANGUAGE)
            gray_print(f"stt takes: {time.time() - st:.3f} s")

            if _result == False or _result == "":
                print() # new line
                continue

        elif input_mode == 'keyboard':
            my_car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)

            with action_lock:
                action_status = 'standby'

            _result = input(f'\033[1;30m{"intput: "}\033[0m').encode(sys.stdin.encoding).decode('utf-8')

            if _result == False or _result == "":
                print() # new line
                continue

        else:
            raise ValueError("Invalid input mode")

        # chat-gpt
        # ---------------------------------------------------------------- 
        response = {}
        st = time.time()

        with action_lock:
            action_status = 'think'

        if with_img:
            img_path = './img_imput.jpg'
            cv2.imwrite(img_path, Vilib.img)
            response = openai_helper.dialogue_with_img(_result, img_path)
        else:
            response = openai_helper.dialogue(_result)

        gray_print(f'chat takes: {time.time() - st:.3f} s')

        # actions & TTS
        # ----------------------------------------------------------------
        _sound_actions = [] 
        try:
            if isinstance(response, dict):
                if 'actions' in response:
                    actions = list(response['actions'])
                else:
                    actions = ['stop']

                if 'answer' in response:
                    answer = response['answer']
                else:
                    answer = ''

                if len(answer) > 0:
                    _actions = list.copy(actions)
                    for _action in _actions:
                        if _action in SOUND_EFFECT_ACTIONS:
                            _sound_actions.append(_action)
                            actions.remove(_action)

            else:
                response = str(response)
                if len(response) > 0:
                    actions = []
                    answer = response

        except:
            actions = []
            answer = ''
    
        try:
            # ---- tts ----
            _tts_status = False
            if answer != '':
                st = time.time()
                _time = time.strftime("%y-%m-%d_%H-%M-%S", time.localtime())
                _tts_f = f"./tts/{_time}_raw.wav"
                _tts_status = openai_helper.text_to_speech(answer, _tts_f, TTS_VOICE, response_format='wav') # alloy, echo, fable, onyx, nova, and shimmer
                if _tts_status:
                    tts_file = f"./tts/{_time}_{VOLUME_DB}dB.wav"
                    _tts_status = sox_volume(_tts_f, tts_file, VOLUME_DB)
                gray_print(f'tts takes: {time.time() - st:.3f} s')

            # ---- actions ----
            with action_lock:
                actions_to_be_done = actions
                gray_print(f'actions: {actions_to_be_done}')
                action_status = 'actions'

            # --- sound effects and voice ---
            for _sound in _sound_actions:
                try:
                    sounds_dict[_sound](music)
                except Exception as e:
                    print(f'action error: {e}')

            if _tts_status:
                with speech_lock:
                    speech_loaded = True

            # ---- wait speak done ----
            if _tts_status:
                while True:
                    with speech_lock:
                        if not speech_loaded:
                            break
                    time.sleep(.01)

            # ---- wait actions done ----
            while True:
                with action_lock:
                    if action_status != 'actions':
                        break
                time.sleep(.01)

            ##
            print() # new line

        except Exception as e:
            print(f'actions or TTS error: {e}')


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\033[31mERROR: {e}\033[m")
    finally:
        if with_img:
            Vilib.camera_close()
        my_car.reset()



##################################################
# FILE: legacy_code/object_search.py
##################################################

"""
Object search module for PiCar-X
Combines movement, obstacle avoidance, and scene analysis to find objects
"""

import time
import random
from picarx import Picarx
import os
from time import strftime, localtime
from vilib import Vilib

# Constants for obstacle avoidance
POWER = 40  # Slightly reduced from 50 to be more careful
SAFE_DISTANCE = 40  # > 40 safe
DANGER_DISTANCE = 20  # > 20 && < 40 turn around, < 20 backward

# Search patterns
SEARCH_PATTERNS = [
    # Each pattern is a list of (direction, duration) tuples
    # direction: angle of the steering servo
    # duration: time to drive in that direction
    [(0, 2), (15, 1.5), (0, 2), (-15, 1.5)],  # Square-ish pattern
    [(0, 3), (20, 1), (-20, 1), (0, 2)],      # Zigzag pattern
    [(0, 2), (30, 0.8), (-30, 0.8), (0, 2)],  # Wide scan
]

class ObjectSearcher:
    """
    Handles searching for objects by combining movement and scene analysis
    """
    def __init__(self, car, openai_helper=None):
        """
        Initialize the object searcher
        
        Args:
            car: Picarx instance
            openai_helper: OpenAI helper for scene analysis
        """
        self.car = car
        self.openai_helper = openai_helper
        self.target_object = None
        self.is_searching = False
        self.found_object = False
        self.search_start_time = 0
        self.last_scan_time = 0
        self.scan_interval = 5  # seconds between scene scans
        self.max_search_time = 120  # maximum search time in seconds
        self.current_pattern_index = 0
        self.current_step_index = 0
        
        self.IMAGE_CAPTURE_DIR = "image_captures"
        os.makedirs(self.IMAGE_CAPTURE_DIR, exist_ok=True)
        
    def start_search(self, target_object):
        """
        Start searching for a specific object
        
        Args:
            target_object: String description of the object to find
        """
        print(f"Starting search for: {target_object}")
        self.target_object = target_object.lower()
        self.is_searching = True
        self.found_object = False
        self.search_start_time = time.time()
        self.last_scan_time = 0
        self.current_pattern_index = 0
        self.current_step_index = 0
        
    def stop_search(self):
        """Stop the current search"""
        if self.is_searching:
            print("Stopping search")
            self.is_searching = False
            self.car.stop()
            
    def search_step(self):
        """
        Execute one step of the search process
        Returns:
            bool: True if object was found, False otherwise
        """
        if not self.is_searching:
            return False
            
        # Check if we've been searching too long
        if time.time() - self.search_start_time > self.max_search_time:
            print(f"Search timeout after {self.max_search_time} seconds")
            self.stop_search()
            return False
            
        # Check for obstacles
        distance = self.get_distance()
        print(f"Distance to obstacle: {distance} cm")
        
        # Handle obstacles first
        if distance < DANGER_DISTANCE:
            print("Obstacle too close, backing up")
            self.car.set_dir_servo_angle(-30)
            self.car.backward(POWER)
            time.sleep(0.8)
            self.car.stop()
            # Choose a random new direction
            turn_angle = random.choice([-45, -30, 30, 45])
            self.car.set_dir_servo_angle(turn_angle)
            self.car.forward(POWER)
            time.sleep(0.5)
            self.car.stop()
            return False
        elif distance < SAFE_DISTANCE:
            print("Obstacle detected, turning")
            # Turn away from obstacle
            turn_angle = random.choice([-30, 30])
            self.car.set_dir_servo_angle(turn_angle)
            self.car.forward(POWER)
            time.sleep(0.8)
            self.car.stop()
            return False
            
        # Time to scan the environment?
        if time.time() - self.last_scan_time > self.scan_interval:
            return self.scan_for_object()
            
        # Otherwise, follow the search pattern
        pattern = SEARCH_PATTERNS[self.current_pattern_index]
        direction, duration = pattern[self.current_step_index]
        
        print(f"Search pattern: direction={direction}, duration={duration}")
        self.car.set_dir_servo_angle(direction)
        self.car.forward(POWER)
        time.sleep(duration)
        self.car.stop()
        
        # Move to next step in pattern
        self.current_step_index = (self.current_step_index + 1) % len(pattern)
        if self.current_step_index == 0:
            # Completed a pattern, switch to a different one
            self.current_pattern_index = (self.current_pattern_index + 1) % len(SEARCH_PATTERNS)
            
        return False
        
    def scan_for_object(self):
        """
        Scan the environment and check if the target object is visible
        
        Returns:
            bool: True if object was found, False otherwise
        """
        print(f"Scanning for {self.target_object}...")
        self.last_scan_time = time.time()
        
        # Look around in different directions
        scan_directions = [(0, 0), (30, 0), (-30, 0), (0, 20), (0, -20)]
        
        for pan, tilt in scan_directions:
            # Move camera
            self.car.set_cam_pan_angle(pan)
            self.car.set_cam_tilt_angle(tilt)
            time.sleep(0.5)  # Give camera time to move
            
            # Ask GPT to analyze the scene
            if self.openai_helper:
                prompt = f"Can you see a {self.target_object} in the current view? If yes, describe where it is."
                # Capture image
                img_name = f"scan_{strftime('%Y%m%d_%H%M%S', localtime())}"
                response = None # Initialize response
                img_path = None # Initialize img_path
                try:
                    # Vilib should be imported at the top of the file
                    # self.IMAGE_CAPTURE_DIR should be initialized in __init__
                    Vilib.take_photo(img_name, self.IMAGE_CAPTURE_DIR)
                    # Vilib.take_photo saves as path/name.jpg, so img_name should not have .jpg yet
                    img_path = os.path.join(self.IMAGE_CAPTURE_DIR, img_name + ".jpg") 
                    
                    if os.path.exists(img_path):
                        print(f"Captured image: {img_path}")
                        if hasattr(self.openai_helper, 'dialogue_with_img'):
                            response = self.openai_helper.dialogue_with_img(prompt, img_path)
                        else:
                            print("Error: openai_helper does not have dialogue_with_img. Falling back to text-only.")
                            if hasattr(self.openai_helper, 'dialogue'): # Check if dialogue method exists
                                response = self.openai_helper.dialogue(prompt) # Fallback
                            else:
                                print("Error: openai_helper also does not have dialogue method.")
                    else:
                        print(f"Error: Image file not found after Vilib.take_photo: {img_path}")
                
                except NameError as e: 
                    print(f"Error: Vilib or os/time functions not available. Imports correct? Details: {e}")
                except AttributeError as e: 
                    print(f"Error: Attribute missing, likely on self.openai_helper. Details: {e}")
                    # Fallback if dialogue_with_img is somehow not there despite checks
                    if hasattr(self.openai_helper, 'dialogue'):
                         response = self.openai_helper.dialogue(prompt)
                except Exception as e:
                    print(f"Error during image capture or OpenAI call: {e}")
                finally:
                    # Clean up the image if it was created
                    if img_path and os.path.exists(img_path):
                        try:
                            os.remove(img_path)
                            print(f"Deleted image: {img_path}")
                        except OSError as e_del:
                            print(f"Error deleting image {img_path}: {e_del}")
                
                # Check if response indicates the object was found
                if isinstance(response, dict) and "answer" in response:
                    answer_text = response["answer"].lower()
                    print(f"Scene analysis: {answer_text}")
                    
                    # Check if the answer indicates the object was found
                    positive_indicators = ["yes", "i can see", "i see", "found", "visible", "there is", "there's"]
                    if self.target_object in answer_text and any(indicator in answer_text for indicator in positive_indicators):
                        print(f"Found {self.target_object}!")
                        self.found_object = True
                        self.is_searching = False
                        return True
        
        # Reset camera position
        self.car.set_cam_pan_angle(0)
        self.car.set_cam_tilt_angle(0)
        return False
    
    def get_distance(self):
        """Get distance from ultrasonic sensor, with error handling"""
        try:
            return round(self.car.ultrasonic.read(), 2)
        except Exception as e:
            print(f"Error reading ultrasonic sensor: {e}")
            return 100  # Return a safe value if sensor fails


##################################################
# FILE: legacy_code/test_speaker.py
##################################################

#!/usr/bin/env python3
"""
Simple test script to verify speaker functionality on Raspberry Pi with PicarX
"""
import os
import subprocess
import time

def main():
    print("Testing speaker functionality...")
    
    # Enable the speaker GPIO pin
    print("Enabling speaker GPIO pin 20...")
    os.popen("pinctrl set 20 op dh")
    time.sleep(1)
    
    # Test with espeak
    print("Testing with espeak...")
    try:
        subprocess.run(["espeak", "Hello, this is a test of the speaker system"], check=True)
        print("Espeak test completed. Did you hear anything?")
    except Exception as e:
        print(f"Espeak error: {e}")
    
    # Test with aplay if we have a WAV file
    print("\nTesting with aplay and a test sound...")
    try:
        # Create a simple test sound using sox if available
        try:
            subprocess.run(["sox", "-n", "/tmp/test_sound.wav", "synth", "3", "sine", "1000"], check=True)
            print("Created test sound with sox")
            test_sound = "/tmp/test_sound.wav"
        except:
            print("Sox not available, using system sounds if available")
            test_sound = "/usr/share/sounds/alsa/Front_Center.wav"
        
        # Try to play the sound
        subprocess.run(["aplay", test_sound], check=True)
        print("Aplay test completed. Did you hear anything?")
    except Exception as e:
        print(f"Aplay error: {e}")
    
    print("\nSpeaker test complete.")
    print("If you didn't hear anything, check:")
    print("1. Is the speaker properly connected to GPIO pin 20?")
    print("2. Is the volume set correctly?")
    print("3. Are audio packages installed? (espeak, alsa-utils)")
    print("4. Try running with sudo: 'sudo python3 test_speaker.py'")

if __name__ == "__main__":
    main()


##################################################
# FILE: legacy_code/updated_preset_actions.py
##################################################

#!/usr/bin/env python3
"""
Updated preset actions for PiCar-X robot with both original and new actions
"""
from time import sleep
import random
from math import sin, cos, pi
import os

# Original expression actions
# =================================================================
def wave_hands(car):
    car.reset()
    car.set_cam_tilt_angle(20)
    for _ in range(2):
        car.set_dir_servo_angle(-25)
        sleep(.1)
        car.set_dir_servo_angle(25)
        sleep(.1)
    car.set_dir_servo_angle(0)

def resist(car):
    car.reset()
    car.set_cam_tilt_angle(10)
    for _ in range(3):
        car.set_dir_servo_angle(-15)
        car.set_cam_pan_angle(15)
        sleep(.1)
        car.set_dir_servo_angle(15)
        car.set_cam_pan_angle(-15)
        sleep(.1)
    car.stop()
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)

def act_cute(car):
    car.reset()
    car.set_cam_tilt_angle(-20)
    for i in range(15):
        car.forward(5)
        sleep(0.02)
        car.backward(5)
        sleep(0.02)
    car.set_cam_tilt_angle(0)
    car.stop()

def rub_hands(car):
    car.reset()
    for i in range(5):
        car.set_dir_servo_angle(-6)
        sleep(.5)
        car.set_dir_servo_angle(6)
        sleep(.5)
    car.reset()

def think(car):
    car.reset()
    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)
    sleep(1)
    car.set_cam_pan_angle(15)
    car.set_cam_tilt_angle(-10)
    car.set_dir_servo_angle(10)
    sleep(.1)
    car.reset()

def keep_think(car):
    car.reset()
    for i in range(11):
        car.set_cam_pan_angle(i*3)
        car.set_cam_tilt_angle(-i*2)
        car.set_dir_servo_angle(i*2)
        sleep(.05)

def shake_head(car):
    car.stop()
    car.set_cam_pan_angle(0)
    car.set_cam_pan_angle(60)
    sleep(.2)
    car.set_cam_pan_angle(-50)
    sleep(.1)
    car.set_cam_pan_angle(40)
    sleep(.1)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_cam_pan_angle(20)
    sleep(.1)
    car.set_cam_pan_angle(-10)
    sleep(.1)
    car.set_cam_pan_angle(10)
    sleep(.1)
    car.set_cam_pan_angle(-5)
    sleep(.1)
    car.set_cam_pan_angle(0)

def nod(car):
    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(5)
    sleep(.1)
    car.set_cam_tilt_angle(-30)
    sleep(.1)
    car.set_cam_tilt_angle(0)

def depressed(car):
    car.reset()
    car.set_cam_tilt_angle(0)
    car.set_cam_tilt_angle(20)
    sleep(.22)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(0)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-10)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-15)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    car.set_cam_tilt_angle(-19)
    sleep(.1)
    car.set_cam_tilt_angle(-22)
    sleep(.1)
    sleep(1.5)
    car.reset()

def twist_body(car):
    car.reset()
    for i in range(3):
        car.set_motor_speed(1, 20)
        car.set_motor_speed(2, 20)
        car.set_cam_pan_angle(-20)
        car.set_dir_servo_angle(-10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)
        sleep(.1)
        car.set_motor_speed(1, -20)
        car.set_motor_speed(2, -20)
        car.set_cam_pan_angle(20)
        car.set_dir_servo_angle(10)
        sleep(.1)
        car.set_motor_speed(1, 0)
        car.set_motor_speed(2, 0)
        car.set_cam_pan_angle(0)
        car.set_dir_servo_angle(0)
        sleep(.1)

def celebrate(car):
    car.reset()
    car.set_cam_tilt_angle(20)
    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(10)
    car.set_cam_pan_angle(30)
    sleep(.1)
    car.set_dir_servo_angle(30)
    car.set_cam_pan_angle(60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)
    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(-10)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_dir_servo_angle(-30)
    car.set_cam_pan_angle(-60)
    sleep(.3)
    car.set_dir_servo_angle(0)
    car.set_cam_pan_angle(0)
    sleep(.2)

# Search and exploration actions
# =================================================================
def search(car):
    """Basic search action that combines movement and looking around"""
    print("Action: Searching the area")
    # Look around in different directions
    car.set_cam_pan_angle(30)
    time.sleep(0.5)
    car.set_cam_pan_angle(-30)
    time.sleep(0.5)
    car.set_cam_pan_angle(0)
    
    # Move forward a bit
    car.forward(40)
    time.sleep(1.5)
    car.stop()
    
    # Look around again
    car.set_cam_tilt_angle(20)
    time.sleep(0.5)
    car.set_cam_tilt_angle(-20)
    time.sleep(0.5)
    car.set_cam_tilt_angle(0)
    
    # Turn slightly and continue
    car.set_dir_servo_angle(15)
    car.forward(40)
    time.sleep(1)
    car.stop()
    car.set_dir_servo_angle(0)
    
def find_object(car):
    """Start the advanced object search process"""
    global object_searcher, search_target
    
    if not object_search_available or object_searcher is None:
        print("Object search not available, using basic search instead")
        search(car)
        return
    
    # Use the global search_target if available
    object_name = search_target if search_target else "anything interesting"
        
    print(f"Action: Starting advanced search for {object_name}")
    object_searcher.start_search(object_name)
    
    # Do one search step immediately
    object_searcher.search_step()
    
def search_step(car):
    """Execute one step of the object search process"""
    global object_searcher
    
    if not object_search_available or object_searcher is None:
        print("Object search not available, using basic search instead")
        search(car)
        return
        
    # Execute one step of the search process
    found = object_searcher.search_step()
    if found:
        print("Object found!")
        
def stop_search(car):
    """Stop the current search process"""
    global object_searcher
    
    if not object_search_available or object_searcher is None:
        print("No active search to stop")
        car.stop()
        return
        
    print("Action: Stopping search")
    object_searcher.stop_search()

# New movement actions
# =================================================================
def forward(car):
    print("Action: Moving forward")
    car.forward(50)
    sleep(1)
    car.stop()

def backward(car):
    print("Action: Moving backward")
    car.backward(50)
    sleep(1)
    car.stop()

def turn_left(car):
    print("Action: Turning left")
    car.set_dir_servo_angle(30)  # Set steering to left
    car.forward(50)  # Move forward with left steering
    sleep(0.5)
    car.stop()

def turn_right(car):
    print("Action: Turning right")
    car.set_dir_servo_angle(-30)  # Set steering to right
    car.forward(50)  # Move forward with right steering
    sleep(0.5)
    car.stop()

def stop(car):
    print("Action: Stopping")
    car.stop()

# New head movement actions
# =================================================================
def look_up(car):
    print("Action: Looking up")
    # Since get_cam_tilt_angle isn't available, we'll use a relative movement
    car.set_cam_tilt_angle(20)  # Positive angle for looking up

def look_down(car):
    print("Action: Looking down")
    # Since get_cam_tilt_angle isn't available, we'll use a relative movement
    car.set_cam_tilt_angle(-20)  # Negative angle for looking down

def look_left(car):
    print("Action: Looking left")
    # Since get_cam_pan_angle isn't available, we'll use a relative movement
    car.set_cam_pan_angle(30)  # Positive angle for looking left

def look_right(car):
    print("Action: Looking right")
    # Since get_cam_pan_angle isn't available, we'll use a relative movement
    car.set_cam_pan_angle(-30)  # Negative angle for looking right

def look_center(car):
    print("Action: Looking center")
    car.set_cam_pan_angle(0)
    car.set_cam_tilt_angle(0)

# Sound effects
# =================================================================
def honking(music):
    print("Sound: Honking")
    try:
        music.sound_play_threading("../sounds/car-double-horn.wav", 100)
    except Exception as e:
        print(f"Sound effect error: {e}")

def start_engine(music):
    print("Sound: Starting engine")
    try:
        music.sound_play_threading("../sounds/car-start-engine.wav", 50)
    except Exception as e:
        print(f"Sound effect error: {e}")

# Global variables
# =================================================================
# These will be initialized after the functions are defined
my_car = None
music = None
object_searcher = None
search_target = None

# Action and sound dictionaries
# =================================================================
actions_dict = {
    # Original actions with spaces
    "shake head": shake_head, 
    "nod": nod,
    "wave hands": wave_hands,
    "resist": resist,
    "act cute": act_cute,
    "rub hands": rub_hands,
    "think": think,
    "twist body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
    
    # New actions with underscores
    "shake_head": shake_head, 
    "nod": nod,
    "wave_hands": wave_hands,
    "resist": resist,
    "act_cute": act_cute,
    "rub_hands": rub_hands,
    "think": think,
    "twist_body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
    
    # Movement actions
    "forward": forward,
    "backward": backward,
    "turn_left": turn_left,
    "turn_right": turn_right,
    "stop": stop,
    
    # Head movement actions
    "look_up": look_up,
    "look_down": look_down,
    "look_left": look_left,
    "look_right": look_right,
    "look_center": look_center,
    
    # Search and exploration actions
    "search": search,
    "search_area": search,
    "explore": search,
    "find": find_object,
    "find_object": find_object,
    "look_for": find_object,
    "search_step": search_step,
    "stop_search": stop_search,
}

sounds_dict = {
    # Original sound actions
    "honking": honking,
    "start engine": start_engine,
    
    # New sound actions with underscores

if __name__ == "__main__":
    if hardware_available:
        my_car = Picarx()
        music = Music()

    os.popen("pinctrl set 20 op dh") # enable robot_hat speaker switch
    current_path = os.path.dirname(os.path.abspath(__file__))
    os.chdir(current_path) # change working directory

    if hardware_available:
        my_car.reset()
    my_car.reset()

    music = Music()

    sleep(.5)

    print("Available actions:")
    _actions_num = len(actions_dict)
    actions = list(actions_dict.keys())
    for i, key in enumerate(actions):
        print(f'{i} {key}')
    
    print("\nAvailable sounds:")
    _sounds_num = len(sounds_dict)
    sounds = list(sounds_dict.keys())
    for i, key in enumerate(sounds_dict):
        print(f'{i} {key}')

    last_key = None

    try:
        while True:
            key = input("Enter action number or name (or press Enter to repeat last action): ")

            if key == '':
                if last_key > _actions_num - 1:
                    print(sounds[last_key-_actions_num])
                    sounds_dict[sounds[last_key-_actions_num]](music)
                else:
                    print(actions[last_key])
                    actions_dict[actions[last_key]](my_car)
            else:
                try:
                    # Try to parse as a number
                    key_num = int(key)
                    if key_num > (_actions_num + _sounds_num - 1):
                        print("Invalid key number")
                    elif key_num > (_actions_num - 1):
                        last_key = key_num
                        print(sounds[last_key-_actions_num])
                        sounds_dict[sounds[last_key-_actions_num]](music)
                    else:
                        last_key = key_num
                        print(actions[key_num])
                        actions_dict[actions[key_num]](my_car)
                except ValueError:
                    # Try as a string key
                    if key in actions_dict:
                        print(f"Executing action: {key}")
                        actions_dict[key](my_car)
                    elif key in sounds_dict:
                        print(f"Playing sound: {key}")
                        sounds_dict[key](music)
                    else:
                        print(f"Unknown action or sound: {key}")

    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f'Error:\n {e}')
    finally:
        my_car.reset()
        sleep(.1)


##################################################
# FILE: legacy_code/preset_actions.py
##################################################

#!/usr/bin/env python3
"""
Preset actions for PiCar-X robot
"""
import time
from robot_hat import Music

# Movement actions
# =================================================================
def forward(car):
    print("Action: Moving forward")
    car.forward(50)
    time.sleep(1)
    car.stop()

def backward(car):
    print("Action: Moving backward")
    car.backward(50)
    time.sleep(1)
    car.stop()

def turn_left(car):
    print("Action: Turning left")
    car.turn_left(50)
    time.sleep(0.5)
    car.stop()

def turn_right(car):
    print("Action: Turning right")
    car.turn_right(50)
    time.sleep(0.5)
    car.stop()

def stop(car):
    print("Action: Stopping")
    car.stop()

# Head movement actions
# =================================================================
def look_up(car):
    print("Action: Looking up")
    current_angle = car.get_cam_tilt_angle()
    car.set_cam_tilt_angle(current_angle + 10)

def look_down(car):
    print("Action: Looking down")
    current_angle = car.get_cam_tilt_angle()
    car.set_cam_tilt_angle(current_angle - 10)

def look_left(car):
    print("Action: Looking left")
    current_angle = car.get_cam_pan_angle()
    car.set_cam_pan_angle(current_angle + 10)

def look_right(car):
    print("Action: Looking right")
    current_angle = car.get_cam_pan_angle()
    car.set_cam_pan_angle(current_angle - 10)

def look_center(car):
    print("Action: Looking center")
    car.set_cam_pan_angle(0)
    car.set_cam_tilt_angle(0)

# Expression actions
# =================================================================
def shake_head(car):
    print("Action: Shaking head")
    car.set_cam_pan_angle(20)
    time.sleep(0.2)
    car.set_cam_pan_angle(-20)
    time.sleep(0.2)
    car.set_cam_pan_angle(20)
    time.sleep(0.2)
    car.set_cam_pan_angle(0)

def nod(car):
    print("Action: Nodding")
    car.set_cam_tilt_angle(20)
    time.sleep(0.2)
    car.set_cam_tilt_angle(-20)
    time.sleep(0.2)
    car.set_cam_tilt_angle(20)
    time.sleep(0.2)
    car.set_cam_tilt_angle(0)

def wave_hands(car):
    print("Action: Waving hands (simulated with head movement)")
    for _ in range(3):
        car.set_cam_pan_angle(15)
        time.sleep(0.2)
        car.set_cam_pan_angle(-15)
        time.sleep(0.2)
    car.set_cam_pan_angle(0)

def resist(car):
    print("Action: Resisting")
    car.backward(30)
    time.sleep(0.3)
    car.forward(30)
    time.sleep(0.3)
    car.stop()

def act_cute(car):
    print("Action: Acting cute")
    car.set_cam_tilt_angle(15)
    car.set_cam_pan_angle(15)
    time.sleep(0.5)
    car.set_cam_tilt_angle(-15)
    car.set_cam_pan_angle(-15)
    time.sleep(0.5)
    car.set_cam_tilt_angle(0)
    car.set_cam_pan_angle(0)

def rub_hands(car):
    print("Action: Rubbing hands (simulated with movement)")
    car.forward(20)
    time.sleep(0.2)
    car.backward(20)
    time.sleep(0.2)
    car.forward(20)
    time.sleep(0.2)
    car.backward(20)
    time.sleep(0.2)
    car.stop()

def think(car):
    print("Action: Thinking")
    car.set_cam_tilt_angle(20)
    time.sleep(1)
    car.set_cam_tilt_angle(0)

def twist_body(car):
    print("Action: Twisting body")
    car.turn_left(30)
    time.sleep(0.3)
    car.turn_right(30)
    time.sleep(0.3)
    car.turn_left(30)
    time.sleep(0.3)
    car.stop()

def celebrate(car):
    print("Action: Celebrating")
    for _ in range(2):
        car.forward(40)
        time.sleep(0.3)
        car.backward(40)
        time.sleep(0.3)
    car.stop()
    for _ in range(2):
        car.set_cam_tilt_angle(20)
        time.sleep(0.2)
        car.set_cam_tilt_angle(-20)
        time.sleep(0.2)
    car.set_cam_tilt_angle(0)

def depressed(car):
    print("Action: Depressed")
    car.set_cam_tilt_angle(-20)
    time.sleep(1.5)
    car.set_cam_tilt_angle(0)

# Keep thinking action for continuous movement
# =================================================================
def keep_think(car):
    print("Action: Keep thinking")
    car.set_cam_tilt_angle(10)
    time.sleep(0.5)
    car.set_cam_tilt_angle(-10)
    time.sleep(0.5)

# Sound effects
# =================================================================
def start_engine(music):
    print("Sound: Starting engine")
    try:
        music.sound_effect('start_engine.wav')
    except Exception as e:
        print(f"Sound effect error: {e}")

def honking(music):
    print("Sound: Honking")
    try:
        music.sound_effect('honking.wav')
    except Exception as e:
        print(f"Sound effect error: {e}")

# Action and sound dictionaries
# =================================================================
actions_dict = {
    'forward': forward,
    'backward': backward,
    'turn_left': turn_left,
    'turn_right': turn_right,
    'stop': stop,
    'look_up': look_up,
    'look_down': look_down,
    'look_left': look_left,
    'look_right': look_right,
    'look_center': look_center,
    'shake_head': shake_head,
    'nod': nod,
    'wave_hands': wave_hands,
    'resist': resist,
    'act_cute': act_cute,
    'rub_hands': rub_hands,
    'think': think,
    'twist_body': twist_body,
    'celebrate': celebrate,
    'depressed': depressed,
}

sounds_dict = {
    'start_engine': start_engine,
    'honking': honking,
}


##################################################
# FILE: legacy_code/fixed_preset_actions.py
##################################################

"""
PiCar-X Preset Actions Module
Contains predefined actions and sounds for the PiCar-X robot
"""

# Import standard modules
import time
from time import sleep
import random
import os

# Import hardware-specific modules with error handling
try:
    # Only import the classes, don't instantiate them
    from picarx import Picarx
    from robot_hat import Music
    hardware_available = True
except ImportError as e:
    print(f"Error importing hardware modules: {e}")
    hardware_available = False

# Import the object search module
try:
    from object_search import ObjectSearcher
    object_search_available = True
except ImportError:
    print("Object search module not available")
    object_search_available = False

# Global variables
# =================================================================
# These will be set by agent_car.py
my_car = None
music = None
object_searcher = None

# This file should not initialize any hardware
# Hardware will be initialized in agent_car.py
search_target = None

# Constants
DEFAULT_HEAD_PAN = 0
DEFAULT_HEAD_TILT = 0

# Original action functions
# =================================================================
def shake_head(car):
    """Shake head action"""
    print("Action: Shaking head")
    car.set_cam_pan_angle(30)
    sleep(.2)
    car.set_cam_pan_angle(-30)
    sleep(.2)
    car.set_cam_pan_angle(30)
    sleep(.2)
    car.set_cam_pan_angle(-30)
    sleep(.2)
    car.set_cam_pan_angle(0)
    sleep(.2)

def nod(car):
    """Nod action"""
    print("Action: Nodding")
    car.set_cam_tilt_angle(20)
    sleep(.2)
    car.set_cam_tilt_angle(-20)
    sleep(.2)
    car.set_cam_tilt_angle(20)
    sleep(.2)
    car.set_cam_tilt_angle(-20)
    sleep(.2)
    car.set_cam_tilt_angle(0)
    sleep(.2)

def wave_hands(car):
    """Wave hands action"""
    print("Action: Waving hands")
    car.set_dir_servo_angle(30)
    sleep(.2)
    car.set_dir_servo_angle(-30)
    sleep(.2)
    car.set_dir_servo_angle(30)
    sleep(.2)
    car.set_dir_servo_angle(-30)
    sleep(.2)
    car.set_dir_servo_angle(0)
    sleep(.2)

def resist(car):
    """Resist action"""
    print("Action: Resisting")
    car.forward(50)
    sleep(.1)
    car.forward(0)
    sleep(.1)
    car.backward(50)
    sleep(.1)
    car.forward(0)
    sleep(.1)
    car.forward(50)
    sleep(.1)
    car.forward(0)
    sleep(.1)
    car.backward(50)
    sleep(.1)
    car.forward(0)
    sleep(.1)

def act_cute(car):
    """Act cute action"""
    print("Action: Acting cute")
    car.set_cam_pan_angle(20)
    sleep(.2)
    car.set_cam_tilt_angle(20)
    sleep(.2)
    car.set_cam_pan_angle(-20)
    sleep(.2)
    car.set_cam_tilt_angle(-20)
    sleep(.2)
    car.set_cam_pan_angle(0)
    sleep(.2)
    car.set_cam_tilt_angle(0)
    sleep(.2)

def rub_hands(car):
    """Rub hands action"""
    print("Action: Rubbing hands")
    car.set_dir_servo_angle(20)
    sleep(.2)
    car.set_dir_servo_angle(30)
    sleep(.2)
    car.set_dir_servo_angle(20)
    sleep(.2)
    car.set_dir_servo_angle(30)
    sleep(.2)
    car.set_dir_servo_angle(0)
    sleep(.2)

def think(car):
    """Think action"""
    print("Action: Thinking")
    car.set_cam_pan_angle(30)
    sleep(.5)
    car.set_cam_tilt_angle(20)
    sleep(.5)
    car.set_cam_pan_angle(-30)
    sleep(.5)
    car.set_cam_tilt_angle(-20)
    sleep(.5)
    car.set_cam_pan_angle(0)
    sleep(.2)
    car.set_cam_tilt_angle(0)
    sleep(.2)

def keep_think(car):
    """Keep thinking action"""
    print("Action: Keep thinking")
    car.set_cam_pan_angle(30)
    sleep(.5)
    car.set_cam_tilt_angle(20)
    sleep(.5)
    car.set_cam_pan_angle(-30)
    sleep(.5)
    car.set_cam_tilt_angle(-20)
    sleep(.5)
    car.set_cam_pan_angle(0)
    sleep(.2)
    car.set_cam_tilt_angle(0)
    sleep(.2)

def twist_body(car):
    """Twist body action"""
    print("Action: Twisting body")
    car.set_dir_servo_angle(30)
    sleep(.2)
    car.set_dir_servo_angle(-30)
    sleep(.2)
    car.set_dir_servo_angle(30)
    sleep(.2)
    car.set_dir_servo_angle(-30)
    sleep(.2)
    car.set_dir_servo_angle(0)
    sleep(.2)

def celebrate(car):
    """Celebrate action"""
    print("Action: Celebrating")
    car.set_dir_servo_angle(30)
    sleep(.1)
    car.set_dir_servo_angle(-30)
    sleep(.1)
    car.set_dir_servo_angle(30)
    sleep(.1)
    car.set_dir_servo_angle(-30)
    sleep(.1)
    car.set_dir_servo_angle(0)
    sleep(.1)
    car.set_cam_pan_angle(30)
    sleep(.1)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_cam_pan_angle(30)
    sleep(.1)
    car.set_cam_pan_angle(-30)
    sleep(.1)
    car.set_cam_pan_angle(0)
    sleep(.1)

def depressed(car):
    """Depressed action"""
    print("Action: Depressed")
    car.set_cam_tilt_angle(-30)
    sleep(.2)
    car.set_cam_pan_angle(0)
    sleep(.2)

# Search and exploration actions
# =================================================================
def search(car):
    """Basic search action that combines movement and looking around"""
    print("Action: Searching the area")
    # Look around in different directions
    car.set_cam_pan_angle(30)
    time.sleep(0.5)
    car.set_cam_pan_angle(-30)
    time.sleep(0.5)
    car.set_cam_pan_angle(0)
    
    # Move forward a bit
    car.forward(40)
    time.sleep(1.5)
    car.stop()
    
    # Look around again
    car.set_cam_tilt_angle(20)
    time.sleep(0.5)
    car.set_cam_tilt_angle(-20)
    time.sleep(0.5)
    car.set_cam_tilt_angle(0)
    
    # Turn slightly and continue
    car.set_dir_servo_angle(15)
    car.forward(40)
    time.sleep(1)
    car.stop()
    car.set_dir_servo_angle(0)
    
def find_object(car):
    """Start the advanced object search process"""
    global object_searcher, search_target
    
    if not object_search_available or object_searcher is None:
        print("Object search not available, using basic search instead")
        search(car)
        return
    
    # Use the global search_target if available
    object_name = search_target if search_target else "anything interesting"
        
    print(f"Action: Starting advanced search for {object_name}")
    object_searcher.start_search(object_name)
    
    # Do one search step immediately
    object_searcher.search_step()
    
def search_step(car):
    """Execute one step of the object search process"""
    global object_searcher
    
    if not object_search_available or object_searcher is None:
        print("Object search not available, using basic search instead")
        search(car)
        return
        
    # Execute one step of the search process
    found = object_searcher.search_step()
    if found:
        print("Object found!")
        
def stop_search(car):
    """Stop the current search process"""
    global object_searcher
    
    if not object_search_available or object_searcher is None:
        print("No active search to stop")
        car.stop()
        return
        
    print("Action: Stopping search")
    object_searcher.stop_search()

# New movement actions
# =================================================================
def forward(car):
    """Move forward"""
    print("Action: Moving forward")
    car.set_dir_servo_angle(0)
    car.forward(50)
    time.sleep(1)
    car.stop()

def backward(car):
    """Move backward"""
    print("Action: Moving backward")
    car.set_dir_servo_angle(0)
    car.backward(50)
    time.sleep(1)
    car.stop()

def turn_left(car):
    """Turn left"""
    print("Action: Turning left")
    car.set_dir_servo_angle(-30)
    car.forward(50)
    time.sleep(1)
    car.stop()
    car.set_dir_servo_angle(0)

def turn_right(car):
    """Turn right"""
    print("Action: Turning right")
    car.set_dir_servo_angle(30)
    car.forward(50)
    time.sleep(1)
    car.stop()
    car.set_dir_servo_angle(0)

def stop(car):
    """Stop movement"""
    print("Action: Stopping")
    car.stop()

# Head movement actions
# =================================================================
def look_up(car):
    """Look up"""
    print("Action: Looking up")
    car.set_cam_tilt_angle(30)
    time.sleep(0.5)

def look_down(car):
    """Look down"""
    print("Action: Looking down")
    car.set_cam_tilt_angle(-30)
    time.sleep(0.5)

def look_left(car):
    """Look left"""
    print("Action: Looking left")
    car.set_cam_pan_angle(30)
    time.sleep(0.5)

def look_right(car):
    """Look right"""
    print("Action: Looking right")
    car.set_cam_pan_angle(-30)
    time.sleep(0.5)

def look_center(car):
    """Look center"""
    print("Action: Looking center")
    car.set_cam_pan_angle(0)
    car.set_cam_tilt_angle(0)
    time.sleep(0.5)

# Sound effects
# =================================================================
def start_engine(car):
    """Play start engine sound"""
    print("Sound: Start engine")
    try:
        global music
        if music:
            music.sound_effect_threading(music.sound_effect_path + "start_engine.wav")
    except Exception as e:
        print(f"Sound effect error: {e}")

# Action and sound dictionaries
# =================================================================
actions_dict = {
    # Original actions with spaces
    "shake head": shake_head, 
    "nod": nod,
    "wave hands": wave_hands,
    "resist": resist,
    "act cute": act_cute,
    "rub hands": rub_hands,
    "think": think,
    "twist body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
    
    # New actions with underscores
    "shake_head": shake_head, 
    "nod": nod,
    "wave_hands": wave_hands,
    "resist": resist,
    "act_cute": act_cute,
    "rub_hands": rub_hands,
    "think": think,
    "twist_body": twist_body,
    "celebrate": celebrate,
    "depressed": depressed,
    
    # Movement actions
    "forward": forward,
    "backward": backward,
    "turn_left": turn_left,
    "turn_right": turn_right,
    "stop": stop,
    
    # Head movement actions
    "look_up": look_up,
    "look_down": look_down,
    "look_left": look_left,
    "look_right": look_right,
    "look_center": look_center,
    
    # Search and exploration actions
    "search": search,
    "search_area": search,
    "explore": search,
    "find": find_object,
    "find_object": find_object,
    "look_for": find_object,
    "search_step": search_step,
    "stop_search": stop_search,
}

sounds_dict = {
    # Original sound actions with spaces
    "start engine": start_engine,
    
    # New sound actions with underscores
    "start_engine": start_engine,
}


# Test code when run directly
# =================================================================
if __name__ == "__main__":
    if hardware_available:
        test_car = Picarx()
        test_car.reset()
        
        print("Testing basic actions...")
        shake_head(test_car)
        nod(test_car)
        
        print("Testing search actions...")
        search(test_car)
    else:
        print("Hardware not available, can't run test actions")


##################################################
# FILE: legacy_code/reset_gpio.py
##################################################

#!/usr/bin/env python3
"""
GPIO Reset Utility for PiCar-X
This script attempts to clean up and release any GPIO pins that might be in use
"""

import time
import os
import sys

def reset_gpio():
    """Attempt to reset and release all GPIO pins"""
    print("Attempting to reset GPIO pins...")
    
    try:
        # Try to use gpiozero's cleanup functions
        from gpiozero import Device
        from gpiozero.pins.rpigpio import RPiGPIOFactory
        Device.pin_factory = RPiGPIOFactory()
        Device.pin_factory.close()
        print("GPIO pins reset via gpiozero")
        return True
    except Exception as e:
        print(f"Error resetting via gpiozero: {e}")
    
    try:
        # Alternative method using RPi.GPIO
        import RPi.GPIO as GPIO
        # Check if mode is already set
        try:
            mode = GPIO.getmode()
            if mode is None:
                GPIO.setmode(GPIO.BCM)
        except:
            # If getmode() isn't available, just set it
            GPIO.setmode(GPIO.BCM)
        
        # Clean up all pins
        GPIO.cleanup()
        print("GPIO pins reset via RPi.GPIO")
        return True
    except Exception as e:
        print(f"Error resetting via RPi.GPIO: {e}")
    
    # Last resort - try to use system commands
    try:
        os.system("sudo killall pigpiod")
        time.sleep(1)
        os.system("sudo pigpiod")
        time.sleep(1)
        print("GPIO pins reset via system commands")
        return True
    except Exception as e:
        print(f"Error resetting via system commands: {e}")
    
    return False

if __name__ == "__main__":
    success = reset_gpio()
    sys.exit(0 if success else 1)


##################################################
# FILE: Makefile
##################################################

.PHONY: test test-unit test-integration test-e2e lint format check-format install-dev clean

# Python interpreter
PYTHON = python3
PIP = pip3

# Directories
SRC_DIR = src
TESTS_DIR = tests
UNIT_TESTS_DIR = $(TESTS_DIR)/unit
INTEGRATION_TESTS_DIR = $(TESTS_DIR)/integration
E2E_TESTS_DIR = $(TESTS_DIR)/e2e

# Test options
TEST_OPTS = -v --cov=$(SRC_DIR) --cov-report=term-missing --cov-report=html

# Install development dependencies
install-dev:
	$(PIP) install -r requirements.txt
	$(PIP) install pytest pytest-cov black flake8 mypy

# Run all tests
test: test-unit test-integration test-e2e

# Run unit tests
test-unit:
	$(PYTHON) -m pytest $(TEST_OPTS) $(UNIT_TESTS_DIR)

# Run integration tests
test-integration:
	$(PYTHON) -m pytest $(TEST_OPTS) $(INTEGRATION_TESTS_DIR)

# Run end-to-end tests
test-e2e:
	$(PYTHON) -m pytest $(TEST_OPTS) $(E2E_TESTS_DIR)

# Lint the code
lint:
	flake8 $(SRC_DIR) $(TESTS_DIR)
	mypy $(SRC_DIR) $(TESTS_DIR)

# Format the code
format:
	black $(SRC_DIR) $(TESTS_DIR)

# Check code formatting
check-format:
	black --check $(SRC_DIR) $(TESTS_DIR)

# Clean up temporary files
clean:
	find . -type d -name '__pycache__' -exec rm -rf {} +
	find . -type f -name '*.pyc' -delete
	find . -type f -name '*.pyo' -delete
	find . -type f -name '*~' -delete
	rm -rf .coverage htmlcov/ .pytest_cache/ .mypy_cache/

# Default target
.DEFAULT_GOAL := test


##################################################
# FILE: tests/unit/test_voice.py
##################################################

"""
Unit tests for the voice module.
"""
import pytest
import tempfile
from unittest.mock import MagicMock, patch
from src.voice.speech_recognition import SpeechRecognizer
from src.voice.text_to_speech import TextToSpeech

class TestSpeechRecognizer:
    """Test cases for SpeechRecognizer."""
    
    @pytest.fixture
    def recognizer(self):
        """Create a SpeechRecognizer instance for testing."""
        with patch('speech_recognition.Recognizer') as mock_recognizer:
            with patch('speech_recognition.Microphone'):
                yield SpeechRecognizer()
    
    def test_listen_success(self, recognizer):
        """Test successful speech recognition."""
        # Mock the recognizer to return test text
        recognizer.recognizer.recognize_google.return_value = "test command"
        
        # Call the method
        result = recognizer.listen()
        
        # Verify
        assert result == "test command"
        recognizer.recognizer.listen.assert_called_once()
    
    def test_listen_timeout(self, recognizer):
        """Test speech recognition timeout."""
        # Mock the recognizer to raise a timeout
        recognizer.recognizer.listen.side_effect = recognizer.recognizer.WaitTimeoutError()
        
        # Call the method
        result = recognizer.listen()
        
        # Verify
        assert result is None

class TestTextToSpeech:
    """Test cases for TextToSpeech."""
    
    @pytest.fixture
    def tts(self):
        """Create a TextToSpeech instance for testing."""
        with patch('pygame.mixer.init'), \
             patch('pygame.mixer.music'):
            yield TextToSpeech()
    
    def test_speak_success(self, tts):
        """Test successful text-to-speech conversion."""
        # Mock the gTTS and file operations
        with patch('gtts.gTTS') as mock_gtts, \
             patch('tempfile.NamedTemporaryFile') as mock_temp_file:
            # Setup mock file
            mock_file = MagicMock()
            mock_temp_file.return_value.__enter__.return_value = mock_file
            mock_file.name = "/tmp/test.mp3"
            
            # Call the method
            result = tts.speak("Hello, world!")
            
            # Verify
            assert result is True
            mock_gtts.assert_called_once_with(
                text="Hello, world!",
                lang='en',
                slow=False
            )
    
    def test_speak_empty_text(self, tts):
        """Test speaking empty text."""
        result = tts.speak("")
        assert result is False
    
    def test_stop(self, tts):
        """Test stopping speech."""
        tts.stop()
        tts.mixer.music.stop.assert_called_once()


##################################################
# FILE: tests/unit/test_navigation.py
##################################################

"""
Unit tests for the navigation module.
"""
import pytest
from unittest.mock import MagicMock, patch
from src.movement.navigation import RobotController

class TestRobotController:
    """Test cases for RobotController."""
    
    def test_move_forward(self, mock_robot_controller):
        """Test moving forward with a given speed."""
        # Setup
        controller = RobotController()
        test_speed = 50
        
        # Execute
        controller.move_forward(test_speed)
        
        # Verify
        controller.car.forward.assert_called_once_with(test_speed)
    
    def test_move_backward(self, mock_robot_controller):
        """Test moving backward with a given speed."""
        # Setup
        controller = RobotController()
        test_speed = 30
        
        # Execute
        controller.move_backward(test_speed)
        
        # Verify
        controller.car.backward.assert_called_once_with(test_speed)
    
    def test_turn_left(self, mock_robot_controller):
        """Test turning left by a given angle."""
        # Setup
        controller = RobotController()
        test_angle = 45
        
        # Execute
        controller.turn_left(test_angle)
        
        # Verify
        controller.car.set_dir_servo_angle.assert_called_once_with(test_angle)
    
    def test_turn_right(self, mock_robot_controller):
        """Test turning right by a given angle."""
        # Setup
        controller = RobotController()
        test_angle = 45
        
        # Execute
        controller.turn_right(test_angle)
        
        # Verify
        controller.car.set_dir_servo_angle.assert_called_once_with(-test_angle)
    
    def test_stop(self, mock_robot_controller):
        """Test stopping all movement."""
        # Setup
        controller = RobotController()
        
        # Execute
        controller.stop()
        
        # Verify
        controller.car.stop.assert_called_once()
        controller.car.set_dir_servo_angle.assert_called_once_with(0)
        controller.car.set_cam_pan_angle.assert_called_once_with(0)


##################################################
# FILE: tests/unit/test_command_handler.py
##################################################

"""
Unit tests for the command handler.
"""
import pytest
from unittest.mock import MagicMock
from src.agent.command_handler import CommandHandler

class TestCommandHandler:
    """Test cases for CommandHandler."""
    
    @pytest.fixture
    def mock_robot(self):
        """Create a mock robot controller."""
        robot = MagicMock()
        robot.move_forward = MagicMock()
        robot.move_backward = MagicMock()
        robot.turn_left = MagicMock()
        robot.turn_right = MagicMock()
        robot.stop = MagicMock()
        robot.look_around = MagicMock()
        return robot
    
    @pytest.fixture
    def handler(self, mock_robot):
        """Create a CommandHandler with a mock robot."""
        return CommandHandler(mock_robot)
    
    def test_process_command_move_forward(self, handler, mock_robot):
        """Test processing a move forward command."""
        # Test with default speed
        success, response = handler.process_command("move forward")
        assert success is True
        mock_robot.move_forward.assert_called_once_with(50)  # Default speed
        
        # Test with custom speed
        mock_robot.move_forward.reset_mock()
        success, response = handler.process_command("move forward 75 percent")
        assert success is True
        mock_robot.move_forward.assert_called_once_with(75)
    
    def test_process_command_move_backward(self, handler, mock_robot):
        """Test processing a move backward command."""
        # Test with default speed
        success, response = handler.process_command("move backward")
        assert success is True
        mock_robot.move_backward.assert_called_once_with(30)  # Default speed
        
        # Test with custom speed
        mock_robot.move_backward.reset_mock()
        success, response = handler.process_command("move backward 40 percent")
        assert success is True
        mock_robot.move_backward.assert_called_once_with(40)
    
    def test_process_command_turn_left(self, handler, mock_robot):
        """Test processing a turn left command."""
        # Test with default angle
        success, response = handler.process_command("turn left")
        assert success is True
        mock_robot.turn_left.assert_called_once_with(30)  # Default angle
        
        # Test with custom angle
        mock_robot.turn_left.reset_mock()
        success, response = handler.process_command("turn left 45 degrees")
        assert success is True
        mock_robot.turn_left.assert_called_once_with(45)
    
    def test_process_command_turn_right(self, handler, mock_robot):
        """Test processing a turn right command."""
        # Test with default angle
        success, response = handler.process_command("turn right")
        assert success is True
        mock_robot.turn_right.assert_called_once_with(30)  # Default angle
        
        # Test with custom angle
        mock_robot.turn_right.reset_mock()
        success, response = handler.process_command("turn right 45 degrees")
        assert success is True
        mock_robot.turn_right.assert_called_once_with(45)
    
    def test_process_command_stop(self, handler, mock_robot):
        """Test processing a stop command."""
        success, response = handler.process_command("stop")
        assert success is True
        mock_robot.stop.assert_called_once()
    
    def test_process_command_look_around(self, handler, mock_robot):
        """Test processing a look around command."""
        success, response = handler.process_command("look around")
        assert success is True
        mock_robot.look_around.assert_called_once()
    
    def test_process_command_help(self, handler, mock_robot):
        """Test processing a help command."""
        success, response = handler.process_command("help")
        assert success is True
        assert "Here's what I can do" in response
    
    def test_process_command_unknown(self, handler, mock_robot):
        """Test processing an unknown command."""
        success, response = handler.process_command("do something crazy")
        assert success is False
        assert "I'm not sure how to do that" in response


##################################################
# FILE: tests/conftest.py
##################################################

"""
Pytest configuration and fixtures for testing the robot.
"""
import pytest
from unittest.mock import MagicMock, patch
import os
import sys
from pathlib import Path

# Add the project root to the Python path
sys.path.append(str(Path(__file__).parent.parent))

# Fixtures
@pytest.fixture
def mock_robot_controller():
    """Create a mock RobotController for testing."""
    with patch('src.movement.navigation.RobotController') as mock:
        yield mock()

@pytest.fixture
def mock_speech_recognizer():
    """Create a mock SpeechRecognizer for testing."""
    with patch('src.voice.speech_recognition.SpeechRecognizer') as mock:
        yield mock()

@pytest.fixture
def mock_text_to_speech():
    """Create a mock TextToSpeech for testing."""
    with patch('src.voice.text_to_speech.TextToSpeech') as mock:
        yield mock()

@pytest.fixture
def test_audio_file(tmp_path):
    """Create a test audio file."""
    test_file = tmp_path / "test_audio.wav"
    test_file.write_bytes(b'RIFF$\x00\x00\x00WAVEfmt \x10\x00\x00\x00\x01\x00\x01\x00\x80>\x00\x00\x00}\x00\x00\x02\x00\x10\x00data\x00\x00\x00\x00')
    return str(test_file)


##################################################
# FILE: tests/test_movement.py
##################################################

"""
Test script for basic robot movement functionality.
"""
import time
import unittest
from unittest.mock import MagicMock, patch

from src.movement.navigation import RobotController
from src.utils.gpio_utils import setup_gpio, safe_shutdown, is_raspberry_pi

class TestRobotMovement(unittest.TestCase):
    """Test cases for robot movement."""
    
    def setUp(self):
        """Set up test fixtures."""
        # Create a mock for the Picarx class
        self.mock_car = MagicMock()
        
        # Patch the Picarx class to return our mock
        self.patcher = patch('picarx.Picarx', return_value=self.mock_car)
        self.mock_picarx = self.patcher.start()
        
        # Initialize the robot controller
        self.robot = RobotController()
        
    def tearDown(self):
        """Clean up after tests."""
        self.patcher.stop()
        
    def test_move_forward(self):
        """Test moving forward."""
        self.robot.move_forward(50)
        self.mock_car.forward.assert_called_once_with(50)
    
    def test_turn_left(self):
        """Test turning left."""
        self.robot.turn_left(30)
        self.mock_car.set_dir_servo_angle.assert_called_once_with(30)
    
    def test_stop(self):
        """Test stopping the robot."""
        self.robot.stop()
        self.mock_car.stop.assert_called_once()
        self.mock_car.set_dir_servo_angle.assert_called_once_with(0)
        self.mock_car.set_cam_pan_angle.assert_called_once_with(0)

class TestHardwareIntegration(unittest.TestCase):
    """Integration tests with actual hardware."""
    
    @classmethod
    def setUpClass(cls):
        """Set up the robot controller with actual hardware."""
        if not is_raspberry_pi():
            return
            
        try:
            # Set up GPIO before initializing hardware
            setup_gpio()
            
            # Initialize the robot controller
            cls.robot = RobotController()
            cls.hardware_available = True
            
            # Register cleanup for safe exit
            import atexit
            atexit.register(safe_shutdown)
            
        except Exception as e:
            print(f"Hardware initialization failed: {e}")
            cls.hardware_available = False
    
    def test_basic_movements(self):
        """Test basic movements if hardware is available."""
        if not self.hardware_available:
            self.skipTest("Hardware not available or initialization failed")
            
        try:
            # Test forward movement
            print("Testing forward movement...")
            self.robot.move_forward(30)
            time.sleep(1)
            self.robot.stop()
            
            # Test turning
            print("Testing turning...")
            self.robot.turn_left(30)
            time.sleep(1)
            self.robot.turn_right(30)
            time.sleep(1)
            self.robot.stop()
            
            # Test looking around
            print("Testing camera movement...")
            self.robot.look_around()
            
            print("All tests completed successfully!")
            
        except Exception as e:
            self.fail(f"Test failed with error: {e}")
        finally:
            self.robot.stop()

if __name__ == "__main__":
    unittest.main()


##################################################
# FILE: tests/integration/test_robot_commands.py
##################################################

"""
Integration tests for robot commands.
"""
import pytest
from unittest.mock import MagicMock, patch
from src.agent.command_handler import CommandHandler
from src.movement.navigation import RobotController

class TestRobotCommandsIntegration:
    """Integration tests for robot commands."""
    
    @pytest.fixture
    def robot_controller(self):
        """Create a real robot controller with a mock car."""
        with patch('picarx.Picarx') as mock_picarx:
            controller = RobotController()
            controller.car = mock_picarx()
            yield controller
    
    @pytest.fixture
    def command_handler(self, robot_controller):
        """Create a command handler with a real robot controller."""
        return CommandHandler(robot_controller)
    
    def test_move_forward_integration(self, command_handler, robot_controller):
        """Test the integration of move forward command with robot controller."""
        # Execute
        success, response = command_handler.process_command("move forward 50 percent")
        
        # Verify
        assert success is True
        robot_controller.car.forward.assert_called_once_with(50)
        assert "Moving forward at 50% speed" in response
    
    def test_turn_left_integration(self, command_handler, robot_controller):
        """Test the integration of turn left command with robot controller."""
        # Execute
        success, response = command_handler.process_command("turn left 45 degrees")
        
        # Verify
        assert success is True
        robot_controller.car.set_dir_servo_angle.assert_called_once_with(45)
        assert "Turning left 45 degrees" in response
    
    def test_stop_integration(self, command_handler, robot_controller):
        """Test the integration of stop command with robot controller."""
        # Execute
        success, response = command_handler.process_command("stop")
        
        # Verify
        assert success is True
        robot_controller.car.stop.assert_called_once()
        assert "Stopping all movement" in response


##################################################
# FILE: tests/e2e/test_voice_commands.py
##################################################

"""
End-to-end tests for voice commands.
"""
import pytest
from unittest.mock import MagicMock, patch
from src.agent.robot_agent import RobotAgent

class TestVoiceCommandsE2E:
    """End-to-end tests for voice commands."""
    
    @pytest.fixture
    def robot_agent(self):
        """Create a robot agent with mocked components."""
        with patch('src.voice.speech_recognition.SpeechRecognizer') as mock_sr, \
             patch('src.voice.text_to_speech.TextToSpeech') as mock_tts, \
             patch('src.movement.navigation.RobotController') as mock_robot:
            
            # Create the robot agent
            agent = RobotAgent(use_voice=True)
            
            # Save references to the mocks
            agent.speech_recognizer = mock_sr
            agent.tts = mock_tts
            agent.robot = mock_robot
            
            # Configure the speech recognizer
            agent.speech_recognizer.listen.return_value = "robot move forward 50 percent"
            
            yield agent
    
    def test_voice_command_processing(self, robot_agent):
        """Test that voice commands are properly processed and executed."""
        # Mock the command handler's process_command method
        mock_process_command = MagicMock(return_value=(True, "Moving forward at 50% speed"))
        robot_agent.command_handler.process_command = mock_process_command
        
        # Mock the TTS speak method
        robot_agent.tts.speak.return_value = True
        
        # Run the interactive mode (will exit after one command due to our mock)
        robot_agent.running = False  # Ensure it only runs once
        robot_agent.run_interactive()
        
        # Verify the command was processed
        mock_process_command.assert_called_once_with("move forward 50 percent")
        
        # Verify the response was spoken
        robot_agent.tts.speak.assert_called_once_with("Moving forward at 50% speed")
    
    def test_wake_word_handling(self, robot_agent):
        """Test that the wake word is properly handled."""
        # Set up the test
        robot_agent.speech_recognizer.listen.return_value = "robot what time is it"
        mock_process_command = MagicMock(return_value=(True, "The time is 3:00 PM"))
        robot_agent.command_handler.process_command = mock_process_command
        robot_agent.tts.speak.return_value = True
        
        # Run the test
        robot_agent.running = False  # Ensure it only runs once
        robot_agent.run_interactive()
        
        # Verify the wake word was removed
        mock_process_command.assert_called_once_with("what time is it")


##################################################
# FILE: deploymentplan.md
##################################################

# Deployment & Implementation Plan for Embodied AI Family Assistant Robot

This document outlines a step-by-step implementation strategy for building, testing, and deploying the family assistant robot. Each phase builds logically on the last to ensure reliability, debuggability, and modular development.

---

## Step 1: Environment Setup and Hello World

**Goal**: Confirm Raspberry Pi setup and code deploys and runs remotely.

* [ ] Flash Raspberry Pi OS onto SD card
* [ ] Enable SSH and connect Pi to WiFi
* [ ] SSH into Pi: `ssh pi@<robot_ip>`
* [ ] Install Python 3.10+, pip, and virtualenv
* [ ] Run a `main.py` with a `print("Hello, robot!")` to confirm execution

---

## Step 2: Create Modular Skeleton

**Goal**: Prepare directory structure and create stub modules.

* [ ] Set up folder tree: `voice/`, `vision/`, `memory/`, `agentic/`, etc.
* [ ] Create all files with placeholder functions and docstrings
* [ ] Confirm `main.py` can import from all submodules without error

---

## Step 3: Basic Local-Only Voice Pipeline

**Goal**: Validate Whisper STT and Google TTS in isolation (on your dev machine).

1. `voice/stt.py`

   * [ ] Load audio file
   * [ ] Transcribe with OpenAI Whisper API
2. `voice/tts.py`

   * [ ] Synthesize speech from text via Google TTS API
   * [ ] Save audio to file and play it back
3. Integration Test

   * [ ] Record short clip → STT → ChatGPT → TTS → audio

Test locally **before** deploying to Pi.

---

## Step 4: Deploy Voice Pipeline to Pi

**Goal**: Enable full audio interaction on the robot.

* [ ] Connect USB mic and speaker to Pi
* [ ] Test recording mic input and playing audio
* [ ] Deploy working `stt.py` and `tts.py`
* [ ] Run a simple voice loop: record → transcribe → respond → speak

---

## Step 5: Add Wake Word Detection

**Goal**: Add Porcupine or keyword trigger to reduce unnecessary transcription.

* [ ] Install Porcupine SDK
* [ ] Replace manual start with wake word trigger
* [ ] Confirm detection with print/log

---

## Step 6: Add Moderation and Error Handling

**Goal**: Ensure responses are family-friendly and system doesn't crash.

* [ ] `filtering/moderation.py` with OpenAI Moderation API
* [ ] Wrap tool calls with `robust_tool_execution()`
* [ ] Print fallback message on failure

---

## Step 7: Reasoning + Tool Interface (No Real Tools Yet)

**Goal**: Let the LLM return a function name to call, using dummy tools.

1. `agentic/tools.py`

   * [ ] Define test tools: `speak(text)`, `fake_tool()`
2. `agentic/reasoning.py`

   * [ ] Register tool definitions with OpenAI
   * [ ] Call model with prompt → parse tool call
   * [ ] Confirm correct function name + args

---

## Step 8: Add Basic Real Tools

**Goal**: Wire up real tools in the same format.

* [ ] Implement `google_assistant.py` to send commands
* [ ] Add `speak`, `turn_on_light`, `get_profile_info` to registry
* [ ] Test "Turn off the kitchen lights" → executes tool

---

## Step 9: Vision System: Face Recognition

**Goal**: Build local-only recognition and test live camera input.

* [ ] `vision/recognize.py` loads known encodings
* [ ] Captures frame and finds faces
* [ ] Matches against local database and returns name
* [ ] Test with images + live camera feed

---

## Step 10: Navigation + Face Scan Loop

**Goal**: Robot physically patrols and recognizes family.

* [ ] Implement `navigation.py` for driving + avoiding obstacles
* [ ] Add loop to scan room-by-room for a face match
* [ ] On match, trigger a `speak()` tool call

---

## Step 11: Memory Management

**Goal**: Enable persistent profiles and summary context.

* [ ] Implement `memory_manager.py` to log past interactions
* [ ] Store JSON profile for each person (likes, routines, etc.)
* [ ] Integrate into `reasoning.py` context prompt

---

## Step 12: Safety Layer + Real Deployment

**Goal**: Ensure robot acts responsibly and consistently.

* [ ] Add `safety_check()` before all motion
* [ ] Confirm fail-safe for motion when children are too close
* [ ] Finalize logs, retries, fallback messages
* [ ] Run in real family environment

---

## Future Optional Steps

* [ ] Streaming STT for low-latency responsiveness
* [ ] Semantic memory using FAISS embeddings
* [ ] Vision-Language-Action planning models
* [ ] Offline fallback mode for low-connectivity usage
* [ ] Integrate new Google Home Local APIs (if needed)

---

By testing each core module locally, then integrating progressively on the Pi, we minimize complexity while validating system behavior at every step.


##################################################
# FILE: README.md
##################################################

# Family Robot Assistant

A smart, voice-controlled robot assistant built on the PiCar-X platform with Raspberry Pi.

## Overview

The Family Robot Assistant is a comprehensive project that integrates various technologies to provide a safe and interactive experience for families. The project leverages the PiCar-X platform, Raspberry Pi, and a range of software components to deliver a robust and feature-rich robot assistant.

## Features

- Voice commands via speech recognition
- Object search and recognition
- Smart home integration
- Face recognition
- Safe, family-friendly interactions

### Voice Commands

The robot assistant supports voice commands via speech recognition, allowing users to interact with the robot using natural language. The speech recognition system is integrated with the robot's movement and navigation systems, enabling users to control the robot's movements and actions using voice commands.

### Object Search and Recognition

The robot assistant is equipped with computer vision capabilities, enabling it to search and recognize objects in its environment. This feature allows users to ask the robot to find specific objects, and the robot will use its vision system to locate and identify the object.

### Smart Home Integration

The robot assistant can integrate with smart home systems, enabling users to control their home's lighting, temperature, and security systems using voice commands. This feature provides a seamless and convenient way to manage smart home devices.

### Face Recognition

The robot assistant features face recognition capabilities, allowing it to recognize and respond to individual users. This feature enables the robot to provide personalized interactions and experiences for each user.

### Safe and Family-Friendly Interactions

The robot assistant is designed with safety and family-friendliness in mind. The robot's interactions are designed to be engaging and educational, while also ensuring the safety and well-being of users.

## Setup

1. Install dependencies:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: .\venv\Scripts\activate
   pip install -r requirements.txt
   ```

2. Configure environment variables in `.env`
3. Run the main application:
   ```bash
   python -m src.main
   ```

## Project Structure

```
src/
├── __init__.py
├── main.py           # Main application entry point
├── config.py         # Configuration and environment variables
├── movement/         # Robot movement and navigation
├── voice/            # Speech recognition and synthesis
├── vision/           # Computer vision components
├── memory/           # Memory and context management
└── utils/            # Utility functions and helpers
```

## Technical Details

### Hardware Components

* PiCar-X platform
* Raspberry Pi
* Camera module
* Microphone module
* Speaker module

### Software Components

* Python 3.x
* Speech recognition library (e.g. Google Cloud Speech-to-Text)
* Computer vision library (e.g. OpenCV)
* Smart home integration library (e.g. Home Assistant)

### System Requirements

* Raspberry Pi 4 or later
* 4GB or more of RAM
* 16GB or more of storage
* Internet connection

## Contributing

Contributions to the Family Robot Assistant project are welcome. If you're interested in contributing, please fork the repository and submit a pull request with your changes.

## License

The Family Robot Assistant project is licensed under the MIT License.


##################################################
# FILE: requirements-agent.txt
##################################################

# Core dependencies
numpy>=1.21.0
opencv-python>=4.5.0
pyserial>=3.5
python-dotenv>=0.19.0

# AI/ML
torch>=1.9.0
torchvision>=0.10.0
transformers>=4.15.0

# Async
asyncio>=3.4.3
aiohttp>=3.8.0

# Logging and debugging
loguru>=0.6.0

# Testing
pytest>=6.2.5
pytest-asyncio>=0.15.1
pytest-cov>=2.12.1

# Development
black>=21.12b0
isort>=5.10.1
mypy>=0.930
flake8>=4.0.1


##################################################
# FILE: setup.py
##################################################

from setuptools import setup, find_packages

setup(
    name="family-robot",
    version="0.1.0",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    install_requires=[
        "picarx>=0.1.0",
        "robot-hat>=0.1.0",
        "opencv-python>=4.5.0",
        "numpy>=1.19.0",
        "python-dotenv>=0.19.0",
        "openai>=0.27.0",
        "SpeechRecognition>=3.8.1",
        "pyaudio>=0.2.11",
        "vilib>=1.0.0",
        "RPi.GPIO>=0.7.0",
        "pyserial>=3.5",
        "pyserial-asyncio>=0.6"
    ],
    python_requires=">=3.7",
    author="Your Name",
    author_email="your.email@example.com",
    description="A smart, voice-controlled robot assistant for the PiCar-X platform",
    long_description=open("README.md").read(),
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/family-robot",
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
    ],
)


##################################################
# FILE: run_tests.sh
##################################################

#!/bin/bash
# Test runner script for the robot project

# Exit on error
set -e

echo "=== Running Unit Tests ==="
python -m pytest tests/unit/ -v --cov=src --cov-report=term-missing

echo -e "\n=== Running Integration Tests ==="
python -m pytest tests/integration/ -v

echo -e "\n=== Running End-to-End Tests ==="
python -m pytest tests/e2e/ -v

echo -e "\n=== Running Static Code Analysis ==="
flake8 src/ tests/
mypy src/ tests/

echo -e "\n=== All tests completed successfully! ==="


##################################################
# FILE: temp_keys.py
##################################################

#!/usr/bin/env python3
"""
API Keys for external services
"""

# OpenAI API Key
OPENAI_API_KEY = "your_openai_api_key_here"  # Replace with your actual API key


##################################################
# FILE: scripts/pi_flexible_search.sh
##################################################

#!/bin/bash
# Flexible script to search for and approach any object with configurable parameters
# Designed to run directly on the Raspberry Pi

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Display usage if help flag is provided
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  echo -e "${YELLOW}Usage: ./pi_flexible_search.sh <object_name> <timeout_seconds> [confidence_threshold]${NC}"
  echo ""
  echo "Parameters:"
  echo "  <object_name>         The object to search for (e.g., 'books', 'chair', 'water bottle')"
  echo "  <timeout_seconds>     Maximum time in seconds for the search (e.g., 60, 90)"
  echo "  [confidence_threshold] Optional confidence threshold (0.0-1.0, default: 0.6)"
  echo ""
  echo "Examples:"
  echo "  ./pi_flexible_search.sh 'coffee mug' 45"
  echo "  ./pi_flexible_search.sh 'laptop' 60 0.7"
  exit 0
fi

# Parse command line arguments with defaults
OBJECT="${1:-books}"
TIMEOUT="${2:-60}"
CONFIDENCE="${3:-0.6}"

# Validate parameters
if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]]; then
  echo -e "${RED}❌ Error: Timeout must be a positive integer${NC}"
  echo "Run ./pi_flexible_search.sh --help for usage information"
  exit 1
fi

if (( $(echo "$CONFIDENCE < 0.0" | bc -l) )) || (( $(echo "$CONFIDENCE > 1.0" | bc -l) )); then
  echo -e "${RED}❌ Error: Confidence threshold must be between 0.0 and 1.0${NC}"
  echo "Run ./pi_flexible_search.sh --help for usage information"
  exit 1
fi

echo -e "${YELLOW}🚀 Running search and approach for '$OBJECT' with ${TIMEOUT}s timeout and ${CONFIDENCE} confidence threshold...${NC}"

# Ensure the API key is set
echo -e "${GREEN}🔑 Checking for OpenAI API key...${NC}"
if [ ! -f .env ]; then
  echo -e "${YELLOW}⚠️ No .env file found. Please ensure OPENAI_API_KEY is set in your environment.${NC}"
fi

# Run the search with the specified parameters
echo -e "${GREEN}🧪 Running search and approach test...${NC}"
echo -e "${GREEN}🔍 Looking for '$OBJECT' (timeout: ${TIMEOUT}s, confidence: ${CONFIDENCE})...${NC}"
echo -e "${YELLOW}⏳ This may take a while depending on the timeout value...${NC}"

# Execute the search command
python -m scripts.test_object_search_standalone --object "$OBJECT" --timeout $TIMEOUT --confidence $CONFIDENCE

# Check the exit status
STATUS=$?
if [ $STATUS -eq 0 ]; then
  echo -e "${GREEN}✅ Test completed successfully!${NC}"
else
  echo -e "${RED}❌ Test encountered an error (exit code: $STATUS)${NC}"
fi


##################################################
# FILE: scripts/backpack_finder_vilib.py
##################################################

#!/usr/bin/env python3
"""
Backpack Finder for PiCar-X using vilib
Uses GPT-4 Vision to search for a backpack
Based on the working hardware initialization pattern from working_gpt_car.py
"""

import os
import sys
import time
import base64
import json
import logging
import argparse
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectFinder:
    """
    PiCar-X robot that searches for a backpack using GPT-4 Vision
    """
    
    def __init__(self):
        """Initialize the backpack finder"""
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # Initialize hardware
        self._init_hardware()
        
        # Initialize OpenAI client
        if OPENAI_AVAILABLE and OPENAI_API_KEY:
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Initialize camera using vilib (following gpt_car.py pattern)
        if CAMERA_AVAILABLE:
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized")
            return 100  # Default safe distance
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100  # Default safe distance on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="tennis ball"):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                # Move toward the object
                                self.move_toward_object(position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_object:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
            
            return found_object
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def move_toward_object(self, position):
        """Move toward the detected object based on its position with improved approach"""
        if not position:
            logger.warning("No position information available")
            return
        
        # Parse position information (format is typically "left/right/center, top/middle/bottom")
        position = position.lower()
        logger.info(f"Moving toward object at position: {position}")
        print(f"🚗 Moving toward object at {position}...")
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if "left" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = -45
            else:
                turn_angle = -30
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif "right" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = 45
            else:
                turn_angle = 30
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.5)
        
        # Check distance before moving forward
        distance = self.check_distance()
        
        # Handle invalid distance readings
        if distance < 0 or distance > 300:
            logger.warning(f"Invalid distance reading: {distance}cm, using default")
            distance = 50  # Use a reasonable default
        
        if distance < 20:  # Less than 20cm
            logger.warning(f"Obstacle detected at {distance}cm, cannot approach further")
            print(f"⚠️ Obstacle at {distance}cm, cannot approach further")
            return
        
        # Calculate approach distance based on current distance
        # Move shorter distances for more precise positioning
        approach_time = min(distance / 100, 1.0)  # Scale approach time by distance, max 1 second
        
        # Move forward toward the object
        logger.info(f"Moving forward toward object for {approach_time:.1f}s")
        print(f"🚗 Moving forward toward object for {approach_time:.1f}s...")
        
        # Move forward with appropriate speed based on distance
        speed = 40 if distance > 50 else 30  # Slower when closer
        self.move_forward(speed=speed, duration=approach_time)
        
        # Check distance again
        new_distance = self.check_distance()
        
        # Handle invalid distance readings
        if new_distance < 0 or new_distance > 300:
            logger.warning(f"Invalid distance reading: {new_distance}cm, using default")
            new_distance = 30  # Use a reasonable default
        
        if new_distance < 20:  # Less than 20cm
            logger.info(f"Reached object at {new_distance}cm")
            print(f"🎉 Reached object! Distance: {new_distance}cm")
            # Celebrate by turning in place
            self.turn(20)
            time.sleep(0.3)
            self.turn(-40)
            time.sleep(0.3)
            self.turn(20)
        elif new_distance < distance - 10:  # Made progress, try once more
            # Move a bit more if still far away but we're getting closer
            logger.info(f"Getting closer, distance: {new_distance}cm (was {distance}cm)")
            print(f"🚗 Getting closer, distance: {new_distance}cm...")
            
            # Calculate new approach time
            approach_time = min(new_distance / 150, 0.8)  # Shorter time for fine positioning
            self.move_forward(speed=25, duration=approach_time)  # Slower speed for precision
            
            # Final distance check
            final_distance = self.check_distance()
            if 0 <= final_distance < 300:  # Valid reading
                logger.info(f"Final distance to object: {final_distance}cm")
                print(f"🎉 Final distance to object: {final_distance}cm")
            else:
                logger.warning(f"Invalid final distance reading: {final_distance}cm")
                print("🎉 Reached destination!")
        else:
            # Didn't get much closer, might be a false positive or object is not directly ahead
            logger.info(f"Approach complete, final distance: {new_distance}cm")
            print(f"🎉 Approach complete, final distance: {new_distance}cm")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="PiCar-X Object Finder")
    parser.add_argument("--timeout", type=int, default=60, help="Search timeout in seconds")
    parser.add_argument("--confidence", type=float, default=0.6, help="Confidence threshold (0-1)")
    parser.add_argument("--api-key", type=str, help="OpenAI API key")
    parser.add_argument("--object", type=str, default="tennis ball", help="Object to search for")
    args = parser.parse_args()
    
    # Initialize the object finder
    finder = ObjectFinder()
    
    # Start the search
    print(f"Starting {args.object} search with timeout {args.timeout}s")
    try:
        finder.search_for_object(object_name=args.object, timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/test_camera.py
##################################################

#!/usr/bin/env python3
"""
Simple test script for the camera module.
Run this on the Raspberry Pi to test the camera.
"""
import cv2
import time
import logging
from pathlib import Path

# Add the project root to the Python path
import sys
sys.path.append(str(Path(__file__).parent.parent))

from vision.camera import Camera

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('camera_test.log')
    ]
)
logger = logging.getLogger(__name__)

def test_camera():
    """Test the camera functionality."""
    print("Testing camera...")
    camera = Camera()
    
    try:
        # Start the camera
        if not camera.start():
            print("❌ Failed to start camera")
            return False
        
        print("✅ Camera started successfully")
        print("Capturing test image in 2 seconds...")
        time.sleep(2)
        
        # Capture a frame
        frame = camera.capture_frame()
        if frame is None:
            print("❌ Failed to capture frame")
            return False
        
        print(f"✅ Captured frame with shape: {frame.shape}")
        
        # Save the frame
        image_path = camera.save_frame("camera_test")
        if image_path:
            print(f"✅ Test image saved to: {image_path}")
        else:
            print("❌ Failed to save test image")
            return False
            
        return True
        
    except Exception as e:
        logger.error(f"Camera test failed: {str(e)}", exc_info=True)
        return False
    finally:
        camera.release()

def main():
    """Run all camera tests."""
    print("=== Camera Test ===\n")
    
    if not test_camera():
        print("\n❌ Camera test failed!")
        return 1
    
    print("\n✅ All camera tests passed!")
    return 0

if __name__ == "__main__":
    sys.exit(main())


##################################################
# FILE: scripts/test_agent.py
##################################################

#!/usr/bin/env python3
"""
Test script for the agent integration
Tests the object search functionality with proper hardware initialization
"""

import os
import sys
import time
import asyncio
import logging
from typing import Dict, Any, Optional

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('agent_test.log')
    ]
)
logger = logging.getLogger(__name__)

# Import the agent integration
try:
    from src.agent.integration import get_agent_system, run_search
    logger.info("Agent integration imported successfully")
except ImportError as e:
    logger.error(f"Failed to import agent integration: {e}")
    sys.exit(1)

async def test_search(object_name: str, timeout: int = 60):
    """Test the object search functionality"""
    logger.info(f"Testing search for: {object_name}")
    
    try:
        # Initialize the agent system
        agent = get_agent_system()
        if not agent.initialize():
            logger.error("Failed to initialize agent system")
            return
        
        # Run the search
        logger.info("Starting search...")
        result = await agent.search_for_object(object_name, timeout)
        
        # Log the result
        logger.info(f"Search result: {result}")
        return result
    except Exception as e:
        logger.error(f"Test failed: {e}")
    finally:
        # Clean up
        if agent:
            agent.cleanup()

def main():
    """Main entry point"""
    # Parse command line arguments
    if len(sys.argv) < 2:
        print("Usage: python test_agent.py <object_name> [timeout]")
        sys.exit(1)
    
    object_name = sys.argv[1]
    timeout = int(sys.argv[2]) if len(sys.argv) > 2 else 60
    
    print(f"Testing search for '{object_name}' with timeout {timeout}s")
    
    try:
        # Run the test
        result = asyncio.run(test_search(object_name, timeout))
        
        # Print the result
        if result and result.get("status") == "success":
            print(f"✅ Object found: {result.get('location', 'unknown location')}")
        else:
            print(f"❌ Search failed: {result.get('message', 'unknown error')}")
    except KeyboardInterrupt:
        print("\nTest interrupted by user")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/vision_search_test.py
##################################################

#!/usr/bin/env python3
"""
Vision-based search test for PiCar-X
Uses GPT-4 Vision to search for specific objects
"""

import os
import sys
import time
import asyncio
import logging
import argparse
from pathlib import Path

# Add the project root to the Python path
project_root = str(Path(__file__).parent.parent)
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('vision_search.log')
    ]
)
logger = logging.getLogger(__name__)

# Hardware availability flag
HARDWARE_AVAILABLE = False

# Try to import hardware components
try:
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available, using mock implementations: {e}")

class PiCarXHardware:
    """
    Hardware controller for PiCar-X
    Follows the exact initialization pattern from working_gpt_car.py
    """
    
    def __init__(self):
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.position = (0, 0, 0)  # x, y, heading in degrees
        
    def initialize(self):
        """Initialize hardware components in the correct order"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return False
            
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order - EXACTLY as in working_gpt_car.py
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' instead of 'LED_R'
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
            return False
    
    async def move_forward(self, distance: float, speed: float = 50) -> None:
        """Move forward a specific distance"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            await asyncio.sleep(abs(distance) / max(speed, 1) * 0.1)
            # Update simulated position
            self.position = (
                self.position[0] + distance * 0.1,  # Simple forward movement
                self.position[1],
                self.position[2]
            )
            return
            
        try:
            logger.info(f"Moving forward {distance}m at speed {speed}")
            self.px.forward(speed)
            # Convert distance to time based on speed
            # This is an approximation and may need calibration
            await asyncio.sleep(abs(distance) / max(speed, 1) * 10)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            self.px.stop()  # Safety stop
    
    async def turn(self, degrees: float, speed: float = 50) -> None:
        """Turn in place by the specified degrees"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            await asyncio.sleep(abs(degrees) / 90 * 0.5)
            # Update simulated heading
            self.position = (
                self.position[0],
                self.position[1],
                (self.position[2] + degrees) % 360
            )
            return
            
        try:
            logger.info(f"Turning {degrees} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(degrees, 35), -35)
            
            if clamped_angle != degrees:
                logger.warning(f"Angle {degrees} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(degrees) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                await asyncio.sleep(abs(degrees) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                await asyncio.sleep(abs(degrees) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            self.px.set_dir_servo_angle(0)  # Reset steering
    
    async def check_obstacles(self) -> float:
        """Check for obstacles using ultrasonic sensor"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating obstacle check")
            return 100.0  # Simulate no obstacles
            
        try:
            # Get distance from ultrasonic sensor
            distance = self.px.ultrasonic.read()
            logger.info(f"Obstacle distance: {distance}cm")
            return distance
        except Exception as e:
            logger.error(f"Obstacle check error: {e}")
            return 100.0  # Default to no obstacles on error
    
    def get_position(self):
        """Get the current position and heading"""
        return self.position
    
    def cleanup(self):
        """Clean up hardware resources"""
        if self.initialized:
            try:
                logger.info("Cleaning up hardware resources")
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

class SimpleSearchMemory:
    """Simple memory for search operations"""
    
    def __init__(self):
        self.visited_areas = []
        self.object_sightings = {}
        logger.info("Initialized simple search memory")
    
    def record_visit(self, position):
        """Record that we visited a position"""
        self.visited_areas.append(position)
        logger.info(f"Recorded visit to position {position}")
    
    def record_sighting(self, object_name, position, confidence):
        """Record an object sighting"""
        if object_name not in self.object_sightings:
            self.object_sightings[object_name] = []
        
        self.object_sightings[object_name].append({
            'position': position,
            'confidence': confidence,
            'timestamp': time.time()
        })
        logger.info(f"Recorded sighting of {object_name} at {position} with {confidence:.1%} confidence")

async def vision_search(car, vision, object_name="backpack", timeout=60, confidence_threshold=0.6):
    """
    Search for an object using vision
    Uses a spiral search pattern and GPT-4 Vision for object detection
    """
    logger.info(f"Starting vision search for {object_name}")
    print(f"🔍 Searching for {object_name}...")
    
    # Create memory
    memory = SimpleSearchMemory()
    
    # Spiral search pattern parameters
    spiral_steps = 5  # Number of steps in the spiral
    step_size = 0.3   # Distance to move in each step (meters)
    turn_angle = 45   # Angle to turn after each step (degrees)
    
    start_time = time.time()
    found_object = False
    
    try:
        # Execute the spiral search pattern
        for step in range(spiral_steps):
            # Check timeout
            if time.time() - start_time > timeout:
                logger.warning(f"Search timed out after {timeout}s")
                print(f"⏱️ Search timed out after {timeout}s")
                break
            
            # Calculate step distance (increases with spiral)
            step_distance = step_size * (1 + step * 0.2)
            
            # Check for obstacles
            distance = await car.check_obstacles()
            if distance < 20:  # Less than 20cm
                logger.warning(f"Obstacle detected at {distance}cm, turning to avoid")
                print(f"⚠️ Obstacle detected at {distance}cm, turning to avoid")
                await car.turn(90)  # Turn away from obstacle
                continue
            
            # Move forward
            logger.info(f"Moving forward {step_distance}m (step {step+1}/{spiral_steps})")
            await car.move_forward(step_distance)
            
            # Record the visit
            current_position = car.get_position()
            memory.record_visit(current_position)
            
            # Scan for objects with vision
            logger.info(f"Scanning for {object_name}")
            print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
            
            # Capture image and detect objects
            detected_objects = await vision.detect_objects()
            
            # Check if we found the target object
            for obj in detected_objects:
                obj_name = obj['name'].lower()
                confidence = obj['confidence']
                
                # Check if this matches our target object
                if object_name.lower() in obj_name and confidence >= confidence_threshold:
                    # Record the sighting
                    memory.record_sighting(
                        object_name=obj['name'],
                        position=obj['position'],
                        confidence=confidence
                    )
                    
                    # Return success
                    logger.info(f"Found {obj_name} at {obj['position']} with {confidence:.1%} confidence")
                    print(f"✅ Found {obj_name} at {obj['position']} with {confidence:.1%} confidence!")
                    found_object = True
                    break
                else:
                    # Log other objects seen
                    logger.info(f"Saw {obj_name} with {confidence:.1%} confidence, but looking for {object_name}")
                    print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence, but looking for {object_name}")
            
            if found_object:
                break
            
            # Turn for next step in spiral
            logger.info(f"Turning {turn_angle} degrees")
            await car.turn(turn_angle)
        
        if not found_object:
            logger.warning(f"❌ Failed to find {object_name}")
            print(f"❌ Failed to find {object_name}")
        
        elapsed = time.time() - start_time
        logger.info(f"Search completed in {elapsed:.1f}s")
        print(f"🕒 Search completed in {elapsed:.1f}s")
        
        return found_object, memory.object_sightings
    
    except Exception as e:
        logger.error(f"Vision search failed: {e}")
        print(f"❌ Vision search failed: {e}")
        return False, {}

async def run_vision_search(args):
    """Run the vision-based search"""
    car = None
    vision = None
    
    try:
        # Initialize hardware
        car = PiCarXHardware()
        result = car.initialize()
        
        if result:
            logger.info("✅ Hardware initialized successfully")
            print("✅ Hardware initialized successfully")
        else:
            logger.warning("❌ Hardware initialization failed, running in simulation mode")
            print("❌ Hardware initialization failed, running in simulation mode")
        
        # Initialize vision
        try:
            # Import the GPT Vision module
            from src.vision.gpt_vision import get_gpt_vision
            vision = get_gpt_vision()
            logger.info("Vision system initialized")
            print("📷 Vision system initialized")
        except Exception as e:
            logger.error(f"Failed to initialize vision: {e}")
            print(f"❌ Failed to initialize vision: {e}")
            return
        
        # Run the vision search
        found, sightings = await vision_search(
            car=car,
            vision=vision,
            object_name=args.object_name,
            timeout=args.timeout,
            confidence_threshold=args.confidence
        )
        
        # Print summary of what we found
        if found:
            print("\n=== Search Results ===")
            print(f"✅ Successfully found {args.object_name}!")
            
            # Print details of all sightings
            for obj_name, obj_sightings in sightings.items():
                print(f"\n{obj_name}:")
                for sighting in obj_sightings:
                    print(f"  - Position: {sighting['position']}, Confidence: {sighting['confidence']:.1%}")
        else:
            print("\n=== Search Results ===")
            print(f"❌ Did not find {args.object_name}")
            
            # Print what we did see
            if sightings:
                print("\nOther objects detected:")
                for obj_name, obj_sightings in sightings.items():
                    print(f"  - {obj_name}: {len(obj_sightings)} sightings")
    
    finally:
        # Clean up
        if car:
            car.cleanup()
        
        if vision:
            vision.cleanup()

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Vision-based search for PiCar-X')
    parser.add_argument('--object-name', type=str, default="backpack", help='Object to search for')
    parser.add_argument('--timeout', type=int, default=60, help='Search timeout in seconds')
    parser.add_argument('--confidence', type=float, default=0.6, help='Confidence threshold (0-1)')
    
    args = parser.parse_args()
    
    print(f"Starting vision search for {args.object_name} with timeout {args.timeout}s")
    
    try:
        # Run the vision search
        asyncio.run(run_vision_search(args))
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/backpack_finder.py
##################################################

#!/usr/bin/env python3
"""
Backpack Finder for PiCar-X
Uses GPT-4 Vision to search for a backpack
Based on the working hardware initialization pattern from working_gpt_car.py
"""

import os
import sys
import time
import base64
import json
import logging
import argparse
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import camera modules
try:
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("OpenCV available for camera access")
except ImportError:
    logger.warning("OpenCV not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class BackpackFinder:
    """
    PiCar-X robot that searches for a backpack using GPT-4 Vision
    """
    
    def __init__(self):
        """Initialize the backpack finder"""
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera = None
        
        # Initialize hardware
        self._init_hardware()
        
        # Initialize OpenAI client
        if OPENAI_AVAILABLE and OPENAI_API_KEY:
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Initialize camera
        if CAMERA_AVAILABLE:
            try:
                self.camera = cv2.VideoCapture(0)
                if not self.camera.isOpened():
                    raise Exception("Could not open camera")
                logger.info("Camera initialized with OpenCV")
            except Exception as e:
                logger.error(f"Failed to initialize camera: {e}")
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating distance check")
            return 100.0  # Simulate no obstacles
        
        try:
            distance = self.px.ultrasonic.read()
            logger.info(f"Distance: {distance}cm")
            return distance
        except Exception as e:
            logger.error(f"Distance check error: {e}")
            return 100.0  # Default to no obstacles on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera"""
        if not self.camera:
            logger.warning("Camera not available")
            return None
        
        try:
            # Capture frame
            ret, frame = self.camera.read()
            if not ret:
                logger.warning("Failed to capture image")
                return None
            
            # Save the image
            cv2.imwrite(save_path, frame)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a backpack if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4-vision-preview",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_backpack(self, timeout=60, confidence_threshold=0.6):
        """Search for a backpack using a simple search pattern"""
        logger.info("Starting search for backpack")
        print("🔍 Searching for backpack...")
        
        start_time = time.time()
        found_backpack = False
        search_pattern = [
            # (action, parameter)
            # action can be "forward", "turn", or "scan"
            ("scan", None),  # Initial scan
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Scan again
            ("turn", 45),  # Turn right
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Scan again
            ("turn", -90),  # Turn left
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Scan again
            ("turn", 45),  # Return to center
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Final scan
        ]
        
        try:
            # Execute the search pattern
            for i, (action, param) in enumerate(search_pattern):
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Check for obstacles
                if action in ["forward", "turn"]:
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, turning to avoid")
                        print(f"⚠️ Obstacle detected at {distance}cm, turning to avoid")
                        self.turn(90)  # Turn away from obstacle
                        continue
                
                # Execute the action
                if action == "forward":
                    logger.info(f"Moving forward for {param}s")
                    print(f"🚗 Moving forward...")
                    self.move_forward(speed=50, duration=param)
                
                elif action == "turn":
                    logger.info(f"Turning {param} degrees")
                    print(f"🔄 Turning {param} degrees...")
                    self.turn(param)
                
                elif action == "scan":
                    logger.info("Scanning for backpack")
                    print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                    
                    # Capture image
                    image_path = self.capture_image()
                    if not image_path:
                        logger.warning("Failed to capture image")
                        continue
                    
                    # Analyze image with GPT-4 Vision
                    objects = self.analyze_image_with_gpt4(image_path)
                    
                    # Check if we found a backpack
                    for obj in objects:
                        obj_name = obj.get("name", "").lower()
                        confidence = obj.get("confidence", 0)
                        position = obj.get("position", "unknown")
                        
                        if "backpack" in obj_name and confidence >= confidence_threshold:
                            logger.info(f"Found backpack with {confidence:.1%} confidence at {position}")
                            print(f"✅ Found backpack with {confidence:.1%} confidence at {position}!")
                            found_backpack = True
                            break
                        else:
                            # Log other objects seen
                            logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                            print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                    
                    if found_backpack:
                        break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_backpack:
                logger.warning("Failed to find backpack")
                print("❌ Failed to find backpack")
            
            return found_backpack
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera:
            try:
                self.camera.release()
                logger.info("Camera released")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Search for a backpack using PiCar-X and GPT-4 Vision')
    parser.add_argument('--timeout', type=int, default=60, help='Search timeout in seconds')
    parser.add_argument('--confidence', type=float, default=0.6, help='Confidence threshold (0-1)')
    parser.add_argument('--api-key', type=str, help='OpenAI API key (optional)')
    
    args = parser.parse_args()
    
    # Set API key if provided
    if args.api_key:
        os.environ["OPENAI_API_KEY"] = args.api_key
    
    print(f"Starting backpack search with timeout {args.timeout}s")
    
    # Create and run the backpack finder
    finder = None
    try:
        finder = BackpackFinder()
        finder.search_for_backpack(timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/robot_object_finder.py
##################################################

#!/usr/bin/env python3
"""
Backpack Finder for PiCar-X using vilib
Uses GPT-4 Vision to search for a backpack
Based on the working hardware initialization pattern from working_gpt_car.py
"""

import os
import sys
import time
import base64
import json
import logging
import argparse
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectFinder:
    """
    PiCar-X robot that searches for a backpack using GPT-4 Vision
    """
    
    def __init__(self):
        """Initialize the backpack finder"""
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # Initialize hardware
        self._init_hardware()
        
        # Initialize OpenAI client
        if OPENAI_AVAILABLE and OPENAI_API_KEY:
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Initialize camera using vilib (following gpt_car.py pattern)
        if CAMERA_AVAILABLE:
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized")
            return 100  # Default safe distance
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100  # Default safe distance on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="tennis ball"):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                # Move toward the object
                                self.move_toward_object(position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_object:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
            
            return found_object
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def move_toward_object(self, position):
        """Move toward the detected object based on its position with improved approach"""
        if not position:
            logger.warning("No position information available")
            return
        
        # Parse position information (format is typically "left/right/center, top/middle/bottom")
        position = position.lower()
        logger.info(f"Moving toward object at position: {position}")
        print(f"🚗 Moving toward object at {position}...")
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if "left" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = -45
            else:
                turn_angle = -30
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif "right" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = 45
            else:
                turn_angle = 30
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.5)
        
        # Check distance before moving forward
        distance = self.check_distance()
        
        # Handle invalid distance readings
        if distance < 0 or distance > 300:
            logger.warning(f"Invalid distance reading: {distance}cm, using default")
            distance = 50  # Use a reasonable default
        
        if distance < 20:  # Less than 20cm
            logger.warning(f"Obstacle detected at {distance}cm, cannot approach further")
            print(f"⚠️ Obstacle at {distance}cm, cannot approach further")
            return
        
        # Calculate approach distance based on current distance
        # Move shorter distances for more precise positioning
        approach_time = min(distance / 100, 1.0)  # Scale approach time by distance, max 1 second
        
        # Move forward toward the object
        logger.info(f"Moving forward toward object for {approach_time:.1f}s")
        print(f"🚗 Moving forward toward object for {approach_time:.1f}s...")
        
        # Move forward with appropriate speed based on distance
        speed = 40 if distance > 50 else 30  # Slower when closer
        self.move_forward(speed=speed, duration=approach_time)
        
        # Check distance again
        new_distance = self.check_distance()
        
        # Handle invalid distance readings
        if new_distance < 0 or new_distance > 300:
            logger.warning(f"Invalid distance reading: {new_distance}cm, using default")
            new_distance = 30  # Use a reasonable default
        
        if new_distance < 20:  # Less than 20cm
            logger.info(f"Reached object at {new_distance}cm")
            print(f"🎉 Reached object! Distance: {new_distance}cm")
            # Celebrate by turning in place
            self.turn(20)
            time.sleep(0.3)
            self.turn(-40)
            time.sleep(0.3)
            self.turn(20)
        elif new_distance < distance - 10:  # Made progress, try once more
            # Move a bit more if still far away but we're getting closer
            logger.info(f"Getting closer, distance: {new_distance}cm (was {distance}cm)")
            print(f"🚗 Getting closer, distance: {new_distance}cm...")
            
            # Calculate new approach time
            approach_time = min(new_distance / 150, 0.8)  # Shorter time for fine positioning
            self.move_forward(speed=25, duration=approach_time)  # Slower speed for precision
            
            # Final distance check
            final_distance = self.check_distance()
            if 0 <= final_distance < 300:  # Valid reading
                logger.info(f"Final distance to object: {final_distance}cm")
                print(f"🎉 Final distance to object: {final_distance}cm")
            else:
                logger.warning(f"Invalid final distance reading: {final_distance}cm")
                print("🎉 Reached destination!")
        else:
            # Didn't get much closer, might be a false positive or object is not directly ahead
            logger.info(f"Approach complete, final distance: {new_distance}cm")
            print(f"🎉 Approach complete, final distance: {new_distance}cm")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="PiCar-X Object Finder")
    parser.add_argument("--timeout", type=int, default=60, help="Search timeout in seconds")
    parser.add_argument("--confidence", type=float, default=0.6, help="Confidence threshold (0-1)")
    parser.add_argument("--api-key", type=str, help="OpenAI API key")
    parser.add_argument("--object", type=str, default="tennis ball", help="Object to search for")
    args = parser.parse_args()
    
    # Initialize the object finder
    finder = ObjectFinder()
    
    # Start the search
    print(f"Starting {args.object} search with timeout {args.timeout}s")
    try:
        finder.search_for_object(object_name=args.object, timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/setup_venv.sh
##################################################

#!/bin/bash
# Set up a virtual environment for PiCar-X vision search

echo "Setting up virtual environment for PiCar-X vision search..."

# Install python3-venv if not already installed
echo "Installing python3-venv..."
sudo apt-get update
sudo apt-get install -y python3-venv python3-full

# Create a virtual environment
echo "Creating virtual environment..."
python3 -m venv ~/family-robot/venv

# Activate the virtual environment and install dependencies
echo "Installing dependencies in virtual environment..."
source ~/family-robot/venv/bin/activate
pip install --upgrade pip
pip install openai opencv-python gtts

# Check if dependencies are installed
echo "Checking if dependencies are installed..."
python -c "import openai; print('OpenAI installed successfully')" || echo "Failed to install OpenAI"
python -c "import cv2; print('OpenCV installed successfully')" || echo "Failed to install OpenCV"
python -c "import gtts; print('gTTS installed successfully')" || echo "Failed to install gTTS"

# Create an activation script for easy use
echo "Creating activation script..."
cat > ~/family-robot/activate_venv.sh << 'EOF'
#!/bin/bash
source ~/family-robot/venv/bin/activate
echo "Virtual environment activated. Run 'deactivate' to exit."
EOF

chmod +x ~/family-robot/activate_venv.sh

echo "Virtual environment setup complete!"
echo "To activate the virtual environment, run: source ~/family-robot/activate_venv.sh"


##################################################
# FILE: scripts/setup_key.py
##################################################

#!/usr/bin/env python3
"""
Simple script to set up the OpenAI API key on the Pi
"""

import os
import sys
import argparse

def main():
    parser = argparse.ArgumentParser(description='Set up OpenAI API key')
    parser.add_argument('api_key', type=str, help='Your OpenAI API key')
    args = parser.parse_args()
    
    # Create keys.py file with the API key
    with open('keys.py', 'w') as f:
        f.write(f'OPENAI_API_KEY = "{args.api_key}"\n')
    
    print(f"✅ API key saved to keys.py")
    print(f"🔑 You can now run the object finder with: python3 standalone_object_finder.py")

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/standalone_object_finder.py
##################################################

#!/usr/bin/env python3
"""
Standalone Object Finder for PiCar-X
This script provides a simplified version of the object search functionality
that doesn't depend on the full agent architecture
"""

import os
import sys
import time
import base64
import logging
import argparse
import json
from typing import Dict, Any, List, Tuple, Optional
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('object_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import required libraries
try:
    import cv2
    import openai
    import vilib
    from picarx import Picarx
    from robot_hat import Ultrasonic, Pin
    from picamera2 import Picamera2
except ImportError as e:
    logger.error(f"Failed to import required libraries: {e}")
    logger.error("Make sure to install: opencv-python, openai, vilib, picarx, robot_hat, picamera2")
    sys.exit(1)

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class StandaloneObjectFinder:
    """
    Standalone implementation of the object finder functionality
    """
    
    def __init__(self, api_key=None, confidence_threshold=0.6):
        """Initialize the object finder"""
        self.api_key = api_key or OPENAI_API_KEY
        self.confidence_threshold = confidence_threshold
        self.camera_initialized = False
        self.px = None
        self.ultrasonic = None
        self.client = None
        self.searching = False
        
        # Initialize OpenAI client
        if self.api_key:
            try:
                self.client = openai.OpenAI(api_key=self.api_key)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        else:
            logger.error("No OpenAI API key provided")
            sys.exit(1)
    
    def initialize_hardware(self):
        """Initialize the PiCar-X hardware"""
        try:
            # Initialize PiCar-X
            self.px = Picarx()
            logger.info("PiCar-X initialized")
            
            # Initialize ultrasonic sensor
            self.ultrasonic = Ultrasonic(trig=Pin('D2'), echo=Pin('D3'))
            logger.info("Ultrasonic sensor initialized")
            
            # Initialize camera
            vilib.init_camera()
            vilib.camera_start()
            time.sleep(2)  # Give camera time to initialize
            self.camera_initialized = True
            logger.info("Camera initialized")
            
            return True
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            return False
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Use vilib.img attribute to get the current frame
            if hasattr(vilib, 'img') and vilib.img is not None:
                cv2.imwrite(save_path, vilib.img)
                logger.info(f"Image captured and saved to {save_path}")
                return save_path
            else:
                logger.warning("No image available from vilib")
                return None
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.ultrasonic:
            logger.warning("Ultrasonic sensor not initialized")
            return 100.0  # Default safe distance
        
        # Take multiple readings to improve reliability
        readings = []
        for _ in range(3):
            try:
                distance = self.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            except Exception as e:
                logger.error(f"Distance sensor error: {e}")
        
        # Calculate average of valid readings
        if readings:
            avg_distance = sum(readings) / len(readings)
            logger.info(f"Distance: {avg_distance:.2f}cm")
            return avg_distance
        else:
            logger.warning("No valid distance readings")
            return 100.0  # Default safe distance
    
    def detect_object(self, image_path, object_name):
        """Detect objects in an image using GPT-4 Vision"""
        if not self.client:
            logger.error("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.error(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Create prompt for GPT-4 Vision
            prompt = (
                f"Identify all objects visible in this image. I'm specifically looking for a {object_name}. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            # Call GPT-4 Vision API
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract and parse response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Parse the response
            return self._parse_vision_response(result)
            
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def _parse_vision_response(self, response_text):
        """Parse the GPT-4 Vision response text"""
        try:
            # Try to extract JSON from the response
            import json
            import re
            
            # Look for JSON array in the response
            json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
                objects = json.loads(json_str)
                
                # Convert to our standard format
                result = []
                for obj in objects:
                    # Extract position information
                    position = obj.get('position', '').lower()
                    
                    result.append({
                        'name': obj.get('name', 'unknown'),
                        'confidence': obj.get('confidence', 0.5),
                        'position': position
                    })
                
                return result
            
            # If no JSON found, try to extract information from text
            objects = []
            lines = response_text.split('\n')
            current_object = {}
            
            for line in lines:
                if not line.strip():
                    continue
                
                # Check for object name
                if ':' not in line and not current_object:
                    current_object = {'name': line.strip(), 'confidence': 0.7}
                
                # Check for confidence
                elif 'confidence' in line.lower():
                    try:
                        confidence = float(re.search(r'(\d+(\.\d+)?)', line).group(1))
                        if confidence > 1:
                            confidence /= 100  # Convert percentage to decimal
                        current_object['confidence'] = confidence
                    except:
                        pass
                
                # Check for position
                elif 'position' in line.lower():
                    position = line.lower().split(':')[-1].strip()
                    current_object['position'] = position
                
                # If we have a complete object, add it to the list
                if 'name' in current_object and 'confidence' in current_object:
                    if 'position' not in current_object:
                        current_object['position'] = 'center, middle'
                    
                    objects.append(current_object)
                    current_object = {}
            
            return objects
        
        except Exception as e:
            logger.error(f"Failed to parse vision response: {e}")
            return []
    
    def turn_toward_object(self, position):
        """Turn toward the detected object based on its position"""
        if not self.px:
            logger.warning("PiCar-X not initialized")
            return
        
        logger.info(f"Turning toward object at position: {position}")
        
        # Parse position string
        position = position.lower()
        
        # Determine turn angle based on horizontal position
        angle = 0
        if "left" in position:
            if "far" in position:
                angle = -45
            else:
                angle = -30
            logger.info(f"Turning left {abs(angle)} degrees")
            self.px.set_dir_servo_angle(angle)
            time.sleep(1)
        elif "right" in position:
            if "far" in position:
                angle = 45
            else:
                angle = 30
            logger.info(f"Turning right {angle} degrees")
            self.px.set_dir_servo_angle(angle)
            time.sleep(1)
        
        # Reset steering
        self.px.set_dir_servo_angle(0)
    
    def move_toward_object(self, position):
        """Move toward the detected object"""
        if not self.px:
            logger.warning("PiCar-X not initialized")
            return
        
        # First, turn toward the object
        self.turn_toward_object(position)
        
        # Check distance before moving
        distance = self.check_distance()
        if distance < 20:  # Too close, don't move
            logger.info(f"Object is too close ({distance:.2f}cm), not moving forward")
            return
        
        # Move forward based on distance
        move_time = min(distance / 100, 1.0)  # Scale move time by distance, max 1 second
        logger.info(f"Moving forward for {move_time:.2f}s")
        self.px.forward(50)  # 50% speed
        time.sleep(move_time)
        self.px.stop()
        
        # Check distance again
        distance = self.check_distance()
        logger.info(f"Distance after move: {distance:.2f}cm")
        
        # If still far, move a bit more
        if distance > 30:
            move_time = min(distance / 200, 0.5)  # Shorter move time
            logger.info(f"Still far, moving forward for {move_time:.2f}s more")
            self.px.forward(30)  # Slower speed
            time.sleep(move_time)
            self.px.stop()
            
            # Final distance check
            distance = self.check_distance()
            logger.info(f"Final distance: {distance:.2f}cm")
        
        # Celebrate finding the object
        logger.info("Object reached! Celebrating...")
        self.px.set_dir_servo_angle(30)
        time.sleep(0.5)
        self.px.set_dir_servo_angle(-30)
        time.sleep(0.5)
        self.px.set_dir_servo_angle(0)
    
    def search_for_object(self, object_name, timeout=60):
        """Search for an object using a comprehensive search pattern"""
        if not self.initialize_hardware():
            logger.error("Failed to initialize hardware")
            return False
        
        logger.info(f"Starting search for {object_name} with timeout {timeout}s")
        self.searching = True
        start_time = time.time()
        
        try:
            # First, perform a 360-degree scan in place
            scan_angles = [0, 45, 90, 135, 180, 225, 270, 315]
            
            for angle in scan_angles:
                if not self.searching or time.time() - start_time >= timeout:
                    break
                
                # Turn to the scan angle
                logger.info(f"Turning to {angle} degrees for scan")
                self.px.set_dir_servo_angle(angle % 90)  # Keep within servo limits
                time.sleep(1)
                
                # Capture image and detect objects
                image_path = self.capture_image()
                if not image_path:
                    continue
                
                # Detect objects in the image
                objects = self.detect_object(image_path, object_name)
                
                # Check if the target object is in the detected objects
                for obj in objects:
                    obj_name = obj.get('name', '').lower()
                    confidence = obj.get('confidence', 0.0)
                    position = obj.get('position', '')
                    
                    # Log what we see
                    logger.info(f"Saw {obj_name} with {confidence:.1%} confidence at {position}")
                    
                    # Check if this is our target object
                    if object_name.lower() in obj_name and confidence >= self.confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        
                        # Move toward the object
                        self.move_toward_object(position)
                        
                        return True
            
            # If not found in initial scan, start exploration pattern
            logger.info(f"{object_name} not found in initial scan, starting exploration")
            
            # Set up exploration parameters
            search_angles = [0, 45, -45, 90, -90]
            
            # Continue searching until timeout
            while time.time() - start_time < timeout and self.searching:
                # Try different angles
                for angle in search_angles:
                    if not self.searching or time.time() - start_time >= timeout:
                        break
                    
                    # Turn to the search angle
                    logger.info(f"Turning to {angle} degrees for exploration")
                    self.px.set_dir_servo_angle(angle)
                    time.sleep(1)
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        continue
                    
                    # Move forward if path is clear
                    logger.info("Moving forward to explore")
                    self.px.forward(40)
                    time.sleep(0.7)
                    self.px.stop()
                    
                    # Capture image and detect objects
                    image_path = self.capture_image()
                    if not image_path:
                        continue
                    
                    # Detect objects in the image
                    objects = self.detect_object(image_path, object_name)
                    
                    # Check if the target object is in the detected objects
                    for obj in objects:
                        obj_name = obj.get('name', '').lower()
                        confidence = obj.get('confidence', 0.0)
                        position = obj.get('position', '')
                        
                        # Log what we see
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence at {position}")
                        
                        # Check if this is our target object
                        if object_name.lower() in obj_name and confidence >= self.confidence_threshold:
                            logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                            
                            # Move toward the object
                            self.move_toward_object(position)
                            
                            return True
            
            # Object not found within timeout
            logger.info(f"Search completed, {object_name} not found within {timeout}s")
            return False
            
        except KeyboardInterrupt:
            logger.info("Search interrupted by user")
            return False
        except Exception as e:
            logger.error(f"Error during search: {e}")
            return False
        finally:
            self.searching = False
            self.cleanup()
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Stop the car
        if self.px:
            self.px.stop()
        
        # Release the camera
        if self.camera_initialized:
            try:
                vilib.camera_release()
                logger.info("Camera released")
            except:
                pass
        
        logger.info("Cleanup complete")

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='PiCar-X Object Finder')
    parser.add_argument('--object', type=str, default='tennis ball', help='Object to search for')
    parser.add_argument('--timeout', type=int, default=60, help='Search timeout in seconds')
    parser.add_argument('--confidence', type=float, default=0.6, help='Confidence threshold (0.0-1.0)')
    parser.add_argument('--api-key', type=str, help='OpenAI API key (optional)')
    args = parser.parse_args()
    
    # Create the object finder
    finder = StandaloneObjectFinder(
        api_key=args.api_key,
        confidence_threshold=args.confidence
    )
    
    # Search for the object
    print(f"🔍 Starting search for {args.object} with timeout {args.timeout}s...")
    result = finder.search_for_object(args.object, args.timeout)
    
    # Display the result
    if result:
        print(f"✅ Found {args.object}!")
    else:
        print(f"❌ {args.object} not found within {args.timeout}s")

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/install_dependencies.sh
##################################################

#!/bin/bash
# Install dependencies for PiCar-X vision search

echo "Installing dependencies for PiCar-X vision search..."

# Update package lists
echo "Updating package lists..."
sudo apt-get update

# Install Python dependencies
echo "Installing Python dependencies..."
pip3 install --upgrade pip
pip3 install openai
pip3 install opencv-python
pip3 install gtts

# Check if dependencies are installed
echo "Checking if dependencies are installed..."
python3 -c "import openai; print('OpenAI installed successfully')" || echo "Failed to install OpenAI"
python3 -c "import cv2; print('OpenCV installed successfully')" || echo "Failed to install OpenCV"
python3 -c "import gtts; print('gTTS installed successfully')" || echo "Failed to install gTTS"

echo "Dependency installation complete!"


##################################################
# FILE: scripts/generate_code_dump.sh
##################################################

#!/bin/bash

# Script to generate a code dump of all files in the repository
# Creates code-dump.txt with file paths and contents

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Output file
OUTPUT_FILE="code-dump.txt"
REPO_ROOT="/Users/ethangrabau/Robot_Car"
EXCLUDE_DIRS=("__pycache__" "venv" ".git" "legacy_scripts" ".idea" ".vscode")
EXCLUDE_EXTENSIONS=("pyc" "jpg" "jpeg" "png" "gif" "zip" "tar" "gz" "mp3" "mp4" "wav" "pdf")

# Change to repository root
cd "$REPO_ROOT" || { echo -e "${RED}Error: Could not change to repository root${NC}"; exit 1; }

# Clear or create output file
echo "# Robot Car Code Dump - $(date)" > "$OUTPUT_FILE"
echo "# Repository: $REPO_ROOT" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Function to check if directory should be excluded
is_excluded_dir() {
  local dir="$1"
  for excluded in "${EXCLUDE_DIRS[@]}"; do
    if [[ "$dir" == *"/$excluded"* || "$dir" == *"/$excluded" ]]; then
      return 0 # True, should exclude
    fi
  done
  return 1 # False, should not exclude
}

# Function to check if file should be excluded based on extension
is_excluded_extension() {
  local file="$1"
  local ext="${file##*.}"
  for excluded in "${EXCLUDE_EXTENSIONS[@]}"; do
    if [[ "$ext" == "$excluded" ]]; then
      return 0 # True, should exclude
    fi
  done
  return 1 # False, should not exclude
}

# Function to process a file
process_file() {
  local file="$1"
  local rel_path="${file#$REPO_ROOT/}"
  
  # Skip files with excluded extensions
  if is_excluded_extension "$file"; then
    echo -e "${YELLOW}Skipping binary/large file: $rel_path${NC}"
    return
  fi
  
  # Skip very large files (>1MB)
  local size=$(wc -c < "$file")
  if (( size > 1000000 )); then
    echo -e "${YELLOW}Skipping large file ($size bytes): $rel_path${NC}"
    return
  fi
  
  echo -e "${GREEN}Processing: $rel_path${NC}"
  
  # Add file header to output
  echo "##################################################" >> "$OUTPUT_FILE"
  echo "# FILE: $rel_path" >> "$OUTPUT_FILE"
  echo "##################################################" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
  
  # Add file content
  cat "$file" >> "$OUTPUT_FILE"
  
  # Add newlines after file
  echo "" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
}

# Find all files and process them
echo -e "${GREEN}Generating code dump...${NC}"
file_count=0

while IFS= read -r -d '' file; do
  dir=$(dirname "$file")
  
  # Skip excluded directories
  if is_excluded_dir "$dir"; then
    continue
  fi
  
  process_file "$file"
  ((file_count++))
done < <(find "$REPO_ROOT" -type f -not -path "*/\.*" -print0)

# Add summary at the end
echo "# End of code dump - $file_count files included" >> "$OUTPUT_FILE"

echo -e "${GREEN}Code dump generated: $OUTPUT_FILE${NC}"
echo -e "${GREEN}Included $file_count files${NC}"
echo -e "${YELLOW}You can now upload this file to ChatGPT for analysis${NC}"


##################################################
# FILE: scripts/backpack_finder_fixed.py
##################################################

#!/usr/bin/env python3
"""
Backpack Finder for PiCar-X using vilib
Uses GPT-4 Vision to search for a backpack
Based on the working hardware initialization pattern from working_gpt_car.py
"""

import os
import sys
import time
import base64
import json
import logging
import argparse
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class BackpackFinder:
    """
    PiCar-X robot that searches for a backpack using GPT-4 Vision
    """
    
    def __init__(self):
        """Initialize the backpack finder"""
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # Initialize hardware
        self._init_hardware()
        
        # Initialize OpenAI client
        if OPENAI_AVAILABLE and OPENAI_API_KEY:
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Initialize camera using vilib (following gpt_car.py pattern)
        if CAMERA_AVAILABLE:
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.show_fps()
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating distance check")
            return 100.0  # Simulate no obstacles
        
        try:
            distance = self.px.ultrasonic.read()
            logger.info(f"Distance: {distance}cm")
            return distance
        except Exception as e:
            logger.error(f"Distance check error: {e}")
            return 100.0  # Default to no obstacles on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            # This is the key fix - using Vilib.img instead of Vilib.get_image()
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a backpack if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_backpack(self, timeout=60, confidence_threshold=0.6):
        """Search for a backpack using a simple search pattern"""
        logger.info("Starting search for backpack")
        print("🔍 Searching for backpack...")
        
        start_time = time.time()
        found_backpack = False
        search_pattern = [
            # (action, parameter)
            # action can be "forward", "turn", or "scan"
            ("scan", None),  # Initial scan
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Scan again
            ("turn", 45),  # Turn right
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Scan again
            ("turn", -90),  # Turn left
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Scan again
            ("turn", 45),  # Return to center
            ("forward", 0.5),  # Move forward
            ("scan", None),  # Final scan
        ]
        
        try:
            # Execute the search pattern
            for i, (action, param) in enumerate(search_pattern):
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Check for obstacles
                if action in ["forward", "turn"]:
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, turning to avoid")
                        print(f"⚠️ Obstacle detected at {distance}cm, turning to avoid")
                        self.turn(90)  # Turn away from obstacle
                        continue
                
                # Execute the action
                if action == "forward":
                    logger.info(f"Moving forward for {param}s")
                    print(f"🚗 Moving forward...")
                    self.move_forward(speed=50, duration=param)
                
                elif action == "turn":
                    logger.info(f"Turning {param} degrees")
                    print(f"🔄 Turning {param} degrees...")
                    self.turn(param)
                
                elif action == "scan":
                    logger.info("Scanning for backpack")
                    print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                    
                    # Capture image
                    image_path = self.capture_image()
                    if not image_path:
                        logger.warning("Failed to capture image")
                        continue
                    
                    # Analyze image with GPT-4 Vision
                    objects = self.analyze_image_with_gpt4(image_path)
                    
                    # Check if we found a backpack
                    for obj in objects:
                        obj_name = obj.get("name", "").lower()
                        confidence = obj.get("confidence", 0)
                        position = obj.get("position", "unknown")
                        
                        if "backpack" in obj_name and confidence >= confidence_threshold:
                            logger.info(f"Found backpack with {confidence:.1%} confidence at {position}")
                            print(f"✅ Found backpack with {confidence:.1%} confidence at {position}!")
                            found_backpack = True
                            break
                        else:
                            # Log other objects seen
                            logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                            print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                    
                    if found_backpack:
                        break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_backpack:
                logger.warning("Failed to find backpack")
                print("❌ Failed to find backpack")
            
            return found_backpack
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Search for a backpack using PiCar-X and GPT-4 Vision')
    parser.add_argument('--timeout', type=int, default=60, help='Search timeout in seconds')
    parser.add_argument('--confidence', type=float, default=0.6, help='Confidence threshold (0-1)')
    parser.add_argument('--api-key', type=str, help='OpenAI API key (optional)')
    parser.add_argument('--object-name', type=str, default='backpack', help='Object to search for (default: backpack)')
    
    args = parser.parse_args()
    
    # Set API key if provided
    if args.api_key:
        os.environ["OPENAI_API_KEY"] = args.api_key
    
    print(f"Starting backpack search with timeout {args.timeout}s")
    
    # Create and run the backpack finder
    finder = None
    try:
        finder = BackpackFinder()
        finder.search_for_backpack(timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/test_object_search_standalone.py
##################################################

#!/usr/bin/env python3
"""
Standalone test script for the ObjectSearchTool
This script can be run directly on the Raspberry Pi to test the object search functionality
"""

import os
import sys
import time
import asyncio
import logging
import argparse
from pathlib import Path

# Add parent directory to path to import modules
parent_dir = str(Path(__file__).parent.parent)
sys.path.insert(0, parent_dir)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('object_search_test.log')
    ]
)
logger = logging.getLogger(__name__)

# Import the ObjectSearchTool class
sys.path.append(os.path.join(parent_dir, 'src', 'agent', 'tools'))
from object_search_tool import ObjectSearchTool

async def main():
    """Main function to test the ObjectSearchTool"""
    parser = argparse.ArgumentParser(description='Test the ObjectSearchTool')
    parser.add_argument('--object', type=str, default='tennis ball', help='Object to search for')
    parser.add_argument('--timeout', type=int, default=60, help='Search timeout in seconds')
    parser.add_argument('--confidence', type=float, default=0.5, help='Confidence threshold (0.0-1.0)')
    args = parser.parse_args()
    
    try:
        # Create the object search tool with direct hardware access
        print(f"🤖 Initializing object search tool...")
        search_tool = ObjectSearchTool()
        
        # Execute the search
        print(f"🔍 Starting search for {args.object} with timeout {args.timeout}s...")
        result = await search_tool.execute(
            object_name=args.object,
            timeout=args.timeout,
            confidence_threshold=args.confidence
        )
        
        # Display the result
        if result["success"]:
            print(f"✅ {result['message']}")
            print(f"📍 Position: {result.get('position', 'unknown')}")
            print(f"🎯 Confidence: {result.get('confidence', 0.0):.1%}")
            print(f"🕒 Search time: {result['search_time']:.1f}s")
        else:
            print(f"❌ {result['message']}")
            print(f"🕒 Search time: {result.get('search_time', 0.0):.1f}s")
        
    except KeyboardInterrupt:
        print("\n🛑 Search interrupted by user")
    except Exception as e:
        logger.error(f"Error: {e}")
        print(f"❌ Error: {e}")
    finally:
        # Clean up resources
        if 'search_tool' in locals():
            search_tool.cleanup()
        print("🧹 Cleaned up resources")

if __name__ == "__main__":
    # Run the async main function
    asyncio.run(main())


##################################################
# FILE: scripts/fix_hardware_paths.sh
##################################################

#!/bin/bash
# Fix hardware paths and dependencies for PiCar-X

echo "Fixing hardware paths and dependencies for PiCar-X..."

# Create a symbolic link to the picarx module if it's not in the Python path
if [ -d "/usr/local/lib/python3.11/dist-packages/picarx" ]; then
  echo "picarx module found in system packages"
else
  echo "Creating symbolic link to picarx module"
  # Check common locations
  if [ -d "/home/pi/picar-x/lib/picarx" ]; then
    sudo ln -sf /home/pi/picar-x/lib/picarx /usr/local/lib/python3.11/dist-packages/
  elif [ -d "/home/pi/SunFounder_PiCar-X/picarx" ]; then
    sudo ln -sf /home/pi/SunFounder_PiCar-X/picarx /usr/local/lib/python3.11/dist-packages/
  else
    echo "Could not find picarx module. Please install it first."
  fi
fi

# Create a symbolic link to the robot_hat module if it's not in the Python path
if [ -d "/usr/local/lib/python3.11/dist-packages/robot_hat" ]; then
  echo "robot_hat module found in system packages"
else
  echo "Creating symbolic link to robot_hat module"
  # Check common locations
  if [ -d "/home/pi/picar-x/lib/robot_hat" ]; then
    sudo ln -sf /home/pi/picar-x/lib/robot_hat /usr/local/lib/python3.11/dist-packages/
  elif [ -d "/home/pi/SunFounder_PiCar-X/robot_hat" ]; then
    sudo ln -sf /home/pi/SunFounder_PiCar-X/robot_hat /usr/local/lib/python3.11/dist-packages/
  else
    echo "Could not find robot_hat module. Please install it first."
  fi
fi

# Create a symbolic link to the vilib module if it's not in the Python path
if [ -d "/usr/local/lib/python3.11/dist-packages/vilib" ]; then
  echo "vilib module found in system packages"
else
  echo "Creating symbolic link to vilib module"
  # Check common locations
  if [ -d "/home/pi/picar-x/lib/vilib" ]; then
    sudo ln -sf /home/pi/picar-x/lib/vilib /usr/local/lib/python3.11/dist-packages/
  elif [ -d "/home/pi/SunFounder_PiCar-X/vilib" ]; then
    sudo ln -sf /home/pi/SunFounder_PiCar-X/vilib /usr/local/lib/python3.11/dist-packages/
  else
    echo "Could not find vilib module. Please install it first."
  fi
fi

# Add the modules to the virtual environment
source ~/family-robot/venv/bin/activate
python -c "import sys; print('Python path:', sys.path)"
deactivate

echo "Hardware paths fixed!"


##################################################
# FILE: scripts/test_approach_tool.py
##################################################

#!/usr/bin/env python3
"""
Test script for the ApproachObjectTool

This script demonstrates how to use the ObjectSearchTool and ApproachObjectTool together
to find and approach objects in the environment.
"""

import os
import sys
import time
import asyncio
import argparse
import logging
from pathlib import Path

# Add the parent directory to the Python path
sys.path.append(str(Path(__file__).parent.parent))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('approach_test.log')
    ]
)
logger = logging.getLogger('approach_test')

# Import the tools
try:
    from src.agent.tools.object_search_tool import ObjectSearchTool
    from src.agent.tools.approach_object_tool import ApproachObjectTool
except ImportError as e:
    logger.error(f"Failed to import tools: {e}")
    sys.exit(1)

async def main():
    """Main function to run the test"""
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description='Test the ApproachObjectTool')
    parser.add_argument('--object', type=str, default='ball', help='Object to search for')
    parser.add_argument('--timeout', type=int, default=30, help='Search timeout in seconds')
    parser.add_argument('--confidence', type=float, default=0.6, help='Confidence threshold (0.0-1.0)')
    parser.add_argument('--min-distance', type=int, default=15, help='Minimum approach distance in cm')
    parser.add_argument('--max-approach-time', type=int, default=30, help='Maximum approach time in seconds')
    parser.add_argument('--search-only', action='store_true', help='Only perform search, no approach')
    args = parser.parse_args()
    
    # Print test configuration
    print(f"🔍 Testing object search and approach for: {args.object}")
    print(f"⚙️ Configuration:")
    print(f"   - Search timeout: {args.timeout}s")
    print(f"   - Confidence threshold: {args.confidence}")
    print(f"   - Minimum approach distance: {args.min_distance}cm")
    print(f"   - Maximum approach time: {args.max_approach_time}s")
    print(f"   - Search only mode: {'Yes' if args.search_only else 'No'}")
    
    try:
        # Initialize the search tool
        search_tool = ObjectSearchTool()
        
        # Step 1: Search for the object
        print(f"\n🔍 Step 1: Searching for {args.object}...")
        search_result = await search_tool.execute(
            object_name=args.object,
            timeout=args.timeout,
            confidence_threshold=args.confidence
        )
        
        print(f"\n📊 Search Results:")
        print(f"   - Success: {'✅' if search_result.get('found', False) else '❌'}")
        print(f"   - Search time: {search_result.get('search_time', 0):.1f}s")
        print(f"   - Confidence: {search_result.get('confidence', 0):.2f}")
        print(f"   - Position: {search_result.get('position', 'unknown')}")
        print(f"   - Message: {search_result.get('message', '')}")
        
        # If search was successful and we're not in search-only mode, approach the object
        if search_result.get('found', False) and not args.search_only:
            # Initialize the approach tool
            approach_tool = ApproachObjectTool()
            
            # Step 2: Approach the object
            print(f"\n🚗 Step 2: Approaching {args.object}...")
            approach_result = await approach_tool.execute(
                object_name=args.object,
                position=search_result.get('position', 'center'),
                confidence=search_result.get('confidence', 0.6),
                max_approach_time=args.max_approach_time,
                min_distance=args.min_distance
            )
            
            print(f"\n📊 Approach Results:")
            print(f"   - Success: {'✅' if approach_result.get('success', False) else '❌'}")
            print(f"   - Approach time: {approach_result.get('approach_time', 0):.1f}s")
            print(f"   - Approach steps: {approach_result.get('approach_steps', 0)}")
            print(f"   - Final distance: {approach_result.get('final_distance', 0):.1f}cm")
            print(f"   - Message: {approach_result.get('message', '')}")
            
            # Clean up resources
            approach_tool.cleanup()
        
        # Clean up search tool resources
        search_tool.cleanup()
        
        print("\n✅ Test completed!")
        
    except Exception as e:
        logger.error(f"Test failed: {e}")
        print(f"\n❌ Test failed: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    # Check for OpenAI API key
    if not os.environ.get('OPENAI_API_KEY'):
        # Try to load from .env file
        try:
            from dotenv import load_dotenv
            load_dotenv()
        except ImportError:
            pass
        
        if not os.environ.get('OPENAI_API_KEY'):
            print("⚠️ OPENAI_API_KEY environment variable not set!")
            print("Please set it before running this script:")
            print("export OPENAI_API_KEY='your-api-key'")
            sys.exit(1)
    
    # Run the async main function
    exit_code = asyncio.run(main())
    sys.exit(exit_code)


##################################################
# FILE: scripts/run_vision_search.sh
##################################################

#!/bin/bash
# Run vision search test with virtual environment

# Activate the virtual environment
source ~/family-robot/venv/bin/activate

# Set OpenAI API key if available
if [ -f ~/family-robot/keys.py ]; then
    echo "Using API key from keys.py"
    export OPENAI_API_KEY=$(python3 -c "from keys import OPENAI_API_KEY; print(OPENAI_API_KEY)")
fi

# Run the vision search test
cd ~/family-robot
python3 vision_search_test.py "$@"

# Deactivate the virtual environment
deactivate


##################################################
# FILE: scripts/OBJECT_SEARCH_README.md
##################################################

# PiCar-X Object Search Tool

This tool integrates the enhanced object search functionality into the agent architecture. It enables the robot to search for objects using GPT-4 Vision, move toward detected objects, and provide detailed feedback.

## Setup Instructions

1. **Deploy the code to the Pi**
   - All necessary files have been copied to the `~/family-robot/` directory on the Pi

2. **Configure the OpenAI API Key**
   - Connect to the Pi via SSH
   - Run the setup script with your API key:
     ```bash
     cd ~/family-robot
     chmod +x setup_api_key.sh
     ./setup_api_key.sh YOUR_OPENAI_API_KEY
     ```

3. **Enable the Speaker Switch (if needed for audio feedback)**
   ```bash
   pinctrl set 20 op dh
   ```

## Running the Object Search Tool

Run the test script to search for objects:

```bash
cd ~/family-robot
python3 test_object_search_tool.py --object "tennis ball" --timeout 60 --confidence 0.6
```

### Command-line Arguments

- `--object`: The object to search for (default: "tennis ball")
- `--timeout`: Search timeout in seconds (default: 60)
- `--confidence`: Confidence threshold (0.0-1.0) (default: 0.5)
- `--area`: Area to search in (optional)

## Features

The integrated object search tool includes:

1. **Enhanced Vision Detection**
   - Uses GPT-4o Vision API for accurate object detection
   - Provides position information (left/right/center, top/bottom/middle)
   - Filters results by confidence threshold

2. **Improved Search Patterns**
   - Performs initial 360-degree scan in place
   - Uses adaptive exploration pattern with obstacle avoidance
   - Optimized turning angles based on detected object position

3. **Reliable Distance Sensing**
   - Takes multiple ultrasonic sensor readings
   - Filters out invalid readings
   - Averages valid readings for improved reliability

4. **Object Approach**
   - Turns toward detected objects based on position
   - Moves forward with distance checking
   - Stops at a safe distance from the object

## Integration with Agent Architecture

The object search tool is fully integrated with the agent architecture:

- Uses the `PiCarXHardware` class for hardware control
- Uses the `GPTVision` class for vision processing
- Implements async methods compatible with the agent system
- Returns structured results for agent processing

## Troubleshooting

- If the camera isn't working, check that the camera module is enabled in `raspi-config`
- If the ultrasonic sensor gives erratic readings, check the connections
- If the API calls fail, verify your API key is correctly set up
- Check the log file `object_search_test.log` for detailed error information


##################################################
# FILE: scripts/simple_integration_test.py
##################################################

#!/usr/bin/env python3
"""
Simplified integration test for PiCar-X hardware
Tests the hardware integration directly without dependencies on other modules
"""

import os
import sys
import time
import asyncio
import logging
import argparse
from pathlib import Path

# Add the project root to the Python path
project_root = str(Path(__file__).parent.parent)
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('simple_integration.log')
    ]
)
logger = logging.getLogger(__name__)

# Hardware availability flag
HARDWARE_AVAILABLE = False

# Try to import hardware components
try:
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available, using mock implementations: {e}")

class PiCarXHardware:
    """
    Hardware controller for PiCar-X
    Follows the exact initialization pattern from working_gpt_car.py
    """
    
    def __init__(self):
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.position = (0, 0, 0)  # x, y, heading in degrees
        
    def initialize(self):
        """Initialize hardware components in the correct order"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return False
            
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order - EXACTLY as in working_gpt_car.py
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' instead of 'LED_R'
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
            return False
    
    async def move_forward(self, distance: float, speed: float = 50) -> None:
        """Move forward a specific distance"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            await asyncio.sleep(abs(distance) / max(speed, 1) * 0.1)
            # Update simulated position
            self.position = (
                self.position[0] + distance * 0.1,  # Simple forward movement
                self.position[1],
                self.position[2]
            )
            return
            
        try:
            logger.info(f"Moving forward {distance}m at speed {speed}")
            self.px.forward(speed)
            # Convert distance to time based on speed
            # This is an approximation and may need calibration
            await asyncio.sleep(abs(distance) / max(speed, 1) * 10)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            self.px.stop()  # Safety stop
    
    async def turn(self, degrees: float, speed: float = 50) -> None:
        """Turn in place by the specified degrees"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            await asyncio.sleep(abs(degrees) / 90 * 0.5)
            # Update simulated heading
            self.position = (
                self.position[0],
                self.position[1],
                (self.position[2] + degrees) % 360
            )
            return
            
        try:
            logger.info(f"Turning {degrees} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(degrees, 35), -35)
            
            if clamped_angle != degrees:
                logger.warning(f"Angle {degrees} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(degrees) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                await asyncio.sleep(abs(degrees) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                await asyncio.sleep(abs(degrees) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            self.px.set_dir_servo_angle(0)  # Reset steering
    
    async def check_obstacles(self) -> float:
        """Check for obstacles using ultrasonic sensor"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating obstacle check")
            return 100.0  # Simulate no obstacles
            
        try:
            # Get distance from ultrasonic sensor
            distance = self.px.ultrasonic.read()
            logger.info(f"Obstacle distance: {distance}cm")
            return distance
        except Exception as e:
            logger.error(f"Obstacle check error: {e}")
            return 100.0  # Default to no obstacles on error
    
    def get_position(self):
        """Get the current position and heading"""
        return self.position
    
    def cleanup(self):
        """Clean up hardware resources"""
        if self.initialized:
            try:
                logger.info("Cleaning up hardware resources")
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

class MockVision:
    """Mock vision system for testing"""
    
    def __init__(self, objects_to_find=None):
        self.objects_to_find = objects_to_find or []
        self.scan_count = 0
        logger.info("Initialized mock vision system")
    
    async def detect_objects(self, image=None):
        """Simulate object detection with increasingly likely detection"""
        self.scan_count += 1
        logger.info(f"Mock: Scanning for objects (scan #{self.scan_count})")
        
        # If this is the 3rd scan, "find" the objects
        if self.scan_count >= 3:
            logger.info(f"Mock: Found objects: {self.objects_to_find}")
            return self.objects_to_find
        
        # Otherwise, return empty list (nothing found)
        logger.info("Mock: No objects detected")
        return []

class SimpleSearchMemory:
    """Simple memory for search operations"""
    
    def __init__(self):
        self.visited_areas = []
        self.object_sightings = {}
        logger.info("Initialized simple search memory")
    
    def record_visit(self, position):
        """Record that we visited a position"""
        self.visited_areas.append(position)
        logger.info(f"Recorded visit to position {position}")
    
    def record_sighting(self, object_name, position, confidence):
        """Record an object sighting"""
        if object_name not in self.object_sightings:
            self.object_sightings[object_name] = []
        
        self.object_sightings[object_name].append({
            'position': position,
            'confidence': confidence,
            'timestamp': time.time()
        })
        logger.info(f"Recorded sighting of {object_name} at {position} with {confidence:.1%} confidence")

async def test_hardware_initialization():
    """Test hardware initialization"""
    logger.info("Testing hardware initialization")
    
    car = PiCarXHardware()
    result = car.initialize()
    
    if result:
        logger.info("✅ Hardware initialized successfully")
        print("✅ Hardware initialized successfully")
    else:
        logger.warning("❌ Hardware initialization failed, running in simulation mode")
        print("❌ Hardware initialization failed, running in simulation mode")
    
    return car

async def test_movement_and_turning(car):
    """Test basic movement and turning"""
    logger.info("Testing basic movement and turning")
    
    try:
        # Move forward
        logger.info("Testing forward movement")
        await car.move_forward(0.5, 50)
        
        # Turn right
        logger.info("Testing right turn")
        await car.turn(30, 50)
        
        # Move forward
        logger.info("Testing forward movement")
        await car.move_forward(0.5, 50)
        
        # Turn left
        logger.info("Testing left turn")
        await car.turn(-60, 50)
        
        # Move forward
        logger.info("Testing forward movement")
        await car.move_forward(0.5, 50)
        
        # Return to center
        logger.info("Returning to center")
        await car.turn(30, 50)
        
        logger.info("✅ Movement and turning tests completed")
        print("✅ Movement and turning tests completed")
        return True
    except Exception as e:
        logger.error(f"Movement test failed: {e}")
        print(f"❌ Movement test failed: {e}")
        return False

async def test_obstacle_detection(car):
    """Test obstacle detection"""
    logger.info("Testing obstacle detection")
    
    try:
        # Check for obstacles
        distance = await car.check_obstacles()
        
        if distance is not None:
            logger.info(f"✅ Obstacle detection working, distance: {distance}cm")
            print(f"✅ Obstacle detection working, distance: {distance}cm")
            return True
        else:
            logger.warning("❌ Obstacle detection not working")
            print("❌ Obstacle detection not working")
            return False
    except Exception as e:
        logger.error(f"Obstacle detection test failed: {e}")
        print(f"❌ Obstacle detection test failed: {e}")
        return False

async def test_simple_search(car, object_name="ball", timeout=30):
    """Test a simple search pattern"""
    logger.info(f"Testing simple search for {object_name}")
    
    # Create mock vision and memory
    vision = MockVision([
        {'name': object_name, 'confidence': 0.85, 'position': (2, 1, 0)}
    ])
    memory = SimpleSearchMemory()
    
    # Simple search pattern
    search_patterns = [
        # Each tuple is (turn_degrees, move_distance)
        (0, 0.5),    # Forward
        (45, 0),     # Turn right
        (0, 0.5),    # Forward
        (-90, 0),    # Turn left
        (0, 0.5),    # Forward
    ]
    
    start_time = time.time()
    found_object = False
    
    try:
        # Execute the search pattern
        for pattern_idx, (turn_degrees, move_distance) in enumerate(search_patterns):
            # Check timeout
            if time.time() - start_time > timeout:
                logger.warning(f"Search timed out after {timeout}s")
                break
            
            # Execute the pattern step
            logger.info(f"Executing search pattern step {pattern_idx+1}/{len(search_patterns)}")
            
            # Turn if needed
            if turn_degrees != 0:
                await car.turn(turn_degrees)
            
            # Move if needed
            if move_distance != 0:
                await car.move_forward(move_distance)
            
            # Record the visit
            current_position = car.get_position()
            memory.record_visit(current_position)
            
            # Scan for objects
            logger.info(f"Scanning for {object_name}")
            detected_objects = await vision.detect_objects()
            
            # Check if we found the target object
            for obj in detected_objects:
                if obj['name'].lower() == object_name.lower():
                    # Record the sighting
                    memory.record_sighting(
                        object_name=obj['name'],
                        position=obj['position'],
                        confidence=obj['confidence']
                    )
                    
                    # Return success
                    logger.info(f"Found {object_name} at {obj['position']} with {obj['confidence']:.1%} confidence")
                    print(f"✅ Found {object_name} at {obj['position']} with {obj['confidence']:.1%} confidence")
                    found_object = True
                    break
            
            if found_object:
                break
        
        if not found_object:
            logger.warning(f"❌ Failed to find {object_name}")
            print(f"❌ Failed to find {object_name}")
        
        elapsed = time.time() - start_time
        logger.info(f"Search completed in {elapsed:.1f}s")
        return found_object
    
    except Exception as e:
        logger.error(f"Search test failed: {e}")
        print(f"❌ Search test failed: {e}")
        return False

async def run_tests(args):
    """Run all tests"""
    car = None
    
    try:
        # Initialize hardware
        car = await test_hardware_initialization()
        
        # Run the selected tests
        if args.test_type == 'movement':
            await test_movement_and_turning(car)
        elif args.test_type == 'obstacle':
            await test_obstacle_detection(car)
        elif args.test_type == 'search':
            await test_simple_search(car, args.object_name, args.timeout)
        else:
            # Run all tests
            print("=== Testing Hardware Initialization ===")
            # Hardware already initialized above
            
            print("\n=== Testing Movement and Turning ===")
            await test_movement_and_turning(car)
            
            print("\n=== Testing Obstacle Detection ===")
            await test_obstacle_detection(car)
            
            print("\n=== Testing Simple Search ===")
            await test_simple_search(car, args.object_name, args.timeout)
    
    finally:
        # Clean up
        if car:
            car.cleanup()

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Test the PiCar-X hardware integration')
    parser.add_argument('--object-name', type=str, default="ball", help='Object to search for')
    parser.add_argument('--timeout', type=int, default=30, help='Search timeout in seconds')
    parser.add_argument('--test-type', type=str, choices=['movement', 'obstacle', 'search', 'all'], default='all',
                        help='Type of test to run')
    
    args = parser.parse_args()
    
    print(f"Starting hardware integration test with timeout {args.timeout}s")
    
    try:
        # Run the tests
        asyncio.run(run_tests(args))
    except KeyboardInterrupt:
        print("\nTest interrupted by user")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/setup_api_key.sh
##################################################

#!/bin/bash
# Set up OpenAI API key for PiCar-X vision search

echo "Setting up OpenAI API key for PiCar-X vision search..."

# Check if API key is provided
if [ -z "$1" ]; then
  echo "Please provide your OpenAI API key as an argument"
  echo "Usage: ./setup_api_key.sh YOUR_API_KEY"
  exit 1
fi

# Create keys.py file with API key
echo "Creating keys.py file..."
cat > ~/family-robot/keys.py << EOF
# OpenAI API key
OPENAI_API_KEY = "$1"

# Optional: Assistant ID if you're using OpenAI Assistants API
OPENAI_ASSISTANT_ID = ""
EOF

echo "API key set up successfully!"
echo "You can now run the backpack finder with: ./backpack_finder.py"


##################################################
# FILE: scripts/integration_test.py
##################################################

#!/usr/bin/env python3
"""
Comprehensive integration test for PiCar-X agent system
Tests the hardware integration, enhanced search tool, and agent system
"""

import os
import sys
import time
import asyncio
import logging
import argparse
from pathlib import Path

# Add the project root to the Python path
project_root = str(Path(__file__).parent.parent)
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('integration_test.log')
    ]
)
logger = logging.getLogger(__name__)

# Import agent system
from src.agent.agent_system import get_agent_system, process_command

async def test_direct_tool_execution(object_name="ball", timeout=30):
    """Test direct tool execution"""
    logger.info(f"Testing direct tool execution for object: {object_name}")
    
    try:
        # Get the agent system
        agent = get_agent_system()
        
        # Execute the search tool directly
        logger.info(f"Executing search for {object_name}")
        result = await agent.search_for_object(
            object_name=object_name,
            timeout=timeout
        )
        
        # Log the result
        if result.get('status') == 'success':
            logger.info(f"✅ Found {object_name} at {result.get('location')} with {result.get('confidence'):.1%} confidence")
            print(f"✅ Found {object_name} at {result.get('location')} with {result.get('confidence'):.1%} confidence")
        else:
            logger.warning(f"❌ Failed to find {object_name}: {result.get('message')}")
            print(f"❌ Failed to find {object_name}: {result.get('message')}")
        
        return result
    
    except Exception as e:
        logger.error(f"Test failed with error: {e}")
        import traceback
        traceback.print_exc()
        return {"status": "error", "message": str(e)}

async def test_natural_language_command(command="find the ball", timeout=30):
    """Test natural language command processing"""
    logger.info(f"Testing natural language command: '{command}'")
    
    try:
        # Process the command
        logger.info(f"Processing command: {command}")
        result = await process_command(command)
        
        # Log the result
        if result.get('status') == 'success':
            object_name = result.get('object_name', 'object')
            logger.info(f"✅ Command succeeded: Found {object_name} at {result.get('location')} with {result.get('confidence'):.1%} confidence")
            print(f"✅ Command succeeded: Found {object_name} at {result.get('location')} with {result.get('confidence'):.1%} confidence")
        else:
            logger.warning(f"❌ Command failed: {result.get('message')}")
            print(f"❌ Command failed: {result.get('message')}")
        
        return result
    
    except Exception as e:
        logger.error(f"Test failed with error: {e}")
        import traceback
        traceback.print_exc()
        return {"status": "error", "message": str(e)}

async def run_tests(args):
    """Run all tests"""
    try:
        # Get the agent system
        agent = get_agent_system()
        
        # Run the tests
        if args.test_type == 'direct':
            await test_direct_tool_execution(args.object_name, args.timeout)
        elif args.test_type == 'command':
            await test_natural_language_command(args.command, args.timeout)
        else:
            # Run both tests
            print("=== Testing Direct Tool Execution ===")
            await test_direct_tool_execution(args.object_name, args.timeout)
            
            print("\n=== Testing Natural Language Command ===")
            command = args.command or f"find the {args.object_name}"
            await test_natural_language_command(command, args.timeout)
    
    finally:
        # Clean up
        if 'agent' in locals() and agent:
            agent.cleanup()

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Test the PiCar-X agent system')
    parser.add_argument('--object-name', type=str, default="ball", help='Object to search for')
    parser.add_argument('--timeout', type=int, default=30, help='Search timeout in seconds')
    parser.add_argument('--test-type', type=str, choices=['direct', 'command', 'both'], default='both',
                        help='Type of test to run')
    parser.add_argument('--command', type=str, help='Natural language command to process')
    
    args = parser.parse_args()
    
    print(f"Starting integration test with timeout {args.timeout}s")
    
    try:
        # Run the tests
        asyncio.run(run_tests(args))
    except KeyboardInterrupt:
        print("\nTest interrupted by user")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()


##################################################
# FILE: scripts/deploy_and_test.sh
##################################################

#!/bin/bash

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Configuration
PI_USER="pi"
PI_IP="192.168.0.151"
PI_PASSWORD="raspberry"
PI_PATH="/home/pi/Robot_Car"
SOURCE_FILE="/Users/ethangrabau/Robot_Car/src/agent/tools/object_search_tool.py"
DEST_DIR="$PI_PATH/src/agent/tools"
FLEXIBLE_SEARCH_SCRIPT="/tmp/robot_car_transfer/pi_flexible_search.sh"
PI_FLEXIBLE_SEARCH_PATH="$PI_PATH/scripts"

# Check if files exist
if [ ! -f "$SOURCE_FILE" ]; then
    echo "Error: Source file $SOURCE_FILE not found"
    exit 1
fi

if [ ! -f "$FLEXIBLE_SEARCH_SCRIPT" ]; then
    echo "Error: Flexible search script $FLEXIBLE_SEARCH_SCRIPT not found"
    exit 1
fi

echo -e "${YELLOW}Deploying enhanced object approach functionality...${NC}"

# Transfer the updated object_search_tool.py to the Pi
echo -e "${GREEN}Transferring updated object_search_tool.py to Raspberry Pi...${NC}"
sshpass -p "$PI_PASSWORD" scp "$SOURCE_FILE" "$PI_USER@$PI_IP:$DEST_DIR/"

if [ $? -ne 0 ]; then
    echo -e "${RED}Failed to transfer object_search_tool.py. Check connection to Pi.${NC}"
    exit 1
fi

# Transfer the flexible search script to the Pi
echo -e "${GREEN}Transferring flexible search script to Raspberry Pi...${NC}"
sshpass -p "$PI_PASSWORD" scp "$FLEXIBLE_SEARCH_SCRIPT" "$PI_USER@$PI_IP:$PI_FLEXIBLE_SEARCH_PATH/pi_flexible_search.sh"

if [ $? -ne 0 ]; then
    echo -e "${RED}Failed to transfer pi_flexible_search.sh. Check connection to Pi.${NC}"
    exit 1
fi

# Make the script executable
echo -e "${GREEN}Making pi_flexible_search.sh executable on the Pi...${NC}"
sshpass -p "$PI_PASSWORD" ssh "$PI_USER@$PI_IP" "chmod +x $PI_FLEXIBLE_SEARCH_PATH/pi_flexible_search.sh"

echo -e "${GREEN}Deployment complete!${NC}"
echo -e "${YELLOW}To test the updated approach algorithm, run this command from your computer:${NC}"
echo -e "${GREEN}sshpass -p \"$PI_PASSWORD\" ssh $PI_USER@$PI_IP \"cd $PI_PATH && python -m src.agent.tools.object_search_tool banana 120 0.6\"${NC}"
echo -e "${YELLOW}Or use the flexible search script:${NC}"
echo -e "${GREEN}sshpass -p \"$PI_PASSWORD\" ssh $PI_USER@$PI_IP \"$PI_FLEXIBLE_SEARCH_PATH/pi_flexible_search.sh banana 120 0.6\"${NC}"
echo -e "${YELLOW}Try with different objects and positions to test the improved approach behavior${NC}"
echo -e "${YELLOW}For example:${NC}"
echo -e "${GREEN}sshpass -p \"$PI_PASSWORD\" ssh $PI_USER@$PI_IP \"cd $PI_PATH && python -m src.agent.tools.object_search_tool water_bottle 120 0.6\"${NC}"


##################################################
# FILE: scripts/test_hardware.py
##################################################

#!/usr/bin/env python3
"""
Comprehensive hardware test script for the robot.
Run this on the Raspberry Pi to test all hardware components.
"""
import time
import sys
import logging
from pathlib import Path

# Add the project root to the Python path
sys.path.append(str(Path(__file__).parent.parent))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('hardware_test.log')
    ]
)
logger = logging.getLogger(__name__)

def test_movements(robot):
    """Test basic robot movements."""
    tests = [
        ("Moving forward at 30% speed", lambda: robot.move_forward(30)),
        ("Moving backward at 30% speed", lambda: robot.move_backward(30)),
        ("Turning left 30 degrees", lambda: robot.turn_left(30)),
        ("Turning right 30 degrees", lambda: robot.turn_right(30)),
        ("Looking around", robot.look_around),
    ]
    
    for description, movement_func in tests:
        try:
            logger.info(f"Testing: {description}")
            print(f"\n--- {description} ---")
            print("Starting in 2 seconds... (Press Ctrl+C to skip)")
            time.sleep(2)
            
            movement_func()
            time.sleep(3)  # Let the movement happen for 3 seconds
            robot.stop()
            
            print("Test passed!")
            logger.info(f"Test passed: {description}")
            
        except KeyboardInterrupt:
            print("\nTest interrupted!")
            robot.stop()
            break
        except Exception as e:
            logger.error(f"Test failed: {description} - {str(e)}")
            print(f"Error: {str(e)}")
        
        time.sleep(1)  # Pause between tests

def test_camera():
    """Test the camera functionality."""
    try:
        import cv2
        from src.vision.camera import Camera
        
        logger.info("Testing camera...")
        print("\n--- Testing Camera ---")
        
        camera = Camera()
        print("Camera initialized. Capturing test image...")
        
        # Capture and save a test image
        frame = camera.capture_frame()
        if frame is not None:
            test_image_path = "camera_test.jpg"
            cv2.imwrite(test_image_path, frame)
            print(f"Test image saved to {test_image_path}")
            logger.info(f"Test image saved to {test_image_path}")
        else:
            print("Failed to capture image from camera")
            logger.error("Failed to capture image from camera")
            
        camera.release()
        
    except ImportError as e:
        logger.warning(f"Camera test skipped - missing dependency: {e}")
        print("Camera test skipped - missing dependencies")
    except Exception as e:
        logger.error(f"Camera test failed: {str(e)}")
        print(f"Camera test error: {str(e)}")

def test_audio():
    """Test the audio input/output."""
    try:
        from src.voice import TextToSpeech
        
        logger.info("Testing audio output...")
        print("\n--- Testing Audio Output ---")
        print("You should hear a test message...")
        
        tts = TextToSpeech()
        tts.speak("This is a test of the text-to-speech system. If you can hear this, the audio is working correctly.")
        
        print("Audio test complete!")
        logger.info("Audio output test passed")
        
    except Exception as e:
        logger.error(f"Audio test failed: {str(e)}")
        print(f"Audio test error: {str(e)}")

def main():
    """Run all hardware tests."""
    from src.movement.navigation import RobotController
    from src.utils.gpio_utils import setup_gpio, is_raspberry_pi
    
    print("\n=== Robot Hardware Test ===\n")
    
    if not is_raspberry_pi():
        print("Warning: Not running on a Raspberry Pi. Some tests may not work correctly.")
        logger.warning("Not running on a Raspberry Pi")
    
    # Initialize GPIO
    setup_gpio()
    
    try:
        # Initialize robot controller
        print("Initializing robot controller...")
        robot = RobotController()
        
        # Run tests
        test_movements(robot)
        test_camera()
        test_audio()
        
        print("\nAll tests completed!")
        logger.info("All hardware tests completed successfully")
        
    except Exception as e:
        logger.critical(f"Hardware test failed: {str(e)}", exc_info=True)
        print(f"\nError: {str(e)}")
        print("Check the logs for more details.")
    finally:
        # Clean up
        if 'robot' in locals():
            robot.stop()
        print("\nHardware test complete.")

if __name__ == "__main__":
    main()


##################################################
# FILE: object_search_test.log
##################################################

2025-06-09 20:06:07,699 - __main__ - ERROR - Error importing ObjectSearchTool: No module named 'src.agent'


##################################################
# FILE: src/config.py
##################################################

"""Configuration settings for the robot assistant."""
import os
from dotenv import load_dotenv
from pathlib import Path

# Load environment variables from .env file
env_path = Path(__file__).parent.parent / '.env'
load_dotenv(dotenv_path=env_path)

# Hardware settings
DEFAULT_HEAD_TILT = 20  # Default camera tilt angle
DEFAULT_POWER = 30  # Default motor power (0-100)

# Voice settings
TTS_VOICE = os.getenv('TTS_VOICE', 'echo')
STT_LANGUAGE = os.getenv('STT_LANGUAGE', 'en-US')

# OpenAI settings
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
OPENAI_ASSISTANT_ID = os.getenv('OPENAI_ASSISTANT_ID')

# Safety settings
SAFE_DISTANCE = 40  # cm
DANGER_DISTANCE = 20  # cm
MAX_SEARCH_TIME = 120  # seconds

# File paths
BASE_DIR = Path(__file__).parent.parent
DATA_DIR = BASE_DIR / 'data'
LOG_DIR = BASE_DIR / 'logs'

# Create necessary directories
for directory in [DATA_DIR, LOG_DIR]:
    directory.mkdir(exist_ok=True)


##################################################
# FILE: src/utils/gpio_utils.py
##################################################

"""
GPIO utilities for managing hardware resources and preventing conflicts.
"""
import RPi.GPIO as GPIO
import os
import time
from typing import Optional

def cleanup_gpio():
    """
    Clean up GPIO resources.
    This should be called before initializing hardware to prevent conflicts.
    """
    try:
        GPIO.cleanup()
        time.sleep(0.1)  # Give time for cleanup to complete
    except Exception as e:
        print(f"Warning during GPIO cleanup: {e}")

def is_raspberry_pi() -> bool:
    """
    Check if the code is running on a Raspberry Pi.
    
    Returns:
        bool: True if running on a Raspberry Pi, False otherwise
    """
    try:
        with open('/proc/device-tree/model', 'r') as f:
            return 'Raspberry Pi' in f.read()
    except:
        return False

def setup_gpio():
    """
    Set up GPIO with safe defaults.
    Should be called at the start of the program.
    """
    if not is_raspberry_pi():
        return
        
    try:
        # Clean up any existing GPIO state
        cleanup_gpio()
        
        # Set GPIO mode to BCM (Broadcom SOC channel numbering)
        GPIO.setmode(GPIO.BCM)
        
        # Disable GPIO warnings (they can be noisy)
        GPIO.setwarnings(False)
        
    except Exception as e:
        print(f"Warning: Failed to set up GPIO: {e}")

def safe_shutdown():
    """
    Safely shut down the GPIO and hardware components.
    Should be called when the program exits.
    """
    if not is_raspberry_pi():
        return
        
    try:
        # Clean up GPIO
        cleanup_gpio()
    except Exception as e:
        print(f"Warning during safe shutdown: {e}")
    finally:
        # Ensure we don't leave any processes hanging
        try:
            import psutil
            current_process = psutil.Process()
            for child in current_process.children(recursive=True):
                child.terminate()
            current_process.terminate()
        except:
            pass


##################################################
# FILE: src/agent/tools/object_search_tool_simple.py
##################################################

"""
Object Search Tool for the Robot Agent

This tool enables the agent to search for any object in the environment
using GPT-4 Vision for object detection and PiCar-X for movement.
"""

import os
import sys
import time
import base64
import json
import logging
import asyncio
from typing import Dict, Any, Optional, List
from pathlib import Path

# Import agent tool base classes
from .base_tool import BaseTool, ToolExecutionError

# We'll use our own SearchMemory implementation for simplicity
# If you want to use the agent's memory system later, uncomment this:
# from ..memory import SearchMemory

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectSearchTool(BaseTool):
    """
    Tool for searching for objects in the environment.
    
    This is a high-level tool that combines movement, vision, and navigation
    to search for objects in the environment using GPT-4 Vision for object detection.
    """
    
    name = "search_for_object"
    description = "Search for an object in the environment. Returns when found or search is complete."
    
    parameters = {
        "object_name": {
            "type": str,
            "description": "Name or description of the object to find",
            "required": True
        },
        "search_area": {
            "type": str,
            "description": "Optional area to search (e.g., 'living_room', 'kitchen')",
            "required": False
        },
        "timeout": {
            "type": int,
            "description": "Maximum search time in seconds (default: 120)",
            "required": False,
            "default": 120
        },
        "confidence_threshold": {
            "type": float,
            "description": "Confidence threshold for object detection (0.0-1.0)",
            "required": False,
            "default": 0.7
        }
    }
    
    def __init__(self, car=None, vision_system=None, navigator=None):
        """Initialize the object search tool.
        
        Args:
            car: Optional car controller interface. If None, will initialize hardware directly.
            vision_system: Optional vision system interface. If None, will initialize camera directly.
            navigator: Optional navigator for room-level navigation.
        """
        # Store agent interfaces if provided
        self.car = car
        self.vision_system = vision_system
        self.navigator = navigator
        self.memory = SearchMemory()  # Memory for search history
        
        # Initialize state variables
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # If car interface is provided, use its hardware
        if self.car is not None and hasattr(self.car, 'px'):
            self.px = self.car.px
            self.initialized = self.px is not None
            logger.info("Using car interface for hardware access")
        else:
            # Otherwise initialize hardware directly
            self._init_hardware()
        
        # If vision system is provided, use its OpenAI client
        if self.vision_system is not None and hasattr(self.vision_system, 'openai_client'):
            self.openai_client = self.vision_system.openai_client
            logger.info("Using vision system's OpenAI client")
        elif OPENAI_AVAILABLE and OPENAI_API_KEY:
            # Otherwise initialize OpenAI client directly
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized directly")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # If vision system is provided, use its camera
        if self.vision_system is not None and hasattr(self.vision_system, 'camera_initialized'):
            self.camera_initialized = self.vision_system.camera_initialized
            logger.info("Using vision system's camera")
        elif CAMERA_AVAILABLE:
            # Otherwise initialize camera directly
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib directly")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    async def execute(self, **kwargs):
        """Execute the object search.
        
        Args:
            object_name: Name or description of the object to find
            search_area: Optional area to search (e.g., 'living_room', 'kitchen')
            timeout: Maximum search time in seconds (default: 120)
            confidence_threshold: Confidence threshold for object detection (0.0-1.0)
            
        Returns:
            Dict containing search results
        """
        # Extract parameters
        object_name = kwargs.get("object_name")
        search_area = kwargs.get("search_area")
        timeout = kwargs.get("timeout", 120)
        confidence_threshold = kwargs.get("confidence_threshold", 0.7)
        
        logger.info(f"Starting search for {object_name} with timeout {timeout}s and confidence threshold {confidence_threshold}")
        
        # If a specific area is requested and we have a navigator, go there first
        if search_area and self.navigator:
            logger.info(f"Navigating to {search_area} before searching")
            # This would call the navigator to move to the specified area
            # await self.navigator.navigate_to(search_area)
        
        # Execute the search
        try:
            # Call the existing search_for_object method
            result = self.search_for_object(object_name, timeout, confidence_threshold)
            
            # Format the result for the agent
            return {
                "success": result.get("found", False),
                "object_name": object_name,
                "confidence": result.get("confidence", 0.0),
                "position": result.get("position", "unknown"),
                "search_time": result.get("search_time", 0.0),
                "message": result.get("message", "Search completed")
            }
        except Exception as e:
            logger.error(f"Error during object search: {e}")
            return {
                "success": False,
                "object_name": object_name,
                "message": f"Error during search: {str(e)}"
            }
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware modules not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized")
            return 100  # Default safe distance
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100  # Default safe distance on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="tennis ball"):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            # Store all detections in memory
                            self.memory.add("detected_objects", {
                                "name": obj_name,
                                "confidence": confidence,
                                "position": position,
                                "timestamp": time.time()
                            })
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                
                                # Store the successful detection in memory
                                self.memory.set("last_confidence", confidence)
                                self.memory.set("last_position", position)
                                self.memory.set("last_detection_time", time.time())
                                
                                # Move toward the object
                                self.move_toward_object(position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            # Prepare result dictionary
            result = {
                "found": found_object,
                "search_time": elapsed,
                "confidence": self.memory.get("last_confidence", 0.0),
                "position": self.memory.get("last_position", "unknown"),
            }
            
            if found_object:
                result["message"] = f"Found {object_name} in {elapsed:.1f}s"
            else:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
                result["message"] = f"Failed to find {object_name} after {elapsed:.1f}s"
            
            return result
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return {
                "found": False,
                "search_time": time.time() - start_time,
                "message": f"Error during search: {str(e)}"
            }
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def move_toward_object(self, position):
        """Move toward the detected object based on its position with improved approach"""
        if not position:
            logger.warning("No position information available")
            return
        
        # Parse position information (format is typically "left/right/center, top/middle/bottom")
        position = position.lower()
        logger.info(f"Moving toward object at position: {position}")
        print(f"🚗 Moving toward object at {position}...")
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if "left" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = -45
            else:
                turn_angle = -30
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif "right" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = 45
            else:
                turn_angle = 30
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.5)
        
        # Check distance before moving forward
        distance = self.check_distance()
        
        # Handle invalid distance readings
        if distance < 0 or distance > 300:
            logger.warning(f"Invalid distance reading: {distance}cm, using default")
            distance = 50  # Use a reasonable default
        
        if distance < 20:  # Less than 20cm
            logger.warning(f"Obstacle detected at {distance}cm, cannot approach further")
            print(f"⚠️ Obstacle at {distance}cm, cannot approach further")
            return
        
        # Calculate approach distance based on current distance
        # Move shorter distances for more precise positioning
        approach_time = min(distance / 100, 1.0)  # Scale approach time by distance, max 1 second
        
        # Move forward toward the object
        logger.info(f"Moving forward toward object for {approach_time:.1f}s")
        print(f"🚗 Moving forward toward object for {approach_time:.1f}s...")
        
        # Move forward with appropriate speed based on distance
        speed = 40 if distance > 50 else 30  # Slower when closer
        self.move_forward(speed=speed, duration=approach_time)
        
        # Check distance again
        new_distance = self.check_distance()
        
        # Handle invalid distance readings
        if new_distance < 0 or new_distance > 300:
            logger.warning(f"Invalid distance reading: {new_distance}cm, using default")
            new_distance = 30  # Use a reasonable default
        
        if new_distance < 20:  # Less than 20cm
            logger.info(f"Reached object at {new_distance}cm")
            print(f"🎉 Reached object! Distance: {new_distance}cm")
            # Celebrate by turning in place
            self.turn(20)
            time.sleep(0.3)
            self.turn(-40)
            time.sleep(0.3)
            self.turn(20)
        elif new_distance < distance - 10:  # Made progress, try once more
            # Move a bit more if still far away but we're getting closer
            logger.info(f"Getting closer, distance: {new_distance}cm (was {distance}cm)")
            print(f"🚗 Getting closer, distance: {new_distance}cm...")
            
            # Calculate new approach time
            approach_time = min(new_distance / 150, 0.8)  # Shorter time for fine positioning
            self.move_forward(speed=25, duration=approach_time)  # Slower speed for precision
            
            # Final distance check
            final_distance = self.check_distance()
            if 0 <= final_distance < 300:  # Valid reading
                logger.info(f"Final distance to object: {final_distance}cm")
                print(f"🎉 Final distance to object: {final_distance}cm")
            else:
                logger.warning(f"Invalid final distance reading: {final_distance}cm")
                print("🎉 Reached destination!")
        else:
            # Didn't get much closer, might be a false positive or object is not directly ahead
            logger.info(f"Approach complete, final distance: {new_distance}cm")
            print(f"🎉 Approach complete, final distance: {new_distance}cm")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

# Simple memory implementation for the object search tool
class SearchMemory:
    """Simple memory class for storing search-related information"""
    
    def __init__(self):
        """Initialize the memory"""
        self._memory = {}
        self._lists = {}
    
    def set(self, key, value):
        """Set a value in memory"""
        self._memory[key] = value
    
    def get(self, key, default=None):
        """Get a value from memory"""
        return self._memory.get(key, default)
    
    def add(self, list_name, item):
        """Add an item to a list in memory"""
        if list_name not in self._lists:
            self._lists[list_name] = []
        self._lists[list_name].append(item)
    
    def get_list(self, list_name):
        """Get a list from memory"""
        return self._lists.get(list_name, [])
    
    def clear(self):
        """Clear the memory"""
        self._memory = {}
        self._lists = {}



##################################################
# FILE: src/agent/tools/registry.py
##################################################

from typing import Dict, Type, Optional, List, Any
from .base_tool import BaseTool

class ToolRegistry:
    """Registry for all available tools in the agent system."""
    
    _instance = None
    _tools: Dict[str, Type[BaseTool]] = {}
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(ToolRegistry, cls).__new__(cls)
        return cls._instance
    
    @classmethod
    def register_tool(cls, tool_cls: Type[BaseTool]) -> None:
        """Register a tool class in the registry."""
        if not issubclass(tool_cls, BaseTool):
            raise TypeError(f"{tool_cls.__name__} is not a subclass of BaseTool")
        
        if not hasattr(tool_cls, 'name') or not tool_cls.name:
            raise ValueError(f"Tool class {tool_cls.__name__} must define a 'name' class variable")
            
        cls._tools[tool_cls.name] = tool_cls
    
    @classmethod
    def get_tool_class(cls, tool_name: str) -> Optional[Type[BaseTool]]:
        """Get a tool class by name."""
        return cls._tools.get(tool_name)
    
    @classmethod
    def create_tool(cls, tool_name: str, **kwargs) -> Optional[BaseTool]:
        """Create a tool instance by name with the given parameters."""
        tool_cls = cls.get_tool_class(tool_name)
        if tool_cls is None:
            return None
        return tool_cls(**kwargs)
    
    @classmethod
    def get_available_tools(cls) -> List[Dict[str, Any]]:
        """Get a list of all available tools with their schemas."""
        tools = []
        for name, tool_cls in cls._tools.items():
            tool_info = {
                'name': name,
                'description': getattr(tool_cls, 'description', ''),
                'parameters': getattr(tool_cls, 'parameters', {})
            }
            tools.append(tool_info)
        return tools
    
    @classmethod
    def clear_registry(cls) -> None:
        """Clear all registered tools. Mainly for testing."""
        cls._tools = {}

# Create a singleton instance
tool_registry = ToolRegistry()


##################################################
# FILE: src/agent/tools/object_search_tool.py
##################################################

"""
Object Search Tool for the Robot Agent

This tool enables the agent to search for any object in the environment
using GPT-4 Vision for object detection and PiCar-X for movement.
"""

import os
import sys
import time
import base64
import json
import logging
import asyncio
from typing import Dict, Any, Optional, List
from pathlib import Path

# Import agent tool base classes
try:
    from .base_tool import BaseTool, ToolExecutionError
except ImportError:
    # For standalone testing
    import sys
    from pathlib import Path
    sys.path.append(str(Path(__file__).parent))
    try:
        from base_tool import BaseTool, ToolExecutionError
    except ImportError:
        # Define minimal versions for testing
        class BaseTool:
            """Minimal BaseTool implementation for testing"""
            def __init__(self):
                self.name = "base_tool"
                self.description = "Base tool class"
                self.parameters = {}
            
            async def execute(self, **kwargs):
                """Execute the tool"""
                raise NotImplementedError
        
        class ToolExecutionError(Exception):
            """Error raised when tool execution fails"""
            pass

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectSearchTool(BaseTool):
    """
    Tool for searching for objects in the environment.
    
    This is a high-level tool that combines movement, vision, and navigation
    to search for objects in the environment using GPT-4 Vision for object detection.
    """
    
    name = "search_for_object"
    description = "Search for an object in the environment. Returns when found or search is complete."
    
    parameters = {
        "object_name": {
            "type": str,
            "description": "Name or description of the object to find",
            "required": True
        },
        "search_area": {
            "type": str,
            "description": "Optional area to search (e.g., 'living_room', 'kitchen')",
            "required": False
        },
        "timeout": {
            "type": int,
            "description": "Maximum search time in seconds (default: 120)",
            "required": False,
            "default": 120
        },
        "confidence_threshold": {
            "type": float,
            "description": "Confidence threshold for object detection (0.0-1.0)",
            "required": False,
            "default": 0.7
        }
    }
    
    def __init__(self, car=None, vision_system=None, navigator=None):
        """Initialize the object search tool.
        
        Args:
            car: Optional car controller interface. If None, will initialize hardware directly.
            vision_system: Optional vision system interface. If None, will initialize camera directly.
            navigator: Optional navigator for room-level navigation.
        """
        # Store agent interfaces if provided
        self.car = car
        self.vision_system = vision_system
        self.navigator = navigator
        self.memory = SearchMemory()  # Memory for search history
        
        # Initialize state variables
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # If car interface is provided, use its hardware
        if self.car is not None and hasattr(self.car, 'px'):
            self.px = self.car.px
            self.initialized = self.px is not None
            logger.info("Using car interface for hardware access")
        else:
            # Otherwise initialize hardware directly
            self._init_hardware()
        
        # If vision system is provided, use its OpenAI client
        if self.vision_system is not None and hasattr(self.vision_system, 'openai_client'):
            self.openai_client = self.vision_system.openai_client
            logger.info("Using vision system's OpenAI client")
        elif OPENAI_AVAILABLE and OPENAI_API_KEY:
            # Otherwise initialize OpenAI client directly
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized directly")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # If vision system is provided, use its camera
        if self.vision_system is not None and hasattr(self.vision_system, 'camera_initialized'):
            self.camera_initialized = self.vision_system.camera_initialized
            logger.info("Using vision system's camera")
        elif CAMERA_AVAILABLE:
            # Otherwise initialize camera directly
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib directly")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    async def execute(self, **kwargs):
        """Execute the object search.
        
        Args:
            object_name: Name or description of the object to find
            search_area: Optional area to search (e.g., 'living_room', 'kitchen')
            timeout: Maximum search time in seconds (default: 120)
            confidence_threshold: Confidence threshold for object detection (0.0-1.0)
            
        Returns:
            Dict containing search results
        """
        # Extract parameters
        object_name = kwargs.get("object_name")
        search_area = kwargs.get("search_area")
        timeout = kwargs.get("timeout", 120)
        confidence_threshold = kwargs.get("confidence_threshold", 0.7)
        
        logger.info(f"Starting search for {object_name} with timeout {timeout}s and confidence threshold {confidence_threshold}")
        
        # If a specific area is requested and we have a navigator, go there first
        if search_area and self.navigator:
            logger.info(f"Navigating to {search_area} before searching")
            # This would call the navigator to move to the specified area
            # await self.navigator.navigate_to(search_area)
        
        # Execute the search
        try:
            # Call the existing search_for_object method
            result = self.search_for_object(object_name, timeout, confidence_threshold)
            
            # Format the result for the agent
            return {
                "success": result.get("found", False),
                "object_name": object_name,
                "confidence": result.get("confidence", 0.0),
                "position": result.get("position", "unknown"),
                "search_time": result.get("search_time", 0.0),
                "message": result.get("message", "Search completed")
            }
        except Exception as e:
            logger.error(f"Error during object search: {e}")
            return {
                "success": False,
                "object_name": object_name,
                "message": f"Error during search: {str(e)}"
            }
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware modules not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized")
            return 100  # Default safe distance
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100  # Default safe distance on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="tennis ball"):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(object_name, position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            # Store all detections in memory
                            self.memory.add("detected_objects", {
                                "name": obj_name,
                                "confidence": confidence,
                                "position": position,
                                "timestamp": time.time()
                            })
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                
                                # Store the successful detection in memory
                                self.memory.set("last_confidence", confidence)
                                self.memory.set("last_position", position)
                                self.memory.set("last_detection_time", time.time())
                                
                                # Move toward the object
                                self.move_toward_object(object_name, position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            # Prepare result dictionary
            result = {
                "found": found_object,
                "search_time": elapsed,
                "confidence": self.memory.get("last_confidence", 0.0),
                "position": self.memory.get("last_position", "unknown"),
            }
            
            if found_object:
                result["message"] = f"Found {object_name} in {elapsed:.1f}s"
            else:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
                result["message"] = f"Failed to find {object_name} after {elapsed:.1f}s"
            
            return result
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return {
                "found": False,
                "search_time": time.time() - start_time,
                "message": f"Error during search: {str(e)}"
            }
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def extract_position_details(self, position_str):
        """Extract detailed position information from position string
        
        Args:
            position_str (str): Position string from GPT-4 Vision (e.g., "left top", "center")
            
        Returns:
            dict: Detailed position information including horizontal, vertical, and quadrant
        """
        if not position_str:
            return {
                "original": "",
                "horizontal": "center",
                "vertical": "middle",
                "quadrant": 5,
                "distance_estimate": "unknown"
            }
            
        position_str = position_str.lower()
        
        # Initialize position details
        position = {
            "original": position_str,
            "horizontal": "center",  # left, center, right
            "vertical": "middle",   # top, middle, bottom
            "quadrant": 5,          # Numeric quadrant (1-9, with 5 being center)
            "distance_estimate": "unknown"
        }
        
        # Extract horizontal position
        if "left" in position_str:
            position["horizontal"] = "left"
        elif "right" in position_str:
            position["horizontal"] = "right"
        
        # Extract vertical position
        if "top" in position_str:
            position["vertical"] = "top"
        elif "bottom" in position_str:
            position["vertical"] = "bottom"
        
        # Determine quadrant (like numpad)
        # 7 8 9
        # 4 5 6
        # 1 2 3
        quadrant_map = {
            ("left", "top"): 7,
            ("center", "top"): 8,
            ("right", "top"): 9,
            ("left", "middle"): 4,
            ("center", "middle"): 5,
            ("right", "middle"): 6,
            ("left", "bottom"): 1,
            ("center", "bottom"): 2,
            ("right", "bottom"): 3
        }
        
        position["quadrant"] = quadrant_map.get(
            (position["horizontal"], position["vertical"]), 5
        )
        
        # Try to extract any distance information if present
        distance_keywords = ["close", "near", "far", "distant"]
        for keyword in distance_keywords:
            if keyword in position_str:
                position["distance_estimate"] = keyword
                break
                
        return position
    
    def move_toward_object(self, object_name, position):
        """Enhanced iterative movement toward detected object to get very close (under 10cm)
        
        Args:
            object_name: Name of the object to approach
            position: Position string of the object (e.g., "left, top")
            
        Returns:
            Final distance to the object in cm
        """
        if not position:
            logger.warning("No position information available")
            return 100  # Return a default distance
        
        # Extract detailed position information
        position_details = self.extract_position_details(position)
        
        # Add a brief pause after detection to ensure stability
        logger.info("Pausing briefly to stabilize after object detection")
        print("⏱️ Pausing briefly to stabilize after object detection...")
        time.sleep(0.5)
        
        # Capture another image to confirm object position before moving
        logger.info("Confirming object position before moving")
        print("🔍 Confirming object position before moving...")
        confirm_image_path = self.capture_image()
        if confirm_image_path:
            confirm_objects = self.analyze_image_with_gpt4(confirm_image_path, object_name)
            object_confirmed = False
            confirmed_position = position
            
            for obj in confirm_objects:
                obj_name = obj.get("name", "").lower()
                confidence = obj.get("confidence", 0)
                obj_position = obj.get("position", "unknown")
                
                if object_name.lower() in obj_name.lower() and confidence >= 0.6:
                    object_confirmed = True
                    confirmed_position = obj_position
                    logger.info(f"Confirmed {object_name} at {obj_position} with {confidence*100:.1f}% confidence")
                    print(f"✅ Confirmed {object_name} at {obj_position} with {confidence*100:.1f}% confidence")
                    break
            
            if not object_confirmed:
                logger.warning(f"Could not confirm {object_name} position before moving")
                print(f"⚠️ Could not confirm {object_name} position before moving")
                # Return early if we can't confirm the object
                return 100
            
            # Use the confirmed position for movement
            position_details = self.extract_position_details(confirmed_position)
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if position_details["horizontal"] == "left":
            # Adjust turn angle based on position descriptor
            if position_details["distance_estimate"] == "far":
                turn_angle = -30  # Reduced from -45 for more cautious turning
            else:
                turn_angle = -20  # Reduced from -30 for more cautious turning
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif position_details["horizontal"] == "right":
            # Adjust turn angle based on position descriptor
            if position_details["distance_estimate"] == "far":
                turn_angle = 30  # Reduced from 45 for more cautious turning
            else:
                turn_angle = 20  # Reduced from 30 for more cautious turning
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.2)  # Reduced from 0.5 for better performance
        
        # Get initial distance measurement
        initial_distance = self.check_distance()
        
        # Handle invalid distance readings
        if initial_distance < 0 or initial_distance > 300:
            initial_distance = 50  # Use a reasonable default
        
        logger.info(f"Initial distance to object: {initial_distance}cm")
        print(f"📏 Initial distance to object: {initial_distance}cm")
        
        # Target minimum distance (but not too close)
        target_distance = 8  # Target getting within 8cm
        current_distance = initial_distance
        
        # Iterative approach - get progressively closer with multiple movements
        max_iterations = 8  # Allow up to 8 approach iterations
        position_check_interval = 1  # Check position every iteration (more frequent verification)
        
        for i in range(max_iterations):
            # Check if we've reached target distance or are close enough to stop
            if current_distance <= 15 or i >= max_iterations:  # Reduced from 20cm to 15cm for closer approach
                logger.info(f"Target distance reached: {current_distance}cm")
                print(f"🎥 Target distance reached: {current_distance}cm")
                break
            
            # Safety check - if very close, stop
            if current_distance < 5:
                logger.warning(f"Very close to object ({current_distance}cm), stopping for safety")
                print(f"⚠️ Very close to object ({current_distance}cm), stopping for safety")
                break
            
            # Periodically verify object position and adjust direction
            # More frequent verification (every iteration)
            if i % position_check_interval == 0:
                logger.info(f"Verifying object position at iteration {i}")
                print(f"🔍 Verifying object position...")
                
                # Capture image and analyze
                image_path = self.capture_image()
                if image_path:
                    objects = self.analyze_image_with_gpt4(image_path, object_name)
                    found_object = False
                    
                    for obj in objects:
                        obj_name = obj.get("name", "").lower()
                        confidence = obj.get("confidence", 0)
                        obj_position = obj.get("position", "unknown")
                        
                        # If we find our target object with good confidence
                        if object_name.lower() in obj_name.lower() and confidence >= 0.6:
                            found_object = True
                            logger.info(f"Verified {object_name} at {obj_position} with {confidence*100:.1f}% confidence")
                            print(f"✅ Verified {object_name} at {obj_position} with {confidence*100:.1f}% confidence")
                            
                            # If object has moved from center, adjust direction
                            if "center" not in obj_position.lower():
                                # Adjust direction based on new position and maintain angle
                                new_position_details = self.extract_position_details(obj_position)
                                if new_position_details["horizontal"] == "left":
                                    # More significant left adjustment to maintain angle
                                    adjustment = -20  # Increased from -15
                                    logger.info(f"Object moved left, adjusting direction by {adjustment} degrees")
                                    print(f"🔄 Object moved left, adjusting direction...")
                                    self.turn(adjustment)
                                    # Set steering angle for forward movement to maintain trajectory
                                    self.px.set_dir_servo_angle(-10)  # Keep wheels turned left during forward movement
                                    # Store last known direction for use if object is lost
                                    self.memory.add("last_direction", "left")
                                elif new_position_details["horizontal"] == "right":
                                    # More significant right adjustment to maintain angle
                                    adjustment = 20  # Increased from 15
                                    logger.info(f"Object moved right, adjusting direction by {adjustment} degrees")
                                    print(f"🔄 Object moved right, adjusting direction...")
                                    self.turn(adjustment)
                                    # Set steering angle for forward movement to maintain trajectory
                                    self.px.set_dir_servo_angle(10)  # Keep wheels turned right during forward movement
                                    # Store last known direction for use if object is lost
                                    self.memory.add("last_direction", "right")
                                elif new_position_details["horizontal"] == "center":
                                    # Object is centered, reset steering angle
                                    logger.info("Object is centered, straightening wheels")
                                    print("🔄 Object is centered, straightening wheels...")
                                    self.px.set_dir_servo_angle(0)
                                    # Store last known direction for use if object is lost
                                    self.memory.add("last_direction", "center")
                                time.sleep(0.3)  # Longer wait for turn to complete
                            break
                    
                    if not found_object:
                        logger.warning(f"Object {object_name} no longer visible, continuing with last known direction")
                        print(f"⚠️ Object {object_name} no longer visible, continuing with last known direction")
                        
                        # Maintain steering angle based on last known direction
                        last_direction = self.memory.get("last_direction", "center")
                        if last_direction == "left":
                            # Continue turning slightly left to maintain trajectory
                            logger.info("Maintaining left steering angle since object was last seen on the left")
                            print("🔄 Maintaining left steering angle...")
                            self.px.set_dir_servo_angle(-10)
                        elif last_direction == "right":
                            # Continue turning slightly right to maintain trajectory
                            logger.info("Maintaining right steering angle since object was last seen on the right")
                            print("🔄 Maintaining right steering angle...")
                            self.px.set_dir_servo_angle(10)
            
            # Calculate approach speed and duration based on current distance and alignment
            is_centered = self.memory.get("last_direction", "center") == "center"
            
            if current_distance > 100 and is_centered:
                # Far away and well-aligned, take bigger steps
                approach_speed = 40
                approach_duration = min(0.8, current_distance / 150)  # Longer duration for faster approach
                logger.info(f"Object centered and far away, moving quickly for {approach_duration:.1f}s")
                print(f"🚗 Object centered and far away, moving quickly for {approach_duration:.1f}s...")
            elif current_distance > 50:
                # Still far away, move at moderate speed
                approach_speed = 30
                approach_duration = min(0.5, current_distance / 200)  # Adaptive duration
                logger.info(f"Moving forward toward object for {approach_duration:.1f}s")
                print(f"🚗 Moving forward toward object for {approach_duration:.1f}s...")
            elif current_distance > 25:
                # Getting close, slow down
                approach_speed = 20
                approach_duration = min(0.3, current_distance / 250)  # Shorter movements
                logger.info(f"Approaching object at medium speed for {approach_duration:.1f}s")
                print(f"🚘 Approaching object at medium speed for {approach_duration:.1f}s...")
            else:
                # Very close, move very slowly for final approach
                approach_speed = 15
                approach_duration = min(0.2, current_distance / 300)  # Very short movements
                logger.info(f"Final approach at slow speed for {approach_duration:.1f}s")
                print(f"🚙 Final approach at slow speed for {approach_duration:.1f}s...")
                
            # Add a small pause before moving to ensure stability
            time.sleep(0.2)
            
            # Move forward
            logger.info(f"Moving forward at speed {approach_speed} for {approach_duration}s")
            self.px.forward(approach_speed)
            time.sleep(approach_duration)
            self.px.stop()
            
            # Update distance tracking
            previous_distance = current_distance
            current_distance = self.check_distance()
            if current_distance < 0 or current_distance > 300:
                # Try one more time
                time.sleep(0.1)
                current_distance = self.check_distance()
                if current_distance < 0 or current_distance > 300:
                    # If still invalid, use an estimate based on previous distance
                    current_distance = previous_distance * 0.7  # Assume we moved about 30% closer
            
            logger.info(f"Getting closer, distance: {current_distance}cm (was {previous_distance}cm)")
            print(f"📏 New distance: {current_distance}cm (was {previous_distance}cm)")
        
        logger.info(f"Final distance to object: {current_distance}cm")
        print(f"🎉 Final distance to object: {current_distance}cm")
        return current_distance
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

# Simple memory implementation for the object search tool
class SearchMemory:
    """Simple memory class for storing search-related information"""
    
    def __init__(self):
        """Initialize the memory"""
        self._memory = {}
        self._lists = {}
    
    def set(self, key, value):
        """Set a value in memory"""
        self._memory[key] = value
    
    def get(self, key, default=None):
        """Get a value from memory"""
        return self._memory.get(key, default)
    
    def add(self, list_name, item):
        """Add an item to a list in memory"""
        if list_name not in self._lists:
            self._lists[list_name] = []
        self._lists[list_name].append(item)
    
    def get_list(self, list_name):
        """Get a list from memory"""
        return self._lists.get(list_name, [])
    
    def clear(self):
        """Clear the memory"""
        self._memory = {}
        self._lists = {}



##################################################
# FILE: src/agent/tools/__init__.py
##################################################

from .base_tool import BaseTool, ToolExecutionError
from .registry import ToolRegistry, tool_registry
from .object_search_tool import ObjectSearchTool

__all__ = [
    'BaseTool',
    'ToolExecutionError',
    'ToolRegistry',
    'tool_registry',
    'ObjectSearchTool'
]


##################################################
# FILE: src/agent/tools/object_search_tool_new.py
##################################################

"""Object Search Tool for the Robot Agent

This tool enables the agent to search for any object in the environment
using GPT-4 Vision for object detection and PiCar-X for movement.
"""

from typing import Dict, Any, Optional, Tuple, List
import os
import sys
import time
import base64
import json
import logging
import asyncio
from pathlib import Path

from ..memory import SearchMemory
from .base_tool import BaseTool, ToolExecutionError

logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectSearchTool(BaseTool):
    """Tool for searching for objects in the environment.
    
    This is a high-level tool that combines movement, vision, and navigation
    to search for objects in the environment. It uses GPT-4 Vision for object detection
    and controls the PiCar-X robot to move around and find the specified object.
    """
    
    name = "search_for_object"
    description = "Search for an object in the environment. Returns when found or search is complete."
    
    parameters = {
        "object_name": {
            "type": str,
            "description": "Name or description of the object to find",
            "required": True
        },
        "search_area": {
            "type": str,
            "description": "Optional area to search (e.g., 'living_room', 'kitchen')",
            "required": False
        },
        "timeout": {
            "type": int,
            "description": "Maximum search time in seconds (default: 120)",
            "required": False,
            "default": 120
        },
        "confidence_threshold": {
            "type": float,
            "description": "Confidence threshold for object detection (0.0-1.0)",
            "required": False,
            "default": 0.7
        }
    }
    
    def __init__(self, car, vision_system, navigator=None):
        """Initialize the object search tool.
        
        Args:
            car: Instance of the car controller
            vision_system: Instance of the vision system for object detection
            navigator: Optional navigator for room-level navigation
        """
        self.car = car  # Car controller interface
        self.vision_system = vision_system  # Vision system interface
        self.navigator = navigator  # Optional room navigator
        self.memory = SearchMemory()  # Memory for search history
        
        # Search state
        self.is_searching = False
        self.search_start_time = 0
        
        # Initialize OpenAI client if needed
        # Note: In our architecture, this should be handled by the vision_system
        self.openai_client = None
        if hasattr(self.vision_system, 'openai_client'):
            self.openai_client = self.vision_system.openai_client
        elif OPENAI_AVAILABLE and OPENAI_API_KEY:
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized directly in ObjectSearchTool")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Hardware availability flags
        self.hardware_available = hasattr(self.car, 'px') and self.car.px is not None
        self.camera_initialized = hasattr(self.vision_system, 'camera_initialized') and self.vision_system.camera_initialized
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute the object search.
        
        Returns:
            Dict containing search results
        """
        try:
            # Validate and extract parameters
            object_name = kwargs.get("object_name")
            search_area = kwargs.get("search_area")
            timeout = kwargs.get("timeout", 120)
            confidence_threshold = kwargs.get("confidence_threshold", 0.7)
            
            if not object_name:
                raise ToolExecutionError("object_name parameter is required")
            
            logger.info(f"Starting search for {object_name} in {search_area or 'current area'}")
            
            self.is_searching = True
            self.search_start_time = time.time()
            
            # Execute the search
            found = await self._search_for_object(object_name, timeout, confidence_threshold)
            
            # Format and return results
            elapsed = time.time() - self.search_start_time
            
            if found:
                return {
                    "status": "success",
                    "message": f"Found {object_name} after {elapsed:.1f}s",
                    "object_found": True,
                    "search_area": search_area,
                    "search_time": elapsed
                }
            else:
                return {
                    "status": "not_found",
                    "message": f"Search completed, {object_name} not found after {elapsed:.1f}s",
                    "object_found": False,
                    "search_area": search_area,
                    "search_time": elapsed
                }
                
        except Exception as e:
            logger.error(f"Error during object search: {e}")
            return {
                "status": "error",
                "message": str(e),
                "object_found": False
            }
        finally:
            self.is_searching = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.hardware_available:
            logger.warning("Hardware not available, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized")
            return 100  # Default safe distance
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100  # Default safe distance on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="tennis ball"):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                # Move toward the object
                                self.move_toward_object(position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_object:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
            
            return found_object
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def move_toward_object(self, position):
        """Move toward the detected object based on its position with improved approach"""
        if not position:
            logger.warning("No position information available")
            return
        
        # Parse position information (format is typically "left/right/center, top/middle/bottom")
        position = position.lower()
        logger.info(f"Moving toward object at position: {position}")
        print(f"🚗 Moving toward object at {position}...")
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if "left" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = -45
            else:
                turn_angle = -30
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif "right" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = 45
            else:
                turn_angle = 30
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.5)
        
        # Check distance before moving forward
        distance = self.check_distance()
        
        # Handle invalid distance readings
        if distance < 0 or distance > 300:
            logger.warning(f"Invalid distance reading: {distance}cm, using default")
            distance = 50  # Use a reasonable default
        
        if distance < 20:  # Less than 20cm
            logger.warning(f"Obstacle detected at {distance}cm, cannot approach further")
            print(f"⚠️ Obstacle at {distance}cm, cannot approach further")
            return
        
        # Calculate approach distance based on current distance
        # Move shorter distances for more precise positioning
        approach_time = min(distance / 100, 1.0)  # Scale approach time by distance, max 1 second
        
        # Move forward toward the object
        logger.info(f"Moving forward toward object for {approach_time:.1f}s")
        print(f"🚗 Moving forward toward object for {approach_time:.1f}s...")
        
        # Move forward with appropriate speed based on distance
        speed = 40 if distance > 50 else 30  # Slower when closer
        self.move_forward(speed=speed, duration=approach_time)
        
        # Check distance again
        new_distance = self.check_distance()
        
        # Handle invalid distance readings
        if new_distance < 0 or new_distance > 300:
            logger.warning(f"Invalid distance reading: {new_distance}cm, using default")
            new_distance = 30  # Use a reasonable default
        
        if new_distance < 20:  # Less than 20cm
            logger.info(f"Reached object at {new_distance}cm")
            print(f"🎉 Reached object! Distance: {new_distance}cm")
            # Celebrate by turning in place
            self.turn(20)
            time.sleep(0.3)
            self.turn(-40)
            time.sleep(0.3)
            self.turn(20)
        elif new_distance < distance - 10:  # Made progress, try once more
            # Move a bit more if still far away but we're getting closer
            logger.info(f"Getting closer, distance: {new_distance}cm (was {distance}cm)")
            print(f"🚗 Getting closer, distance: {new_distance}cm...")
            
            # Calculate new approach time
            approach_time = min(new_distance / 150, 0.8)  # Shorter time for fine positioning
            self.move_forward(speed=25, duration=approach_time)  # Slower speed for precision
            
            # Final distance check
            final_distance = self.check_distance()
            if 0 <= final_distance < 300:  # Valid reading
                logger.info(f"Final distance to object: {final_distance}cm")
                print(f"🎉 Final distance to object: {final_distance}cm")
            else:
                logger.warning(f"Invalid final distance reading: {final_distance}cm")
                print("🎉 Reached destination!")
        else:
            # Didn't get much closer, might be a false positive or object is not directly ahead
            logger.info(f"Approach complete, final distance: {new_distance}cm")
            print(f"🎉 Approach complete, final distance: {new_distance}cm")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="PiCar-X Object Finder")
    parser.add_argument("--timeout", type=int, default=60, help="Search timeout in seconds")
    parser.add_argument("--confidence", type=float, default=0.6, help="Confidence threshold (0-1)")
    parser.add_argument("--api-key", type=str, help="OpenAI API key")
    parser.add_argument("--object", type=str, default="tennis ball", help="Object to search for")
    args = parser.parse_args()
    
    # Initialize the object finder
    finder = ObjectFinder()
    
    # Start the search
    print(f"Starting {args.object} search with timeout {args.timeout}s")
    try:
        finder.search_for_object(object_name=args.object, timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: src/agent/tools/enhanced_search_tool.py
##################################################

#!/usr/bin/env python3
"""
Enhanced Object Search Tool for PiCar-X
Implements advanced search patterns and obstacle avoidance
"""

import os
import sys
import time
import asyncio
import logging
import random
from typing import Dict, Any, Optional, List, Tuple

# Import base tool
from src.agent.tools.base_tool import BaseTool, ToolExecutionError

# Import memory components
from src.agent.memory.search_memory import SearchMemory, SearchArea

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('enhanced_search.log')
    ]
)
logger = logging.getLogger(__name__)

class EnhancedSearchTool(BaseTool):
    """
    Enhanced tool for searching for objects with advanced patterns and obstacle avoidance
    """
    
    def __init__(self, car=None, vision_system=None, memory=None):
        """Initialize the search tool with hardware components"""
        super().__init__(
            name="search_for_object",
            description="Search for a specific object in the environment",
            parameters={
                "object_name": {
                    "type": "string",
                    "description": "Name of the object to search for"
                },
                "search_area": {
                    "type": "object",
                    "description": "Optional area to search within",
                    "required": False
                },
                "timeout": {
                    "type": "integer",
                    "description": "Maximum time to search in seconds",
                    "default": 60,
                    "required": False
                },
                "min_confidence": {
                    "type": "number",
                    "description": "Minimum confidence threshold for object detection",
                    "default": 0.7,
                    "required": False
                }
            }
        )
        
        # Store hardware components
        self.car = car
        self.vision_system = vision_system
        self.memory = memory or SearchMemory()
        
        # Search state
        self.is_searching = False
        self.current_search = None
        
        # Import hardware integration if not provided
        if self.car is None or self.vision_system is None:
            try:
                from src.agent.hardware_integration import get_hardware, get_vision_system, get_obstacle_avoidance
                self.car = self.car or get_hardware()
                self.vision_system = self.vision_system or get_vision_system()
                self.obstacle_avoidance = get_obstacle_avoidance()
                logger.info("Hardware components loaded from integration module")
            except ImportError as e:
                logger.error(f"Failed to import hardware integration: {e}")
                raise ToolExecutionError("Hardware integration not available")
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute the search for the specified object"""
        # Extract parameters
        object_name = kwargs.get("object_name")
        search_area = kwargs.get("search_area")
        timeout = kwargs.get("timeout", 60)
        min_confidence = kwargs.get("min_confidence", 0.7)
        
        if not object_name:
            raise ToolExecutionError("Object name is required")
        
        logger.info(f"Starting search for {object_name} with timeout {timeout}s")
        self.is_searching = True
        self.current_search = {
            "object_name": object_name,
            "start_time": time.time(),
            "timeout": timeout
        }
        
        try:
            # Check if we already know where this object is
            remembered_location = self.memory.recall_object_location(object_name)
            if remembered_location:
                logger.info(f"Found {object_name} in memory at {remembered_location}")
                return {
                    "status": "success",
                    "object_name": object_name,
                    "location": remembered_location,
                    "confidence": 0.9,  # High confidence since we remember it
                    "source": "memory"
                }
            
            # Start the search
            return await self._search_for_object(
                object_name=object_name,
                search_area=search_area,
                timeout=timeout,
                min_confidence=min_confidence
            )
        
        except Exception as e:
            logger.error(f"Search failed: {e}")
            return {
                "status": "error",
                "message": str(e)
            }
        
        finally:
            self.is_searching = False
            self.current_search = None
    
    async def _search_for_object(self, object_name, search_area=None, timeout=60, min_confidence=0.7):
        """
        Implement the search logic with advanced patterns and obstacle avoidance
        """
        start_time = time.time()
        search_patterns = self._get_search_patterns()
        pattern_index = 0
        
        # Track visited positions to avoid revisiting
        visited_positions = set()
        
        while time.time() - start_time < timeout:
            # Check if we've exhausted our patterns
            if pattern_index >= len(search_patterns):
                pattern_index = 0  # Start over with the patterns
            
            # Get the current pattern
            current_pattern = search_patterns[pattern_index]
            logger.info(f"Executing search pattern {pattern_index + 1}/{len(search_patterns)}")
            
            # Execute each step in the pattern
            for step_idx, (action, value) in enumerate(current_pattern):
                # Check timeout
                if time.time() - start_time >= timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    return {
                        "status": "timeout",
                        "message": f"Search timed out after {timeout}s"
                    }
                
                # Execute the action
                try:
                    if action == "move":
                        # Check for obstacles before moving
                        path_clear = await self._check_and_avoid_obstacles()
                        if not path_clear:
                            logger.warning("Could not clear path, trying different direction")
                            continue
                        
                        await self.car.move_forward(value)
                    elif action == "turn":
                        await self.car.turn(value)
                    elif action == "scan":
                        # Scan for the object
                        result = await self._scan_for_object(object_name, min_confidence)
                        if result:
                            return result
                    
                    # Record the current position
                    current_pos = self.car.get_position()
                    pos_key = (round(current_pos[0], 1), round(current_pos[1], 1))
                    
                    # If we've been here before, try a different pattern
                    if pos_key in visited_positions:
                        logger.info(f"Already visited position {pos_key}, trying different pattern")
                        break
                    
                    visited_positions.add(pos_key)
                    self.memory.record_visit(current_pos)
                    
                except Exception as e:
                    logger.error(f"Error during search step {step_idx}: {e}")
            
            # Move to the next pattern
            pattern_index += 1
        
        # If we get here, we didn't find the object
        logger.warning(f"Failed to find {object_name} after {timeout}s")
        return {
            "status": "not_found",
            "message": f"Failed to find {object_name} after {timeout}s"
        }
    
    async def _scan_for_object(self, object_name, min_confidence):
        """Scan the current area for the target object"""
        logger.info(f"Scanning for {object_name}")
        
        # Capture image and detect objects
        detected_objects = await self.vision_system.detect_objects()
        
        # Check if we found the target object
        for obj in detected_objects:
            if obj['name'].lower() == object_name.lower() and obj.get('confidence', 0) >= min_confidence:
                # Record the sighting
                self.memory.record_sighting(
                    object_name=obj['name'],
                    position=obj['position'],
                    confidence=obj['confidence']
                )
                
                logger.info(f"Found {object_name} at {obj['position']} with {obj['confidence']:.1%} confidence")
                return {
                    "status": "success",
                    "object_name": object_name,
                    "location": obj['position'],
                    "confidence": obj['confidence'],
                    "source": "vision"
                }
        
        return None
    
    async def _check_and_avoid_obstacles(self):
        """Check for obstacles and avoid them if necessary"""
        if not hasattr(self, 'obstacle_avoidance'):
            # No obstacle avoidance available
            return True
            
        # Check if path is clear
        path_clear = await self.obstacle_avoidance.check_path()
        if not path_clear:
            # Try to avoid the obstacle
            return await self.obstacle_avoidance.avoid_obstacle()
        
        return True
    
    def _get_search_patterns(self):
        """
        Get a list of search patterns to try
        Each pattern is a list of (action, value) tuples
        Actions: "move" (distance in meters), "turn" (degrees), "scan" (None)
        """
        return [
            # Spiral pattern
            [
                ("scan", None),
                ("move", 0.5), ("turn", 90), ("scan", None),
                ("move", 0.5), ("turn", 90), ("scan", None),
                ("move", 1.0), ("turn", 90), ("scan", None),
                ("move", 1.0), ("turn", 90), ("scan", None),
                ("move", 1.5), ("turn", 90), ("scan", None),
            ],
            
            # Grid pattern
            [
                ("scan", None),
                ("move", 1.0), ("scan", None),
                ("turn", 90), ("move", 0.5), ("turn", 90), ("scan", None),
                ("move", 1.0), ("scan", None),
                ("turn", -90), ("move", 0.5), ("turn", -90), ("scan", None),
            ],
            
            # Random exploration
            [
                ("scan", None),
                ("turn", random.uniform(-45, 45)), ("move", random.uniform(0.5, 1.5)), ("scan", None),
                ("turn", random.uniform(-45, 45)), ("move", random.uniform(0.5, 1.5)), ("scan", None),
                ("turn", random.uniform(-45, 45)), ("move", random.uniform(0.5, 1.5)), ("scan", None),
            ]
        ]


##################################################
# FILE: src/agent/tools/base_tool.py
##################################################

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Type, TypeVar

T = TypeVar('T', bound='BaseTool')

class ToolExecutionError(Exception):
    """Exception raised when a tool fails to execute."""
    def __init__(self, message: str, tool_name: Optional[str] = None):
        self.tool_name = tool_name
        self.message = message
        super().__init__(self.message)

class BaseTool(ABC):
    """Base class for all tools in the agent system.
    
    Tools can be high-level (task-oriented) or low-level (direct hardware control).
    """
    
    name: str
    description: str
    parameters: Dict[str, Any]
    
    def __init_subclass__(cls, **kwargs):
        """Register the tool in the registry when subclassed."""
        super().__init_subclass__(**kwargs)
        if hasattr(cls, 'name') and cls.name:
            from .registry import ToolRegistry
            ToolRegistry.register_tool(cls)
    
    @classmethod
    def from_dict(cls: Type[T], data: Dict[str, Any]) -> T:
        """Create a tool instance from a dictionary."""
        return cls(**data)
    
    @abstractmethod
    async def execute(self, **kwargs) -> Any:
        """Execute the tool with the given parameters.
        
        Args:
            **kwargs: Tool-specific parameters
            
        Returns:
            The result of the tool execution
        """
        pass
    
    def validate_parameters(self, **kwargs) -> bool:
        """Validate the provided parameters against the tool's schema."""
        if not hasattr(self, 'parameters'):
            return True
            
        for param, param_info in self.parameters.items():
            if param_info.get('required', False) and param not in kwargs:
                raise ValueError(f"Missing required parameter: {param}")
                
            param_type = param_info.get('type')
            if param in kwargs and param_type:
                if not isinstance(kwargs[param], param_type):
                    try:
                        kwargs[param] = param_type(kwargs[param])
                    except (TypeError, ValueError):
                        raise ValueError(f"Parameter {param} must be of type {param_type.__name__}")
        
        return True


##################################################
# FILE: src/agent/tools/object_search_tool_clean.py
##################################################

"""
Object Search Tool for the Robot Agent

This tool enables the agent to search for any object in the environment
using GPT-4 Vision for object detection and PiCar-X for movement.
"""

import os
import sys
import time
import base64
import json
import logging
import asyncio
from typing import Dict, Any, Optional, Tuple, List
from pathlib import Path

from ..memory import SearchMemory
from .base_tool import BaseTool, ToolExecutionError

logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectSearchTool(BaseTool):
    """
    Tool for searching for objects in the environment.
    
    This is a high-level tool that combines movement, vision, and navigation
    to search for objects in the environment. It uses GPT-4 Vision for object detection
    and controls the PiCar-X robot to move around and find the specified object.
    """
    
    name = "search_for_object"
    description = "Search for an object in the environment. Returns when found or search is complete."
    
    parameters = {
        "object_name": {
            "type": str,
            "description": "Name or description of the object to find",
            "required": True
        },
        "search_area": {
            "type": str,
            "description": "Optional area to search (e.g., 'living_room', 'kitchen')",
            "required": False
        },
        "timeout": {
            "type": int,
            "description": "Maximum search time in seconds (default: 120)",
            "required": False,
            "default": 120
        },
        "confidence_threshold": {
            "type": float,
            "description": "Confidence threshold for object detection (0.0-1.0)",
            "required": False,
            "default": 0.7
        }
    }
    
    def __init__(self, car, vision_system, navigator=None):
        """Initialize the object search tool.
        
        Args:
            car: Instance of the car controller
            vision_system: Instance of the vision system for object detection
            navigator: Optional navigator for room-level navigation
        """
        self.car = car  # Car controller interface
        self.vision_system = vision_system  # Vision system interface
        self.navigator = navigator  # Optional room navigator
        self.memory = SearchMemory()  # Memory for search history
        
        # Search state
        self.is_searching = False
        self.search_start_time = 0
        
        # Hardware references for compatibility with existing code
        self.px = getattr(self.car, 'px', None)
        self.openai_client = getattr(self.vision_system, 'openai_client', None)
        
        # Hardware availability flags
        self.hardware_available = self.px is not None
        self.camera_initialized = getattr(self.vision_system, 'camera_initialized', False)
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute the object search.
        
        Args:
            object_name: Name or description of the object to find
            search_area: Optional area to search (e.g., 'living_room', 'kitchen')
            timeout: Maximum search time in seconds (default: 120)
            confidence_threshold: Confidence threshold for object detection (0.0-1.0)
            
        Returns:
            Dict containing search results
        """
        try:
            # Extract parameters
            object_name = kwargs.get("object_name")
            search_area = kwargs.get("search_area")
            timeout = kwargs.get("timeout", 120)
            confidence_threshold = kwargs.get("confidence_threshold", 0.7)
            
            if not object_name:
                raise ToolExecutionError("object_name parameter is required")
            
            logger.info(f"Starting search for {object_name} in {search_area or 'current area'}")
            
            self.is_searching = True
            self.search_start_time = time.time()
            
            # Execute the search
            found = await self.search_for_object(object_name, timeout, confidence_threshold)
            
            # Format and return results
            elapsed = time.time() - self.search_start_time
            
            if found:
                return {
                    "status": "success",
                    "message": f"Found {object_name} after {elapsed:.1f}s",
                    "object_found": True,
                    "search_area": search_area,
                    "search_time": elapsed
                }
            else:
                return {
                    "status": "not_found",
                    "message": f"Search completed, {object_name} not found after {elapsed:.1f}s",
                    "object_found": False,
                    "search_area": search_area,
                    "search_time": elapsed
                }
                
        except Exception as e:
            logger.error(f"Error during object search: {e}")
            return {
                "status": "error",
                "message": str(e),
                "object_found": False
            }
        finally:
            self.is_searching = False
    
    async def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.hardware_available:
            logger.warning("Hardware not available, simulating movement")
            await asyncio.sleep(duration)
            return
        
        try:
            # Use car interface if available, otherwise fall back to direct px access
            if hasattr(self.car, 'move_forward'):
                await self.car.move_forward(speed, duration)
            else:
                self.px.forward(speed)
                await asyncio.sleep(duration)
                self.px.stop()
        except Exception as e:
            logger.error(f"Error moving forward: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    async def turn(self, angle):
        """Turn by the specified angle"""
        if not self.hardware_available:
            logger.warning("Hardware not available, simulating turn")
            await asyncio.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            
            # Use car interface if available, otherwise fall back to direct px access
            if hasattr(self.car, 'turn'):
                await self.car.turn(angle)
            else:
                if angle > 0:
                    # Turn right
                    self.px.set_dir_servo_angle(30)
                    await asyncio.sleep(0.5)
                    self.px.forward(50)
                    await asyncio.sleep(abs(angle) / 90)  # Approximate timing
                else:
                    # Turn left
                    self.px.set_dir_servo_angle(-30)
                    await asyncio.sleep(0.5)
                    self.px.forward(50)
                    await asyncio.sleep(abs(angle) / 90)  # Approximate timing
                
                # Reset steering and stop
                self.px.set_dir_servo_angle(0)
                self.px.stop()
            # Note: Reset already handled in the else block if needed
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    async def check_distance(self) -> float:
        """Check distance using ultrasonic sensor with improved reliability
        
        Returns:
            float: Distance in cm, or 100 (default safe distance) if unavailable
        """
        if not self.hardware_available:
            logger.warning("Hardware not available")
            return 100.0  # Default safe distance
        
        try:
            # Use car interface if available
            if hasattr(self.car, 'get_distance'):
                return await self.car.get_distance()
            
            # Otherwise use direct hardware access
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                await asyncio.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                # Move toward the object
                                self.move_toward_object(position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_object:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
            
            return found_object
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def move_toward_object(self, position):
        """Move toward the detected object based on its position with improved approach"""
        if not position:
            logger.warning("No position information available")
            return
        
        # Parse position information (format is typically "left/right/center, top/middle/bottom")
        position = position.lower()
        logger.info(f"Moving toward object at position: {position}")
        print(f"🚗 Moving toward object at {position}...")
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if "left" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = -45
            else:
                turn_angle = -30
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif "right" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = 45
            else:
                turn_angle = 30
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.5)
        
        # Check distance before moving forward
        distance = self.check_distance()
        
        # Handle invalid distance readings
        if distance < 0 or distance > 300:
            logger.warning(f"Invalid distance reading: {distance}cm, using default")
            distance = 50  # Use a reasonable default
        
        if distance < 20:  # Less than 20cm
            logger.warning(f"Obstacle detected at {distance}cm, cannot approach further")
            print(f"⚠️ Obstacle at {distance}cm, cannot approach further")
            return
        
        # Calculate approach distance based on current distance
        # Move shorter distances for more precise positioning
        approach_time = min(distance / 100, 1.0)  # Scale approach time by distance, max 1 second
        
        # Move forward toward the object
        logger.info(f"Moving forward toward object for {approach_time:.1f}s")
        print(f"🚗 Moving forward toward object for {approach_time:.1f}s...")
        
        # Move forward with appropriate speed based on distance
        speed = 40 if distance > 50 else 30  # Slower when closer
        self.move_forward(speed=speed, duration=approach_time)
        
        # Check distance again
        new_distance = self.check_distance()
        
        # Handle invalid distance readings
        if new_distance < 0 or new_distance > 300:
            logger.warning(f"Invalid distance reading: {new_distance}cm, using default")
            new_distance = 30  # Use a reasonable default
        
        if new_distance < 20:  # Less than 20cm
            logger.info(f"Reached object at {new_distance}cm")
            print(f"🎉 Reached object! Distance: {new_distance}cm")
            # Celebrate by turning in place
            self.turn(20)
            time.sleep(0.3)
            self.turn(-40)
            time.sleep(0.3)
            self.turn(20)
        elif new_distance < distance - 10:  # Made progress, try once more
            # Move a bit more if still far away but we're getting closer
            logger.info(f"Getting closer, distance: {new_distance}cm (was {distance}cm)")
            print(f"🚗 Getting closer, distance: {new_distance}cm...")
            
            # Calculate new approach time
            approach_time = min(new_distance / 150, 0.8)  # Shorter time for fine positioning
            self.move_forward(speed=25, duration=approach_time)  # Slower speed for precision
            
            # Final distance check
            final_distance = self.check_distance()
            if 0 <= final_distance < 300:  # Valid reading
                logger.info(f"Final distance to object: {final_distance}cm")
                print(f"🎉 Final distance to object: {final_distance}cm")
            else:
                logger.warning(f"Invalid final distance reading: {final_distance}cm")
                print("🎉 Reached destination!")
        else:
            # Didn't get much closer, might be a false positive or object is not directly ahead
            logger.info(f"Approach complete, final distance: {new_distance}cm")
            print(f"🎉 Approach complete, final distance: {new_distance}cm")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="PiCar-X Object Finder")
    parser.add_argument("--timeout", type=int, default=60, help="Search timeout in seconds")
    parser.add_argument("--confidence", type=float, default=0.6, help="Confidence threshold (0-1)")
    parser.add_argument("--api-key", type=str, help="OpenAI API key")
    parser.add_argument("--object", type=str, default="tennis ball", help="Object to search for")
    args = parser.parse_args()
    
    # Initialize the object finder
    finder = ObjectFinder()
    
    # Start the search
    print(f"Starting {args.object} search with timeout {args.timeout}s")
    try:
        finder.search_for_object(object_name=args.object, timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: src/agent/tools/object_search_tool_fresh.py
##################################################

#!/usr/bin/env python3
"""
Backpack Finder for PiCar-X using vilib
Uses GPT-4 Vision to search for a backpack
Based on the working hardware initialization pattern from working_gpt_car.py
"""

import os
import sys
import time
import base64
import json
import logging
import argparse
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('backpack_finder.log')
    ]
)
logger = logging.getLogger(__name__)

# Try to import hardware components
try:
    # Following the exact import pattern from working_gpt_car.py
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available: {e}")
    HARDWARE_AVAILABLE = False

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available")
    OPENAI_AVAILABLE = False

# Try to import vilib for camera access
try:
    from vilib import Vilib
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    CAMERA_AVAILABLE = False

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
        logger.info("OpenAI API key loaded from keys.py")
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class ObjectFinder:
    """
    PiCar-X robot that searches for a backpack using GPT-4 Vision
    """
    
    def __init__(self):
        """Initialize the backpack finder"""
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # Initialize hardware
        self._init_hardware()
        
        # Initialize OpenAI client
        if OPENAI_AVAILABLE and OPENAI_API_KEY:
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Initialize camera using vilib (following gpt_car.py pattern)
        if CAMERA_AVAILABLE:
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return
        
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED')  # Use 'LED' as in working_gpt_car.py
            
            # Change working directory to current path (as in working_gpt_car.py)
            current_path = os.path.dirname(os.path.abspath(__file__))
            os.chdir(current_path)
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            time.sleep(duration)
            return
        
        try:
            logger.info(f"Moving forward at speed {speed} for {duration}s")
            self.px.forward(speed)
            time.sleep(duration)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            if self.initialized:
                self.px.stop()  # Safety stop
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            time.sleep(abs(angle) / 90)
            return
        
        try:
            logger.info(f"Turning {angle} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(angle, 35), -35)
            
            if clamped_angle != angle:
                logger.warning(f"Angle {angle} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(angle) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                time.sleep(abs(angle) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                time.sleep(abs(angle) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            if self.initialized:
                self.px.set_dir_servo_angle(0)  # Reset steering
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized")
            return 100  # Default safe distance
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100  # Default safe distance on error
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized")
            return None
        
        try:
            # Get the current frame from vilib.img (as in gpt_car.py)
            if not hasattr(Vilib, 'img') or Vilib.img is None:
                logger.warning("No image available from vilib")
                return None
                
            # Save the image
            cv2.imwrite(save_path, Vilib.img)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="tennis ball"):
        """Analyze an image using GPT-4 Vision to find objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available")
            return []
        
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return []
        
        try:
            # Encode image to base64
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Call GPT-4 Vision API
            prompt = (
                "Identify all objects visible in this image. "
                "I'm particularly interested in finding a " + object_name + " if one is present. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Try to parse JSON from the response
            try:
                # Look for JSON array in the response
                import re
                json_match = re.search(r'\[.*\]', result, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                    objects = json.loads(json_str)
                    return objects
            except Exception as e:
                logger.error(f"Failed to parse JSON from response: {e}")
            
            # If JSON parsing fails, return a simple representation
            return [{"name": "unknown", "confidence": 0.5, "position": "unknown"}]
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def search_for_object(self, object_name="tennis ball", timeout=60, confidence_threshold=0.6):
        """Search for a tennis ball using a comprehensive search pattern"""
        logger.info(f"Starting search for {object_name}")
        print(f"🔍 Searching for {object_name}...")
        
        start_time = time.time()
        found_object = False
        
        # First do a full 360-degree scan in place
        full_scan_angles = [0, 45, 90, 135, 180, 225, 270, 315, 0]  # Return to original position
        
        try:
            # First do a full 360-degree scan in place
            logger.info("Starting 360-degree scan")
            print("🔄 Starting 360-degree scan...")
            
            for angle in full_scan_angles:
                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning(f"Search timed out after {timeout}s")
                    print(f"⏱️ Search timed out after {timeout}s")
                    break
                
                # Turn to the specified angle
                if angle != 0 or full_scan_angles.index(angle) == 0:  # Skip the last 0 turn
                    logger.info(f"Turning to {angle} degrees for scan")
                    print(f"🔄 Turning to {angle} degrees for scan...")
                    
                    # Calculate relative angle to turn
                    if full_scan_angles.index(angle) == 0:
                        # First angle, just set position
                        self.turn(angle)
                    else:
                        # Calculate difference from previous angle
                        prev_angle = full_scan_angles[full_scan_angles.index(angle) - 1]
                        diff = angle - prev_angle
                        # Handle wrap-around (e.g., from 315 to 0)
                        if diff < -180:
                            diff += 360
                        elif diff > 180:
                            diff -= 360
                        self.turn(diff)
                
                # Scan at this angle
                logger.info(f"Scanning at {angle} degrees")
                print(f"📸 Taking a picture at {angle} degrees...")
                
                # Capture image
                image_path = self.capture_image()
                if not image_path:
                    logger.warning("Failed to capture image")
                    continue
                
                # Analyze image with GPT-4 Vision
                objects = self.analyze_image_with_gpt4(image_path, object_name)
                
                # Check if we found the object
                for obj in objects:
                    obj_name = obj.get("name", "").lower()
                    confidence = obj.get("confidence", 0)
                    position = obj.get("position", "unknown")
                    
                    if object_name.lower() in obj_name and confidence >= confidence_threshold:
                        logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                        print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                        found_object = True
                        # Move toward the object
                        self.move_toward_object(position)
                        break
                    else:
                        # Log other objects seen
                        logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                        print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                
                if found_object:
                    break
            
            # If object not found in initial scan, do a more thorough search
            if not found_object and time.time() - start_time < timeout:
                logger.info(f"{object_name} not found in initial scan, starting exploration")
                print(f"🔍 {object_name} not found in initial scan, exploring the area...")
                
                # Define a more thorough search pattern
                search_pattern = [
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn right and scan
                    ("turn", 90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                    
                    # Turn left and scan
                    ("turn", -90),
                    ("scan", None),
                    
                    # Move forward and scan
                    ("forward", 0.5),
                    ("scan", None),
                ]
                
                for action, param in search_pattern:
                    # Check timeout
                    if time.time() - start_time > timeout:
                        logger.warning(f"Search timed out after {timeout}s")
                        print(f"⏱️ Search timed out after {timeout}s")
                        break
                    
                    # Check for obstacles
                    distance = self.check_distance()
                    if distance < 20:  # Less than 20cm
                        logger.warning(f"Obstacle detected at {distance}cm, adjusting path")
                        print(f"⚠️ Obstacle detected at {distance}cm, adjusting path")
                        
                        # Try to find a clear path
                        clear_path_found = False
                        for test_angle in [45, -45, 90, -90]:
                            self.turn(test_angle)
                            test_distance = self.check_distance()
                            if test_distance > 30:  # Found a clear path
                                logger.info(f"Found clear path at angle {test_angle}, distance {test_distance}cm")
                                print(f"🛣️ Found clear path, continuing search...")
                                clear_path_found = True
                                break
                        
                        if not clear_path_found:
                            logger.warning("No clear path found, reversing direction")
                            print("⚠️ No clear path found, reversing direction")
                            self.turn(180)
                        
                        continue
                    
                    # Execute the action
                    if action == "forward":
                        logger.info(f"Moving forward for {param}s")
                        print(f"🚗 Moving forward...")
                        self.move_forward(speed=50, duration=param)
                    
                    elif action == "turn":
                        logger.info(f"Turning {param} degrees")
                        print(f"🔄 Turning {param} degrees...")
                        self.turn(param)
                    
                    elif action == "scan":
                        logger.info("Scanning for " + object_name)
                        print(f"📸 Taking a picture and analyzing with GPT-4 Vision...")
                        
                        # Capture image
                        image_path = self.capture_image()
                        if not image_path:
                            logger.warning("Failed to capture image")
                            continue
                        
                        # Analyze image with GPT-4 Vision
                        objects = self.analyze_image_with_gpt4(image_path, object_name)
                        
                        # Check if we found the object
                        for obj in objects:
                            obj_name = obj.get("name", "").lower()
                            confidence = obj.get("confidence", 0)
                            position = obj.get("position", "unknown")
                            
                            if object_name.lower() in obj_name and confidence >= confidence_threshold:
                                logger.info(f"Found {object_name} with {confidence:.1%} confidence at {position}")
                                print(f"✅ Found {object_name} with {confidence:.1%} confidence at {position}!")
                                found_object = True
                                # Move toward the object
                                self.move_toward_object(position)
                                break
                            else:
                                # Log other objects seen
                                logger.info(f"Saw {obj_name} with {confidence:.1%} confidence")
                                print(f"👁️ Saw {obj_name} with {confidence:.1%} confidence")
                        
                        if found_object:
                            break
            
            # Report results
            elapsed = time.time() - start_time
            logger.info(f"Search completed in {elapsed:.1f}s")
            print(f"🕒 Search completed in {elapsed:.1f}s")
            
            if not found_object:
                logger.warning(f"Failed to find {object_name}")
                print(f"❌ Failed to find {object_name}")
            
            return found_object
        
        except Exception as e:
            logger.error(f"Search error: {e}")
            print(f"❌ Error during search: {e}")
            return False
        
        finally:
            # Stop the robot
            if self.initialized:
                self.px.stop()
    
    def move_toward_object(self, position):
        """Move toward the detected object based on its position with improved approach"""
        if not position:
            logger.warning("No position information available")
            return
        
        # Parse position information (format is typically "left/right/center, top/middle/bottom")
        position = position.lower()
        logger.info(f"Moving toward object at position: {position}")
        print(f"🚗 Moving toward object at {position}...")
        
        # First, turn toward the object based on horizontal position
        turn_angle = 0
        if "left" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = -45
            else:
                turn_angle = -30
            logger.info(f"Object is on the left, turning {turn_angle} degrees")
            print(f"🔄 Turning left {abs(turn_angle)} degrees toward object...")
            self.turn(turn_angle)
        elif "right" in position:
            # Adjust turn angle based on position descriptor
            if "far" in position:
                turn_angle = 45
            else:
                turn_angle = 30
            logger.info(f"Object is on the right, turning {turn_angle} degrees")
            print(f"🔄 Turning right {turn_angle} degrees toward object...")
            self.turn(turn_angle)
        
        # Wait a moment for the turn to complete
        time.sleep(0.5)
        
        # Check distance before moving forward
        distance = self.check_distance()
        
        # Handle invalid distance readings
        if distance < 0 or distance > 300:
            logger.warning(f"Invalid distance reading: {distance}cm, using default")
            distance = 50  # Use a reasonable default
        
        if distance < 20:  # Less than 20cm
            logger.warning(f"Obstacle detected at {distance}cm, cannot approach further")
            print(f"⚠️ Obstacle at {distance}cm, cannot approach further")
            return
        
        # Calculate approach distance based on current distance
        # Move shorter distances for more precise positioning
        approach_time = min(distance / 100, 1.0)  # Scale approach time by distance, max 1 second
        
        # Move forward toward the object
        logger.info(f"Moving forward toward object for {approach_time:.1f}s")
        print(f"🚗 Moving forward toward object for {approach_time:.1f}s...")
        
        # Move forward with appropriate speed based on distance
        speed = 40 if distance > 50 else 30  # Slower when closer
        self.move_forward(speed=speed, duration=approach_time)
        
        # Check distance again
        new_distance = self.check_distance()
        
        # Handle invalid distance readings
        if new_distance < 0 or new_distance > 300:
            logger.warning(f"Invalid distance reading: {new_distance}cm, using default")
            new_distance = 30  # Use a reasonable default
        
        if new_distance < 20:  # Less than 20cm
            logger.info(f"Reached object at {new_distance}cm")
            print(f"🎉 Reached object! Distance: {new_distance}cm")
            # Celebrate by turning in place
            self.turn(20)
            time.sleep(0.3)
            self.turn(-40)
            time.sleep(0.3)
            self.turn(20)
        elif new_distance < distance - 10:  # Made progress, try once more
            # Move a bit more if still far away but we're getting closer
            logger.info(f"Getting closer, distance: {new_distance}cm (was {distance}cm)")
            print(f"🚗 Getting closer, distance: {new_distance}cm...")
            
            # Calculate new approach time
            approach_time = min(new_distance / 150, 0.8)  # Shorter time for fine positioning
            self.move_forward(speed=25, duration=approach_time)  # Slower speed for precision
            
            # Final distance check
            final_distance = self.check_distance()
            if 0 <= final_distance < 300:  # Valid reading
                logger.info(f"Final distance to object: {final_distance}cm")
                print(f"🎉 Final distance to object: {final_distance}cm")
            else:
                logger.warning(f"Invalid final distance reading: {final_distance}cm")
                print("🎉 Reached destination!")
        else:
            # Didn't get much closer, might be a false positive or object is not directly ahead
            logger.info(f"Approach complete, final distance: {new_distance}cm")
            print(f"🎉 Approach complete, final distance: {new_distance}cm")
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="PiCar-X Object Finder")
    parser.add_argument("--timeout", type=int, default=60, help="Search timeout in seconds")
    parser.add_argument("--confidence", type=float, default=0.6, help="Confidence threshold (0-1)")
    parser.add_argument("--api-key", type=str, help="OpenAI API key")
    parser.add_argument("--object", type=str, default="tennis ball", help="Object to search for")
    args = parser.parse_args()
    
    # Initialize the object finder
    finder = ObjectFinder()
    
    # Start the search
    print(f"Starting {args.object} search with timeout {args.timeout}s")
    try:
        finder.search_for_object(object_name=args.object, timeout=args.timeout, confidence_threshold=args.confidence)
    except KeyboardInterrupt:
        print("\nSearch interrupted by user")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if finder:
            finder.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: src/agent/tools/approach_object_tool.py
##################################################

"""
Approach Object Tool for the Robot Agent

This tool enables the agent to approach an already detected object in the environment
using GPT-4 Vision for object tracking and PiCar-X for movement.
"""

import os
import sys
import time
import base64
import json
import logging
import asyncio
from typing import Dict, Any, Optional, List
from pathlib import Path

# Import agent tool base classes
try:
    from .base_tool import BaseTool, ToolExecutionError
except ImportError:
    # For standalone testing
    import sys
    from pathlib import Path
    sys.path.append(str(Path(__file__).parent))
    try:
        from base_tool import BaseTool, ToolExecutionError
    except ImportError:
        # Define minimal versions for testing
        class BaseTool:
            """Minimal BaseTool implementation for testing"""
            def __init__(self):
                self.name = "base_tool"
                self.description = "Base tool class"
                self.parameters = {}
            
            async def execute(self, **kwargs):
                """Execute the tool"""
                raise NotImplementedError
        
        class ToolExecutionError(Exception):
            """Error raised when tool execution fails"""
            pass

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('object_approach.log')
    ]
)
logger = logging.getLogger('approach_object_tool')

# Check for OpenAI availability
try:
    import openai
    OPENAI_AVAILABLE = True
    OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY')
except ImportError:
    OPENAI_AVAILABLE = False
    OPENAI_API_KEY = None
    logger.warning("OpenAI package not available, vision features will be limited")

# Check for camera and hardware availability
try:
    from vilib import Vilib
    CAMERA_AVAILABLE = True
except ImportError:
    CAMERA_AVAILABLE = False
    logger.warning("vilib not available, camera features will be limited")

# Import hardware dependencies (with fallbacks for testing)
try:
    import robot_hat
    from robot_hat import Pin, ADC, PWM, Servo, utils
    import picarx
    HARDWARE_AVAILABLE = True
except ImportError:
    HARDWARE_AVAILABLE = False
    logger.warning("Hardware libraries not available, will run in simulation mode")

# Simple memory class for storing approach-related information
class ApproachMemory:
    """Simple memory class for storing approach-related information"""
    
    def __init__(self):
        """Initialize the memory"""
        self._memory = {}
        self._lists = {}
    
    def set(self, key, value):
        """Set a value in memory"""
        self._memory[key] = value
    
    def get(self, key, default=None):
        """Get a value from memory"""
        return self._memory.get(key, default)
    
    def add(self, list_name, item):
        """Add an item to a list in memory"""
        if list_name not in self._lists:
            self._lists[list_name] = []
        self._lists[list_name].append(item)
    
    def get_list(self, list_name):
        """Get a list from memory"""
        return self._lists.get(list_name, [])
    
    def clear(self):
        """Clear the memory"""
        self._memory = {}
        self._lists = {}


class ApproachObjectTool(BaseTool):
    """Tool for approaching objects in the environment.
    
    This tool enables the agent to approach an already detected object in the environment
    using GPT-4 Vision for object tracking and PiCar-X for movement.
    """
    
    name = "approach_object"
    description = "Approach an object in the environment. Returns when reached or approach is complete."
    parameters = {
        "object_name": {
            "type": str,
            "description": "Name or description of the object to approach",
            "required": True
        },
        "position": {
            "type": str,
            "description": "Initial position of the object (e.g., 'left', 'right center')",
            "required": True
        },
        "confidence": {
            "type": float,
            "description": "Confidence in the object detection (0.0-1.0)",
            "required": False,
            "default": 0.6
        },
        "max_approach_time": {
            "type": int,
            "description": "Maximum time to spend approaching in seconds",
            "required": False,
            "default": 30
        },
        "min_distance": {
            "type": int,
            "description": "Minimum distance to maintain from object in cm",
            "required": False,
            "default": 15
        }
    }
    
    def __init__(self, car=None, vision_system=None):
        """Initialize the approach object tool.
        
        Args:
            car: Optional car controller interface. If None, will initialize hardware directly.
            vision_system: Optional vision system interface. If None, will initialize camera directly.
        """
        # Store agent interfaces if provided
        self.car = car
        self.vision_system = vision_system
        self.memory = ApproachMemory()  # Memory for approach history
        
        # Initialize state variables
        self.px = None
        self.pin = None
        self.initialized = False
        self.openai_client = None
        self.camera_initialized = False
        
        # If car interface is provided, use its hardware
        if self.car is not None and hasattr(self.car, 'px'):
            self.px = self.car.px
            self.initialized = self.px is not None
            logger.info("Using car interface for hardware access")
        else:
            # Otherwise initialize hardware directly
            self._init_hardware()
        
        # If vision system is provided, use its OpenAI client
        if self.vision_system is not None and hasattr(self.vision_system, 'openai_client'):
            self.openai_client = self.vision_system.openai_client
            logger.info("Using vision system's OpenAI client")
        elif OPENAI_AVAILABLE and OPENAI_API_KEY:
            # Otherwise initialize OpenAI client directly
            try:
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized directly")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # If vision system is provided, use its camera
        if self.vision_system is not None and hasattr(self.vision_system, 'camera_initialized'):
            self.camera_initialized = self.vision_system.camera_initialized
            logger.info("Using vision system's camera")
        elif CAMERA_AVAILABLE:
            # Otherwise initialize camera directly
            try:
                # Initialize camera with vilib (exactly as in gpt_car.py)
                Vilib.camera_start(vflip=False, hflip=False)
                Vilib.display(local=False, web=True)
                
                # Wait for camera to initialize
                for _ in range(100):  # Wait up to 1 second
                    if hasattr(Vilib, 'flask_start') and Vilib.flask_start:
                        break
                    time.sleep(0.01)
                
                time.sleep(0.5)  # Additional wait time as in gpt_car.py
                self.camera_initialized = True
                logger.info("Camera initialized with vilib directly")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute the approach object tool
        
        Args:
            object_name: Name of the object to approach
            position: Position of the object (e.g., 'left', 'right center')
            confidence: Confidence threshold for object detection
            max_approach_time: Maximum time to spend approaching in seconds
            min_distance: Minimum distance to maintain from object in cm
            
        Returns:
            Dict containing approach results
        """
        # Extract parameters
        object_name = kwargs.get('object_name', 'object')
        position = kwargs.get('position', 'center')
        confidence = kwargs.get('confidence', 0.6)
        max_approach_time = kwargs.get('max_approach_time', 30)
        min_distance = kwargs.get('min_distance', 15)
        
        logger.info(f"Executing ApproachObjectTool for {object_name} at position {position}")
        print(f"🚗 Approaching {object_name} at position {position}...")
        
        try:
            # Execute the approach algorithm
            result = self.approach_object(
                object_name=object_name,
                position=position,
                confidence=confidence,
                max_approach_time=max_approach_time,
                min_distance=min_distance
            )
            
            # Log the result
            if result["success"]:
                logger.info(f"Successfully approached {object_name}: {result['message']}")
            else:
                logger.warning(f"Failed to approach {object_name}: {result['message']}")
                
            return result
            
        except Exception as e:
            logger.error(f"Error during approach: {e}")
            print(f"❌ Error during approach: {e}")
            return {
                "success": False,
                "approach_time": 0,
                "message": f"Error during approach: {str(e)}"
            }
        finally:
            # Clean up resources
            try:
                # Stop the robot
                if self.initialized:
                    self.px.stop()
            except Exception as e:
                logger.error(f"Error during cleanup: {e}")
    
    def _init_hardware(self):
        """Initialize hardware components following working_gpt_car.py pattern"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware libraries not available, running in simulation mode")
            return
        
        try:
            # Initialize PiCar-X hardware
            self.px = picarx.Picarx()
            self.pin = Pin("D0")
            
            # Test basic movement to verify hardware
            self.px.forward(0)  # Stop any existing movement
            time.sleep(0.1)
            
            # Hardware initialization successful
            self.initialized = True
            logger.info("Hardware initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
    
    def move_forward(self, speed=50, duration=1.0):
        """Move forward at the specified speed for the specified duration"""
        if not self.initialized:
            logger.warning("Hardware not initialized, cannot move forward")
            return
        
        try:
            self.px.forward(speed)
            time.sleep(duration)
            self.px.forward(0)  # Stop
        except Exception as e:
            logger.error(f"Error moving forward: {e}")
    
    def turn(self, angle):
        """Turn by the specified angle"""
        if not self.initialized:
            logger.warning("Hardware not initialized, cannot turn")
            return
        
        try:
            # Convert angle to appropriate turn direction and magnitude
            if angle > 0:  # Turn right
                self.px.set_dir_servo_angle(angle)
                time.sleep(0.3)  # Give time for the servo to adjust
                self.px.forward(30)  # Move forward while turning
                time.sleep(0.5)
                self.px.forward(0)  # Stop
                self.px.set_dir_servo_angle(0)  # Reset steering
            elif angle < 0:  # Turn left
                self.px.set_dir_servo_angle(angle)
                time.sleep(0.3)  # Give time for the servo to adjust
                self.px.forward(30)  # Move forward while turning
                time.sleep(0.5)
                self.px.forward(0)  # Stop
                self.px.set_dir_servo_angle(0)  # Reset steering
        except Exception as e:
            logger.error(f"Error turning: {e}")
    
    def check_distance(self):
        """Check distance using ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized, cannot check distance")
            return 50  # Return a default value
        
        try:
            # Take multiple readings for reliability
            distances = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                if 0 <= distance < 300:  # Valid reading range
                    distances.append(distance)
                time.sleep(0.05)  # Short delay between readings
            
            # Filter out invalid readings and average the rest
            valid_distances = [d for d in distances if 0 <= d < 300]
            if valid_distances:
                return sum(valid_distances) / len(valid_distances)
            else:
                logger.warning("No valid distance readings")
                return 50  # Default value
                
        except Exception as e:
            logger.error(f"Error checking distance: {e}")
            return 50  # Default value
    
    def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera using vilib"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized, cannot capture image")
            return None
        
        try:
            # Use vilib to capture image
            Vilib.take_photo(save_path)
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Error capturing image: {e}")
            return None
    
    def analyze_image_with_gpt4(self, image_path, object_name="object"):
        """Analyze an image using GPT-4 Vision to find and track objects"""
        if not self.openai_client:
            logger.warning("OpenAI client not available, cannot analyze image")
            return []
        
        try:
            # Read the image file
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read()).decode('utf-8')
            
            # Prepare the prompt for object detection with position information
            prompt = f"""Analyze this image and find the {object_name}. 
            If you see the {object_name}, provide the following information in JSON format:
            1. Is the {object_name} present? (true/false)
            2. Position of the {object_name} in the image (left/center/right, top/middle/bottom)
            3. Approximate distance (close, medium, far) if you can estimate it
            4. Your confidence level (0.0-1.0)
            5. A brief description of the {object_name}
            
            Format your response as a JSON object with the following structure:
            {{"objects": [{{"name": "{object_name}", "present": true/false, "position": "position description", "distance": "distance estimate", "confidence": confidence_value, "description": "brief description"}}]}}
            
            If multiple {object_name}s are visible, include all of them in the objects array.
            If no {object_name} is visible, return {{"objects": []}}
            """
            
            # Call the OpenAI API with the image
            response = self.openai_client.chat.completions.create(
                model="gpt-4-vision-preview",
                messages=[
                    {"role": "system", "content": "You are a computer vision system that detects objects and their positions in images."},
                    {"role": "user", "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}
                    ]}
                ],
                max_tokens=1000
            )
            
            # Extract the response text
            response_text = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {response_text}")
            
            # Parse the JSON response
            # Find JSON content between triple backticks if present
            import re
            json_match = re.search(r'```json\s*(.+?)\s*```', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                # Try to find any JSON-like structure
                json_match = re.search(r'\{\s*"objects"\s*:.+?\}', response_text, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                else:
                    json_str = response_text
            
            try:
                result = json.loads(json_str)
                objects = result.get("objects", [])
                return objects
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse JSON response: {e}")
                # Attempt to extract information manually
                if "not present" in response_text.lower() or "no object" in response_text.lower():
                    return []
                else:
                    # Create a basic object with available information
                    return [{
                        "name": object_name,
                        "present": "present" in response_text.lower(),
                        "position": "unknown",
                        "confidence": 0.5,
                        "description": "Object details could not be parsed"
                    }]
                
        except Exception as e:
            logger.error(f"Error analyzing image with GPT-4 Vision: {e}")
            return []
    
    def extract_position_details(self, position_str):
        """Extract detailed position information from position string
        
        Args:
            position_str (str): Position string from GPT-4 Vision (e.g., "left top", "center")
            
        Returns:
            dict: Detailed position information including horizontal, vertical, and quadrant
        """
        if not position_str:
            return {
                "original": "",
                "horizontal": "center",
                "vertical": "middle",
                "quadrant": 5,
                "distance_estimate": "unknown"
            }
            
        position_str = position_str.lower()
        
        # Initialize position details
        position = {
            "original": position_str,
            "horizontal": "center",  # left, center, right
            "vertical": "middle",   # top, middle, bottom
            "quadrant": 5,          # Numeric quadrant (1-9, with 5 being center)
            "distance_estimate": "unknown"
        }
        
        # Extract horizontal position
        if "left" in position_str:
            position["horizontal"] = "left"
        elif "right" in position_str:
            position["horizontal"] = "right"
        
        # Extract vertical position
        if "top" in position_str:
            position["vertical"] = "top"
        elif "bottom" in position_str:
            position["vertical"] = "bottom"
        
        # Determine quadrant (like numpad)
        # 7 8 9
        # 4 5 6
        # 1 2 3
        quadrant_map = {
            ("left", "top"): 7,
            ("center", "top"): 8,
            ("right", "top"): 9,
            ("left", "middle"): 4,
            ("center", "middle"): 5,
            ("right", "middle"): 6,
            ("left", "bottom"): 1,
            ("center", "bottom"): 2,
            ("right", "bottom"): 3
        }
        
        position["quadrant"] = quadrant_map.get(
            (position["horizontal"], position["vertical"]), 5
        )
        
        # Try to extract any distance information if present
        distance_keywords = {"close": "close", "near": "close", "far": "far", "distant": "far", "medium": "medium"}
        for keyword, value in distance_keywords.items():
            if keyword in position_str:
                position["distance_estimate"] = value
                break
                
        return position
    
    def approach_object(self, object_name, position, confidence=0.6, max_approach_time=30, min_distance=15):
        """Approach an object using an iterative approach algorithm
        
        Args:
            object_name: Name of the object to approach
            position: Initial position of the object (e.g., 'left', 'right center')
            confidence: Confidence threshold for object detection
            max_approach_time: Maximum time to spend approaching in seconds
            min_distance: Minimum distance to maintain from object in cm
            
        Returns:
            Dict containing approach results
        """
        if not self.initialized or not self.camera_initialized:
            logger.warning("Hardware or camera not initialized, cannot approach object")
            return {
                "success": False,
                "approach_time": 0,
                "message": "Hardware or camera not initialized"
            }
        
        # Initialize approach variables
        start_time = time.time()
        approach_complete = False
        object_lost = False
        approach_steps = 0
        last_position = position
        last_confidence = confidence
        last_distance = self.check_distance()
        
        # Extract initial position details
        position_details = self.extract_position_details(position)
        logger.info(f"Initial position details: {position_details}")
        
        # Store initial state
        self.memory.set("initial_distance", last_distance)
        
        # Main approach loop
        while not approach_complete and time.time() - start_time < max_approach_time:
            approach_steps += 1
            logger.info(f"Approach step {approach_steps}")
            print(f"🚗 Approach step {approach_steps}...")
            
            # Check current distance
            current_distance = self.check_distance()
            logger.info(f"Current distance: {current_distance}cm")
            
            # If we're close enough to the object, we're done
            if current_distance <= min_distance + 5:  # Add small buffer
                logger.info(f"Reached target distance: {current_distance}cm")
                print(f"🎉 Reached target distance: {current_distance}cm!")
                approach_complete = True
                break
            
            # Capture image to verify object is still visible
            image_path = self.capture_image(f"approach_{approach_steps}.jpg")
            if not image_path:
                logger.warning("Failed to capture image")
                continue
            
            # Analyze image to find object
            objects = self.analyze_image_with_gpt4(image_path, object_name)
            
            # Check if object is still visible
            target_object = None
            for obj in objects:
                obj_name = obj.get("name", "").lower()
                obj_confidence = obj.get("confidence", 0)
                if object_name.lower() in obj_name and obj_confidence >= confidence:
                    target_object = obj
                    break
            
            if not target_object:
                logger.warning(f"Object {object_name} not found in image")
                print(f"⚠️ Object {object_name} not visible, trying to recover...")
                
                # If we've lost the object, try turning slightly to find it again
                if not object_lost:
                    object_lost = True
                    # Try turning in the direction we last saw the object
                    if position_details["horizontal"] == "left":
                        self.turn(-20)  # Turn left
                    elif position_details["horizontal"] == "right":
                        self.turn(20)  # Turn right
                    continue
                else:
                    # If we've already tried to recover once, give up
                    logger.warning("Object lost and recovery failed")
                    print(f"❌ Object {object_name} lost, approach failed")
                    return {
                        "success": False,
                        "approach_time": time.time() - start_time,
                        "approach_steps": approach_steps,
                        "final_distance": current_distance,
                        "message": f"Object {object_name} lost during approach"
                    }
            
            # Reset object_lost flag if we found the object again
            object_lost = False
            
            # Update position and confidence
            last_position = target_object.get("position", last_position)
            last_confidence = target_object.get("confidence", last_confidence)
            
            # Extract new position details
            position_details = self.extract_position_details(last_position)
            logger.info(f"Updated position details: {position_details}")
            
            # Determine approach strategy based on position and distance
            if position_details["horizontal"] != "center":
                # Need to turn toward the object first
                turn_angle = 30 if position_details["horizontal"] == "right" else -30
                logger.info(f"Turning {turn_angle} degrees toward object")
                print(f"🔄 Turning {'right' if turn_angle > 0 else 'left'} to center object...")
                self.turn(turn_angle)
                continue  # Skip forward movement this iteration
            
            # Object is centered, move forward
            # Calculate approach distance based on current distance and position
            approach_distance = min(current_distance - min_distance, 30)  # Cap at 30cm per step
            
            # Convert distance to movement time (rough approximation)
            # Assuming speed of 30 moves about 20cm per second
            move_time = approach_distance / 40.0  # seconds
            move_time = max(min(move_time, 1.0), 0.3)  # Between 0.3 and 1.0 seconds
            
            # Move forward
            logger.info(f"Moving forward for {move_time:.1f}s (approx {approach_distance:.1f}cm)")
            print(f"🚗 Moving forward for {move_time:.1f}s...")
            self.move_forward(speed=30, duration=move_time)
            
            # Short pause to stabilize
            time.sleep(0.3)
            
            # Update last distance
            last_distance = current_distance
        
        # Check if we timed out
        elapsed_time = time.time() - start_time
        if not approach_complete and elapsed_time >= max_approach_time:
            logger.warning(f"Approach timed out after {max_approach_time}s")
            print(f"⏰ Approach timed out after {max_approach_time}s")
            return {
                "success": False,
                "approach_time": elapsed_time,
                "approach_steps": approach_steps,
                "final_distance": self.check_distance(),
                "message": f"Approach timed out after {max_approach_time}s"
            }
        
        # Approach complete
        final_distance = self.check_distance()
        logger.info(f"Approach complete in {elapsed_time:.1f}s, final distance: {final_distance}cm")
        print(f"🎉 Approach complete in {elapsed_time:.1f}s, final distance: {final_distance}cm")
        
        # Celebrate by wiggling if we reached the target
        if final_distance <= min_distance + 10:  # Within 10cm of target
            self.turn(10)
            time.sleep(0.2)
            self.turn(-20)
            time.sleep(0.2)
            self.turn(10)
        
        return {
            "success": True,
            "approach_time": elapsed_time,
            "approach_steps": approach_steps,
            "final_distance": final_distance,
            "message": f"Successfully approached {object_name} to {final_distance}cm in {elapsed_time:.1f}s"
        }
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up resources")
        
        # Clean up hardware
        if self.initialized:
            try:
                self.px.stop()
            except Exception as e:
                logger.error(f"Hardware cleanup error: {e}")
        
        # Clean up camera
        if self.camera_initialized:
            try:
                Vilib.camera_close()
                logger.info("Camera closed")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")


##################################################
# FILE: src/agent/memory/__init__.py
##################################################

from .search_memory import SearchMemory, SearchArea

__all__ = [
    'SearchMemory',
    'SearchArea'
]


##################################################
# FILE: src/agent/memory/search_memory.py
##################################################

import time
from typing import Dict, List, Optional, Tuple
import numpy as np
from dataclasses import dataclass, field

@dataclass
class SearchArea:
    """Represents a search area with position and dimensions."""
    x: float
    y: float
    width: float
    height: float
    last_searched: float = field(default_factory=time.time)
    search_count: int = 0
    
    def contains(self, x: float, y: float) -> bool:
        """Check if a point is within this search area."""
        return (self.x <= x < self.x + self.width and 
                self.y <= y < self.y + self.height)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            'x': self.x,
            'y': self.y,
            'width': self.width,
            'height': self.height,
            'last_searched': self.last_searched,
            'search_count': self.search_count
        }

class SearchMemory:
    """Tracks search progress and remembers visited locations."""
    
    def __init__(self, decay_rate: float = 0.95):
        """Initialize search memory.
        
        Args:
            decay_rate: How quickly to forget old searches (0-1, higher = remember longer)
        """
        self.search_areas: List[SearchArea] = []
        self.object_locations: Dict[str, List[Dict]] = {}
        self.decay_rate = decay_rate
        self.current_search_area: Optional[SearchArea] = None
    
    def add_search_area(self, x: float, y: float, width: float, height: float) -> SearchArea:
        """Add a new search area."""
        area = SearchArea(x, y, width, height)
        self.search_areas.append(area)
        return area
    
    def get_least_searched_area(self) -> Optional[SearchArea]:
        """Get the area that has been searched the least recently."""
        if not self.search_areas:
            return None
            
        # Sort by last_searched and search_count
        return min(self.search_areas, key=lambda a: (a.last_searched, a.search_count))
    
    def record_visit(self, x: float, y: float) -> None:
        """Record a visit to a location."""
        now = time.time()
        
        # Update existing area if point is inside it
        for area in self.search_areas:
            if area.contains(x, y):
                area.last_searched = now
                area.search_count += 1
                return
        
        # If not in any area, create a new small area
        self.add_search_area(x - 0.1, y - 0.1, 0.2, 0.2)
    
    def remember_object_location(self, object_name: str, x: float, y: float, 
                              confidence: float = 1.0) -> None:
        """Remember the location of an object."""
        if object_name not in self.object_locations:
            self.object_locations[object_name] = []
            
        self.object_locations[object_name].append({
            'x': x,
            'y': y,
            'confidence': confidence,
            'timestamp': time.time()
        })
    
    def recall_object_location(self, object_name: str) -> Optional[Tuple[float, float, float]]:
        """Recall the most likely location of an object."""
        if object_name not in self.object_locations or not self.object_locations[object_name]:
            return None
            
        # Get most recent sighting
        recent = max(self.object_locations[object_name], key=lambda x: x['timestamp'])
        return (recent['x'], recent['y'], recent['confidence'])
    
    def decay_memory(self) -> None:
        """Apply decay to memory to forget old information."""
        # Remove old object locations
        current_time = time.time()
        for obj_name, locations in list(self.object_locations.items()):
            # Filter out old entries
            self.object_locations[obj_name] = [
                loc for loc in locations 
                if (current_time - loc['timestamp']) < (86400 / self.decay_rate)  # 1 day / decay_rate
            ]
            
            # Remove object if no locations left
            if not self.object_locations[obj_name]:
                del self.object_locations[obj_name]


##################################################
# FILE: src/agent/command_handler.py
##################################################

"""
Command handler for processing voice commands and executing robot actions.
"""
import re
import logging
from typing import Dict, Callable, Any, Optional, List, Tuple

class CommandHandler:
    """Handles voice commands and maps them to robot actions."""
    
    def __init__(self, robot_controller):
        """Initialize the command handler.
        
        Args:
            robot_controller: Instance of RobotController for movement control
        """
        self.robot = robot_controller
        self.commands = self._initialize_commands()
        
    def _initialize_commands(self) -> Dict[str, Dict[str, Any]]:
        """Initialize the command patterns and their handlers.
        
        Returns:
            Dict containing command patterns and their handlers
        """
        return {
            "move_forward": {
                "patterns": [
                    r"go forward(?: (\d+) (?:percent|%))?",
                    r"move forward(?: (\d+) (?:percent|%))?",
                    r"drive forward(?: (\d+) (?:percent|%))?",
                ],
                "handler": self._handle_move_forward,
                "help": "Move forward [speed in %]"
            },
            "move_backward": {
                "patterns": [
                    r"go backward(?: (\d+) (?:percent|%))?",
                    r"move backward(?: (\d+) (?:percent|%))?",
                    r"drive backward(?: (\d+) (?:percent|%))?",
                    r"reverse(?: (\d+) (?:percent|%))?",
                ],
                "handler": self._handle_move_backward,
                "help": "Move backward [speed in %]"
            },
            "turn_left": {
                "patterns": [
                    r"turn left(?: (\d+) degrees)?",
                    r"go left(?: (\d+) degrees)?",
                    r"steer left(?: (\d+) degrees)?",
                ],
                "handler": self._handle_turn_left,
                "help": "Turn left [angle in degrees]"
            },
            "turn_right": {
                "patterns": [
                    r"turn right(?: (\d+) degrees)?",
                    r"go right(?: (\d+) degrees)?",
                    r"steer right(?: (\d+) degrees)?",
                ],
                "handler": self._handle_turn_right,
                "help": "Turn right [angle in degrees]"
            },
            "stop": {
                "patterns": [
                    r"stop",
                    r"halt",
                    r"freeze",
                    r"emergency stop",
                ],
                "handler": self._handle_stop,
                "help": "Stop all movement"
            },
            "look_around": {
                "patterns": [
                    r"look around",
                    r"scan area",
                    r"survey the area",
                ],
                "handler": self._handle_look_around,
                "help": "Look around with the camera"
            },
            "help": {
                "patterns": [
                    r"help",
                    r"what can you do",
                    r"list commands",
                ],
                "handler": self._handle_help,
                "help": "Show available commands"
            },
        }
    
    def process_command(self, command: str) -> Tuple[bool, str]:
        """Process a voice command and execute the corresponding action.
        
        Args:
            command: The voice command string
            
        Returns:
            Tuple of (success, response_message)
        """
        if not command.strip():
            return False, "I didn't hear a command."
            
        command = command.lower().strip()
        logging.info(f"Processing command: {command}")
        
        # Check for matching command patterns
        for cmd_name, cmd_info in self.commands.items():
            for pattern in cmd_info["patterns"]:
                match = re.fullmatch(pattern, command)
                if match:
                    try:
                        response = cmd_info["handler"](*match.groups())
                        return True, response or f"Executed: {cmd_name}"
                    except Exception as e:
                        logging.error(f"Error executing command {cmd_name}: {e}")
                        return False, f"Sorry, I couldn't execute that command: {str(e)}"
        
        return False, "I'm not sure how to do that. Say 'help' for a list of commands."
    
    # Command handlers
    def _handle_move_forward(self, speed_str: str = None) -> str:
        """Handle move forward command."""
        speed = self._parse_speed(speed_str, default=50)
        self.robot.move_forward(speed)
        return f"Moving forward at {speed}% speed"
    
    def _handle_move_backward(self, speed_str: str = None) -> str:
        """Handle move backward command."""
        speed = self._parse_speed(speed_str, default=30)  # Safer default for reverse
        self.robot.move_backward(speed)
        return f"Moving backward at {speed}% speed"
    
    def _handle_turn_left(self, angle_str: str = None) -> str:
        """Handle turn left command."""
        angle = self._parse_angle(angle_str, default=30)
        self.robot.turn_left(angle)
        return f"Turning left {angle} degrees"
    
    def _handle_turn_right(self, angle_str: str = None) -> str:
        """Handle turn right command."""
        angle = self._parse_angle(angle_str, default=30)
        self.robot.turn_right(angle)
        return f"Turning right {angle} degrees"
    
    def _handle_stop(self) -> str:
        """Handle stop command."""
        self.robot.stop()
        return "Stopping all movement"
    
    def _handle_look_around(self) -> str:
        """Handle look around command."""
        self.robot.look_around()
        return "Looking around"
    
    def _handle_help(self) -> str:
        """Handle help command."""
        help_text = "Here's what I can do:\n"
        for cmd_info in self.commands.values():
            help_text += f"- {cmd_info['help']}\n"
        return help_text
    
    # Utility methods
    def _parse_speed(self, speed_str: Optional[str], default: int = 50) -> int:
        """Parse speed from string, ensuring it's within valid range."""
        if not speed_str:
            return default
            
        try:
            speed = int(speed_str)
            return max(0, min(100, speed))  # Clamp between 0 and 100
        except (ValueError, TypeError):
            return default
    
    def _parse_angle(self, angle_str: Optional[str], default: int = 30) -> int:
        """Parse angle from string, ensuring it's within valid range."""
        if not angle_str:
            return default
            
        try:
            angle = int(angle_str)
            return max(0, min(90, angle))  # Clamp between 0 and 90 degrees
        except (ValueError, TypeError):
            return default


##################################################
# FILE: src/agent/agent_system.py
##################################################

#!/usr/bin/env python3
"""
Agent System for PiCar-X
Implements the hybrid agent-tool architecture with LLM-based reasoning
"""

import os
import sys
import time
import json
import asyncio
import logging
from typing import Dict, Any, Optional, List, Tuple

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('agent_system.log')
    ]
)
logger = logging.getLogger(__name__)

# Import tool registry and tools
from src.agent.tools.registry import tool_registry
from src.agent.tools.base_tool import BaseTool
from src.agent.tools.enhanced_search_tool import EnhancedSearchTool

# Import hardware integration
from src.agent.hardware_integration import (
    get_hardware, 
    get_vision_system, 
    get_obstacle_avoidance,
    cleanup_all
)

# Import memory components
from src.agent.memory.search_memory import SearchMemory

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

class AgentSystem:
    """
    Main agent system for PiCar-X
    Implements the hybrid agent-tool architecture
    """
    
    def __init__(self):
        """Initialize the agent system"""
        self.hardware = get_hardware()
        self.vision = get_vision_system()
        self.memory = SearchMemory()
        self.tools = {}
        self.initialized = False
        
        # OpenAI client for LLM reasoning
        self.openai_client = None
        if OPENAI_API_KEY:
            try:
                import openai
                self.openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)
                logger.info("OpenAI client initialized")
            except ImportError:
                logger.warning("OpenAI package not installed")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
    
    def initialize(self):
        """Initialize the agent system and register tools"""
        logger.info("Initializing agent system")
        
        # Register tools
        self._register_tools()
        
        self.initialized = True
        logger.info("Agent system initialized")
        return True
    
    def _register_tools(self):
        """Register all available tools"""
        # Register the enhanced search tool
        search_tool = EnhancedSearchTool(
            car=self.hardware,
            vision_system=self.vision,
            memory=self.memory
        )
        
        # Add to our local tools dictionary
        self.tools['search'] = search_tool
        
        # Register with the global tool registry
        tool_registry.register_tool(search_tool)
        
        logger.info(f"Registered tools: {list(tool_registry.list_tools())}")
    
    async def execute_tool(self, tool_name: str, **kwargs) -> Dict[str, Any]:
        """Execute a specific tool by name"""
        if not self.initialized:
            logger.error("Agent system not initialized")
            return {"status": "error", "message": "Agent system not initialized"}
        
        # Get the tool from the registry
        tool = tool_registry.get_tool(tool_name)
        if not tool:
            logger.error(f"Tool '{tool_name}' not found")
            return {"status": "error", "message": f"Tool '{tool_name}' not found"}
        
        try:
            logger.info(f"Executing tool '{tool_name}' with args: {kwargs}")
            result = await tool.execute(**kwargs)
            return result
        except Exception as e:
            logger.error(f"Tool execution failed: {e}")
            return {"status": "error", "message": str(e)}
    
    async def search_for_object(self, object_name: str, timeout: int = 60) -> Dict[str, Any]:
        """Convenience method to search for an object"""
        return await self.execute_tool(
            tool_name="search_for_object",
            object_name=object_name,
            timeout=timeout
        )
    
    async def process_command(self, command: str) -> Dict[str, Any]:
        """
        Process a natural language command using LLM reasoning
        """
        if not self.openai_client:
            logger.warning("OpenAI client not available, using rule-based command processing")
            return await self._rule_based_command_processing(command)
        
        try:
            # Prepare the tools for function calling
            tools = []
            for tool_name in tool_registry.list_tools():
                tool = tool_registry.get_tool(tool_name)
                if tool:
                    tools.append({
                        "type": "function",
                        "function": {
                            "name": tool.name,
                            "description": tool.description,
                            "parameters": {
                                "type": "object",
                                "properties": tool.parameters,
                                "required": [
                                    param for param, details in tool.parameters.items()
                                    if details.get("required", True)
                                ]
                            }
                        }
                    })
            
            # Call the OpenAI API for tool selection
            response = self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an assistant controlling a PiCar-X robot. Select the appropriate tool to execute the user's command."},
                    {"role": "user", "content": command}
                ],
                tools=tools,
                tool_choice="auto"
            )
            
            # Extract the tool call
            message = response.choices[0].message
            if message.tool_calls:
                tool_call = message.tool_calls[0]
                tool_name = tool_call.function.name
                tool_args = json.loads(tool_call.function.arguments)
                
                logger.info(f"LLM selected tool '{tool_name}' with args: {tool_args}")
                return await self.execute_tool(tool_name, **tool_args)
            else:
                logger.warning("LLM did not select a tool")
                return {"status": "error", "message": "Could not determine appropriate action"}
                
        except Exception as e:
            logger.error(f"LLM reasoning failed: {e}")
            return await self._rule_based_command_processing(command)
    
    async def _rule_based_command_processing(self, command: str) -> Dict[str, Any]:
        """
        Simple rule-based command processing as fallback
        """
        command = command.lower().strip()
        
        # Check for search commands
        search_keywords = ["find", "search", "look for", "where is", "locate"]
        for keyword in search_keywords:
            if keyword in command:
                # Extract the object name after the keyword
                parts = command.split(keyword, 1)
                if len(parts) > 1:
                    object_name = parts[1].strip()
                    if object_name:
                        logger.info(f"Rule-based processing detected search for '{object_name}'")
                        return await self.search_for_object(object_name)
        
        # Default response
        return {
            "status": "error", 
            "message": "Could not understand command. Try 'find [object]'"
        }
    
    def cleanup(self):
        """Clean up all resources"""
        logger.info("Cleaning up agent system")
        cleanup_all()

# Singleton instance
_agent_system = None

def get_agent_system():
    """Get or create the agent system singleton"""
    global _agent_system
    if _agent_system is None:
        _agent_system = AgentSystem()
        _agent_system.initialize()
    return _agent_system

async def process_command(command: str) -> Dict[str, Any]:
    """Helper function to process a command"""
    agent = get_agent_system()
    return await agent.process_command(command)


##################################################
# FILE: src/agent/__init__.py
##################################################

"""
Agent module for the family robot assistant.
"""
from .command_handler import CommandHandler
from .robot_agent import RobotAgent

__all__ = ['CommandHandler', 'RobotAgent']


##################################################
# FILE: src/agent/integration.py
##################################################

#!/usr/bin/env python3
"""
Integration module for PiCar-X agent system
Bridges the working hardware code with the new agent framework
"""

import os
import sys
import time
import asyncio
import logging
from typing import Dict, Any, Optional, List

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('agent_integration.log')
    ]
)
logger = logging.getLogger(__name__)

# Hardware availability flag
HARDWARE_AVAILABLE = False

# Try to import hardware components
try:
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError:
    logger.warning("Hardware modules not available, using mock implementations")

# Import agent components
try:
    from src.agent.tools import ObjectSearchTool, tool_registry
    from src.agent.memory import SearchMemory
    logger.info("Agent modules loaded successfully")
except ImportError as e:
    logger.error(f"Failed to import agent modules: {e}")
    logger.error("Make sure the agent code is properly deployed")

class PiCarXController:
    """
    Controller for PiCar-X hardware
    Follows the initialization pattern from working_gpt_car.py
    """
    
    def __init__(self):
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        
    def initialize(self):
        """Initialize hardware components in the correct order"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return False
            
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED_R')
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
            return False
    
    async def move_forward(self, distance: float, speed: float = 50):
        """Move forward a specific distance"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            await asyncio.sleep(abs(distance) / max(speed, 1) * 0.1)
            return
            
        try:
            logger.info(f"Moving forward {distance}m at speed {speed}")
            self.px.forward(speed)
            await asyncio.sleep(abs(distance) / max(speed, 1) * 10)  # Rough estimate
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
    
    async def turn(self, degrees: float, speed: float = 50):
        """Turn in place by the specified degrees"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            await asyncio.sleep(abs(degrees) / 90 * 0.5)
            return
            
        try:
            logger.info(f"Turning {degrees} degrees")
            if degrees > 0:
                self.px.set_dir_servo_angle(degrees)
            else:
                self.px.set_dir_servo_angle(degrees)
            await asyncio.sleep(abs(degrees) / 90)  # Rough estimate
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
    
    def cleanup(self):
        """Clean up hardware resources"""
        if self.initialized:
            try:
                logger.info("Cleaning up hardware resources")
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

class VisionSystem:
    """
    Vision system for object detection
    Integrates with the camera and GPT-4 Vision
    """
    
    def __init__(self):
        self.camera_initialized = False
        
        # Try to initialize camera
        try:
            import vilib
            vilib.init_camera()
            vilib.camera_start()
            self.camera_initialized = True
            logger.info("Camera initialized successfully")
        except ImportError:
            logger.warning("vilib not available, vision will be simulated")
        except Exception as e:
            logger.error(f"Failed to initialize camera: {e}")
    
    async def capture_image(self, save_path: str = "current_view.jpg"):
        """Capture an image from the camera"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized, simulating capture")
            return None
            
        try:
            import vilib
            import cv2
            import numpy as np
            
            # Get frame from vilib
            frame = vilib.get_frame()
            if frame is not None:
                cv2.imwrite(save_path, frame)
                logger.info(f"Image captured and saved to {save_path}")
                return save_path
            else:
                logger.warning("Failed to get frame from camera")
                return None
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    async def detect_objects(self, image_path: Optional[str] = None):
        """
        Detect objects in an image
        In a real implementation, this would use GPT-4 Vision or another model
        """
        # Simulate object detection
        logger.info("Simulating object detection")
        await asyncio.sleep(0.5)
        
        # Return mock detection results
        return [
            {"name": "ball", "confidence": 0.85, "position": (2, 1, 0)},
            {"name": "chair", "confidence": 0.75, "position": (3, 2, 0)}
        ]
    
    def cleanup(self):
        """Clean up vision resources"""
        if self.camera_initialized:
            try:
                import vilib
                vilib.camera_release()
                logger.info("Camera resources released")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

class AgentSystem:
    """
    Main agent system for PiCar-X
    Integrates hardware control, vision, and agent tools
    """
    
    def __init__(self):
        self.car = PiCarXController()
        self.vision = VisionSystem()
        self.memory = SearchMemory()
        self.tools = {}
        self.initialized = False
    
    def initialize(self):
        """Initialize the agent system"""
        # Initialize hardware first
        hardware_ok = self.car.initialize()
        
        # Register tools
        try:
            self.tools['search'] = ObjectSearchTool(
                car=self.car,
                vision_system=self.vision
            )
            self.initialized = True
            logger.info("Agent system initialized successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize agent system: {e}")
            self.initialized = False
            return False
    
    async def search_for_object(self, object_name: str, timeout: int = 60):
        """Search for an object using the search tool"""
        if not self.initialized:
            logger.warning("Agent system not initialized")
            return {"status": "error", "message": "Agent system not initialized"}
            
        if 'search' not in self.tools:
            logger.warning("Search tool not available")
            return {"status": "error", "message": "Search tool not available"}
            
        try:
            logger.info(f"Starting search for {object_name}")
            result = await self.tools['search'].execute(
                object_name=object_name,
                timeout=timeout
            )
            return result
        except Exception as e:
            logger.error(f"Search failed: {e}")
            return {"status": "error", "message": str(e)}
    
    def cleanup(self):
        """Clean up all resources"""
        logger.info("Cleaning up agent system")
        self.car.cleanup()
        self.vision.cleanup()

# Singleton instance
_agent_system = None

def get_agent_system():
    """Get or create the agent system singleton"""
    global _agent_system
    if _agent_system is None:
        _agent_system = AgentSystem()
    return _agent_system

async def run_search(object_name: str, timeout: int = 60):
    """Helper function to run a search"""
    agent = get_agent_system()
    agent.initialize()
    try:
        return await agent.search_for_object(object_name, timeout)
    finally:
        agent.cleanup()


##################################################
# FILE: src/agent/hardware_bridge.py
##################################################

#!/usr/bin/env python3
"""
Hardware bridge for PiCar-X agent system
Connects the agent tools with the hardware using the proven initialization pattern
"""

import os
import sys
import time
import asyncio
import logging
from typing import Dict, Any, Optional, List, Tuple

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('hardware_bridge.log')
    ]
)
logger = logging.getLogger(__name__)

# Hardware availability flag
HARDWARE_AVAILABLE = False

# Try to import hardware components
try:
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError:
    logger.warning("Hardware modules not available, using mock implementations")

class PiCarXHardware:
    """
    Hardware controller for PiCar-X
    Follows the exact initialization pattern from working_gpt_car.py
    """
    
    def __init__(self):
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.position = (0, 0, 0)  # x, y, heading in degrees
        
    def initialize(self):
        """Initialize hardware components in the correct order"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return False
            
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED_R')
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
            return False
    
    async def move_forward(self, distance: float, speed: float = 50) -> None:
        """Move forward a specific distance"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            await asyncio.sleep(abs(distance) / max(speed, 1) * 0.1)
            # Update simulated position
            self.position = (
                self.position[0] + distance * 0.1,  # Simple forward movement
                self.position[1],
                self.position[2]
            )
            return
            
        try:
            logger.info(f"Moving forward {distance}m at speed {speed}")
            self.px.forward(speed)
            await asyncio.sleep(abs(distance) / max(speed, 1) * 10)  # Rough estimate
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
    
    async def turn(self, degrees: float, speed: float = 50) -> None:
        """Turn in place by the specified degrees"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            await asyncio.sleep(abs(degrees) / 90 * 0.5)
            # Update simulated heading
            self.position = (
                self.position[0],
                self.position[1],
                (self.position[2] + degrees) % 360
            )
            return
            
        try:
            logger.info(f"Turning {degrees} degrees")
            if degrees > 0:
                self.px.set_dir_servo_angle(degrees)
            else:
                self.px.set_dir_servo_angle(degrees)
            await asyncio.sleep(abs(degrees) / 90)  # Rough estimate
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
    
    def get_position(self) -> Tuple[float, float, float]:
        """Get the current position and heading"""
        return self.position
    
    async def distance_sensor(self) -> float:
        """Get distance from ultrasonic sensor with improved reliability"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating distance check")
            return 100.0  # Simulate no obstacles
        
        try:
            # Take multiple readings to improve reliability
            readings = []
            for _ in range(3):
                distance = self.px.ultrasonic.read()
                # Filter out invalid readings (negative or very large values)
                if 0 <= distance < 300:  # Valid range: 0-300cm
                    readings.append(distance)
                await asyncio.sleep(0.05)  # Short delay between readings
            
            # Calculate average of valid readings
            if readings:
                avg_distance = sum(readings) / len(readings)
                logger.info(f"Distance: {avg_distance:.2f}cm")
                return avg_distance
            else:
                logger.warning("No valid distance readings")
                return 100.0  # Default safe distance
        except Exception as e:
            logger.error(f"Distance sensor error: {e}")
            return 100.0  # Default to no obstacles on error
    
    def cleanup(self):
        """Clean up hardware resources"""
        if self.initialized:
            try:
                logger.info("Cleaning up hardware resources")
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

# Singleton instance
_hardware = None

def get_hardware():
    """Get or create the hardware singleton"""
    global _hardware
    if _hardware is None:
        _hardware = PiCarXHardware()
        _hardware.initialize()
    return _hardware


##################################################
# FILE: src/agent/hardware_integration.py
##################################################

#!/usr/bin/env python3
"""
Hardware integration for PiCar-X agent system
Connects the agent tools with the actual hardware using the proven initialization pattern
"""

import os
import sys
import time
import asyncio
import logging
from typing import Dict, Any, Optional, List, Tuple

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('hardware_integration.log')
    ]
)
logger = logging.getLogger(__name__)

# Hardware availability flag
HARDWARE_AVAILABLE = False

# Try to import hardware components
try:
    from picarx import Picarx
    from robot_hat import Music, Pin
    HARDWARE_AVAILABLE = True
    logger.info("Hardware modules available")
except ImportError as e:
    logger.warning(f"Hardware modules not available, using mock implementations: {e}")

# Try to import vision components
VISION_AVAILABLE = False
try:
    import vilib
    from picamera2 import Picamera2
    VISION_AVAILABLE = True
    logger.info("Vision modules available")
except ImportError as e:
    logger.warning(f"Vision modules not available, using mock implementations: {e}")

class PiCarXHardware:
    """
    Hardware controller for PiCar-X
    Follows the exact initialization pattern from working_gpt_car.py
    """
    
    def __init__(self):
        self.px = None
        self.music = None
        self.pin = None
        self.initialized = False
        self.position = (0, 0, 0)  # x, y, heading in degrees
        
    def initialize(self):
        """Initialize hardware components in the correct order"""
        if not HARDWARE_AVAILABLE:
            logger.warning("Hardware not available, running in simulation mode")
            return False
            
        try:
            # Follow the exact initialization pattern from working_gpt_car.py
            logger.info("Initializing PiCar-X hardware...")
            
            # Enable robot_hat speaker switch (from working_gpt_car.py)
            os.popen("pinctrl set 20 op dh")
            
            # Initialize hardware in the correct order
            self.px = Picarx()
            self.music = Music()
            self.pin = Pin('LED_R')
            
            self.initialized = True
            logger.info("Hardware initialized successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize hardware: {e}")
            self.initialized = False
            return False
    
    async def move_forward(self, distance: float, speed: float = 50) -> None:
        """Move forward a specific distance"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            await asyncio.sleep(abs(distance) / max(speed, 1) * 0.1)
            # Update simulated position
            self.position = (
                self.position[0] + distance * 0.1,  # Simple forward movement
                self.position[1],
                self.position[2]
            )
            return
            
        try:
            logger.info(f"Moving forward {distance}m at speed {speed}")
            self.px.forward(speed)
            # Convert distance to time based on speed
            # This is an approximation and may need calibration
            await asyncio.sleep(abs(distance) / max(speed, 1) * 10)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            self.px.stop()  # Safety stop
    
    async def move_backward(self, distance: float, speed: float = 50) -> None:
        """Move backward a specific distance"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating movement")
            await asyncio.sleep(abs(distance) / max(speed, 1) * 0.1)
            return
            
        try:
            logger.info(f"Moving backward {distance}m at speed {speed}")
            self.px.backward(speed)
            await asyncio.sleep(abs(distance) / max(speed, 1) * 10)
            self.px.stop()
        except Exception as e:
            logger.error(f"Movement error: {e}")
            self.px.stop()  # Safety stop
    
    async def turn(self, degrees: float, speed: float = 50) -> None:
        """Turn in place by the specified degrees"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating turn")
            await asyncio.sleep(abs(degrees) / 90 * 0.5)
            # Update simulated heading
            self.position = (
                self.position[0],
                self.position[1],
                (self.position[2] + degrees) % 360
            )
            return
            
        try:
            logger.info(f"Turning {degrees} degrees")
            # Limit the angle to what the hardware can handle
            clamped_angle = max(min(degrees, 35), -35)
            
            if clamped_angle != degrees:
                logger.warning(f"Angle {degrees} clamped to {clamped_angle}")
            
            # Set the steering angle
            self.px.set_dir_servo_angle(clamped_angle)
            
            # If we need to turn more than the hardware allows, we'll need to move forward a bit
            if abs(degrees) > 35:
                # Move forward while turning to achieve a larger turn
                self.px.forward(30)
                await asyncio.sleep(abs(degrees) / 35 * 0.5)
                self.px.stop()
            else:
                # Just wait a moment for the turn to complete
                await asyncio.sleep(abs(degrees) / 90)
            
            # Reset steering to straight
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Turn error: {e}")
            self.px.set_dir_servo_angle(0)  # Reset steering
    
    async def scan_surroundings(self, angles: List[float] = [-30, 0, 30]):
        """Scan surroundings by turning to different angles"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating scan")
            for angle in angles:
                logger.info(f"Mock: Scanning at angle {angle}")
                await asyncio.sleep(0.5)
            return
        
        try:
            logger.info("Scanning surroundings")
            for angle in angles:
                self.px.set_dir_servo_angle(angle)
                await asyncio.sleep(1)  # Give time to scan at this angle
            
            # Reset to center
            self.px.set_dir_servo_angle(0)
        except Exception as e:
            logger.error(f"Scan error: {e}")
            self.px.set_dir_servo_angle(0)  # Reset steering
    
    async def check_obstacles(self) -> Optional[float]:
        """Check for obstacles using ultrasonic sensor"""
        if not self.initialized:
            logger.warning("Hardware not initialized, simulating obstacle check")
            return None
            
        try:
            # Get distance from ultrasonic sensor
            distance = self.px.ultrasonic.read()
            logger.info(f"Obstacle distance: {distance}cm")
            return distance
        except Exception as e:
            logger.error(f"Obstacle check error: {e}")
            return None
    
    def get_position(self) -> Tuple[float, float, float]:
        """Get the current position and heading"""
        return self.position
    
    def cleanup(self):
        """Clean up hardware resources"""
        if self.initialized:
            try:
                logger.info("Cleaning up hardware resources")
                self.px.stop()
                if self.music:
                    self.music.music_stop()
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

class VisionSystem:
    """
    Vision system for object detection
    Integrates with the camera and GPT-4 Vision API
    """
    
    def __init__(self):
        self.camera_initialized = False
        self.camera = None
        
        # Try to initialize camera
        if VISION_AVAILABLE:
            try:
                # Initialize camera using vilib
                vilib.init_camera()
                vilib.camera_start()
                self.camera_initialized = True
                logger.info("Camera initialized successfully using vilib")
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
                try:
                    # Fallback to picamera2
                    self.camera = Picamera2()
                    self.camera.start()
                    self.camera_initialized = True
                    logger.info("Camera initialized successfully using picamera2")
                except Exception as e2:
                    logger.error(f"Failed to initialize camera with picamera2: {e2}")
        else:
            logger.warning("Vision modules not available, vision will be simulated")
    
    async def capture_image(self, save_path: str = "current_view.jpg"):
        """Capture an image from the camera"""
        if not self.camera_initialized:
            logger.warning("Camera not initialized, simulating capture")
            return None
            
        try:
            if self.camera:
                # Using picamera2
                self.camera.capture_file(save_path)
            else:
                # Using vilib
                import cv2
                frame = vilib.get_frame()
                if frame is not None:
                    cv2.imwrite(save_path, frame)
                else:
                    logger.warning("Failed to get frame from camera")
                    return None
                    
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Image capture error: {e}")
            return None
    
    async def detect_objects(self, image_path: Optional[str] = None):
        """
        Detect objects in an image
        In a real implementation, this would use GPT-4 Vision or another model
        """
        # If we have a real image, capture it
        if self.camera_initialized and image_path is None:
            image_path = await self.capture_image()
        
        if image_path and os.path.exists(image_path):
            # TODO: Replace with actual GPT-4 Vision API call
            logger.info(f"Simulating object detection on {image_path}")
            await asyncio.sleep(1)
            
            # Return mock detection results
            return [
                {"name": "ball", "confidence": 0.85, "position": (2, 1, 0)},
                {"name": "chair", "confidence": 0.75, "position": (3, 2, 0)}
            ]
        else:
            logger.warning("No image available for object detection")
            return []
    
    def cleanup(self):
        """Clean up vision resources"""
        if self.camera_initialized:
            try:
                if self.camera:
                    self.camera.stop()
                else:
                    vilib.camera_release()
                logger.info("Camera resources released")
            except Exception as e:
                logger.error(f"Camera cleanup error: {e}")

class ObstacleAvoidance:
    """
    Obstacle avoidance system for PiCar-X
    """
    
    def __init__(self, car):
        self.car = car
        self.safe_distance = 30  # cm
        logger.info("Obstacle avoidance system initialized")
    
    async def check_path(self) -> bool:
        """Check if the path ahead is clear"""
        if not self.car.initialized:
            return True
            
        distance = await self.car.check_obstacles()
        if distance is None:
            logger.warning("Could not get obstacle distance, assuming path is clear")
            return True
            
        is_clear = distance > self.safe_distance
        if not is_clear:
            logger.warning(f"Obstacle detected at {distance}cm")
        
        return is_clear
    
    async def avoid_obstacle(self) -> bool:
        """Try to avoid an obstacle"""
        logger.info("Attempting to avoid obstacle")
        
        # Scan surroundings to find the best path
        await self.car.scan_surroundings([-30, -15, 0, 15, 30])
        
        # Check left and right
        await self.car.turn(-30)
        left_distance = await self.car.check_obstacles()
        
        await self.car.turn(60)  # Turn from -30 to +30
        right_distance = await self.car.check_obstacles()
        
        # Reset direction
        await self.car.turn(-30)  # Back to center
        
        # Choose the direction with more space
        if left_distance is None and right_distance is None:
            logger.warning("Could not determine obstacle distances, backing up")
            await self.car.move_backward(0.3)
            return False
            
        if (left_distance or 0) > (right_distance or 0):
            logger.info(f"Turning left to avoid obstacle (distance: {left_distance}cm)")
            await self.car.turn(-45)
            await self.car.move_forward(0.5)
        else:
            logger.info(f"Turning right to avoid obstacle (distance: {right_distance}cm)")
            await self.car.turn(45)
            await self.car.move_forward(0.5)
        
        # Check if we're clear now
        return await self.check_path()

# Singleton instances
_hardware = None
_vision = None
_obstacle_avoidance = None

def get_hardware():
    """Get or create the hardware singleton"""
    global _hardware
    if _hardware is None:
        _hardware = PiCarXHardware()
        _hardware.initialize()
    return _hardware

def get_vision_system():
    """Get or create the vision system singleton"""
    global _vision
    if _vision is None:
        _vision = VisionSystem()
    return _vision

def get_obstacle_avoidance():
    """Get or create the obstacle avoidance singleton"""
    global _obstacle_avoidance, _hardware
    if _obstacle_avoidance is None:
        _obstacle_avoidance = ObstacleAvoidance(get_hardware())
    return _obstacle_avoidance

def cleanup_all():
    """Clean up all hardware resources"""
    global _hardware, _vision
    
    if _vision:
        _vision.cleanup()
    
    if _hardware:
        _hardware.cleanup()


##################################################
# FILE: src/agent/robot_agent.py
##################################################

"""
Main agent class for the family robot assistant.
"""
import os
import time
import logging
from typing import Optional, Callable

from src.movement.navigation import RobotController
from src.voice import SpeechRecognizer, TextToSpeech
from .command_handler import CommandHandler
from src.config import (
    LOG_LEVEL, LOG_FORMAT, LOG_FILE,
    STT_LANGUAGE, TTS_LANGUAGE, TTS_VOICE, VOLUME_DB,
    WAKE_WORD
)

# Configure logging
logging.basicConfig(
    level=LOG_LEVEL,
    format=LOG_FORMAT,
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(LOG_FILE)
    ]
)
logger = logging.getLogger(__name__)

class RobotAgent:
    """Main agent class that ties together all robot components."""
    
    def __init__(self, use_voice: bool = True, wake_word: Optional[str] = WAKE_WORD):
        """Initialize the robot agent.
        
        Args:
            use_voice: Whether to enable voice input/output
            wake_word: Optional wake word to listen for
        """
        self.use_voice = use_voice
        self.wake_word = wake_word.lower() if wake_word else None
        self.is_running = False
        
        # Initialize components
        self._init_components()
        
    def _init_components(self):
        """Initialize all robot components."""
        logger.info("Initializing robot components...")
        
        try:
            # Initialize robot controller
            self.robot = RobotController()
            logger.info("Robot controller initialized")
            
            # Initialize voice components if enabled
            if self.use_voice:
                self.speech_recognizer = SpeechRecognizer(language=STT_LANGUAGE)
                self.tts = TextToSpeech(language=TTS_LANGUAGE)
                logger.info("Voice components initialized")
            
            # Initialize command handler
            self.command_handler = CommandHandler(self.robot)
            logger.info("Command handler initialized")
            
        except Exception as e:
            logger.error(f"Failed to initialize components: {e}")
            self.cleanup()
            raise
    
    def speak(self, text: str, block: bool = True) -> bool:
        """Speak the given text if voice is enabled.
        
        Args:
            text: The text to speak
            block: Whether to block until speech is complete
            
        Returns:
            bool: True if speech was initiated successfully
        """
        if not self.use_voice or not hasattr(self, 'tts'):
            print(f"[ROBOT] {text}")
            return False
            
        return self.tts.speak(text, block=block)
    
    def listen(self, timeout: float = 5.0) -> Optional[str]:
        """Listen for voice input if voice is enabled.
        
        Args:
            timeout: Time in seconds to wait for input
            
        Returns:
            str: The recognized text, or None if no speech was detected
        """
        if not self.use_voice or not hasattr(self, 'speech_recognizer'):
            return input("Enter command: ")
            
        return self.speech_recognizer.listen(timeout=timeout)
    
    def process_command(self, command: str) -> bool:
        """Process a command and execute the corresponding action.
        
        Args:
            command: The command to process
            
        Returns:
            bool: True if the command was processed successfully
        """
        if not command:
            return False
            
        # Check for wake word if one is set
        if self.wake_word and self.wake_word in command.lower():
            # Remove wake word from command
            command = command.lower().replace(self.wake_word, '').strip()
            if not command:  # If only wake word was said
                self.speak("Yes? How can I help you?")
                return True
        
        # Process the command
        success, response = self.command_handler.process_command(command)
        
        # Speak or print the response
        if response:
            self.speak(response)
            
        return success
    
    def run_interactive(self):
        """Run the robot in interactive mode, listening for commands."""
        self.is_running = True
        
        try:
            # Greet the user
            greeting = f"Hello! I'm your family robot assistant."
            if self.wake_word:
                greeting += f" Say '{self.wake_word}' followed by a command."
            self.speak(greeting)
            
            # Main loop
            while self.is_running:
                try:
                    # Listen for a command
                    command = self.listen()
                    
                    # Process the command
                    if command and command.lower() in ['exit', 'quit', 'goodbye']:
                        self.speak("Goodbye!")
                        break
                        
                    if command:
                        self.process_command(command)
                        
                except KeyboardInterrupt:
                    logger.info("Keyboard interrupt received, shutting down...")
                    break
                except Exception as e:
                    logger.error(f"Error in main loop: {e}")
                    self.speak("Sorry, I encountered an error. Please try again.")
                    
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Clean up resources."""
        logger.info("Cleaning up...")
        self.is_running = False
        
        # Stop the robot
        if hasattr(self, 'robot'):
            try:
                self.robot.stop()
            except Exception as e:
                logger.error(f"Error stopping robot: {e}")
        
        # Clean up voice components
        if hasattr(self, 'tts'):
            try:
                self.tts.stop()
            except Exception as e:
                logger.error(f"Error cleaning up TTS: {e}")
        
        logger.info("Cleanup complete")
    
    def __del__(self):
        """Ensure resources are cleaned up when the object is destroyed."""
        self.cleanup()

def main():
    """Main entry point for the robot agent."""
    import argparse
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Family Robot Assistant')
    parser.add_argument('--no-voice', action='store_true', help='Disable voice input/output')
    parser.add_argument('--wake-word', type=str, default=WAKE_WORD, 
                       help=f'Wake word to listen for (default: {WAKE_WORD})')
    args = parser.parse_args()
    
    # Create and run the robot agent
    try:
        robot = RobotAgent(use_voice=not args.no_voice, wake_word=args.wake_word)
        robot.run_interactive()
    except KeyboardInterrupt:
        print("\nShutting down...")
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        print(f"\nA fatal error occurred: {e}")
        print("Check the logs for more details.")
    finally:
        if 'robot' in locals():
            robot.cleanup()

if __name__ == "__main__":
    main()


##################################################
# FILE: src/agent/object_search_integration.py
##################################################

#!/usr/bin/env python3
"""
Object Search Integration for Agent Architecture
This module integrates the object search functionality with the agent system
"""

import os
import sys
import time
import asyncio
import logging
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('agent_search.log')
    ]
)
logger = logging.getLogger(__name__)

# Import our modules
from .tools.object_search_tool import ObjectSearchTool
from .hardware_bridge import get_hardware
from ..vision.gpt_vision import get_gpt_vision

class ObjectSearchManager:
    """
    Manager class for object search functionality in the agent system
    """
    
    def __init__(self):
        """Initialize the object search manager"""
        self.car = None
        self.vision = None
        self.search_tool = None
        self.initialized = False
        self.current_search = None
    
    async def initialize(self):
        """Initialize hardware and vision system"""
        if self.initialized:
            return True
            
        try:
            logger.info("Initializing object search manager")
            
            # Initialize hardware
            self.car = get_hardware()
            
            # Initialize vision system
            self.vision = get_gpt_vision()
            
            # Create the object search tool
            self.search_tool = ObjectSearchTool(car=self.car, vision_system=self.vision)
            
            self.initialized = True
            logger.info("Object search manager initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize object search manager: {e}")
            return False
    
    async def search_for_object(self, object_name: str, search_area: Optional[str] = None, 
                               timeout: int = 60, confidence_threshold: float = 0.5) -> Dict[str, Any]:
        """
        Search for an object using the object search tool
        
        Args:
            object_name: Name of the object to search for
            search_area: Optional area to search in
            timeout: Search timeout in seconds
            confidence_threshold: Confidence threshold (0.0-1.0)
            
        Returns:
            Dictionary with search results
        """
        if not self.initialized:
            success = await self.initialize()
            if not success:
                return {
                    "status": "error",
                    "message": "Failed to initialize object search manager",
                    "object_found": False
                }
        
        try:
            logger.info(f"Starting search for {object_name}")
            
            # Execute the search
            self.current_search = asyncio.create_task(
                self.search_tool.execute(
                    object_name=object_name,
                    search_area=search_area,
                    timeout=timeout,
                    confidence_threshold=confidence_threshold
                )
            )
            
            # Wait for the search to complete
            result = await self.current_search
            self.current_search = None
            
            return result
            
        except asyncio.CancelledError:
            logger.info("Search cancelled")
            return {
                "status": "cancelled",
                "message": "Search was cancelled",
                "object_found": False
            }
        except Exception as e:
            logger.error(f"Error during search: {e}")
            return {
                "status": "error",
                "message": f"Error during search: {str(e)}",
                "object_found": False
            }
    
    async def cancel_search(self):
        """Cancel the current search if one is in progress"""
        if self.current_search and not self.current_search.done():
            logger.info("Cancelling current search")
            self.search_tool.stop_search()
            self.current_search.cancel()
            return True
        return False
    
    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up object search manager resources")
        
        # Cancel any ongoing search
        if self.current_search and not self.current_search.done():
            self.search_tool.stop_search()
            self.current_search.cancel()
        
        # Clean up hardware and vision resources
        if self.car:
            self.car.cleanup()
        
        if self.vision:
            self.vision.cleanup()
        
        self.initialized = False

# Singleton instance
_object_search_manager = None

def get_object_search_manager():
    """Get or create the object search manager singleton"""
    global _object_search_manager
    if _object_search_manager is None:
        _object_search_manager = ObjectSearchManager()
    return _object_search_manager

# Example usage in agent system
async def agent_search_command(object_name: str, **kwargs):
    """Example of how an agent would use the object search functionality"""
    manager = get_object_search_manager()
    result = await manager.search_for_object(object_name, **kwargs)
    
    # Format the result for the agent
    if result["object_found"]:
        return {
            "success": True,
            "message": result["message"],
            "position": result.get("position", {}).get("position", "unknown"),
            "confidence": result.get("confidence", 0.0),
            "search_time": result.get("search_time", 0.0)
        }
    else:
        return {
            "success": False,
            "message": result["message"],
            "search_time": result.get("search_time", 0.0)
        }

# Main function for testing
async def main():
    """Main function for testing the object search integration"""
    try:
        # Initialize the manager
        manager = get_object_search_manager()
        await manager.initialize()
        
        # Search for a tennis ball
        result = await manager.search_for_object("tennis ball", timeout=60, confidence_threshold=0.6)
        
        # Display the result
        if result["object_found"]:
            print(f"✅ {result['message']}")
            print(f"📍 Position: {result.get('position', {}).get('position', 'unknown')}")
            print(f"🕒 Search time: {result['search_time']:.1f}s")
        else:
            print(f"❌ {result['message']}")
            print(f"🕒 Search time: {result.get('search_time', 0.0):.1f}s")
        
    except KeyboardInterrupt:
        print("\n🛑 Search interrupted by user")
    except Exception as e:
        logger.error(f"Error: {e}")
        print(f"❌ Error: {e}")
    finally:
        # Clean up resources
        if 'manager' in locals():
            manager.cleanup()
        print("🧹 Cleaned up resources")

if __name__ == "__main__":
    # Run the async main function
    asyncio.run(main())


##################################################
# FILE: src/vision/gpt_vision.py
##################################################

#!/usr/bin/env python3
"""
GPT-4 Vision integration for PiCar-X
Uses OpenAI's GPT-4 Vision API to detect objects in images
"""

import os
import sys
import time
import base64
import logging
import asyncio
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('vision.log')
    ]
)
logger = logging.getLogger(__name__)

# Check for OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    try:
        from keys import OPENAI_API_KEY
    except ImportError:
        logger.warning("OpenAI API key not found in environment or keys.py")
        OPENAI_API_KEY = None

# Try to import OpenAI
try:
    import openai
    OPENAI_AVAILABLE = True
    logger.info("OpenAI package available")
except ImportError:
    logger.warning("OpenAI package not available, install with: pip install openai")
    OPENAI_AVAILABLE = False

# Try to import camera modules
CAMERA_AVAILABLE = False
try:
    import cv2
    CAMERA_AVAILABLE = True
    logger.info("OpenCV available for camera access")
except ImportError:
    logger.warning("OpenCV not available, install with: pip install opencv-python")

try:
    import vilib
    VILIB_AVAILABLE = True
    logger.info("vilib available for camera access")
except ImportError:
    logger.warning("vilib not available")
    VILIB_AVAILABLE = False

try:
    from picamera2 import Picamera2
    PICAMERA2_AVAILABLE = True
    logger.info("picamera2 available for camera access")
except ImportError:
    logger.warning("picamera2 not available")
    PICAMERA2_AVAILABLE = False

class GPTVision:
    """
    GPT-4 Vision integration for object detection
    """
    
    def __init__(self, api_key=None, model="gpt-4o"):
        """Initialize the GPT Vision integration"""
        self.api_key = api_key or OPENAI_API_KEY
        self.model = model
        self.client = None
        self.camera = None
        self.camera_type = None
        
        # Initialize OpenAI client
        if OPENAI_AVAILABLE and self.api_key:
            try:
                self.client = openai.OpenAI(api_key=self.api_key)
                logger.info("OpenAI client initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OpenAI client: {e}")
        
        # Initialize camera
        self._init_camera()
    
    def _init_camera(self):
        """Initialize the camera using available libraries"""
        if VILIB_AVAILABLE:
            try:
                vilib.init_camera()
                vilib.camera_start()
                self.camera_type = "vilib"
                logger.info("Camera initialized with vilib")
                return
            except Exception as e:
                logger.error(f"Failed to initialize camera with vilib: {e}")
        
        if PICAMERA2_AVAILABLE:
            try:
                self.camera = Picamera2()
                self.camera.start()
                self.camera_type = "picamera2"
                logger.info("Camera initialized with picamera2")
                return
            except Exception as e:
                logger.error(f"Failed to initialize camera with picamera2: {e}")
        
        if CAMERA_AVAILABLE:
            try:
                self.camera = cv2.VideoCapture(0)
                if not self.camera.isOpened():
                    raise Exception("Could not open camera")
                self.camera_type = "opencv"
                logger.info("Camera initialized with OpenCV")
                return
            except Exception as e:
                logger.error(f"Failed to initialize camera with OpenCV: {e}")
        
        logger.warning("No camera available, vision will be simulated")
    
    async def capture_image(self, save_path="current_view.jpg"):
        """Capture an image from the camera"""
        if not self.camera_type:
            logger.warning("No camera available, cannot capture image")
            return None
        
        try:
            if self.camera_type == "vilib":
                # Use vilib.img attribute instead of get_frame() method
                if hasattr(vilib, 'img') and vilib.img is not None:
                    cv2.imwrite(save_path, vilib.img)
                else:
                    logger.warning("No image available from vilib")
                    return None
            
            elif self.camera_type == "picamera2":
                self.camera.capture_file(save_path)
            
            elif self.camera_type == "opencv":
                ret, frame = self.camera.read()
                if ret:
                    cv2.imwrite(save_path, frame)
                else:
                    logger.warning("Failed to get frame from OpenCV camera")
                    return None
            
            logger.info(f"Image captured and saved to {save_path}")
            return save_path
        
        except Exception as e:
            logger.error(f"Failed to capture image: {e}")
            return None
    
    def _encode_image(self, image_path):
        """Encode image to base64 for API request"""
        if not os.path.exists(image_path):
            logger.error(f"Image file not found: {image_path}")
            return None
        
        try:
            with open(image_path, "rb") as image_file:
                return base64.b64encode(image_file.read()).decode('utf-8')
        except Exception as e:
            logger.error(f"Failed to encode image: {e}")
            return None
    
    async def detect_objects(self, image_path=None, prompt=None):
        """
        Detect objects in an image using GPT-4 Vision
        If image_path is None, capture a new image
        """
        # Capture image if not provided
        if image_path is None:
            image_path = await self.capture_image()
        
        if not image_path or not os.path.exists(image_path):
            logger.warning("No valid image available for object detection")
            return []
        
        # Check if OpenAI client is available
        if not self.client:
            logger.warning("OpenAI client not available, using mock detection")
            return [
                {"name": "ball", "confidence": 0.85, "position": (2, 1, 0)},
                {"name": "chair", "confidence": 0.75, "position": (3, 2, 0)}
            ]
        
        # Encode image
        base64_image = self._encode_image(image_path)
        if not base64_image:
            return []
        
        # Default prompt if not provided
        if not prompt:
            prompt = (
                "Identify all objects visible in this image. "
                "For each object, provide: "
                "1. The name of the object "
                "2. A confidence score between 0 and 1 "
                "3. The approximate position in the image (left/right/center, top/bottom/middle) "
                "Format your response as a JSON array of objects."
            )
        
        try:
            # Call GPT-4 Vision API
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=1000
            )
            
            # Extract response
            result = response.choices[0].message.content
            logger.info(f"GPT-4 Vision response: {result}")
            
            # Parse the response
            # Note: In a real implementation, you would parse the JSON response
            # For now, we'll return a simplified version
            return self._parse_vision_response(result)
        
        except Exception as e:
            logger.error(f"GPT-4 Vision API error: {e}")
            return []
    
    def _parse_vision_response(self, response_text):
        """Parse the GPT-4 Vision response text"""
        try:
            # Try to extract JSON from the response
            import json
            import re
            
            # Look for JSON array in the response
            json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
                objects = json.loads(json_str)
                
                # Convert to our standard format
                result = []
                for obj in objects:
                    # Extract position information
                    pos_x, pos_y = 0, 0
                    if 'position' in obj:
                        pos_info = obj['position'].lower()
                        if 'left' in pos_info:
                            pos_x = -1
                        elif 'right' in pos_info:
                            pos_x = 1
                        
                        if 'top' in pos_info:
                            pos_y = -1
                        elif 'bottom' in pos_info:
                            pos_y = 1
                    
                    result.append({
                        'name': obj.get('name', 'unknown'),
                        'confidence': obj.get('confidence', 0.5),
                        'position': (pos_x, pos_y, 0)
                    })
                
                return result
            
            # If no JSON found, try to extract information from text
            objects = []
            lines = response_text.split('\n')
            current_object = {}
            
            for line in lines:
                if not line.strip():
                    continue
                
                # Check for object name
                if ':' not in line and not current_object:
                    current_object = {'name': line.strip(), 'confidence': 0.7}
                
                # Check for confidence
                elif 'confidence' in line.lower():
                    try:
                        confidence = float(re.search(r'(\d+(\.\d+)?)', line).group(1))
                        if confidence > 1:
                            confidence /= 100  # Convert percentage to decimal
                        current_object['confidence'] = confidence
                    except:
                        pass
                
                # Check for position
                elif 'position' in line.lower():
                    pos_x, pos_y = 0, 0
                    if 'left' in line.lower():
                        pos_x = -1
                    elif 'right' in line.lower():
                        pos_x = 1
                    
                    if 'top' in line.lower():
                        pos_y = -1
                    elif 'bottom' in line.lower():
                        pos_y = 1
                    
                    current_object['position'] = (pos_x, pos_y, 0)
                
                # If we have a complete object, add it to the list
                if 'name' in current_object and 'confidence' in current_object:
                    if 'position' not in current_object:
                        current_object['position'] = (0, 0, 0)
                    
                    objects.append(current_object)
                    current_object = {}
            
            return objects
        
        except Exception as e:
            logger.error(f"Failed to parse vision response: {e}")
            return []
    
    def cleanup(self):
        """Clean up resources"""
        if self.camera_type == "vilib":
            try:
                vilib.camera_release()
                logger.info("vilib camera released")
            except:
                pass
        
        elif self.camera_type == "picamera2" and self.camera:
            try:
                self.camera.stop()
                logger.info("picamera2 stopped")
            except:
                pass
        
        elif self.camera_type == "opencv" and self.camera:
            try:
                self.camera.release()
                logger.info("OpenCV camera released")
            except:
                pass

# Singleton instance
_gpt_vision = None

def get_gpt_vision():
    """Get or create the GPT Vision singleton"""
    global _gpt_vision
    if _gpt_vision is None:
        _gpt_vision = GPTVision()
    return _gpt_vision


##################################################
# FILE: src/vision/__init__.py
##################################################

"""Vision package for the robot.

This package contains modules for camera control and computer vision.
"""

from .camera import Camera

__all__ = ['Camera']


##################################################
# FILE: src/vision/camera.py
##################################################

"""
Camera module for the robot using the Vilib library.
Handles camera initialization, frame capture, and cleanup.
"""
import os
import logging
import numpy as np
from typing import Optional, Tuple
import cv2

logger = logging.getLogger(__name__)

class Camera:
    """Camera class for capturing frames using the Vilib library."""
    
    def __init__(self, resolution: Tuple[int, int] = (640, 480), framerate: int = 30):
        """Initialize the camera.
        
        Args:
            resolution: Tuple of (width, height) for the camera resolution.
            framerate: Frames per second for the camera.
        """
        self.resolution = resolution
        self.framerate = framerate
        self.is_running = False
        self.Vilib = None
        
        # Import Vilib here to avoid import errors when testing on non-Pi systems
        try:
            from vilib import Vilib
            self.Vilib = Vilib
            self.available = True
            logger.info("Vilib imported successfully")
        except ImportError as e:
            logger.error(f"Failed to import Vilib: {str(e)}")
            self.available = False
    
    def start(self, vflip: bool = False, hflip: bool = False, web_display: bool = False) -> bool:
        """Start the camera.
        
        Args:
            vflip: Flip the image vertically
            hflip: Flip the image horizontally
            web_display: Enable web display at http://<ip>:9000/mjpg
            
        Returns:
            bool: True if the camera started successfully, False otherwise.
        """
        if not self.available:
            logger.error("Cannot start camera: Vilib not available")
            return False
            
        try:
            # Start the camera with the specified settings
            self.Vilib.camera_start(vflip=vflip, hflip=hflip)
            
            # Enable display if requested
            if web_display:
                self.Vilib.display(local=False, web=True)
                logger.info("Web display enabled at http://<ip>:9000/mjpg")
            
            # Wait for camera to initialize
            import time
            time.sleep(1)
            
            self.is_running = True
            logger.info("Camera started successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start camera: {str(e)}")
            self.is_running = False
            return False
    
    def capture_frame(self) -> Optional[np.ndarray]:
        """Capture a single frame from the camera.
        
        Returns:
            Optional[np.ndarray]: The captured frame as a numpy array in BGR format,
            or None if capture failed.
        """
        if not self.is_running:
            if not self.start():
                return None
                
        try:
            # Vilib stores the latest frame in Vilib.img (numpy array)
            if hasattr(self.Vilib, 'img') and self.Vilib.img is not None:
                # Vilib uses BGR format by default (same as OpenCV)
                return self.Vilib.img.copy()
            return None
            
        except Exception as e:
            logger.error(f"Failed to capture frame: {str(e)}")
            return None
    
    def save_frame(self, filename: str, directory: str = ".") -> Optional[str]:
        """Save the current frame to a file.
        
        Args:
            filename: Name of the file to save (without extension).
            directory: Directory to save the file in.
            
        Returns:
            Optional[str]: Path to the saved image, or None if save failed.
        """
        frame = self.capture_frame()
        if frame is None:
            return None
            
        try:
            os.makedirs(directory, exist_ok=True)
            filepath = os.path.join(directory, f"{filename}.jpg")
            success = cv2.imwrite(filepath, frame)
            if success:
                logger.info(f"Frame saved to {filepath}")
                return filepath
            else:
                logger.error(f"Failed to save frame to {filepath}")
                return None
                
        except Exception as e:
            logger.error(f"Error saving frame: {str(e)}")
            return None
    
    def release(self):
        """Release camera resources."""
        if self.is_running and self.available:
            try:
                self.Vilib.camera_close()
                self.is_running = False
                logger.info("Camera released")
            except Exception as e:
                logger.error(f"Error releasing camera: {str(e)}")
    
    def __del__(self):
        """Ensure camera is released when the object is destroyed."""
        self.release()

# Example usage
if __name__ == "__main__":
    import time
    import logging
    
    # Set up logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Create camera instance
    camera = Camera()
    
    try:
        # Start camera with web display enabled
        if not camera.start(vflip=False, hflip=False, web_display=True):
            print("Failed to start camera")
            exit(1)
        
        print("Camera started. Press 's' to save a frame or 'q' to quit.")
        
        # Main loop
        while True:
            frame = camera.capture_frame()
            if frame is not None:
                # Display the frame
                cv2.imshow('Camera Feed', frame)
                
                # Handle key presses
                key = cv2.waitKey(1) & 0xFF
                if key == ord('s'):  # Save frame on 's' key
                    timestamp = time.strftime("%Y%m%d_%H%M%S")
                    saved_path = camera.save_frame(f"capture_{timestamp}")
                    if saved_path:
                        print(f"Frame saved to {saved_path}")
                
                # Exit on 'q' key
                if key == ord('q'):
                    break
                    
    except KeyboardInterrupt:
        print("\nStopping...")
    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
    finally:
        camera.release()
        cv2.destroyAllWindows()
        print("Camera test completed.")


##################################################
# FILE: src/voice/speech_recognition.py
##################################################

"""
Speech recognition module using Google's Speech Recognition API.
"""
import speech_recognition as sr
import logging
from typing import Optional, Callable

from src.config import STT_LANGUAGE

class SpeechRecognizer:
    """Handles speech-to-text conversion."""
    
    def __init__(self, language: str = STT_LANGUAGE, energy_threshold: int = 300):
        """Initialize the speech recognizer.
        
        Args:
            language: Language for speech recognition (e.g., 'en-US')
            energy_threshold: Energy level for considering audio as speech
        """
        self.recognizer = sr.Recognizer()
        self.recognizer.energy_threshold = energy_threshold
        self.language = language
        self.microphone = None
        
        # Adjust for ambient noise
        self._adjust_for_ambient_noise()
    
    def _adjust_for_ambient_noise(self, duration: float = 1.0):
        """Adjust the recognizer for ambient noise.
        
        Args:
            duration: Duration in seconds to listen for ambient noise
        """
        try:
            with sr.Microphone() as source:
                logging.info("Adjusting for ambient noise...")
                self.recognizer.adjust_for_ambient_noise(source, duration=duration)
        except Exception as e:
            logging.warning(f"Could not adjust for ambient noise: {e}")
    
    def listen(self, timeout: float = 5.0, phrase_time_limit: float = 5.0) -> Optional[str]:
        """Listen for audio input and convert to text.
        
        Args:
            timeout: Time in seconds to wait for speech before timing out
            phrase_time_limit: Maximum length of a phrase in seconds
            
        Returns:
            str: The recognized text, or None if no speech was detected
        """
        try:
            with sr.Microphone() as source:
                logging.info("Listening...")
                audio = self.recognizer.listen(
                    source, 
                    timeout=timeout,
                    phrase_time_limit=phrase_time_limit
                )
                
                logging.info("Processing speech...")
                text = self.recognizer.recognize_google(audio, language=self.language)
                logging.info(f"Recognized: {text}")
                return text.lower()
                
        except sr.WaitTimeoutError:
            logging.info("No speech detected")
            return None
        except sr.UnknownValueError:
            logging.info("Could not understand audio")
            return None
        except sr.RequestError as e:
            logging.error(f"Could not request results from Google Speech Recognition service; {e}")
            return None
        except Exception as e:
            logging.error(f"Error in speech recognition: {e}")
            return None
    
    def continuous_listen(self, 
                         callback: Callable[[str], None], 
                         wake_word: Optional[str] = None,
                         timeout: float = 5.0,
                         phrase_time_limit: float = 5.0):
        """Continuously listen for speech and call the callback with recognized text.
        
        Args:
            callback: Function to call with recognized text
            wake_word: Optional wake word to listen for before processing commands
            timeout: Time in seconds to wait for speech before timing out
            phrase_time_limit: Maximum length of a phrase in seconds
        """
        logging.info(f"Starting continuous listening{' for wake word: ' + wake_word if wake_word else ''}")
        
        while True:
            try:
                text = self.listen(timeout=timeout, phrase_time_limit=phrase_time_limit)
                if text:
                    if not wake_word or wake_word.lower() in text.lower():
                        # Remove wake word from the beginning of the text if present
                        if wake_word and text.lower().startswith(wake_word.lower()):
                            text = text[len(wake_word):].strip()
                        callback(text)
            except KeyboardInterrupt:
                logging.info("Stopping continuous listening")
                break
            except Exception as e:
                logging.error(f"Error in continuous listening: {e}")
                continue


##################################################
# FILE: src/voice/__init__.py
##################################################

"""
Voice module for handling speech recognition and text-to-speech.
"""
from .speech_recognition import SpeechRecognizer
from .text_to_speech import TextToSpeech

__all__ = ['SpeechRecognizer', 'TextToSpeech']


##################################################
# FILE: src/voice/text_to_speech.py
##################################################

"""
Text-to-speech module using Google's Text-to-Speech API.
"""
import os
import tempfile
from typing import Optional
import logging
from gtts import gTTS
import pygame
import time

from src.config import TTS_VOICE, VOLUME_DB

class TextToSpeech:
    """Handles text-to-speech conversion and playback."""
    
    def __init__(self, language: str = 'en', slow: bool = False):
        """Initialize the text-to-speech engine.
        
        Args:
            language: Language for speech synthesis (e.g., 'en')
            slow: Whether to speak slowly
        """
        self.language = language
        self.slow = slow
        self.temp_dir = tempfile.gettempdir()
        self.is_speaking = False
        
        # Initialize pygame mixer
        self._init_audio()
    
    def _init_audio(self):
        """Initialize the audio system."""
        try:
            pygame.mixer.init()
            # Set a reasonable buffer size to avoid audio lag
            pygame.mixer.pre_init(44100, -16, 2, 2048)
            pygame.mixer.init()
            return True
        except Exception as e:
            logging.error(f"Failed to initialize audio: {e}")
            return False
    
    def speak(self, text: str, block: bool = True) -> bool:
        """Convert text to speech and play it.
        
        Args:
            text: The text to speak
            block: If True, block until speech is finished
            
        Returns:
            bool: True if successful, False otherwise
        """
        if not text.strip():
            return False
            
        try:
            # Create a temporary file for the speech
            with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False) as f:
                temp_file = f.name
            
            # Generate speech
            tts = gTTS(text=text, lang=self.language, slow=self.slow)
            tts.save(temp_file)
            
            # Play the speech
            return self._play_audio(temp_file, block)
            
        except Exception as e:
            logging.error(f"Error in text-to-speech: {e}")
            return False
        finally:
            # Clean up the temporary file
            try:
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
            except:
                pass
    
    def _play_audio(self, file_path: str, block: bool = True) -> bool:
        """Play an audio file.
        
        Args:
            file_path: Path to the audio file
            block: If True, block until playback is finished
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            self.is_speaking = True
            
            # Load and play the audio file
            pygame.mixer.music.load(file_path)
            pygame.mixer.music.set_volume(1.0)  # Full volume
            pygame.mixer.music.play()
            
            # If blocking, wait for playback to finish
            if block:
                while pygame.mixer.music.get_busy():
                    time.sleep(0.1)
                
            return True
            
        except Exception as e:
            logging.error(f"Error playing audio: {e}")
            return False
        finally:
            self.is_speaking = False
    
    def stop(self):
        """Stop any ongoing speech."""
        try:
            if pygame.mixer.get_init() is not None:
                pygame.mixer.music.stop()
        except:
            pass
        self.is_speaking = False
    
    def is_busy(self) -> bool:
        """Check if the TTS engine is currently speaking.
        
        Returns:
            bool: True if speaking, False otherwise
        """
        try:
            return self.is_speaking or (pygame.mixer.get_init() is not None and pygame.mixer.music.get_busy())
        except:
            return False
    
    def __del__(self):
        """Clean up resources."""
        self.stop()
        try:
            pygame.mixer.quit()
        except:
            pass


##################################################
# FILE: src/movement/__init__.py
##################################################

"""
Movement module for controlling the robot's motors and servos.
"""

from .navigation import RobotController

__all__ = ['RobotController']


##################################################
# FILE: src/movement/navigation.py
##################################################

"""
Navigation and movement control for the robot.
"""
import time
from typing import Optional, Tuple
from picarx import Picarx
from robot_hat import Pin

from src.config import (
    DEFAULT_HEAD_TILT,
    DEFAULT_POWER,
    SAFE_DISTANCE,
    DANGER_DISTANCE
)

class RobotController:
    """Handles all robot movement and servo control."""
    
    def __init__(self):
        """Initialize the robot controller."""
        try:
            self.car = Picarx()
            time.sleep(1)  # Allow time for hardware to initialize
            self.led = Pin('LED')
            self.reset()
            print("Robot hardware initialized successfully")
        except Exception as e:
            print(f"Error initializing robot hardware: {e}")
            raise
    
    def reset(self) -> None:
        """Reset all servos and stop all motors."""
        self.car.stop()
        self.car.set_dir_servo_angle(0)
        self.car.set_cam_pan_angle(0)
        self.car.set_cam_tilt_angle(DEFAULT_HEAD_TILT)
    
    def move_forward(self, power: int = DEFAULT_POWER) -> None:
        """Move the robot forward.
        
        Args:
            power: Motor power (0-100)
        """
        self.car.forward(power)
    
    def move_backward(self, power: int = DEFAULT_POWER) -> None:
        """Move the robot backward.
        
        Args:
            power: Motor power (0-100)
        """
        self.car.backward(power)
    
    def turn_left(self, angle: int = 30) -> None:
        """Turn the robot left.
        
        Args:
            angle: Steering angle (degrees)
        """
        self.car.set_dir_servo_angle(angle)
    
    def turn_right(self, angle: int = 30) -> None:
        """Turn the robot right.
        
        Args:
            angle: Steering angle (degrees)
        """
        self.car.set_dir_servo_angle(-angle)
    
    def stop(self) -> None:
        """Stop all movement and center servos."""
        self.reset()
    
    def look_around(self) -> None:
        """Perform a simple look-around pattern."""
        for angle in [30, 0, -30, 0]:
            self.car.set_cam_pan_angle(angle)
            time.sleep(0.5)
        self.car.set_cam_pan_angle(0)
    
    def get_distance(self) -> float:
        """Get the distance to the nearest obstacle in cm.
        
        Returns:
            Distance in centimeters
        """
        return self.car.get_distance()
    
    def is_safe_to_move(self) -> bool:
        """Check if it's safe to move forward.
        
        Returns:
            True if path is clear, False if obstacle is too close
        """
        distance = self.get_distance()
        return distance > SAFE_DISTANCE if distance > 0 else True
    
    def __del__(self):
        """Clean up resources."""
        try:
            self.reset()
            self.car.stop()
        except:
            pass


##################################################
# FILE: src/main.py
##################################################

"""
Main entry point for the family robot assistant.
"""
import os
import sys
import logging
from pathlib import Path

# Add the project root to the Python path
sys.path.append(str(Path(__file__).parent.parent))

from src.agent import RobotAgent
from src.config import LOG_LEVEL, LOG_FORMAT, LOG_FILE

# Configure logging
logging.basicConfig(
    level=LOG_LEVEL,
    format=LOG_FORMAT,
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(LOG_FILE)
    ]
)
logger = logging.getLogger(__name__)

def main():
    """Main function to initialize and run the robot agent."""
    logger.info("Starting Family Robot Assistant...")
    
    try:
        # Create and run the robot agent
        robot = RobotAgent(use_voice=True)
        robot.run_interactive()
        
    except KeyboardInterrupt:
        logger.info("Shutdown requested by user")
    except Exception as e:
        logger.critical(f"Fatal error: {e}", exc_info=True)
        print(f"\nA fatal error occurred: {e}")
        print("Check the logs for more details.")
    finally:
        logger.info("Shutdown complete")

if __name__ == "__main__":
    main()


# End of code dump - 469 files included
